"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/antd-tag-input";
exports.ids = ["vendor-chunks/antd-tag-input"];
exports.modules = {

/***/ "(ssr)/./node_modules/antd-tag-input/dist/index.es.js":
/*!******************************************************!*\
  !*** ./node_modules/antd-tag-input/dist/index.es.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TagInput)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;\nvar __spreadValues = (a, b2) => {\n  for (var prop in b2 || (b2 = {}))\n    if (__hasOwnProp.call(b2, prop))\n      __defNormalProp(a, prop, b2[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b2)) {\n      if (__propIsEnum.call(b2, prop))\n        __defNormalProp(a, prop, b2[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b2) => __defProps(a, __getOwnPropDescs(b2));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n\n\nvar _default = \"\";\nvar index$5 = \"\";\nvar index$4 = \"\";\nvar index$3 = \"\";\nvar index$2 = \"\";\nvar index$1 = \"\";\nfunction _extends$1() {\n  _extends$1 = Object.assign || function(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key2 in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key2)) {\n          target[key2] = source[key2];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends$1.apply(this, arguments);\n}\nfunction _defineProperty$1(obj, key2, value) {\n  if (key2 in obj) {\n    Object.defineProperty(obj, key2, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key2] = value;\n  }\n  return obj;\n}\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nvar classnames = { exports: {} };\n/*!\n  Copyright (c) 2018 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n(function(module) {\n  (function() {\n    var hasOwn = {}.hasOwnProperty;\n    function classNames2() {\n      var classes = [];\n      for (var i = 0; i < arguments.length; i++) {\n        var arg = arguments[i];\n        if (!arg)\n          continue;\n        var argType = typeof arg;\n        if (argType === \"string\" || argType === \"number\") {\n          classes.push(arg);\n        } else if (Array.isArray(arg)) {\n          if (arg.length) {\n            var inner = classNames2.apply(null, arg);\n            if (inner) {\n              classes.push(inner);\n            }\n          }\n        } else if (argType === \"object\") {\n          if (arg.toString === Object.prototype.toString) {\n            for (var key2 in arg) {\n              if (hasOwn.call(arg, key2) && arg[key2]) {\n                classes.push(key2);\n              }\n            }\n          } else {\n            classes.push(arg.toString());\n          }\n        }\n      }\n      return classes.join(\" \");\n    }\n    if (module.exports) {\n      classNames2.default = classNames2;\n      module.exports = classNames2;\n    } else {\n      window.classNames = classNames2;\n    }\n  })();\n})(classnames);\nvar classNames = classnames.exports;\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key2, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key2 = sourceKeys[i];\n    if (excluded.indexOf(key2) >= 0)\n      continue;\n    target[key2] = source[key2];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null)\n    return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key2, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key2 = sourceSymbolKeys[i];\n      if (excluded.indexOf(key2) >= 0)\n        continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key2))\n        continue;\n      target[key2] = source[key2];\n    }\n  }\n  return target;\n}\nfunction ownKeys$1(object4, enumerableOnly) {\n  var keys2 = Object.keys(object4);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object4);\n    enumerableOnly && (symbols = symbols.filter(function(sym) {\n      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;\n    })), keys2.push.apply(keys2, symbols);\n  }\n  return keys2;\n}\nfunction _objectSpread2$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key2) {\n      _defineProperty$1(target, key2, source[key2]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key2) {\n      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));\n    });\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor)\n      descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps)\n    _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps)\n    _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _setPrototypeOf$1(o, p2) {\n  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {\n    o2.__proto__ = p3;\n    return o2;\n  };\n  return _setPrototypeOf$1(o, p2);\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass)\n    _setPrototypeOf$1(subClass, superClass);\n}\nfunction _getPrototypeOf$1(o) {\n  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n    return o2.__proto__ || Object.getPrototypeOf(o2);\n  };\n  return _getPrototypeOf$1(o);\n}\nfunction _isNativeReflectConstruct$1() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct)\n    return false;\n  if (Reflect.construct.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e2) {\n    return false;\n  }\n}\nfunction _typeof$1(obj) {\n  \"@babel/helpers - typeof\";\n  return _typeof$1 = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(obj2) {\n    return typeof obj2;\n  } : function(obj2) {\n    return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n  }, _typeof$1(obj);\n}\nfunction _assertThisInitialized(self2) {\n  if (self2 === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self2;\n}\nfunction _possibleConstructorReturn(self2, call2) {\n  if (call2 && (_typeof$1(call2) === \"object\" || typeof call2 === \"function\")) {\n    return call2;\n  } else if (call2 !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self2);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf$1(Derived), result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf$1(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr))\n    return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null)\n    return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i)\n        break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null)\n        _i[\"return\"]();\n    } finally {\n      if (_d)\n        throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length)\n    len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o)\n    return;\n  if (typeof o === \"string\")\n    return _arrayLikeToArray(o, minLen);\n  var n2 = Object.prototype.toString.call(o).slice(8, -1);\n  if (n2 === \"Object\" && o.constructor)\n    n2 = o.constructor.name;\n  if (n2 === \"Map\" || n2 === \"Set\")\n    return Array.from(o);\n  if (n2 === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))\n    return _arrayLikeToArray(o, minLen);\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction findDOMNode(node) {\n  if (node instanceof HTMLElement) {\n    return node;\n  }\n  return react_dom__WEBPACK_IMPORTED_MODULE_1___default().findDOMNode(node);\n}\nvar reactIs = { exports: {} };\nvar reactIs_production_min = {};\n/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar b = typeof Symbol === \"function\" && Symbol.for, c = b ? Symbol.for(\"react.element\") : 60103, d = b ? Symbol.for(\"react.portal\") : 60106, e = b ? Symbol.for(\"react.fragment\") : 60107, f$1 = b ? Symbol.for(\"react.strict_mode\") : 60108, g$1 = b ? Symbol.for(\"react.profiler\") : 60114, h$1 = b ? Symbol.for(\"react.provider\") : 60109, k = b ? Symbol.for(\"react.context\") : 60110, l = b ? Symbol.for(\"react.async_mode\") : 60111, m$1 = b ? Symbol.for(\"react.concurrent_mode\") : 60111, n$1 = b ? Symbol.for(\"react.forward_ref\") : 60112, p$1 = b ? Symbol.for(\"react.suspense\") : 60113, q$1 = b ? Symbol.for(\"react.suspense_list\") : 60120, r = b ? Symbol.for(\"react.memo\") : 60115, t = b ? Symbol.for(\"react.lazy\") : 60116, v = b ? Symbol.for(\"react.block\") : 60121, w = b ? Symbol.for(\"react.fundamental\") : 60117, x = b ? Symbol.for(\"react.responder\") : 60118, y = b ? Symbol.for(\"react.scope\") : 60119;\nfunction z(a) {\n  if (typeof a === \"object\" && a !== null) {\n    var u = a.$$typeof;\n    switch (u) {\n      case c:\n        switch (a = a.type, a) {\n          case l:\n          case m$1:\n          case e:\n          case g$1:\n          case f$1:\n          case p$1:\n            return a;\n          default:\n            switch (a = a && a.$$typeof, a) {\n              case k:\n              case n$1:\n              case t:\n              case r:\n              case h$1:\n                return a;\n              default:\n                return u;\n            }\n        }\n      case d:\n        return u;\n    }\n  }\n}\nfunction A(a) {\n  return z(a) === m$1;\n}\nreactIs_production_min.AsyncMode = l;\nreactIs_production_min.ConcurrentMode = m$1;\nreactIs_production_min.ContextConsumer = k;\nreactIs_production_min.ContextProvider = h$1;\nreactIs_production_min.Element = c;\nreactIs_production_min.ForwardRef = n$1;\nreactIs_production_min.Fragment = e;\nreactIs_production_min.Lazy = t;\nreactIs_production_min.Memo = r;\nreactIs_production_min.Portal = d;\nreactIs_production_min.Profiler = g$1;\nreactIs_production_min.StrictMode = f$1;\nreactIs_production_min.Suspense = p$1;\nreactIs_production_min.isAsyncMode = function(a) {\n  return A(a) || z(a) === l;\n};\nreactIs_production_min.isConcurrentMode = A;\nreactIs_production_min.isContextConsumer = function(a) {\n  return z(a) === k;\n};\nreactIs_production_min.isContextProvider = function(a) {\n  return z(a) === h$1;\n};\nreactIs_production_min.isElement = function(a) {\n  return typeof a === \"object\" && a !== null && a.$$typeof === c;\n};\nreactIs_production_min.isForwardRef = function(a) {\n  return z(a) === n$1;\n};\nreactIs_production_min.isFragment = function(a) {\n  return z(a) === e;\n};\nreactIs_production_min.isLazy = function(a) {\n  return z(a) === t;\n};\nreactIs_production_min.isMemo = function(a) {\n  return z(a) === r;\n};\nreactIs_production_min.isPortal = function(a) {\n  return z(a) === d;\n};\nreactIs_production_min.isProfiler = function(a) {\n  return z(a) === g$1;\n};\nreactIs_production_min.isStrictMode = function(a) {\n  return z(a) === f$1;\n};\nreactIs_production_min.isSuspense = function(a) {\n  return z(a) === p$1;\n};\nreactIs_production_min.isValidElementType = function(a) {\n  return typeof a === \"string\" || typeof a === \"function\" || a === e || a === m$1 || a === g$1 || a === f$1 || a === p$1 || a === q$1 || typeof a === \"object\" && a !== null && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h$1 || a.$$typeof === k || a.$$typeof === n$1 || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);\n};\nreactIs_production_min.typeOf = z;\n{\n  reactIs.exports = reactIs_production_min;\n}\nfunction useMemo(getValue2, condition, shouldUpdate) {\n  var cacheRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n  if (!(\"value\" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {\n    cacheRef.current.value = getValue2();\n    cacheRef.current.condition = condition;\n  }\n  return cacheRef.current.value;\n}\nfunction fillRef(ref, node) {\n  if (typeof ref === \"function\") {\n    ref(node);\n  } else if (_typeof$1(ref) === \"object\" && ref && \"current\" in ref) {\n    ref.current = node;\n  }\n}\nfunction composeRef() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n  var refList = refs.filter(function(ref) {\n    return ref;\n  });\n  if (refList.length <= 1) {\n    return refList[0];\n  }\n  return function(node) {\n    refs.forEach(function(ref) {\n      fillRef(ref, node);\n    });\n  };\n}\nfunction supportRef(nodeOrComponent) {\n  var _type$prototype, _nodeOrComponent$prot;\n  var type4 = reactIs.exports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;\n  if (typeof type4 === \"function\" && !((_type$prototype = type4.prototype) === null || _type$prototype === void 0 ? void 0 : _type$prototype.render)) {\n    return false;\n  }\n  if (typeof nodeOrComponent === \"function\" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) === null || _nodeOrComponent$prot === void 0 ? void 0 : _nodeOrComponent$prot.render)) {\n    return false;\n  }\n  return true;\n}\nfunction canUseDom() {\n  return !!(typeof window !== \"undefined\" && window.document && window.document.createElement);\n}\nfunction makePrefixMap(styleProp, eventName) {\n  var prefixes = {};\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes[\"Webkit\".concat(styleProp)] = \"webkit\".concat(eventName);\n  prefixes[\"Moz\".concat(styleProp)] = \"moz\".concat(eventName);\n  prefixes[\"ms\".concat(styleProp)] = \"MS\".concat(eventName);\n  prefixes[\"O\".concat(styleProp)] = \"o\".concat(eventName.toLowerCase());\n  return prefixes;\n}\nfunction getVendorPrefixes(domSupport, win) {\n  var prefixes = {\n    animationend: makePrefixMap(\"Animation\", \"AnimationEnd\"),\n    transitionend: makePrefixMap(\"Transition\", \"TransitionEnd\")\n  };\n  if (domSupport) {\n    if (!(\"AnimationEvent\" in win)) {\n      delete prefixes.animationend.animation;\n    }\n    if (!(\"TransitionEvent\" in win)) {\n      delete prefixes.transitionend.transition;\n    }\n  }\n  return prefixes;\n}\nvar vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== \"undefined\" ? window : {});\nvar style = {};\nif (canUseDom()) {\n  var _document$createEleme = document.createElement(\"div\");\n  style = _document$createEleme.style;\n}\nvar prefixedEventNames = {};\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) {\n    return prefixedEventNames[eventName];\n  }\n  var prefixMap = vendorPrefixes[eventName];\n  if (prefixMap) {\n    var stylePropList = Object.keys(prefixMap);\n    var len = stylePropList.length;\n    for (var i = 0; i < len; i += 1) {\n      var styleProp = stylePropList[i];\n      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {\n        prefixedEventNames[eventName] = prefixMap[styleProp];\n        return prefixedEventNames[eventName];\n      }\n    }\n  }\n  return \"\";\n}\nvar internalAnimationEndName = getVendorPrefixedEventName(\"animationend\");\nvar internalTransitionEndName = getVendorPrefixedEventName(\"transitionend\");\nvar supportTransition = !!(internalAnimationEndName && internalTransitionEndName);\nvar animationEndName = internalAnimationEndName || \"animationend\";\nvar transitionEndName = internalTransitionEndName || \"transitionend\";\nfunction getTransitionName$2(transitionName2, transitionType) {\n  if (!transitionName2)\n    return null;\n  if (_typeof$1(transitionName2) === \"object\") {\n    var type4 = transitionType.replace(/-\\w/g, function(match) {\n      return match[1].toUpperCase();\n    });\n    return transitionName2[type4];\n  }\n  return \"\".concat(transitionName2, \"-\").concat(transitionType);\n}\nvar STATUS_NONE = \"none\";\nvar STATUS_APPEAR = \"appear\";\nvar STATUS_ENTER = \"enter\";\nvar STATUS_LEAVE = \"leave\";\nvar STEP_NONE = \"none\";\nvar STEP_PREPARE = \"prepare\";\nvar STEP_START = \"start\";\nvar STEP_ACTIVE = \"active\";\nvar STEP_ACTIVATED = \"end\";\nfunction useMountStatus(defaultValue) {\n  var destroyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultValue), _useState2 = _slicedToArray(_useState, 2), val = _useState2[0], setVal = _useState2[1];\n  function setValue2(next) {\n    if (!destroyRef.current) {\n      setVal(next);\n    }\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    return function() {\n      destroyRef.current = true;\n    };\n  }, []);\n  return [val, setValue2];\n}\nvar useIsomorphicLayoutEffect = canUseDom() ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar raf = function raf2(callback) {\n  return +setTimeout(callback, 16);\n};\nvar caf = function caf2(num) {\n  return clearTimeout(num);\n};\nif (typeof window !== \"undefined\" && \"requestAnimationFrame\" in window) {\n  raf = function raf3(callback) {\n    return window.requestAnimationFrame(callback);\n  };\n  caf = function caf3(handle) {\n    return window.cancelAnimationFrame(handle);\n  };\n}\nvar rafUUID = 0;\nvar rafIds = /* @__PURE__ */ new Map();\nfunction cleanup(id2) {\n  rafIds.delete(id2);\n}\nfunction wrapperRaf$1(callback) {\n  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n  rafUUID += 1;\n  var id2 = rafUUID;\n  function callRef(leftTimes) {\n    if (leftTimes === 0) {\n      cleanup(id2);\n      callback();\n    } else {\n      var realId = raf(function() {\n        callRef(leftTimes - 1);\n      });\n      rafIds.set(id2, realId);\n    }\n  }\n  callRef(times);\n  return id2;\n}\nwrapperRaf$1.cancel = function(id2) {\n  var realId = rafIds.get(id2);\n  cleanup(realId);\n  return caf(realId);\n};\nvar useNextFrame = function() {\n  var nextFrameRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  function cancelNextFrame() {\n    wrapperRaf$1.cancel(nextFrameRef.current);\n  }\n  function nextFrame(callback) {\n    var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;\n    cancelNextFrame();\n    var nextFrameId = wrapperRaf$1(function() {\n      if (delay <= 1) {\n        callback({\n          isCanceled: function isCanceled() {\n            return nextFrameId !== nextFrameRef.current;\n          }\n        });\n      } else {\n        nextFrame(callback, delay - 1);\n      }\n    });\n    nextFrameRef.current = nextFrameId;\n  }\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    return function() {\n      cancelNextFrame();\n    };\n  }, []);\n  return [nextFrame, cancelNextFrame];\n};\nvar STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];\nvar SkipStep = false;\nvar DoStep = true;\nfunction isActive(step) {\n  return step === STEP_ACTIVE || step === STEP_ACTIVATED;\n}\nvar useStepQueue = function(status, callback) {\n  var _useState = useMountStatus(STEP_NONE), _useState2 = _slicedToArray(_useState, 2), step = _useState2[0], setStep = _useState2[1];\n  var _useNextFrame = useNextFrame(), _useNextFrame2 = _slicedToArray(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];\n  function startQueue() {\n    setStep(STEP_PREPARE);\n  }\n  useIsomorphicLayoutEffect(function() {\n    if (step !== STEP_NONE && step !== STEP_ACTIVATED) {\n      var index2 = STEP_QUEUE.indexOf(step);\n      var nextStep = STEP_QUEUE[index2 + 1];\n      var result = callback(step);\n      if (result === SkipStep) {\n        setStep(nextStep);\n      } else {\n        nextFrame(function(info) {\n          function doNext() {\n            if (info.isCanceled())\n              return;\n            setStep(nextStep);\n          }\n          if (result === true) {\n            doNext();\n          } else {\n            Promise.resolve(result).then(doNext);\n          }\n        });\n      }\n    }\n  }, [status, step]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    return function() {\n      cancelNextFrame();\n    };\n  }, []);\n  return [startQueue, step];\n};\nvar useDomMotionEvents = function(callback) {\n  var cacheElementRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(callback);\n  callbackRef.current = callback;\n  var onInternalMotionEnd = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(event) {\n    callbackRef.current(event);\n  }, []);\n  function removeMotionEvents(element) {\n    if (element) {\n      element.removeEventListener(transitionEndName, onInternalMotionEnd);\n      element.removeEventListener(animationEndName, onInternalMotionEnd);\n    }\n  }\n  function patchMotionEvents(element) {\n    if (cacheElementRef.current && cacheElementRef.current !== element) {\n      removeMotionEvents(cacheElementRef.current);\n    }\n    if (element && element !== cacheElementRef.current) {\n      element.addEventListener(transitionEndName, onInternalMotionEnd);\n      element.addEventListener(animationEndName, onInternalMotionEnd);\n      cacheElementRef.current = element;\n    }\n  }\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    return function() {\n      removeMotionEvents(cacheElementRef.current);\n    };\n  }, []);\n  return [patchMotionEvents, removeMotionEvents];\n};\nfunction useStatus(supportMotion, visible, getElement2, _ref) {\n  var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged;\n  var _useState = useMountStatus(), _useState2 = _slicedToArray(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];\n  var _useState3 = useMountStatus(STATUS_NONE), _useState4 = _slicedToArray(_useState3, 2), status = _useState4[0], setStatus = _useState4[1];\n  var _useState5 = useMountStatus(null), _useState6 = _slicedToArray(_useState5, 2), style2 = _useState6[0], setStyle = _useState6[1];\n  var mountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  var deadlineRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var destroyedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  var cacheElementRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  function getDomElement() {\n    var element = getElement2();\n    return element || cacheElementRef.current;\n  }\n  var activeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  function onInternalMotionEnd(event) {\n    var element = getDomElement();\n    if (event && !event.deadline && event.target !== element) {\n      return;\n    }\n    var canEnd;\n    if (status === STATUS_APPEAR && activeRef.current) {\n      canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);\n    } else if (status === STATUS_ENTER && activeRef.current) {\n      canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);\n    } else if (status === STATUS_LEAVE && activeRef.current) {\n      canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);\n    }\n    if (canEnd !== false && !destroyedRef.current) {\n      setStatus(STATUS_NONE);\n      setStyle(null);\n    }\n  }\n  var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];\n  var eventHandlers = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n    var _ref2, _ref3, _ref4;\n    switch (status) {\n      case STATUS_APPEAR:\n        return _ref2 = {}, _defineProperty$1(_ref2, STEP_PREPARE, onAppearPrepare), _defineProperty$1(_ref2, STEP_START, onAppearStart), _defineProperty$1(_ref2, STEP_ACTIVE, onAppearActive), _ref2;\n      case STATUS_ENTER:\n        return _ref3 = {}, _defineProperty$1(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty$1(_ref3, STEP_START, onEnterStart), _defineProperty$1(_ref3, STEP_ACTIVE, onEnterActive), _ref3;\n      case STATUS_LEAVE:\n        return _ref4 = {}, _defineProperty$1(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty$1(_ref4, STEP_START, onLeaveStart), _defineProperty$1(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;\n      default:\n        return {};\n    }\n  }, [status]);\n  var _useStepQueue = useStepQueue(status, function(newStep) {\n    if (newStep === STEP_PREPARE) {\n      var onPrepare = eventHandlers[STEP_PREPARE];\n      if (!onPrepare) {\n        return SkipStep;\n      }\n      return onPrepare(getDomElement());\n    }\n    if (step in eventHandlers) {\n      var _eventHandlers$step;\n      setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);\n    }\n    if (step === STEP_ACTIVE) {\n      patchMotionEvents(getDomElement());\n      if (motionDeadline > 0) {\n        clearTimeout(deadlineRef.current);\n        deadlineRef.current = setTimeout(function() {\n          onInternalMotionEnd({\n            deadline: true\n          });\n        }, motionDeadline);\n      }\n    }\n    return DoStep;\n  }), _useStepQueue2 = _slicedToArray(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];\n  var active = isActive(step);\n  activeRef.current = active;\n  useIsomorphicLayoutEffect(function() {\n    setAsyncVisible(visible);\n    var isMounted = mountedRef.current;\n    mountedRef.current = true;\n    if (!supportMotion) {\n      return;\n    }\n    var nextStatus;\n    if (!isMounted && visible && motionAppear) {\n      nextStatus = STATUS_APPEAR;\n    }\n    if (isMounted && visible && motionEnter) {\n      nextStatus = STATUS_ENTER;\n    }\n    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {\n      nextStatus = STATUS_LEAVE;\n    }\n    if (nextStatus) {\n      setStatus(nextStatus);\n      startStep();\n    }\n  }, [visible]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    if (status === STATUS_APPEAR && !motionAppear || status === STATUS_ENTER && !motionEnter || status === STATUS_LEAVE && !motionLeave) {\n      setStatus(STATUS_NONE);\n    }\n  }, [motionAppear, motionEnter, motionLeave]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    return function() {\n      clearTimeout(deadlineRef.current);\n      destroyedRef.current = true;\n    };\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    if (asyncVisible !== void 0 && status === STATUS_NONE) {\n      onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);\n    }\n  }, [asyncVisible, status]);\n  var mergedStyle = style2;\n  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {\n    mergedStyle = _objectSpread2$1({\n      transition: \"none\"\n    }, mergedStyle);\n  }\n  return [status, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];\n}\nvar DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {\n  _inherits(DomWrapper2, _React$Component);\n  var _super = _createSuper(DomWrapper2);\n  function DomWrapper2() {\n    _classCallCheck(this, DomWrapper2);\n    return _super.apply(this, arguments);\n  }\n  _createClass(DomWrapper2, [{\n    key: \"render\",\n    value: function render() {\n      return this.props.children;\n    }\n  }]);\n  return DomWrapper2;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nfunction genCSSMotion(config) {\n  var transitionSupport = config;\n  if (_typeof$1(config) === \"object\") {\n    transitionSupport = config.transitionSupport;\n  }\n  function isSupportTransition(props) {\n    return !!(props.motionName && transitionSupport);\n  }\n  var CSSMotion2 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(props, ref) {\n    var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;\n    var supportMotion = isSupportTransition(props);\n    var nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    var wrapperNodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    function getDomElement() {\n      try {\n        return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);\n      } catch (e2) {\n        return null;\n      }\n    }\n    var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];\n    var renderedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(mergedVisible);\n    if (mergedVisible) {\n      renderedRef.current = true;\n    }\n    var setNodeRef = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(node) {\n      nodeRef.current = node;\n      fillRef(ref, node);\n    }, []);\n    var motionChildren;\n    var mergedProps = _objectSpread2$1(_objectSpread2$1({}, eventProps), {}, {\n      visible\n    });\n    if (!children) {\n      motionChildren = null;\n    } else if (status === STATUS_NONE || !isSupportTransition(props)) {\n      if (mergedVisible) {\n        motionChildren = children(_objectSpread2$1({}, mergedProps), setNodeRef);\n      } else if (!removeOnLeave && renderedRef.current) {\n        motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {\n          className: leavedClassName\n        }), setNodeRef);\n      } else if (forceRender) {\n        motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {\n          style: {\n            display: \"none\"\n          }\n        }), setNodeRef);\n      } else {\n        motionChildren = null;\n      }\n    } else {\n      var _classNames;\n      var statusSuffix;\n      if (statusStep === STEP_PREPARE) {\n        statusSuffix = \"prepare\";\n      } else if (isActive(statusStep)) {\n        statusSuffix = \"active\";\n      } else if (statusStep === STEP_START) {\n        statusSuffix = \"start\";\n      }\n      motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {\n        className: classNames(getTransitionName$2(motionName, status), (_classNames = {}, _defineProperty$1(_classNames, getTransitionName$2(motionName, \"\".concat(status, \"-\").concat(statusSuffix)), statusSuffix), _defineProperty$1(_classNames, motionName, typeof motionName === \"string\"), _classNames)),\n        style: statusStyle\n      }), setNodeRef);\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DomWrapper$1, {\n      ref: wrapperNodeRef\n    }, motionChildren);\n  });\n  CSSMotion2.displayName = \"CSSMotion\";\n  return CSSMotion2;\n}\nvar CSSMotion = genCSSMotion(supportTransition);\nvar STATUS_ADD = \"add\";\nvar STATUS_KEEP = \"keep\";\nvar STATUS_REMOVE = \"remove\";\nvar STATUS_REMOVED = \"removed\";\nfunction wrapKeyToObject(key2) {\n  var keyObj;\n  if (key2 && _typeof$1(key2) === \"object\" && \"key\" in key2) {\n    keyObj = key2;\n  } else {\n    keyObj = {\n      key: key2\n    };\n  }\n  return _objectSpread2$1(_objectSpread2$1({}, keyObj), {}, {\n    key: String(keyObj.key)\n  });\n}\nfunction parseKeys() {\n  var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n  return keys2.map(wrapKeyToObject);\n}\nfunction diffKeys() {\n  var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n  var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n  var list = [];\n  var currentIndex = 0;\n  var currentLen = currentKeys.length;\n  var prevKeyObjects = parseKeys(prevKeys);\n  var currentKeyObjects = parseKeys(currentKeys);\n  prevKeyObjects.forEach(function(keyObj) {\n    var hit = false;\n    for (var i = currentIndex; i < currentLen; i += 1) {\n      var currentKeyObj = currentKeyObjects[i];\n      if (currentKeyObj.key === keyObj.key) {\n        if (currentIndex < i) {\n          list = list.concat(currentKeyObjects.slice(currentIndex, i).map(function(obj) {\n            return _objectSpread2$1(_objectSpread2$1({}, obj), {}, {\n              status: STATUS_ADD\n            });\n          }));\n          currentIndex = i;\n        }\n        list.push(_objectSpread2$1(_objectSpread2$1({}, currentKeyObj), {}, {\n          status: STATUS_KEEP\n        }));\n        currentIndex += 1;\n        hit = true;\n        break;\n      }\n    }\n    if (!hit) {\n      list.push(_objectSpread2$1(_objectSpread2$1({}, keyObj), {}, {\n        status: STATUS_REMOVE\n      }));\n    }\n  });\n  if (currentIndex < currentLen) {\n    list = list.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {\n      return _objectSpread2$1(_objectSpread2$1({}, obj), {}, {\n        status: STATUS_ADD\n      });\n    }));\n  }\n  var keys2 = {};\n  list.forEach(function(_ref) {\n    var key2 = _ref.key;\n    keys2[key2] = (keys2[key2] || 0) + 1;\n  });\n  var duplicatedKeys = Object.keys(keys2).filter(function(key2) {\n    return keys2[key2] > 1;\n  });\n  duplicatedKeys.forEach(function(matchKey) {\n    list = list.filter(function(_ref2) {\n      var key2 = _ref2.key, status = _ref2.status;\n      return key2 !== matchKey || status !== STATUS_REMOVE;\n    });\n    list.forEach(function(node) {\n      if (node.key === matchKey) {\n        node.status = STATUS_KEEP;\n      }\n    });\n  });\n  return list;\n}\nvar _excluded$6 = [\"component\", \"children\", \"onVisibleChanged\"], _excluded2 = [\"status\"];\nvar MOTION_PROP_NAMES = [\"eventProps\", \"visible\", \"children\", \"motionName\", \"motionAppear\", \"motionEnter\", \"motionLeave\", \"motionLeaveImmediately\", \"motionDeadline\", \"removeOnLeave\", \"leavedClassName\", \"onAppearStart\", \"onAppearActive\", \"onAppearEnd\", \"onEnterStart\", \"onEnterActive\", \"onEnterEnd\", \"onLeaveStart\", \"onLeaveActive\", \"onLeaveEnd\"];\nfunction genCSSMotionList(transitionSupport) {\n  var CSSMotion$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion;\n  var CSSMotionList2 = /* @__PURE__ */ function(_React$Component) {\n    _inherits(CSSMotionList3, _React$Component);\n    var _super = _createSuper(CSSMotionList3);\n    function CSSMotionList3() {\n      var _this;\n      _classCallCheck(this, CSSMotionList3);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      _this = _super.call.apply(_super, [this].concat(args));\n      _this.state = {\n        keyEntities: []\n      };\n      _this.removeKey = function(removeKey) {\n        _this.setState(function(_ref) {\n          var keyEntities = _ref.keyEntities;\n          return {\n            keyEntities: keyEntities.map(function(entity) {\n              if (entity.key !== removeKey)\n                return entity;\n              return _objectSpread2$1(_objectSpread2$1({}, entity), {}, {\n                status: STATUS_REMOVED\n              });\n            })\n          };\n        });\n      };\n      return _this;\n    }\n    _createClass(CSSMotionList3, [{\n      key: \"render\",\n      value: function render() {\n        var _this2 = this;\n        var keyEntities = this.state.keyEntities;\n        var _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged, restProps = _objectWithoutProperties(_this$props, _excluded$6);\n        var Component2 = component || react__WEBPACK_IMPORTED_MODULE_0__.Fragment;\n        var motionProps = {};\n        MOTION_PROP_NAMES.forEach(function(prop) {\n          motionProps[prop] = restProps[prop];\n          delete restProps[prop];\n        });\n        delete restProps.keys;\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component2, restProps, keyEntities.map(function(_ref2) {\n          var status = _ref2.status, eventProps = _objectWithoutProperties(_ref2, _excluded2);\n          var visible = status === STATUS_ADD || status === STATUS_KEEP;\n          return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CSSMotion$1, _extends$1({}, motionProps, {\n            key: eventProps.key,\n            visible,\n            eventProps,\n            onVisibleChanged: function onVisibleChanged(changedVisible) {\n              _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {\n                key: eventProps.key\n              });\n              if (!changedVisible) {\n                _this2.removeKey(eventProps.key);\n              }\n            }\n          }), children);\n        }));\n      }\n    }], [{\n      key: \"getDerivedStateFromProps\",\n      value: function getDerivedStateFromProps(_ref3, _ref4) {\n        var keys2 = _ref3.keys;\n        var keyEntities = _ref4.keyEntities;\n        var parsedKeyObjects = parseKeys(keys2);\n        var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);\n        return {\n          keyEntities: mixedKeyEntities.filter(function(entity) {\n            var prevEntity = keyEntities.find(function(_ref5) {\n              var key2 = _ref5.key;\n              return entity.key === key2;\n            });\n            if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {\n              return false;\n            }\n            return true;\n          })\n        };\n      }\n    }]);\n    return CSSMotionList3;\n  }(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n  CSSMotionList2.defaultProps = {\n    component: \"div\"\n  };\n  return CSSMotionList2;\n}\nvar CSSMotionList = genCSSMotionList(supportTransition);\nvar Notice = /* @__PURE__ */ function(_Component) {\n  _inherits(Notice2, _Component);\n  var _super = _createSuper(Notice2);\n  function Notice2() {\n    var _this;\n    _classCallCheck(this, Notice2);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.closeTimer = null;\n    _this.close = function(e2) {\n      if (e2) {\n        e2.stopPropagation();\n      }\n      _this.clearCloseTimer();\n      var _this$props = _this.props, onClose2 = _this$props.onClose, noticeKey = _this$props.noticeKey;\n      if (onClose2) {\n        onClose2(noticeKey);\n      }\n    };\n    _this.startCloseTimer = function() {\n      if (_this.props.duration) {\n        _this.closeTimer = window.setTimeout(function() {\n          _this.close();\n        }, _this.props.duration * 1e3);\n      }\n    };\n    _this.clearCloseTimer = function() {\n      if (_this.closeTimer) {\n        clearTimeout(_this.closeTimer);\n        _this.closeTimer = null;\n      }\n    };\n    return _this;\n  }\n  _createClass(Notice2, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.startCloseTimer();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.props.duration !== prevProps.duration || this.props.updateMark !== prevProps.updateMark || this.props.visible !== prevProps.visible && this.props.visible) {\n        this.restartCloseTimer();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearCloseTimer();\n    }\n  }, {\n    key: \"restartCloseTimer\",\n    value: function restartCloseTimer() {\n      this.clearCloseTimer();\n      this.startCloseTimer();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      var _this$props2 = this.props, prefixCls = _this$props2.prefixCls, className = _this$props2.className, closable = _this$props2.closable, closeIcon = _this$props2.closeIcon, style2 = _this$props2.style, onClick = _this$props2.onClick, children = _this$props2.children, holder = _this$props2.holder;\n      var componentClass = \"\".concat(prefixCls, \"-notice\");\n      var dataOrAriaAttributeProps = Object.keys(this.props).reduce(function(acc, key2) {\n        if (key2.substr(0, 5) === \"data-\" || key2.substr(0, 5) === \"aria-\" || key2 === \"role\") {\n          acc[key2] = _this2.props[key2];\n        }\n        return acc;\n      }, {});\n      var node = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends$1({\n        className: classNames(componentClass, className, _defineProperty$1({}, \"\".concat(componentClass, \"-closable\"), closable)),\n        style: style2,\n        onMouseEnter: this.clearCloseTimer,\n        onMouseLeave: this.startCloseTimer,\n        onClick\n      }, dataOrAriaAttributeProps), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"\".concat(componentClass, \"-content\")\n      }, children), closable ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", {\n        tabIndex: 0,\n        onClick: this.close,\n        className: \"\".concat(componentClass, \"-close\")\n      }, closeIcon || /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: \"\".concat(componentClass, \"-close-x\")\n      })) : null);\n      if (holder) {\n        return /* @__PURE__ */ react_dom__WEBPACK_IMPORTED_MODULE_1___default().createPortal(node, holder);\n      }\n      return node;\n    }\n  }]);\n  return Notice2;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nNotice.defaultProps = {\n  onClose: function onClose() {\n  },\n  duration: 1.5\n};\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr))\n    return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null)\n    return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction useNotification(notificationInstance2) {\n  var createdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState([]), _React$useState2 = _slicedToArray(_React$useState, 2), elements = _React$useState2[0], setElements = _React$useState2[1];\n  function notify(noticeProps) {\n    var firstMount = true;\n    notificationInstance2.add(noticeProps, function(div, props) {\n      var key2 = props.key;\n      if (div && (!createdRef.current[key2] || firstMount)) {\n        var noticeEle = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Notice, _extends$1({}, props, {\n          holder: div\n        }));\n        createdRef.current[key2] = noticeEle;\n        setElements(function(originElements) {\n          var index2 = originElements.findIndex(function(ele) {\n            return ele.key === props.key;\n          });\n          if (index2 === -1) {\n            return [].concat(_toConsumableArray(originElements), [noticeEle]);\n          }\n          var cloneList = _toConsumableArray(originElements);\n          cloneList[index2] = noticeEle;\n          return cloneList;\n        });\n      }\n      firstMount = false;\n    });\n  }\n  return [notify, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, elements)];\n}\nvar seed = 0;\nvar now = Date.now();\nfunction getUuid() {\n  var id2 = seed;\n  seed += 1;\n  return \"rcNotification_\".concat(now, \"_\").concat(id2);\n}\nvar Notification = /* @__PURE__ */ function(_Component) {\n  _inherits(Notification2, _Component);\n  var _super = _createSuper(Notification2);\n  function Notification2() {\n    var _this;\n    _classCallCheck(this, Notification2);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.state = {\n      notices: []\n    };\n    _this.hookRefs = /* @__PURE__ */ new Map();\n    _this.add = function(originNotice, holderCallback) {\n      var key2 = originNotice.key || getUuid();\n      var notice2 = _objectSpread2$1(_objectSpread2$1({}, originNotice), {}, {\n        key: key2\n      });\n      var maxCount2 = _this.props.maxCount;\n      _this.setState(function(previousState) {\n        var notices = previousState.notices;\n        var noticeIndex = notices.map(function(v2) {\n          return v2.notice.key;\n        }).indexOf(key2);\n        var updatedNotices = notices.concat();\n        if (noticeIndex !== -1) {\n          updatedNotices.splice(noticeIndex, 1, {\n            notice: notice2,\n            holderCallback\n          });\n        } else {\n          if (maxCount2 && notices.length >= maxCount2) {\n            notice2.key = updatedNotices[0].notice.key;\n            notice2.updateMark = getUuid();\n            notice2.userPassKey = key2;\n            updatedNotices.shift();\n          }\n          updatedNotices.push({\n            notice: notice2,\n            holderCallback\n          });\n        }\n        return {\n          notices: updatedNotices\n        };\n      });\n    };\n    _this.remove = function(removeKey) {\n      _this.setState(function(_ref) {\n        var notices = _ref.notices;\n        return {\n          notices: notices.filter(function(_ref2) {\n            var _ref2$notice = _ref2.notice, key2 = _ref2$notice.key, userPassKey = _ref2$notice.userPassKey;\n            var mergedKey = userPassKey || key2;\n            return mergedKey !== removeKey;\n          })\n        };\n      });\n    };\n    _this.noticePropsMap = {};\n    return _this;\n  }\n  _createClass(Notification2, [{\n    key: \"getTransitionName\",\n    value: function getTransitionName3() {\n      var _this$props = this.props, prefixCls = _this$props.prefixCls, animation = _this$props.animation;\n      var transitionName2 = this.props.transitionName;\n      if (!transitionName2 && animation) {\n        transitionName2 = \"\".concat(prefixCls, \"-\").concat(animation);\n      }\n      return transitionName2;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      var notices = this.state.notices;\n      var _this$props2 = this.props, prefixCls = _this$props2.prefixCls, className = _this$props2.className, closeIcon = _this$props2.closeIcon, style2 = _this$props2.style;\n      var noticeKeys = [];\n      notices.forEach(function(_ref3, index2) {\n        var notice2 = _ref3.notice, holderCallback = _ref3.holderCallback;\n        var updateMark = index2 === notices.length - 1 ? notice2.updateMark : void 0;\n        var key2 = notice2.key, userPassKey = notice2.userPassKey;\n        var noticeProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({\n          prefixCls,\n          closeIcon\n        }, notice2), notice2.props), {}, {\n          key: key2,\n          noticeKey: userPassKey || key2,\n          updateMark,\n          onClose: function onClose2(noticeKey) {\n            var _notice$onClose;\n            _this2.remove(noticeKey);\n            (_notice$onClose = notice2.onClose) === null || _notice$onClose === void 0 ? void 0 : _notice$onClose.call(notice2);\n          },\n          onClick: notice2.onClick,\n          children: notice2.content\n        });\n        noticeKeys.push(key2);\n        _this2.noticePropsMap[key2] = {\n          props: noticeProps,\n          holderCallback\n        };\n      });\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: classNames(prefixCls, className),\n        style: style2\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CSSMotionList, {\n        keys: noticeKeys,\n        motionName: this.getTransitionName(),\n        onVisibleChanged: function onVisibleChanged(changedVisible, _ref4) {\n          var key2 = _ref4.key;\n          if (!changedVisible) {\n            delete _this2.noticePropsMap[key2];\n          }\n        }\n      }, function(_ref5) {\n        var key2 = _ref5.key, motionClassName = _ref5.className, motionStyle = _ref5.style, visible = _ref5.visible;\n        var _this2$noticePropsMap = _this2.noticePropsMap[key2], noticeProps = _this2$noticePropsMap.props, holderCallback = _this2$noticePropsMap.holderCallback;\n        if (holderCallback) {\n          return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            key: key2,\n            className: classNames(motionClassName, \"\".concat(prefixCls, \"-hook-holder\")),\n            style: _objectSpread2$1({}, motionStyle),\n            ref: function ref(div) {\n              if (typeof key2 === \"undefined\") {\n                return;\n              }\n              if (div) {\n                _this2.hookRefs.set(key2, div);\n                holderCallback(div, noticeProps);\n              } else {\n                _this2.hookRefs.delete(key2);\n              }\n            }\n          });\n        }\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Notice, _extends$1({}, noticeProps, {\n          className: classNames(motionClassName, noticeProps === null || noticeProps === void 0 ? void 0 : noticeProps.className),\n          style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), noticeProps === null || noticeProps === void 0 ? void 0 : noticeProps.style),\n          visible\n        }));\n      }));\n    }\n  }]);\n  return Notification2;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nNotification.newInstance = void 0;\nNotification.defaultProps = {\n  prefixCls: \"rc-notification\",\n  animation: \"fade\",\n  style: {\n    top: 65,\n    left: \"50%\"\n  }\n};\nNotification.newInstance = function newNotificationInstance(properties, callback) {\n  var _ref6 = properties || {}, getContainer2 = _ref6.getContainer, props = _objectWithoutProperties(_ref6, [\"getContainer\"]);\n  var div = document.createElement(\"div\");\n  if (getContainer2) {\n    var root2 = getContainer2();\n    root2.appendChild(div);\n  } else {\n    document.body.appendChild(div);\n  }\n  var called = false;\n  function ref(notification2) {\n    if (called) {\n      return;\n    }\n    called = true;\n    callback({\n      notice: function notice2(noticeProps) {\n        notification2.add(noticeProps);\n      },\n      removeNotice: function removeNotice(key2) {\n        notification2.remove(key2);\n      },\n      component: notification2,\n      destroy: function destroy3() {\n        react_dom__WEBPACK_IMPORTED_MODULE_1___default().unmountComponentAtNode(div);\n        if (div.parentNode) {\n          div.parentNode.removeChild(div);\n        }\n      },\n      useNotification: function useNotification$1() {\n        return useNotification(notification2);\n      }\n    });\n  }\n  react_dom__WEBPACK_IMPORTED_MODULE_1___default().render(/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Notification, _extends$1({}, props, {\n    ref\n  })), div);\n};\nvar LoadingOutlined$2 = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"0 0 1024 1024\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z\" } }] }, \"name\": \"loading\", \"theme\": \"outlined\" };\nvar LoadingOutlinedSvg = LoadingOutlined$2;\nvar IconContext = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nvar IconContext$1 = IconContext;\nfunction bound01(n2, max) {\n  if (isOnePointZero(n2)) {\n    n2 = \"100%\";\n  }\n  var isPercent = isPercentage(n2);\n  n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));\n  if (isPercent) {\n    n2 = parseInt(String(n2 * max), 10) / 100;\n  }\n  if (Math.abs(n2 - max) < 1e-6) {\n    return 1;\n  }\n  if (max === 360) {\n    n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));\n  } else {\n    n2 = n2 % max / parseFloat(String(max));\n  }\n  return n2;\n}\nfunction clamp01(val) {\n  return Math.min(1, Math.max(0, val));\n}\nfunction isOnePointZero(n2) {\n  return typeof n2 === \"string\" && n2.indexOf(\".\") !== -1 && parseFloat(n2) === 1;\n}\nfunction isPercentage(n2) {\n  return typeof n2 === \"string\" && n2.indexOf(\"%\") !== -1;\n}\nfunction boundAlpha(a) {\n  a = parseFloat(a);\n  if (isNaN(a) || a < 0 || a > 1) {\n    a = 1;\n  }\n  return a;\n}\nfunction convertToPercentage(n2) {\n  if (n2 <= 1) {\n    return Number(n2) * 100 + \"%\";\n  }\n  return n2;\n}\nfunction pad2(c2) {\n  return c2.length === 1 ? \"0\" + c2 : String(c2);\n}\nfunction rgbToRgb(r2, g2, b2) {\n  return {\n    r: bound01(r2, 255) * 255,\n    g: bound01(g2, 255) * 255,\n    b: bound01(b2, 255) * 255\n  };\n}\nfunction rgbToHsl(r2, g2, b2) {\n  r2 = bound01(r2, 255);\n  g2 = bound01(g2, 255);\n  b2 = bound01(b2, 255);\n  var max = Math.max(r2, g2, b2);\n  var min = Math.min(r2, g2, b2);\n  var h = 0;\n  var s = 0;\n  var l2 = (max + min) / 2;\n  if (max === min) {\n    s = 0;\n    h = 0;\n  } else {\n    var d2 = max - min;\n    s = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);\n    switch (max) {\n      case r2:\n        h = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);\n        break;\n      case g2:\n        h = (b2 - r2) / d2 + 2;\n        break;\n      case b2:\n        h = (r2 - g2) / d2 + 4;\n        break;\n    }\n    h /= 6;\n  }\n  return { h, s, l: l2 };\n}\nfunction hue2rgb(p2, q2, t2) {\n  if (t2 < 0) {\n    t2 += 1;\n  }\n  if (t2 > 1) {\n    t2 -= 1;\n  }\n  if (t2 < 1 / 6) {\n    return p2 + (q2 - p2) * (6 * t2);\n  }\n  if (t2 < 1 / 2) {\n    return q2;\n  }\n  if (t2 < 2 / 3) {\n    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;\n  }\n  return p2;\n}\nfunction hslToRgb(h, s, l2) {\n  var r2;\n  var g2;\n  var b2;\n  h = bound01(h, 360);\n  s = bound01(s, 100);\n  l2 = bound01(l2, 100);\n  if (s === 0) {\n    g2 = l2;\n    b2 = l2;\n    r2 = l2;\n  } else {\n    var q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;\n    var p2 = 2 * l2 - q2;\n    r2 = hue2rgb(p2, q2, h + 1 / 3);\n    g2 = hue2rgb(p2, q2, h);\n    b2 = hue2rgb(p2, q2, h - 1 / 3);\n  }\n  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };\n}\nfunction rgbToHsv(r2, g2, b2) {\n  r2 = bound01(r2, 255);\n  g2 = bound01(g2, 255);\n  b2 = bound01(b2, 255);\n  var max = Math.max(r2, g2, b2);\n  var min = Math.min(r2, g2, b2);\n  var h = 0;\n  var v2 = max;\n  var d2 = max - min;\n  var s = max === 0 ? 0 : d2 / max;\n  if (max === min) {\n    h = 0;\n  } else {\n    switch (max) {\n      case r2:\n        h = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);\n        break;\n      case g2:\n        h = (b2 - r2) / d2 + 2;\n        break;\n      case b2:\n        h = (r2 - g2) / d2 + 4;\n        break;\n    }\n    h /= 6;\n  }\n  return { h, s, v: v2 };\n}\nfunction hsvToRgb(h, s, v2) {\n  h = bound01(h, 360) * 6;\n  s = bound01(s, 100);\n  v2 = bound01(v2, 100);\n  var i = Math.floor(h);\n  var f2 = h - i;\n  var p2 = v2 * (1 - s);\n  var q2 = v2 * (1 - f2 * s);\n  var t2 = v2 * (1 - (1 - f2) * s);\n  var mod = i % 6;\n  var r2 = [v2, q2, p2, p2, t2, v2][mod];\n  var g2 = [t2, v2, v2, q2, p2, p2][mod];\n  var b2 = [p2, p2, t2, v2, v2, q2][mod];\n  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };\n}\nfunction rgbToHex(r2, g2, b2, allow3Char) {\n  var hex2 = [\n    pad2(Math.round(r2).toString(16)),\n    pad2(Math.round(g2).toString(16)),\n    pad2(Math.round(b2).toString(16))\n  ];\n  if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {\n    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);\n  }\n  return hex2.join(\"\");\n}\nfunction rgbaToHex(r2, g2, b2, a, allow4Char) {\n  var hex2 = [\n    pad2(Math.round(r2).toString(16)),\n    pad2(Math.round(g2).toString(16)),\n    pad2(Math.round(b2).toString(16)),\n    pad2(convertDecimalToHex(a))\n  ];\n  if (allow4Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) && hex2[3].startsWith(hex2[3].charAt(1))) {\n    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);\n  }\n  return hex2.join(\"\");\n}\nfunction convertDecimalToHex(d2) {\n  return Math.round(parseFloat(d2) * 255).toString(16);\n}\nfunction convertHexToDecimal(h) {\n  return parseIntFromHex(h) / 255;\n}\nfunction parseIntFromHex(val) {\n  return parseInt(val, 16);\n}\nfunction numberInputToObject(color) {\n  return {\n    r: color >> 16,\n    g: (color & 65280) >> 8,\n    b: color & 255\n  };\n}\nvar names = {\n  aliceblue: \"#f0f8ff\",\n  antiquewhite: \"#faebd7\",\n  aqua: \"#00ffff\",\n  aquamarine: \"#7fffd4\",\n  azure: \"#f0ffff\",\n  beige: \"#f5f5dc\",\n  bisque: \"#ffe4c4\",\n  black: \"#000000\",\n  blanchedalmond: \"#ffebcd\",\n  blue: \"#0000ff\",\n  blueviolet: \"#8a2be2\",\n  brown: \"#a52a2a\",\n  burlywood: \"#deb887\",\n  cadetblue: \"#5f9ea0\",\n  chartreuse: \"#7fff00\",\n  chocolate: \"#d2691e\",\n  coral: \"#ff7f50\",\n  cornflowerblue: \"#6495ed\",\n  cornsilk: \"#fff8dc\",\n  crimson: \"#dc143c\",\n  cyan: \"#00ffff\",\n  darkblue: \"#00008b\",\n  darkcyan: \"#008b8b\",\n  darkgoldenrod: \"#b8860b\",\n  darkgray: \"#a9a9a9\",\n  darkgreen: \"#006400\",\n  darkgrey: \"#a9a9a9\",\n  darkkhaki: \"#bdb76b\",\n  darkmagenta: \"#8b008b\",\n  darkolivegreen: \"#556b2f\",\n  darkorange: \"#ff8c00\",\n  darkorchid: \"#9932cc\",\n  darkred: \"#8b0000\",\n  darksalmon: \"#e9967a\",\n  darkseagreen: \"#8fbc8f\",\n  darkslateblue: \"#483d8b\",\n  darkslategray: \"#2f4f4f\",\n  darkslategrey: \"#2f4f4f\",\n  darkturquoise: \"#00ced1\",\n  darkviolet: \"#9400d3\",\n  deeppink: \"#ff1493\",\n  deepskyblue: \"#00bfff\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1e90ff\",\n  firebrick: \"#b22222\",\n  floralwhite: \"#fffaf0\",\n  forestgreen: \"#228b22\",\n  fuchsia: \"#ff00ff\",\n  gainsboro: \"#dcdcdc\",\n  ghostwhite: \"#f8f8ff\",\n  goldenrod: \"#daa520\",\n  gold: \"#ffd700\",\n  gray: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#adff2f\",\n  grey: \"#808080\",\n  honeydew: \"#f0fff0\",\n  hotpink: \"#ff69b4\",\n  indianred: \"#cd5c5c\",\n  indigo: \"#4b0082\",\n  ivory: \"#fffff0\",\n  khaki: \"#f0e68c\",\n  lavenderblush: \"#fff0f5\",\n  lavender: \"#e6e6fa\",\n  lawngreen: \"#7cfc00\",\n  lemonchiffon: \"#fffacd\",\n  lightblue: \"#add8e6\",\n  lightcoral: \"#f08080\",\n  lightcyan: \"#e0ffff\",\n  lightgoldenrodyellow: \"#fafad2\",\n  lightgray: \"#d3d3d3\",\n  lightgreen: \"#90ee90\",\n  lightgrey: \"#d3d3d3\",\n  lightpink: \"#ffb6c1\",\n  lightsalmon: \"#ffa07a\",\n  lightseagreen: \"#20b2aa\",\n  lightskyblue: \"#87cefa\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#b0c4de\",\n  lightyellow: \"#ffffe0\",\n  lime: \"#00ff00\",\n  limegreen: \"#32cd32\",\n  linen: \"#faf0e6\",\n  magenta: \"#ff00ff\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66cdaa\",\n  mediumblue: \"#0000cd\",\n  mediumorchid: \"#ba55d3\",\n  mediumpurple: \"#9370db\",\n  mediumseagreen: \"#3cb371\",\n  mediumslateblue: \"#7b68ee\",\n  mediumspringgreen: \"#00fa9a\",\n  mediumturquoise: \"#48d1cc\",\n  mediumvioletred: \"#c71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#f5fffa\",\n  mistyrose: \"#ffe4e1\",\n  moccasin: \"#ffe4b5\",\n  navajowhite: \"#ffdead\",\n  navy: \"#000080\",\n  oldlace: \"#fdf5e6\",\n  olive: \"#808000\",\n  olivedrab: \"#6b8e23\",\n  orange: \"#ffa500\",\n  orangered: \"#ff4500\",\n  orchid: \"#da70d6\",\n  palegoldenrod: \"#eee8aa\",\n  palegreen: \"#98fb98\",\n  paleturquoise: \"#afeeee\",\n  palevioletred: \"#db7093\",\n  papayawhip: \"#ffefd5\",\n  peachpuff: \"#ffdab9\",\n  peru: \"#cd853f\",\n  pink: \"#ffc0cb\",\n  plum: \"#dda0dd\",\n  powderblue: \"#b0e0e6\",\n  purple: \"#800080\",\n  rebeccapurple: \"#663399\",\n  red: \"#ff0000\",\n  rosybrown: \"#bc8f8f\",\n  royalblue: \"#4169e1\",\n  saddlebrown: \"#8b4513\",\n  salmon: \"#fa8072\",\n  sandybrown: \"#f4a460\",\n  seagreen: \"#2e8b57\",\n  seashell: \"#fff5ee\",\n  sienna: \"#a0522d\",\n  silver: \"#c0c0c0\",\n  skyblue: \"#87ceeb\",\n  slateblue: \"#6a5acd\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#fffafa\",\n  springgreen: \"#00ff7f\",\n  steelblue: \"#4682b4\",\n  tan: \"#d2b48c\",\n  teal: \"#008080\",\n  thistle: \"#d8bfd8\",\n  tomato: \"#ff6347\",\n  turquoise: \"#40e0d0\",\n  violet: \"#ee82ee\",\n  wheat: \"#f5deb3\",\n  white: \"#ffffff\",\n  whitesmoke: \"#f5f5f5\",\n  yellow: \"#ffff00\",\n  yellowgreen: \"#9acd32\"\n};\nfunction inputToRGB(color) {\n  var rgb = { r: 0, g: 0, b: 0 };\n  var a = 1;\n  var s = null;\n  var v2 = null;\n  var l2 = null;\n  var ok = false;\n  var format2 = false;\n  if (typeof color === \"string\") {\n    color = stringInputToObject(color);\n  }\n  if (typeof color === \"object\") {\n    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {\n      rgb = rgbToRgb(color.r, color.g, color.b);\n      ok = true;\n      format2 = String(color.r).substr(-1) === \"%\" ? \"prgb\" : \"rgb\";\n    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {\n      s = convertToPercentage(color.s);\n      v2 = convertToPercentage(color.v);\n      rgb = hsvToRgb(color.h, s, v2);\n      ok = true;\n      format2 = \"hsv\";\n    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {\n      s = convertToPercentage(color.s);\n      l2 = convertToPercentage(color.l);\n      rgb = hslToRgb(color.h, s, l2);\n      ok = true;\n      format2 = \"hsl\";\n    }\n    if (Object.prototype.hasOwnProperty.call(color, \"a\")) {\n      a = color.a;\n    }\n  }\n  a = boundAlpha(a);\n  return {\n    ok,\n    format: color.format || format2,\n    r: Math.min(255, Math.max(rgb.r, 0)),\n    g: Math.min(255, Math.max(rgb.g, 0)),\n    b: Math.min(255, Math.max(rgb.b, 0)),\n    a\n  };\n}\nvar CSS_INTEGER = \"[-\\\\+]?\\\\d+%?\";\nvar CSS_NUMBER = \"[-\\\\+]?\\\\d*\\\\.\\\\d+%?\";\nvar CSS_UNIT = \"(?:\" + CSS_NUMBER + \")|(?:\" + CSS_INTEGER + \")\";\nvar PERMISSIVE_MATCH3 = \"[\\\\s|\\\\(]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")\\\\s*\\\\)?\";\nvar PERMISSIVE_MATCH4 = \"[\\\\s|\\\\(]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")\\\\s*\\\\)?\";\nvar matchers = {\n  CSS_UNIT: new RegExp(CSS_UNIT),\n  rgb: new RegExp(\"rgb\" + PERMISSIVE_MATCH3),\n  rgba: new RegExp(\"rgba\" + PERMISSIVE_MATCH4),\n  hsl: new RegExp(\"hsl\" + PERMISSIVE_MATCH3),\n  hsla: new RegExp(\"hsla\" + PERMISSIVE_MATCH4),\n  hsv: new RegExp(\"hsv\" + PERMISSIVE_MATCH3),\n  hsva: new RegExp(\"hsva\" + PERMISSIVE_MATCH4),\n  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/\n};\nfunction stringInputToObject(color) {\n  color = color.trim().toLowerCase();\n  if (color.length === 0) {\n    return false;\n  }\n  var named = false;\n  if (names[color]) {\n    color = names[color];\n    named = true;\n  } else if (color === \"transparent\") {\n    return { r: 0, g: 0, b: 0, a: 0, format: \"name\" };\n  }\n  var match = matchers.rgb.exec(color);\n  if (match) {\n    return { r: match[1], g: match[2], b: match[3] };\n  }\n  match = matchers.rgba.exec(color);\n  if (match) {\n    return { r: match[1], g: match[2], b: match[3], a: match[4] };\n  }\n  match = matchers.hsl.exec(color);\n  if (match) {\n    return { h: match[1], s: match[2], l: match[3] };\n  }\n  match = matchers.hsla.exec(color);\n  if (match) {\n    return { h: match[1], s: match[2], l: match[3], a: match[4] };\n  }\n  match = matchers.hsv.exec(color);\n  if (match) {\n    return { h: match[1], s: match[2], v: match[3] };\n  }\n  match = matchers.hsva.exec(color);\n  if (match) {\n    return { h: match[1], s: match[2], v: match[3], a: match[4] };\n  }\n  match = matchers.hex8.exec(color);\n  if (match) {\n    return {\n      r: parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: parseIntFromHex(match[3]),\n      a: convertHexToDecimal(match[4]),\n      format: named ? \"name\" : \"hex8\"\n    };\n  }\n  match = matchers.hex6.exec(color);\n  if (match) {\n    return {\n      r: parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: parseIntFromHex(match[3]),\n      format: named ? \"name\" : \"hex\"\n    };\n  }\n  match = matchers.hex4.exec(color);\n  if (match) {\n    return {\n      r: parseIntFromHex(match[1] + match[1]),\n      g: parseIntFromHex(match[2] + match[2]),\n      b: parseIntFromHex(match[3] + match[3]),\n      a: convertHexToDecimal(match[4] + match[4]),\n      format: named ? \"name\" : \"hex8\"\n    };\n  }\n  match = matchers.hex3.exec(color);\n  if (match) {\n    return {\n      r: parseIntFromHex(match[1] + match[1]),\n      g: parseIntFromHex(match[2] + match[2]),\n      b: parseIntFromHex(match[3] + match[3]),\n      format: named ? \"name\" : \"hex\"\n    };\n  }\n  return false;\n}\nfunction isValidCSSUnit(color) {\n  return Boolean(matchers.CSS_UNIT.exec(String(color)));\n}\nvar TinyColor = function() {\n  function TinyColor2(color, opts) {\n    if (color === void 0) {\n      color = \"\";\n    }\n    if (opts === void 0) {\n      opts = {};\n    }\n    var _a;\n    if (color instanceof TinyColor2) {\n      return color;\n    }\n    if (typeof color === \"number\") {\n      color = numberInputToObject(color);\n    }\n    this.originalInput = color;\n    var rgb = inputToRGB(color);\n    this.originalInput = color;\n    this.r = rgb.r;\n    this.g = rgb.g;\n    this.b = rgb.b;\n    this.a = rgb.a;\n    this.roundA = Math.round(100 * this.a) / 100;\n    this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;\n    this.gradientType = opts.gradientType;\n    if (this.r < 1) {\n      this.r = Math.round(this.r);\n    }\n    if (this.g < 1) {\n      this.g = Math.round(this.g);\n    }\n    if (this.b < 1) {\n      this.b = Math.round(this.b);\n    }\n    this.isValid = rgb.ok;\n  }\n  TinyColor2.prototype.isDark = function() {\n    return this.getBrightness() < 128;\n  };\n  TinyColor2.prototype.isLight = function() {\n    return !this.isDark();\n  };\n  TinyColor2.prototype.getBrightness = function() {\n    var rgb = this.toRgb();\n    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;\n  };\n  TinyColor2.prototype.getLuminance = function() {\n    var rgb = this.toRgb();\n    var R;\n    var G;\n    var B;\n    var RsRGB = rgb.r / 255;\n    var GsRGB = rgb.g / 255;\n    var BsRGB = rgb.b / 255;\n    if (RsRGB <= 0.03928) {\n      R = RsRGB / 12.92;\n    } else {\n      R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);\n    }\n    if (GsRGB <= 0.03928) {\n      G = GsRGB / 12.92;\n    } else {\n      G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);\n    }\n    if (BsRGB <= 0.03928) {\n      B = BsRGB / 12.92;\n    } else {\n      B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);\n    }\n    return 0.2126 * R + 0.7152 * G + 0.0722 * B;\n  };\n  TinyColor2.prototype.getAlpha = function() {\n    return this.a;\n  };\n  TinyColor2.prototype.setAlpha = function(alpha) {\n    this.a = boundAlpha(alpha);\n    this.roundA = Math.round(100 * this.a) / 100;\n    return this;\n  };\n  TinyColor2.prototype.toHsv = function() {\n    var hsv = rgbToHsv(this.r, this.g, this.b);\n    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };\n  };\n  TinyColor2.prototype.toHsvString = function() {\n    var hsv = rgbToHsv(this.r, this.g, this.b);\n    var h = Math.round(hsv.h * 360);\n    var s = Math.round(hsv.s * 100);\n    var v2 = Math.round(hsv.v * 100);\n    return this.a === 1 ? \"hsv(\" + h + \", \" + s + \"%, \" + v2 + \"%)\" : \"hsva(\" + h + \", \" + s + \"%, \" + v2 + \"%, \" + this.roundA + \")\";\n  };\n  TinyColor2.prototype.toHsl = function() {\n    var hsl = rgbToHsl(this.r, this.g, this.b);\n    return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };\n  };\n  TinyColor2.prototype.toHslString = function() {\n    var hsl = rgbToHsl(this.r, this.g, this.b);\n    var h = Math.round(hsl.h * 360);\n    var s = Math.round(hsl.s * 100);\n    var l2 = Math.round(hsl.l * 100);\n    return this.a === 1 ? \"hsl(\" + h + \", \" + s + \"%, \" + l2 + \"%)\" : \"hsla(\" + h + \", \" + s + \"%, \" + l2 + \"%, \" + this.roundA + \")\";\n  };\n  TinyColor2.prototype.toHex = function(allow3Char) {\n    if (allow3Char === void 0) {\n      allow3Char = false;\n    }\n    return rgbToHex(this.r, this.g, this.b, allow3Char);\n  };\n  TinyColor2.prototype.toHexString = function(allow3Char) {\n    if (allow3Char === void 0) {\n      allow3Char = false;\n    }\n    return \"#\" + this.toHex(allow3Char);\n  };\n  TinyColor2.prototype.toHex8 = function(allow4Char) {\n    if (allow4Char === void 0) {\n      allow4Char = false;\n    }\n    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);\n  };\n  TinyColor2.prototype.toHex8String = function(allow4Char) {\n    if (allow4Char === void 0) {\n      allow4Char = false;\n    }\n    return \"#\" + this.toHex8(allow4Char);\n  };\n  TinyColor2.prototype.toRgb = function() {\n    return {\n      r: Math.round(this.r),\n      g: Math.round(this.g),\n      b: Math.round(this.b),\n      a: this.a\n    };\n  };\n  TinyColor2.prototype.toRgbString = function() {\n    var r2 = Math.round(this.r);\n    var g2 = Math.round(this.g);\n    var b2 = Math.round(this.b);\n    return this.a === 1 ? \"rgb(\" + r2 + \", \" + g2 + \", \" + b2 + \")\" : \"rgba(\" + r2 + \", \" + g2 + \", \" + b2 + \", \" + this.roundA + \")\";\n  };\n  TinyColor2.prototype.toPercentageRgb = function() {\n    var fmt = function(x2) {\n      return Math.round(bound01(x2, 255) * 100) + \"%\";\n    };\n    return {\n      r: fmt(this.r),\n      g: fmt(this.g),\n      b: fmt(this.b),\n      a: this.a\n    };\n  };\n  TinyColor2.prototype.toPercentageRgbString = function() {\n    var rnd = function(x2) {\n      return Math.round(bound01(x2, 255) * 100);\n    };\n    return this.a === 1 ? \"rgb(\" + rnd(this.r) + \"%, \" + rnd(this.g) + \"%, \" + rnd(this.b) + \"%)\" : \"rgba(\" + rnd(this.r) + \"%, \" + rnd(this.g) + \"%, \" + rnd(this.b) + \"%, \" + this.roundA + \")\";\n  };\n  TinyColor2.prototype.toName = function() {\n    if (this.a === 0) {\n      return \"transparent\";\n    }\n    if (this.a < 1) {\n      return false;\n    }\n    var hex2 = \"#\" + rgbToHex(this.r, this.g, this.b, false);\n    for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {\n      var _b = _a[_i], key2 = _b[0], value = _b[1];\n      if (hex2 === value) {\n        return key2;\n      }\n    }\n    return false;\n  };\n  TinyColor2.prototype.toString = function(format2) {\n    var formatSet = Boolean(format2);\n    format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;\n    var formattedString = false;\n    var hasAlpha = this.a < 1 && this.a >= 0;\n    var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith(\"hex\") || format2 === \"name\");\n    if (needsAlphaFormat) {\n      if (format2 === \"name\" && this.a === 0) {\n        return this.toName();\n      }\n      return this.toRgbString();\n    }\n    if (format2 === \"rgb\") {\n      formattedString = this.toRgbString();\n    }\n    if (format2 === \"prgb\") {\n      formattedString = this.toPercentageRgbString();\n    }\n    if (format2 === \"hex\" || format2 === \"hex6\") {\n      formattedString = this.toHexString();\n    }\n    if (format2 === \"hex3\") {\n      formattedString = this.toHexString(true);\n    }\n    if (format2 === \"hex4\") {\n      formattedString = this.toHex8String(true);\n    }\n    if (format2 === \"hex8\") {\n      formattedString = this.toHex8String();\n    }\n    if (format2 === \"name\") {\n      formattedString = this.toName();\n    }\n    if (format2 === \"hsl\") {\n      formattedString = this.toHslString();\n    }\n    if (format2 === \"hsv\") {\n      formattedString = this.toHsvString();\n    }\n    return formattedString || this.toHexString();\n  };\n  TinyColor2.prototype.toNumber = function() {\n    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);\n  };\n  TinyColor2.prototype.clone = function() {\n    return new TinyColor2(this.toString());\n  };\n  TinyColor2.prototype.lighten = function(amount) {\n    if (amount === void 0) {\n      amount = 10;\n    }\n    var hsl = this.toHsl();\n    hsl.l += amount / 100;\n    hsl.l = clamp01(hsl.l);\n    return new TinyColor2(hsl);\n  };\n  TinyColor2.prototype.brighten = function(amount) {\n    if (amount === void 0) {\n      amount = 10;\n    }\n    var rgb = this.toRgb();\n    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));\n    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));\n    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));\n    return new TinyColor2(rgb);\n  };\n  TinyColor2.prototype.darken = function(amount) {\n    if (amount === void 0) {\n      amount = 10;\n    }\n    var hsl = this.toHsl();\n    hsl.l -= amount / 100;\n    hsl.l = clamp01(hsl.l);\n    return new TinyColor2(hsl);\n  };\n  TinyColor2.prototype.tint = function(amount) {\n    if (amount === void 0) {\n      amount = 10;\n    }\n    return this.mix(\"white\", amount);\n  };\n  TinyColor2.prototype.shade = function(amount) {\n    if (amount === void 0) {\n      amount = 10;\n    }\n    return this.mix(\"black\", amount);\n  };\n  TinyColor2.prototype.desaturate = function(amount) {\n    if (amount === void 0) {\n      amount = 10;\n    }\n    var hsl = this.toHsl();\n    hsl.s -= amount / 100;\n    hsl.s = clamp01(hsl.s);\n    return new TinyColor2(hsl);\n  };\n  TinyColor2.prototype.saturate = function(amount) {\n    if (amount === void 0) {\n      amount = 10;\n    }\n    var hsl = this.toHsl();\n    hsl.s += amount / 100;\n    hsl.s = clamp01(hsl.s);\n    return new TinyColor2(hsl);\n  };\n  TinyColor2.prototype.greyscale = function() {\n    return this.desaturate(100);\n  };\n  TinyColor2.prototype.spin = function(amount) {\n    var hsl = this.toHsl();\n    var hue = (hsl.h + amount) % 360;\n    hsl.h = hue < 0 ? 360 + hue : hue;\n    return new TinyColor2(hsl);\n  };\n  TinyColor2.prototype.mix = function(color, amount) {\n    if (amount === void 0) {\n      amount = 50;\n    }\n    var rgb1 = this.toRgb();\n    var rgb2 = new TinyColor2(color).toRgb();\n    var p2 = amount / 100;\n    var rgba = {\n      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,\n      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,\n      b: (rgb2.b - rgb1.b) * p2 + rgb1.b,\n      a: (rgb2.a - rgb1.a) * p2 + rgb1.a\n    };\n    return new TinyColor2(rgba);\n  };\n  TinyColor2.prototype.analogous = function(results, slices) {\n    if (results === void 0) {\n      results = 6;\n    }\n    if (slices === void 0) {\n      slices = 30;\n    }\n    var hsl = this.toHsl();\n    var part = 360 / slices;\n    var ret = [this];\n    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {\n      hsl.h = (hsl.h + part) % 360;\n      ret.push(new TinyColor2(hsl));\n    }\n    return ret;\n  };\n  TinyColor2.prototype.complement = function() {\n    var hsl = this.toHsl();\n    hsl.h = (hsl.h + 180) % 360;\n    return new TinyColor2(hsl);\n  };\n  TinyColor2.prototype.monochromatic = function(results) {\n    if (results === void 0) {\n      results = 6;\n    }\n    var hsv = this.toHsv();\n    var h = hsv.h;\n    var s = hsv.s;\n    var v2 = hsv.v;\n    var res = [];\n    var modification = 1 / results;\n    while (results--) {\n      res.push(new TinyColor2({ h, s, v: v2 }));\n      v2 = (v2 + modification) % 1;\n    }\n    return res;\n  };\n  TinyColor2.prototype.splitcomplement = function() {\n    var hsl = this.toHsl();\n    var h = hsl.h;\n    return [\n      this,\n      new TinyColor2({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),\n      new TinyColor2({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })\n    ];\n  };\n  TinyColor2.prototype.onBackground = function(background) {\n    var fg = this.toRgb();\n    var bg = new TinyColor2(background).toRgb();\n    return new TinyColor2({\n      r: bg.r + (fg.r - bg.r) * fg.a,\n      g: bg.g + (fg.g - bg.g) * fg.a,\n      b: bg.b + (fg.b - bg.b) * fg.a\n    });\n  };\n  TinyColor2.prototype.triad = function() {\n    return this.polyad(3);\n  };\n  TinyColor2.prototype.tetrad = function() {\n    return this.polyad(4);\n  };\n  TinyColor2.prototype.polyad = function(n2) {\n    var hsl = this.toHsl();\n    var h = hsl.h;\n    var result = [this];\n    var increment = 360 / n2;\n    for (var i = 1; i < n2; i++) {\n      result.push(new TinyColor2({ h: (h + i * increment) % 360, s: hsl.s, l: hsl.l }));\n    }\n    return result;\n  };\n  TinyColor2.prototype.equals = function(color) {\n    return this.toRgbString() === new TinyColor2(color).toRgbString();\n  };\n  return TinyColor2;\n}();\nvar hueStep = 2;\nvar saturationStep = 0.16;\nvar saturationStep2 = 0.05;\nvar brightnessStep1 = 0.05;\nvar brightnessStep2 = 0.15;\nvar lightColorCount = 5;\nvar darkColorCount = 4;\nvar darkColorMap = [{\n  index: 7,\n  opacity: 0.15\n}, {\n  index: 6,\n  opacity: 0.25\n}, {\n  index: 5,\n  opacity: 0.3\n}, {\n  index: 5,\n  opacity: 0.45\n}, {\n  index: 5,\n  opacity: 0.65\n}, {\n  index: 5,\n  opacity: 0.85\n}, {\n  index: 4,\n  opacity: 0.9\n}, {\n  index: 3,\n  opacity: 0.95\n}, {\n  index: 2,\n  opacity: 0.97\n}, {\n  index: 1,\n  opacity: 0.98\n}];\nfunction toHsv(_ref) {\n  var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;\n  var hsv = rgbToHsv(r2, g2, b2);\n  return {\n    h: hsv.h * 360,\n    s: hsv.s,\n    v: hsv.v\n  };\n}\nfunction toHex(_ref2) {\n  var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;\n  return \"#\".concat(rgbToHex(r2, g2, b2, false));\n}\nfunction mix$1(rgb1, rgb2, amount) {\n  var p2 = amount / 100;\n  var rgb = {\n    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,\n    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,\n    b: (rgb2.b - rgb1.b) * p2 + rgb1.b\n  };\n  return rgb;\n}\nfunction getHue(hsv, i, light) {\n  var hue;\n  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {\n    hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;\n  } else {\n    hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;\n  }\n  if (hue < 0) {\n    hue += 360;\n  } else if (hue >= 360) {\n    hue -= 360;\n  }\n  return hue;\n}\nfunction getSaturation(hsv, i, light) {\n  if (hsv.h === 0 && hsv.s === 0) {\n    return hsv.s;\n  }\n  var saturation;\n  if (light) {\n    saturation = hsv.s - saturationStep * i;\n  } else if (i === darkColorCount) {\n    saturation = hsv.s + saturationStep;\n  } else {\n    saturation = hsv.s + saturationStep2 * i;\n  }\n  if (saturation > 1) {\n    saturation = 1;\n  }\n  if (light && i === lightColorCount && saturation > 0.1) {\n    saturation = 0.1;\n  }\n  if (saturation < 0.06) {\n    saturation = 0.06;\n  }\n  return Number(saturation.toFixed(2));\n}\nfunction getValue$4(hsv, i, light) {\n  var value;\n  if (light) {\n    value = hsv.v + brightnessStep1 * i;\n  } else {\n    value = hsv.v - brightnessStep2 * i;\n  }\n  if (value > 1) {\n    value = 1;\n  }\n  return Number(value.toFixed(2));\n}\nfunction generate$1(color) {\n  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  var patterns = [];\n  var pColor = inputToRGB(color);\n  for (var i = lightColorCount; i > 0; i -= 1) {\n    var hsv = toHsv(pColor);\n    var colorString = toHex(inputToRGB({\n      h: getHue(hsv, i, true),\n      s: getSaturation(hsv, i, true),\n      v: getValue$4(hsv, i, true)\n    }));\n    patterns.push(colorString);\n  }\n  patterns.push(toHex(pColor));\n  for (var _i = 1; _i <= darkColorCount; _i += 1) {\n    var _hsv = toHsv(pColor);\n    var _colorString = toHex(inputToRGB({\n      h: getHue(_hsv, _i),\n      s: getSaturation(_hsv, _i),\n      v: getValue$4(_hsv, _i)\n    }));\n    patterns.push(_colorString);\n  }\n  if (opts.theme === \"dark\") {\n    return darkColorMap.map(function(_ref3) {\n      var index2 = _ref3.index, opacity = _ref3.opacity;\n      var darkColorString = toHex(mix$1(inputToRGB(opts.backgroundColor || \"#141414\"), inputToRGB(patterns[index2]), opacity * 100));\n      return darkColorString;\n    });\n  }\n  return patterns;\n}\nvar presetPrimaryColors = {\n  red: \"#F5222D\",\n  volcano: \"#FA541C\",\n  orange: \"#FA8C16\",\n  gold: \"#FAAD14\",\n  yellow: \"#FADB14\",\n  lime: \"#A0D911\",\n  green: \"#52C41A\",\n  cyan: \"#13C2C2\",\n  blue: \"#1890FF\",\n  geekblue: \"#2F54EB\",\n  purple: \"#722ED1\",\n  magenta: \"#EB2F96\",\n  grey: \"#666666\"\n};\nvar presetPalettes = {};\nvar presetDarkPalettes = {};\nObject.keys(presetPrimaryColors).forEach(function(key2) {\n  presetPalettes[key2] = generate$1(presetPrimaryColors[key2]);\n  presetPalettes[key2].primary = presetPalettes[key2][5];\n  presetDarkPalettes[key2] = generate$1(presetPrimaryColors[key2], {\n    theme: \"dark\",\n    backgroundColor: \"#141414\"\n  });\n  presetDarkPalettes[key2].primary = presetDarkPalettes[key2][5];\n});\npresetPalettes.red;\npresetPalettes.volcano;\npresetPalettes.gold;\npresetPalettes.orange;\npresetPalettes.yellow;\npresetPalettes.lime;\npresetPalettes.green;\npresetPalettes.cyan;\npresetPalettes.blue;\npresetPalettes.geekblue;\npresetPalettes.purple;\npresetPalettes.magenta;\npresetPalettes.grey;\nvar warned = {};\nfunction warning$2(valid, message2) {\n}\nfunction call(method4, valid, message2) {\n  if (!valid && !warned[message2]) {\n    method4(false, message2);\n    warned[message2] = true;\n  }\n}\nfunction warningOnce(valid, message2) {\n  call(warning$2, valid, message2);\n}\nvar MARK_KEY = \"rc-util-key\";\nfunction getMark() {\n  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;\n  if (mark) {\n    return mark.startsWith(\"data-\") ? mark : \"data-\".concat(mark);\n  }\n  return MARK_KEY;\n}\nfunction getContainer$1(option) {\n  if (option.attachTo) {\n    return option.attachTo;\n  }\n  var head = document.querySelector(\"head\");\n  return head || document.body;\n}\nfunction injectCSS(css2) {\n  var _option$csp;\n  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  if (!canUseDom()) {\n    return null;\n  }\n  var styleNode = document.createElement(\"style\");\n  if ((_option$csp = option.csp) === null || _option$csp === void 0 ? void 0 : _option$csp.nonce) {\n    var _option$csp2;\n    styleNode.nonce = (_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce;\n  }\n  styleNode.innerHTML = css2;\n  var container = getContainer$1(option);\n  var firstChild = container.firstChild;\n  if (option.prepend && container.prepend) {\n    container.prepend(styleNode);\n  } else if (option.prepend && firstChild) {\n    container.insertBefore(styleNode, firstChild);\n  } else {\n    container.appendChild(styleNode);\n  }\n  return styleNode;\n}\nvar containerCache = /* @__PURE__ */ new Map();\nfunction findExistNode(key2) {\n  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  var container = getContainer$1(option);\n  return Array.from(containerCache.get(container).children).find(function(node) {\n    return node.tagName === \"STYLE\" && node.getAttribute(getMark(option)) === key2;\n  });\n}\nfunction updateCSS(css2, key2) {\n  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n  var container = getContainer$1(option);\n  if (!containerCache.has(container)) {\n    var placeholderStyle = injectCSS(\"\", option);\n    var parentNode = placeholderStyle.parentNode;\n    containerCache.set(container, parentNode);\n    parentNode.removeChild(placeholderStyle);\n  }\n  var existNode = findExistNode(key2, option);\n  if (existNode) {\n    var _option$csp3, _option$csp4;\n    if (((_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce) && existNode.nonce !== ((_option$csp4 = option.csp) === null || _option$csp4 === void 0 ? void 0 : _option$csp4.nonce)) {\n      var _option$csp5;\n      existNode.nonce = (_option$csp5 = option.csp) === null || _option$csp5 === void 0 ? void 0 : _option$csp5.nonce;\n    }\n    if (existNode.innerHTML !== css2) {\n      existNode.innerHTML = css2;\n    }\n    return existNode;\n  }\n  var newNode = injectCSS(css2, option);\n  newNode.setAttribute(getMark(option), key2);\n  return newNode;\n}\nfunction warning$1(valid, message2) {\n  warningOnce(valid, \"[@ant-design/icons] \".concat(message2));\n}\nfunction isIconDefinition(target) {\n  return _typeof$1(target) === \"object\" && typeof target.name === \"string\" && typeof target.theme === \"string\" && (_typeof$1(target.icon) === \"object\" || typeof target.icon === \"function\");\n}\nfunction normalizeAttrs() {\n  var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n  return Object.keys(attrs).reduce(function(acc, key2) {\n    var val = attrs[key2];\n    switch (key2) {\n      case \"class\":\n        acc.className = val;\n        delete acc.class;\n        break;\n      default:\n        acc[key2] = val;\n    }\n    return acc;\n  }, {});\n}\nfunction generate(node, key2, rootProps) {\n  if (!rootProps) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(node.tag, _objectSpread2$1({\n      key: key2\n    }, normalizeAttrs(node.attrs)), (node.children || []).map(function(child, index2) {\n      return generate(child, \"\".concat(key2, \"-\").concat(node.tag, \"-\").concat(index2));\n    }));\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(node.tag, _objectSpread2$1(_objectSpread2$1({\n    key: key2\n  }, normalizeAttrs(node.attrs)), rootProps), (node.children || []).map(function(child, index2) {\n    return generate(child, \"\".concat(key2, \"-\").concat(node.tag, \"-\").concat(index2));\n  }));\n}\nfunction getSecondaryColor(primaryColor) {\n  return generate$1(primaryColor)[0];\n}\nfunction normalizeTwoToneColors(twoToneColor) {\n  if (!twoToneColor) {\n    return [];\n  }\n  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];\n}\nvar iconStyles = \"\\n.anticon {\\n  display: inline-block;\\n  color: inherit;\\n  font-style: normal;\\n  line-height: 0;\\n  text-align: center;\\n  text-transform: none;\\n  vertical-align: -0.125em;\\n  text-rendering: optimizeLegibility;\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale;\\n}\\n\\n.anticon > * {\\n  line-height: 1;\\n}\\n\\n.anticon svg {\\n  display: inline-block;\\n}\\n\\n.anticon::before {\\n  display: none;\\n}\\n\\n.anticon .anticon-icon {\\n  display: block;\\n}\\n\\n.anticon[tabindex] {\\n  cursor: pointer;\\n}\\n\\n.anticon-spin::before,\\n.anticon-spin {\\n  display: inline-block;\\n  -webkit-animation: loadingCircle 1s infinite linear;\\n  animation: loadingCircle 1s infinite linear;\\n}\\n\\n@-webkit-keyframes loadingCircle {\\n  100% {\\n    -webkit-transform: rotate(360deg);\\n    transform: rotate(360deg);\\n  }\\n}\\n\\n@keyframes loadingCircle {\\n  100% {\\n    -webkit-transform: rotate(360deg);\\n    transform: rotate(360deg);\\n  }\\n}\\n\";\nvar useInsertStyles = function useInsertStyles2() {\n  var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles;\n  var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IconContext$1), csp = _useContext.csp;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    updateCSS(styleStr, \"@ant-design-icons\", {\n      prepend: true,\n      csp\n    });\n  }, []);\n};\nvar _excluded$5 = [\"icon\", \"className\", \"onClick\", \"style\", \"primaryColor\", \"secondaryColor\"];\nvar twoToneColorPalette = {\n  primaryColor: \"#333\",\n  secondaryColor: \"#E6E6E6\",\n  calculated: false\n};\nfunction setTwoToneColors(_ref) {\n  var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;\n  twoToneColorPalette.primaryColor = primaryColor;\n  twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);\n  twoToneColorPalette.calculated = !!secondaryColor;\n}\nfunction getTwoToneColors() {\n  return _objectSpread2$1({}, twoToneColorPalette);\n}\nvar IconBase = function IconBase2(props) {\n  var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties(props, _excluded$5);\n  var colors = twoToneColorPalette;\n  if (primaryColor) {\n    colors = {\n      primaryColor,\n      secondaryColor: secondaryColor || getSecondaryColor(primaryColor)\n    };\n  }\n  useInsertStyles();\n  warning$1(isIconDefinition(icon), \"icon should be icon definiton, but got \".concat(icon));\n  if (!isIconDefinition(icon)) {\n    return null;\n  }\n  var target = icon;\n  if (target && typeof target.icon === \"function\") {\n    target = _objectSpread2$1(_objectSpread2$1({}, target), {}, {\n      icon: target.icon(colors.primaryColor, colors.secondaryColor)\n    });\n  }\n  return generate(target.icon, \"svg-\".concat(target.name), _objectSpread2$1({\n    className,\n    onClick,\n    style: style2,\n    \"data-icon\": target.name,\n    width: \"1em\",\n    height: \"1em\",\n    fill: \"currentColor\",\n    \"aria-hidden\": \"true\"\n  }, restProps));\n};\nIconBase.displayName = \"IconReact\";\nIconBase.getTwoToneColors = getTwoToneColors;\nIconBase.setTwoToneColors = setTwoToneColors;\nvar ReactIcon = IconBase;\nfunction setTwoToneColor(twoToneColor) {\n  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];\n  return ReactIcon.setTwoToneColors({\n    primaryColor,\n    secondaryColor\n  });\n}\nfunction getTwoToneColor() {\n  var colors = ReactIcon.getTwoToneColors();\n  if (!colors.calculated) {\n    return colors.primaryColor;\n  }\n  return [colors.primaryColor, colors.secondaryColor];\n}\nvar _excluded$4 = [\"className\", \"icon\", \"spin\", \"rotate\", \"tabIndex\", \"onClick\", \"twoToneColor\"];\nsetTwoToneColor(\"#1890ff\");\nvar Icon = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(props, ref) {\n  var _classNames;\n  var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties(props, _excluded$4);\n  var _React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(IconContext$1), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? \"anticon\" : _React$useContext$pre;\n  var classString = classNames(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-\").concat(icon.name), !!icon.name), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-spin\"), !!spin || icon.name === \"loading\"), _classNames), className);\n  var iconTabIndex = tabIndex;\n  if (iconTabIndex === void 0 && onClick) {\n    iconTabIndex = -1;\n  }\n  var svgStyle = rotate ? {\n    msTransform: \"rotate(\".concat(rotate, \"deg)\"),\n    transform: \"rotate(\".concat(rotate, \"deg)\")\n  } : void 0;\n  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", _objectSpread2$1(_objectSpread2$1({\n    role: \"img\",\n    \"aria-label\": icon.name\n  }, restProps), {}, {\n    ref,\n    tabIndex: iconTabIndex,\n    onClick,\n    className: classString\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ReactIcon, {\n    icon,\n    primaryColor,\n    secondaryColor,\n    style: svgStyle\n  }));\n});\nIcon.displayName = \"AntdIcon\";\nIcon.getTwoToneColor = getTwoToneColor;\nIcon.setTwoToneColor = setTwoToneColor;\nvar AntdIcon = Icon;\nvar LoadingOutlined = function LoadingOutlined2(props, ref) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {\n    ref,\n    icon: LoadingOutlinedSvg\n  }));\n};\nLoadingOutlined.displayName = \"LoadingOutlined\";\nvar LoadingOutlined$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(LoadingOutlined);\nvar ExclamationCircleFilled$2 = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"64 64 896 896\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z\" } }] }, \"name\": \"exclamation-circle\", \"theme\": \"filled\" };\nvar ExclamationCircleFilledSvg = ExclamationCircleFilled$2;\nvar ExclamationCircleFilled = function ExclamationCircleFilled2(props, ref) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {\n    ref,\n    icon: ExclamationCircleFilledSvg\n  }));\n};\nExclamationCircleFilled.displayName = \"ExclamationCircleFilled\";\nvar ExclamationCircleFilled$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(ExclamationCircleFilled);\nvar CloseCircleFilled$2 = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"64 64 896 896\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z\" } }] }, \"name\": \"close-circle\", \"theme\": \"filled\" };\nvar CloseCircleFilledSvg = CloseCircleFilled$2;\nvar CloseCircleFilled = function CloseCircleFilled2(props, ref) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {\n    ref,\n    icon: CloseCircleFilledSvg\n  }));\n};\nCloseCircleFilled.displayName = \"CloseCircleFilled\";\nvar CloseCircleFilled$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(CloseCircleFilled);\nvar CheckCircleFilled$2 = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"64 64 896 896\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z\" } }] }, \"name\": \"check-circle\", \"theme\": \"filled\" };\nvar CheckCircleFilledSvg = CheckCircleFilled$2;\nvar CheckCircleFilled = function CheckCircleFilled2(props, ref) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {\n    ref,\n    icon: CheckCircleFilledSvg\n  }));\n};\nCheckCircleFilled.displayName = \"CheckCircleFilled\";\nvar CheckCircleFilled$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(CheckCircleFilled);\nvar InfoCircleFilled$2 = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"64 64 896 896\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z\" } }] }, \"name\": \"info-circle\", \"theme\": \"filled\" };\nvar InfoCircleFilledSvg = InfoCircleFilled$2;\nvar InfoCircleFilled = function InfoCircleFilled2(props, ref) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {\n    ref,\n    icon: InfoCircleFilledSvg\n  }));\n};\nInfoCircleFilled.displayName = \"InfoCircleFilled\";\nvar InfoCircleFilled$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(InfoCircleFilled);\nfunction toArray$1(children) {\n  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  var ret = [];\n  react__WEBPACK_IMPORTED_MODULE_0___default().Children.forEach(children, function(child) {\n    if ((child === void 0 || child === null) && !option.keepEmpty) {\n      return;\n    }\n    if (Array.isArray(child)) {\n      ret = ret.concat(toArray$1(child));\n    } else if (reactIs.exports.isFragment(child) && child.props) {\n      ret = ret.concat(toArray$1(child.props.children, option));\n    } else {\n      ret.push(child);\n    }\n  });\n  return ret;\n}\nvar HOOK_MARK = \"RC_FORM_INTERNAL_HOOKS\";\nvar warningFunc = function warningFunc2() {\n  warningOnce(false, \"Can not find FormContext. Please make sure you wrap Field under Form.\");\n};\nvar Context = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  getFieldValue: warningFunc,\n  getFieldsValue: warningFunc,\n  getFieldError: warningFunc,\n  getFieldWarning: warningFunc,\n  getFieldsError: warningFunc,\n  isFieldsTouched: warningFunc,\n  isFieldTouched: warningFunc,\n  isFieldValidating: warningFunc,\n  isFieldsValidating: warningFunc,\n  resetFields: warningFunc,\n  setFields: warningFunc,\n  setFieldsValue: warningFunc,\n  validateFields: warningFunc,\n  submit: warningFunc,\n  getInternalHooks: function getInternalHooks() {\n    warningFunc();\n    return {\n      dispatch: warningFunc,\n      initEntityValue: warningFunc,\n      registerField: warningFunc,\n      useSubscribe: warningFunc,\n      setInitialValues: warningFunc,\n      setCallbacks: warningFunc,\n      getFields: warningFunc,\n      setValidateMessages: warningFunc,\n      setPreserve: warningFunc,\n      getInitialValue: warningFunc\n    };\n  }\n});\nfunction toArray(value) {\n  if (value === void 0 || value === null) {\n    return [];\n  }\n  return Array.isArray(value) ? value : [value];\n}\nvar runtime = { exports: {} };\n(function(module) {\n  var runtime2 = function(exports) {\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined$1;\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n    function define(obj, key2, value) {\n      Object.defineProperty(obj, key2, {\n        value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n      return obj[key2];\n    }\n    try {\n      define({}, \"\");\n    } catch (err) {\n      define = function(obj, key2, value) {\n        return obj[key2] = value;\n      };\n    }\n    function wrap(innerFn, outerFn, self2, tryLocsList) {\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context2(tryLocsList || []);\n      generator._invoke = makeInvokeMethod(innerFn, self2, context);\n      return generator;\n    }\n    exports.wrap = wrap;\n    function tryCatch(fn, obj, arg) {\n      try {\n        return { type: \"normal\", arg: fn.call(obj, arg) };\n      } catch (err) {\n        return { type: \"throw\", arg: err };\n      }\n    }\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\";\n    var ContinueSentinel = {};\n    function Generator() {\n    }\n    function GeneratorFunction() {\n    }\n    function GeneratorFunctionPrototype() {\n    }\n    var IteratorPrototype = {};\n    define(IteratorPrototype, iteratorSymbol, function() {\n      return this;\n    });\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n      IteratorPrototype = NativeIteratorPrototype;\n    }\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = GeneratorFunctionPrototype;\n    define(Gp, \"constructor\", GeneratorFunctionPrototype);\n    define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function(method4) {\n        define(prototype, method4, function(arg) {\n          return this._invoke(method4, arg);\n        });\n      });\n    }\n    exports.isGeneratorFunction = function(genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n    exports.mark = function(genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n        define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n      }\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    };\n    exports.awrap = function(arg) {\n      return { __await: arg };\n    };\n    function AsyncIterator(generator, PromiseImpl) {\n      function invoke(method4, arg, resolve, reject) {\n        var record = tryCatch(generator[method4], generator, arg);\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result = record.arg;\n          var value = result.value;\n          if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n            return PromiseImpl.resolve(value.__await).then(function(value2) {\n              invoke(\"next\", value2, resolve, reject);\n            }, function(err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n          return PromiseImpl.resolve(value).then(function(unwrapped) {\n            result.value = unwrapped;\n            resolve(result);\n          }, function(error) {\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n      var previousPromise;\n      function enqueue(method4, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function(resolve, reject) {\n            invoke(method4, arg, resolve, reject);\n          });\n        }\n        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n      this._invoke = enqueue;\n    }\n    defineIteratorMethods(AsyncIterator.prototype);\n    define(AsyncIterator.prototype, asyncIteratorSymbol, function() {\n      return this;\n    });\n    exports.AsyncIterator = AsyncIterator;\n    exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {\n      if (PromiseImpl === void 0)\n        PromiseImpl = Promise;\n      var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);\n      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {\n        return result.done ? result.value : iter.next();\n      });\n    };\n    function makeInvokeMethod(innerFn, self2, context) {\n      var state = GenStateSuspendedStart;\n      return function invoke(method4, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n        if (state === GenStateCompleted) {\n          if (method4 === \"throw\") {\n            throw arg;\n          }\n          return doneResult();\n        }\n        context.method = method4;\n        context.arg = arg;\n        while (true) {\n          var delegate = context.delegate;\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel)\n                continue;\n              return delegateResult;\n            }\n          }\n          if (context.method === \"next\") {\n            context.sent = context._sent = context.arg;\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n            context.dispatchException(context.arg);\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n          state = GenStateExecuting;\n          var record = tryCatch(innerFn, self2, context);\n          if (record.type === \"normal\") {\n            state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted;\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    }\n    function maybeInvokeDelegate(delegate, context) {\n      var method4 = delegate.iterator[context.method];\n      if (method4 === undefined$1) {\n        context.delegate = null;\n        if (context.method === \"throw\") {\n          if (delegate.iterator[\"return\"]) {\n            context.method = \"return\";\n            context.arg = undefined$1;\n            maybeInvokeDelegate(delegate, context);\n            if (context.method === \"throw\") {\n              return ContinueSentinel;\n            }\n          }\n          context.method = \"throw\";\n          context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n        }\n        return ContinueSentinel;\n      }\n      var record = tryCatch(method4, delegate.iterator, context.arg);\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n      var info = record.arg;\n      if (!info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n      if (info.done) {\n        context[delegate.resultName] = info.value;\n        context.next = delegate.nextLoc;\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n      } else {\n        return info;\n      }\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n    defineIteratorMethods(Gp);\n    define(Gp, toStringTagSymbol, \"Generator\");\n    define(Gp, iteratorSymbol, function() {\n      return this;\n    });\n    define(Gp, \"toString\", function() {\n      return \"[object Generator]\";\n    });\n    function pushTryEntry(locs) {\n      var entry = { tryLoc: locs[0] };\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n      this.tryEntries.push(entry);\n    }\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n    function Context2(tryLocsList) {\n      this.tryEntries = [{ tryLoc: \"root\" }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n    exports.keys = function(object4) {\n      var keys2 = [];\n      for (var key2 in object4) {\n        keys2.push(key2);\n      }\n      keys2.reverse();\n      return function next() {\n        while (keys2.length) {\n          var key3 = keys2.pop();\n          if (key3 in object4) {\n            next.value = key3;\n            next.done = false;\n            return next;\n          }\n        }\n        next.done = true;\n        return next;\n      };\n    };\n    function values(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n        if (!isNaN(iterable.length)) {\n          var i = -1, next = function next2() {\n            while (++i < iterable.length) {\n              if (hasOwn.call(iterable, i)) {\n                next2.value = iterable[i];\n                next2.done = false;\n                return next2;\n              }\n            }\n            next2.value = undefined$1;\n            next2.done = true;\n            return next2;\n          };\n          return next.next = next;\n        }\n      }\n      return { next: doneResult };\n    }\n    exports.values = values;\n    function doneResult() {\n      return { value: undefined$1, done: true };\n    }\n    Context2.prototype = {\n      constructor: Context2,\n      reset: function(skipTempReset) {\n        this.prev = 0;\n        this.next = 0;\n        this.sent = this._sent = undefined$1;\n        this.done = false;\n        this.delegate = null;\n        this.method = \"next\";\n        this.arg = undefined$1;\n        this.tryEntries.forEach(resetTryEntry);\n        if (!skipTempReset) {\n          for (var name in this) {\n            if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n              this[name] = undefined$1;\n            }\n          }\n        }\n      },\n      stop: function() {\n        this.done = true;\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n        return this.rval;\n      },\n      dispatchException: function(exception) {\n        if (this.done) {\n          throw exception;\n        }\n        var context = this;\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n          if (caught) {\n            context.method = \"next\";\n            context.arg = undefined$1;\n          }\n          return !!caught;\n        }\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n          if (entry.tryLoc === \"root\") {\n            return handle(\"end\");\n          }\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n      abrupt: function(type4, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n        if (finallyEntry && (type4 === \"break\" || type4 === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n          finallyEntry = null;\n        }\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type4;\n        record.arg = arg;\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n        return this.complete(record);\n      },\n      complete: function(record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n        if (record.type === \"break\" || record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n        return ContinueSentinel;\n      },\n      finish: function(finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n      \"catch\": function(tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n            return thrown;\n          }\n        }\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function(iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values(iterable),\n          resultName,\n          nextLoc\n        };\n        if (this.method === \"next\") {\n          this.arg = undefined$1;\n        }\n        return ContinueSentinel;\n      }\n    };\n    return exports;\n  }(module.exports);\n  try {\n    regeneratorRuntime = runtime2;\n  } catch (accidentalStrictMode) {\n    if (typeof globalThis === \"object\") {\n      globalThis.regeneratorRuntime = runtime2;\n    } else {\n      Function(\"r\", \"regeneratorRuntime = r\")(runtime2);\n    }\n  }\n})(runtime);\nvar regenerator = runtime.exports;\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key2, arg) {\n  try {\n    var info = gen[key2](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function() {\n    var self2 = this, args = arguments;\n    return new Promise(function(resolve, reject) {\n      var gen = fn.apply(self2, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(void 0);\n    });\n  };\n}\nfunction _extends() {\n  _extends = Object.assign || function(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key2 in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key2)) {\n          target[key2] = source[key2];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n    return o2.__proto__ || Object.getPrototypeOf(o2);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p2) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {\n    o2.__proto__ = p3;\n    return o2;\n  };\n  return _setPrototypeOf(o, p2);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct)\n    return false;\n  if (Reflect.construct.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e2) {\n    return false;\n  }\n}\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct2(Parent2, args2, Class2) {\n      var a = [null];\n      a.push.apply(a, args2);\n      var Constructor = Function.bind.apply(Parent2, a);\n      var instance = new Constructor();\n      if (Class2)\n        _setPrototypeOf(instance, Class2.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? /* @__PURE__ */ new Map() : void 0;\n  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {\n    if (Class2 === null || !_isNativeFunction(Class2))\n      return Class2;\n    if (typeof Class2 !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class2))\n        return _cache.get(Class2);\n      _cache.set(Class2, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class2.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class2);\n  };\n  return _wrapNativeSuper(Class);\n}\nvar formatRegExp = /%[sdj%]/g;\nvar warning = function warning2() {\n};\nif (typeof process !== \"undefined\" && process.env && false) {}\nfunction convertFieldsError(errors) {\n  if (!errors || !errors.length)\n    return null;\n  var fields = {};\n  errors.forEach(function(error) {\n    var field = error.field;\n    fields[field] = fields[field] || [];\n    fields[field].push(error);\n  });\n  return fields;\n}\nfunction format(template) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  var i = 0;\n  var len = args.length;\n  if (typeof template === \"function\") {\n    return template.apply(null, args);\n  }\n  if (typeof template === \"string\") {\n    var str = template.replace(formatRegExp, function(x2) {\n      if (x2 === \"%%\") {\n        return \"%\";\n      }\n      if (i >= len) {\n        return x2;\n      }\n      switch (x2) {\n        case \"%s\":\n          return String(args[i++]);\n        case \"%d\":\n          return Number(args[i++]);\n        case \"%j\":\n          try {\n            return JSON.stringify(args[i++]);\n          } catch (_) {\n            return \"[Circular]\";\n          }\n          break;\n        default:\n          return x2;\n      }\n    });\n    return str;\n  }\n  return template;\n}\nfunction isNativeStringType(type4) {\n  return type4 === \"string\" || type4 === \"url\" || type4 === \"hex\" || type4 === \"email\" || type4 === \"date\" || type4 === \"pattern\";\n}\nfunction isEmptyValue(value, type4) {\n  if (value === void 0 || value === null) {\n    return true;\n  }\n  if (type4 === \"array\" && Array.isArray(value) && !value.length) {\n    return true;\n  }\n  if (isNativeStringType(type4) && typeof value === \"string\" && !value) {\n    return true;\n  }\n  return false;\n}\nfunction asyncParallelArray(arr, func, callback) {\n  var results = [];\n  var total = 0;\n  var arrLength = arr.length;\n  function count(errors) {\n    results.push.apply(results, errors || []);\n    total++;\n    if (total === arrLength) {\n      callback(results);\n    }\n  }\n  arr.forEach(function(a) {\n    func(a, count);\n  });\n}\nfunction asyncSerialArray(arr, func, callback) {\n  var index2 = 0;\n  var arrLength = arr.length;\n  function next(errors) {\n    if (errors && errors.length) {\n      callback(errors);\n      return;\n    }\n    var original = index2;\n    index2 = index2 + 1;\n    if (original < arrLength) {\n      func(arr[original], next);\n    } else {\n      callback([]);\n    }\n  }\n  next([]);\n}\nfunction flattenObjArr(objArr) {\n  var ret = [];\n  Object.keys(objArr).forEach(function(k2) {\n    ret.push.apply(ret, objArr[k2] || []);\n  });\n  return ret;\n}\nvar AsyncValidationError = /* @__PURE__ */ function(_Error) {\n  _inheritsLoose(AsyncValidationError2, _Error);\n  function AsyncValidationError2(errors, fields) {\n    var _this;\n    _this = _Error.call(this, \"Async Validation Error\") || this;\n    _this.errors = errors;\n    _this.fields = fields;\n    return _this;\n  }\n  return AsyncValidationError2;\n}(/* @__PURE__ */ _wrapNativeSuper(Error));\nfunction asyncMap(objArr, option, func, callback, source) {\n  if (option.first) {\n    var _pending = new Promise(function(resolve, reject) {\n      var next = function next2(errors) {\n        callback(errors);\n        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);\n      };\n      var flattenArr = flattenObjArr(objArr);\n      asyncSerialArray(flattenArr, func, next);\n    });\n    _pending[\"catch\"](function(e2) {\n      return e2;\n    });\n    return _pending;\n  }\n  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];\n  var objArrKeys = Object.keys(objArr);\n  var objArrLength = objArrKeys.length;\n  var total = 0;\n  var results = [];\n  var pending = new Promise(function(resolve, reject) {\n    var next = function next2(errors) {\n      results.push.apply(results, errors);\n      total++;\n      if (total === objArrLength) {\n        callback(results);\n        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);\n      }\n    };\n    if (!objArrKeys.length) {\n      callback(results);\n      resolve(source);\n    }\n    objArrKeys.forEach(function(key2) {\n      var arr = objArr[key2];\n      if (firstFields.indexOf(key2) !== -1) {\n        asyncSerialArray(arr, func, next);\n      } else {\n        asyncParallelArray(arr, func, next);\n      }\n    });\n  });\n  pending[\"catch\"](function(e2) {\n    return e2;\n  });\n  return pending;\n}\nfunction isErrorObj(obj) {\n  return !!(obj && obj.message !== void 0);\n}\nfunction getValue$3(value, path) {\n  var v2 = value;\n  for (var i = 0; i < path.length; i++) {\n    if (v2 == void 0) {\n      return v2;\n    }\n    v2 = v2[path[i]];\n  }\n  return v2;\n}\nfunction complementError(rule, source) {\n  return function(oe) {\n    var fieldValue;\n    if (rule.fullFields) {\n      fieldValue = getValue$3(source, rule.fullFields);\n    } else {\n      fieldValue = source[oe.field || rule.fullField];\n    }\n    if (isErrorObj(oe)) {\n      oe.field = oe.field || rule.fullField;\n      oe.fieldValue = fieldValue;\n      return oe;\n    }\n    return {\n      message: typeof oe === \"function\" ? oe() : oe,\n      fieldValue,\n      field: oe.field || rule.fullField\n    };\n  };\n}\nfunction deepMerge(target, source) {\n  if (source) {\n    for (var s in source) {\n      if (source.hasOwnProperty(s)) {\n        var value = source[s];\n        if (typeof value === \"object\" && typeof target[s] === \"object\") {\n          target[s] = _extends({}, target[s], value);\n        } else {\n          target[s] = value;\n        }\n      }\n    }\n  }\n  return target;\n}\nvar required$1 = function required(rule, value, source, errors, options, type4) {\n  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {\n    errors.push(format(options.messages.required, rule.fullField));\n  }\n};\nvar whitespace = function whitespace2(rule, value, source, errors, options) {\n  if (/^\\s+$/.test(value) || value === \"\") {\n    errors.push(format(options.messages.whitespace, rule.fullField));\n  }\n};\nvar pattern$2 = {\n  email: /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+\\.)+[a-zA-Z\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{2,}))$/,\n  url: new RegExp(\"^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\\\S+(?::\\\\S*)?@)?(?:(?:(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[0-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,})))|localhost)(?::\\\\d{2,5})?(?:(/|\\\\?|#)[^\\\\s]*)?$\", \"i\"),\n  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i\n};\nvar types = {\n  integer: function integer(value) {\n    return types.number(value) && parseInt(value, 10) === value;\n  },\n  \"float\": function float(value) {\n    return types.number(value) && !types.integer(value);\n  },\n  array: function array(value) {\n    return Array.isArray(value);\n  },\n  regexp: function regexp(value) {\n    if (value instanceof RegExp) {\n      return true;\n    }\n    try {\n      return !!new RegExp(value);\n    } catch (e2) {\n      return false;\n    }\n  },\n  date: function date(value) {\n    return typeof value.getTime === \"function\" && typeof value.getMonth === \"function\" && typeof value.getYear === \"function\" && !isNaN(value.getTime());\n  },\n  number: function number(value) {\n    if (isNaN(value)) {\n      return false;\n    }\n    return typeof value === \"number\";\n  },\n  object: function object(value) {\n    return typeof value === \"object\" && !types.array(value);\n  },\n  method: function method(value) {\n    return typeof value === \"function\";\n  },\n  email: function email(value) {\n    return typeof value === \"string\" && value.length <= 320 && !!value.match(pattern$2.email);\n  },\n  url: function url(value) {\n    return typeof value === \"string\" && value.length <= 2048 && !!value.match(pattern$2.url);\n  },\n  hex: function hex(value) {\n    return typeof value === \"string\" && !!value.match(pattern$2.hex);\n  }\n};\nvar type$1 = function type(rule, value, source, errors, options) {\n  if (rule.required && value === void 0) {\n    required$1(rule, value, source, errors, options);\n    return;\n  }\n  var custom = [\"integer\", \"float\", \"array\", \"regexp\", \"object\", \"method\", \"email\", \"number\", \"date\", \"url\", \"hex\"];\n  var ruleType = rule.type;\n  if (custom.indexOf(ruleType) > -1) {\n    if (!types[ruleType](value)) {\n      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));\n    }\n  } else if (ruleType && typeof value !== rule.type) {\n    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));\n  }\n};\nvar range = function range2(rule, value, source, errors, options) {\n  var len = typeof rule.len === \"number\";\n  var min = typeof rule.min === \"number\";\n  var max = typeof rule.max === \"number\";\n  var spRegexp = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n  var val = value;\n  var key2 = null;\n  var num = typeof value === \"number\";\n  var str = typeof value === \"string\";\n  var arr = Array.isArray(value);\n  if (num) {\n    key2 = \"number\";\n  } else if (str) {\n    key2 = \"string\";\n  } else if (arr) {\n    key2 = \"array\";\n  }\n  if (!key2) {\n    return false;\n  }\n  if (arr) {\n    val = value.length;\n  }\n  if (str) {\n    val = value.replace(spRegexp, \"_\").length;\n  }\n  if (len) {\n    if (val !== rule.len) {\n      errors.push(format(options.messages[key2].len, rule.fullField, rule.len));\n    }\n  } else if (min && !max && val < rule.min) {\n    errors.push(format(options.messages[key2].min, rule.fullField, rule.min));\n  } else if (max && !min && val > rule.max) {\n    errors.push(format(options.messages[key2].max, rule.fullField, rule.max));\n  } else if (min && max && (val < rule.min || val > rule.max)) {\n    errors.push(format(options.messages[key2].range, rule.fullField, rule.min, rule.max));\n  }\n};\nvar ENUM$1 = \"enum\";\nvar enumerable$1 = function enumerable(rule, value, source, errors, options) {\n  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];\n  if (rule[ENUM$1].indexOf(value) === -1) {\n    errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(\", \")));\n  }\n};\nvar pattern$1 = function pattern(rule, value, source, errors, options) {\n  if (rule.pattern) {\n    if (rule.pattern instanceof RegExp) {\n      rule.pattern.lastIndex = 0;\n      if (!rule.pattern.test(value)) {\n        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n      }\n    } else if (typeof rule.pattern === \"string\") {\n      var _pattern = new RegExp(rule.pattern);\n      if (!_pattern.test(value)) {\n        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n      }\n    }\n  }\n};\nvar rules = {\n  required: required$1,\n  whitespace,\n  type: type$1,\n  range,\n  \"enum\": enumerable$1,\n  pattern: pattern$1\n};\nvar string = function string2(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n  if (validate) {\n    if (isEmptyValue(value, \"string\") && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options, \"string\");\n    if (!isEmptyValue(value, \"string\")) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n      rules.pattern(rule, value, source, errors, options);\n      if (rule.whitespace === true) {\n        rules.whitespace(rule, value, source, errors, options);\n      }\n    }\n  }\n  callback(errors);\n};\nvar method2 = function method3(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== void 0) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\nvar number2 = function number3(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n  if (validate) {\n    if (value === \"\") {\n      value = void 0;\n    }\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== void 0) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\nvar _boolean = function _boolean2(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== void 0) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\nvar regexp2 = function regexp3(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (!isEmptyValue(value)) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\nvar integer2 = function integer3(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== void 0) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\nvar floatFn = function floatFn2(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== void 0) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\nvar array2 = function array3(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n  if (validate) {\n    if ((value === void 0 || value === null) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options, \"array\");\n    if (value !== void 0 && value !== null) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\nvar object2 = function object3(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== void 0) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\nvar ENUM = \"enum\";\nvar enumerable2 = function enumerable3(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== void 0) {\n      rules[ENUM](rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\nvar pattern2 = function pattern3(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n  if (validate) {\n    if (isEmptyValue(value, \"string\") && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (!isEmptyValue(value, \"string\")) {\n      rules.pattern(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\nvar date2 = function date3(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n  if (validate) {\n    if (isEmptyValue(value, \"date\") && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (!isEmptyValue(value, \"date\")) {\n      var dateObject;\n      if (value instanceof Date) {\n        dateObject = value;\n      } else {\n        dateObject = new Date(value);\n      }\n      rules.type(rule, dateObject, source, errors, options);\n      if (dateObject) {\n        rules.range(rule, dateObject.getTime(), source, errors, options);\n      }\n    }\n  }\n  callback(errors);\n};\nvar required2 = function required3(rule, value, callback, source, options) {\n  var errors = [];\n  var type4 = Array.isArray(value) ? \"array\" : typeof value;\n  rules.required(rule, value, source, errors, options, type4);\n  callback(errors);\n};\nvar type2 = function type3(rule, value, callback, source, options) {\n  var ruleType = rule.type;\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n  if (validate) {\n    if (isEmptyValue(value, ruleType) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options, ruleType);\n    if (!isEmptyValue(value, ruleType)) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\nvar any = function any2(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n  }\n  callback(errors);\n};\nvar validators = {\n  string,\n  method: method2,\n  number: number2,\n  \"boolean\": _boolean,\n  regexp: regexp2,\n  integer: integer2,\n  \"float\": floatFn,\n  array: array2,\n  object: object2,\n  \"enum\": enumerable2,\n  pattern: pattern2,\n  date: date2,\n  url: type2,\n  hex: type2,\n  email: type2,\n  required: required2,\n  any\n};\nfunction newMessages() {\n  return {\n    \"default\": \"Validation error on field %s\",\n    required: \"%s is required\",\n    \"enum\": \"%s must be one of %s\",\n    whitespace: \"%s cannot be empty\",\n    date: {\n      format: \"%s date %s is invalid for format %s\",\n      parse: \"%s date could not be parsed, %s is invalid \",\n      invalid: \"%s date %s is invalid\"\n    },\n    types: {\n      string: \"%s is not a %s\",\n      method: \"%s is not a %s (function)\",\n      array: \"%s is not an %s\",\n      object: \"%s is not an %s\",\n      number: \"%s is not a %s\",\n      date: \"%s is not a %s\",\n      \"boolean\": \"%s is not a %s\",\n      integer: \"%s is not an %s\",\n      \"float\": \"%s is not a %s\",\n      regexp: \"%s is not a valid %s\",\n      email: \"%s is not a valid %s\",\n      url: \"%s is not a valid %s\",\n      hex: \"%s is not a valid %s\"\n    },\n    string: {\n      len: \"%s must be exactly %s characters\",\n      min: \"%s must be at least %s characters\",\n      max: \"%s cannot be longer than %s characters\",\n      range: \"%s must be between %s and %s characters\"\n    },\n    number: {\n      len: \"%s must equal %s\",\n      min: \"%s cannot be less than %s\",\n      max: \"%s cannot be greater than %s\",\n      range: \"%s must be between %s and %s\"\n    },\n    array: {\n      len: \"%s must be exactly %s in length\",\n      min: \"%s cannot be less than %s in length\",\n      max: \"%s cannot be greater than %s in length\",\n      range: \"%s must be between %s and %s in length\"\n    },\n    pattern: {\n      mismatch: \"%s value %s does not match pattern %s\"\n    },\n    clone: function clone2() {\n      var cloned = JSON.parse(JSON.stringify(this));\n      cloned.clone = this.clone;\n      return cloned;\n    }\n  };\n}\nvar messages = newMessages();\nvar Schema = /* @__PURE__ */ function() {\n  function Schema2(descriptor) {\n    this.rules = null;\n    this._messages = messages;\n    this.define(descriptor);\n  }\n  var _proto = Schema2.prototype;\n  _proto.define = function define(rules2) {\n    var _this = this;\n    if (!rules2) {\n      throw new Error(\"Cannot configure a schema with no rules\");\n    }\n    if (typeof rules2 !== \"object\" || Array.isArray(rules2)) {\n      throw new Error(\"Rules must be an object\");\n    }\n    this.rules = {};\n    Object.keys(rules2).forEach(function(name) {\n      var item = rules2[name];\n      _this.rules[name] = Array.isArray(item) ? item : [item];\n    });\n  };\n  _proto.messages = function messages2(_messages) {\n    if (_messages) {\n      this._messages = deepMerge(newMessages(), _messages);\n    }\n    return this._messages;\n  };\n  _proto.validate = function validate(source_, o, oc) {\n    var _this2 = this;\n    if (o === void 0) {\n      o = {};\n    }\n    if (oc === void 0) {\n      oc = function oc2() {\n      };\n    }\n    var source = source_;\n    var options = o;\n    var callback = oc;\n    if (typeof options === \"function\") {\n      callback = options;\n      options = {};\n    }\n    if (!this.rules || Object.keys(this.rules).length === 0) {\n      if (callback) {\n        callback(null, source);\n      }\n      return Promise.resolve(source);\n    }\n    function complete(results) {\n      var errors = [];\n      var fields = {};\n      function add(e2) {\n        if (Array.isArray(e2)) {\n          var _errors;\n          errors = (_errors = errors).concat.apply(_errors, e2);\n        } else {\n          errors.push(e2);\n        }\n      }\n      for (var i = 0; i < results.length; i++) {\n        add(results[i]);\n      }\n      if (!errors.length) {\n        callback(null, source);\n      } else {\n        fields = convertFieldsError(errors);\n        callback(errors, fields);\n      }\n    }\n    if (options.messages) {\n      var messages$1 = this.messages();\n      if (messages$1 === messages) {\n        messages$1 = newMessages();\n      }\n      deepMerge(messages$1, options.messages);\n      options.messages = messages$1;\n    } else {\n      options.messages = this.messages();\n    }\n    var series = {};\n    var keys2 = options.keys || Object.keys(this.rules);\n    keys2.forEach(function(z2) {\n      var arr = _this2.rules[z2];\n      var value = source[z2];\n      arr.forEach(function(r2) {\n        var rule = r2;\n        if (typeof rule.transform === \"function\") {\n          if (source === source_) {\n            source = _extends({}, source);\n          }\n          value = source[z2] = rule.transform(value);\n        }\n        if (typeof rule === \"function\") {\n          rule = {\n            validator: rule\n          };\n        } else {\n          rule = _extends({}, rule);\n        }\n        rule.validator = _this2.getValidationMethod(rule);\n        if (!rule.validator) {\n          return;\n        }\n        rule.field = z2;\n        rule.fullField = rule.fullField || z2;\n        rule.type = _this2.getType(rule);\n        series[z2] = series[z2] || [];\n        series[z2].push({\n          rule,\n          value,\n          source,\n          field: z2\n        });\n      });\n    });\n    var errorFields = {};\n    return asyncMap(series, options, function(data, doIt) {\n      var rule = data.rule;\n      var deep = (rule.type === \"object\" || rule.type === \"array\") && (typeof rule.fields === \"object\" || typeof rule.defaultField === \"object\");\n      deep = deep && (rule.required || !rule.required && data.value);\n      rule.field = data.field;\n      function addFullField(key2, schema) {\n        return _extends({}, schema, {\n          fullField: rule.fullField + \".\" + key2,\n          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key2]) : [key2]\n        });\n      }\n      function cb(e2) {\n        if (e2 === void 0) {\n          e2 = [];\n        }\n        var errorList = Array.isArray(e2) ? e2 : [e2];\n        if (!options.suppressWarning && errorList.length) {\n          Schema2.warning(\"async-validator:\", errorList);\n        }\n        if (errorList.length && rule.message !== void 0) {\n          errorList = [].concat(rule.message);\n        }\n        var filledErrors = errorList.map(complementError(rule, source));\n        if (options.first && filledErrors.length) {\n          errorFields[rule.field] = 1;\n          return doIt(filledErrors);\n        }\n        if (!deep) {\n          doIt(filledErrors);\n        } else {\n          if (rule.required && !data.value) {\n            if (rule.message !== void 0) {\n              filledErrors = [].concat(rule.message).map(complementError(rule, source));\n            } else if (options.error) {\n              filledErrors = [options.error(rule, format(options.messages.required, rule.field))];\n            }\n            return doIt(filledErrors);\n          }\n          var fieldsSchema = {};\n          if (rule.defaultField) {\n            Object.keys(data.value).map(function(key2) {\n              fieldsSchema[key2] = rule.defaultField;\n            });\n          }\n          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);\n          var paredFieldsSchema = {};\n          Object.keys(fieldsSchema).forEach(function(field) {\n            var fieldSchema = fieldsSchema[field];\n            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];\n            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));\n          });\n          var schema = new Schema2(paredFieldsSchema);\n          schema.messages(options.messages);\n          if (data.rule.options) {\n            data.rule.options.messages = options.messages;\n            data.rule.options.error = options.error;\n          }\n          schema.validate(data.value, data.rule.options || options, function(errs) {\n            var finalErrors = [];\n            if (filledErrors && filledErrors.length) {\n              finalErrors.push.apply(finalErrors, filledErrors);\n            }\n            if (errs && errs.length) {\n              finalErrors.push.apply(finalErrors, errs);\n            }\n            doIt(finalErrors.length ? finalErrors : null);\n          });\n        }\n      }\n      var res;\n      if (rule.asyncValidator) {\n        res = rule.asyncValidator(rule, data.value, cb, data.source, options);\n      } else if (rule.validator) {\n        res = rule.validator(rule, data.value, cb, data.source, options);\n        if (res === true) {\n          cb();\n        } else if (res === false) {\n          cb(typeof rule.message === \"function\" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + \" fails\");\n        } else if (res instanceof Array) {\n          cb(res);\n        } else if (res instanceof Error) {\n          cb(res.message);\n        }\n      }\n      if (res && res.then) {\n        res.then(function() {\n          return cb();\n        }, function(e2) {\n          return cb(e2);\n        });\n      }\n    }, function(results) {\n      complete(results);\n    }, source);\n  };\n  _proto.getType = function getType(rule) {\n    if (rule.type === void 0 && rule.pattern instanceof RegExp) {\n      rule.type = \"pattern\";\n    }\n    if (typeof rule.validator !== \"function\" && rule.type && !validators.hasOwnProperty(rule.type)) {\n      throw new Error(format(\"Unknown rule type %s\", rule.type));\n    }\n    return rule.type || \"string\";\n  };\n  _proto.getValidationMethod = function getValidationMethod(rule) {\n    if (typeof rule.validator === \"function\") {\n      return rule.validator;\n    }\n    var keys2 = Object.keys(rule);\n    var messageIndex = keys2.indexOf(\"message\");\n    if (messageIndex !== -1) {\n      keys2.splice(messageIndex, 1);\n    }\n    if (keys2.length === 1 && keys2[0] === \"required\") {\n      return validators.required;\n    }\n    return validators[this.getType(rule)] || void 0;\n  };\n  return Schema2;\n}();\nSchema.register = function register(type4, validator) {\n  if (typeof validator !== \"function\") {\n    throw new Error(\"Cannot register a validator by type, validator is not a function\");\n  }\n  validators[type4] = validator;\n};\nSchema.warning = warning;\nSchema.messages = messages;\nSchema.validators = validators;\nvar typeTemplate$1 = \"'${name}' is not a valid ${type}\";\nvar defaultValidateMessages = {\n  default: \"Validation error on field '${name}'\",\n  required: \"'${name}' is required\",\n  enum: \"'${name}' must be one of [${enum}]\",\n  whitespace: \"'${name}' cannot be empty\",\n  date: {\n    format: \"'${name}' is invalid for format date\",\n    parse: \"'${name}' could not be parsed as date\",\n    invalid: \"'${name}' is invalid date\"\n  },\n  types: {\n    string: typeTemplate$1,\n    method: typeTemplate$1,\n    array: typeTemplate$1,\n    object: typeTemplate$1,\n    number: typeTemplate$1,\n    date: typeTemplate$1,\n    boolean: typeTemplate$1,\n    integer: typeTemplate$1,\n    float: typeTemplate$1,\n    regexp: typeTemplate$1,\n    email: typeTemplate$1,\n    url: typeTemplate$1,\n    hex: typeTemplate$1\n  },\n  string: {\n    len: \"'${name}' must be exactly ${len} characters\",\n    min: \"'${name}' must be at least ${min} characters\",\n    max: \"'${name}' cannot be longer than ${max} characters\",\n    range: \"'${name}' must be between ${min} and ${max} characters\"\n  },\n  number: {\n    len: \"'${name}' must equal ${len}\",\n    min: \"'${name}' cannot be less than ${min}\",\n    max: \"'${name}' cannot be greater than ${max}\",\n    range: \"'${name}' must be between ${min} and ${max}\"\n  },\n  array: {\n    len: \"'${name}' must be exactly ${len} in length\",\n    min: \"'${name}' cannot be less than ${min} in length\",\n    max: \"'${name}' cannot be greater than ${max} in length\",\n    range: \"'${name}' must be between ${min} and ${max} in length\"\n  },\n  pattern: {\n    mismatch: \"'${name}' does not match pattern ${pattern}\"\n  }\n};\nfunction get(entity, path) {\n  var current = entity;\n  for (var i = 0; i < path.length; i += 1) {\n    if (current === null || current === void 0) {\n      return void 0;\n    }\n    current = current[path[i]];\n  }\n  return current;\n}\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\nfunction internalSet(entity, paths, value, removeIfUndefined) {\n  if (!paths.length) {\n    return value;\n  }\n  var _paths = _toArray(paths), path = _paths[0], restPath = _paths.slice(1);\n  var clone2;\n  if (!entity && typeof path === \"number\") {\n    clone2 = [];\n  } else if (Array.isArray(entity)) {\n    clone2 = _toConsumableArray(entity);\n  } else {\n    clone2 = _objectSpread2$1({}, entity);\n  }\n  if (removeIfUndefined && value === void 0 && restPath.length === 1) {\n    delete clone2[path][restPath[0]];\n  } else {\n    clone2[path] = internalSet(clone2[path], restPath, value, removeIfUndefined);\n  }\n  return clone2;\n}\nfunction set(entity, paths, value) {\n  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n  if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {\n    return entity;\n  }\n  return internalSet(entity, paths, value, removeIfUndefined);\n}\nfunction getNamePath(path) {\n  return toArray(path);\n}\nfunction getValue$2(store, namePath) {\n  var value = get(store, namePath);\n  return value;\n}\nfunction setValue(store, namePath, value) {\n  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n  var newStore = set(store, namePath, value, removeIfUndefined);\n  return newStore;\n}\nfunction cloneByNamePathList(store, namePathList) {\n  var newStore = {};\n  namePathList.forEach(function(namePath) {\n    var value = getValue$2(store, namePath);\n    newStore = setValue(newStore, namePath, value);\n  });\n  return newStore;\n}\nfunction containsNamePath(namePathList, namePath) {\n  return namePathList && namePathList.some(function(path) {\n    return matchNamePath(path, namePath);\n  });\n}\nfunction isObject$3(obj) {\n  return _typeof$1(obj) === \"object\" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;\n}\nfunction internalSetValues(store, values) {\n  var newStore = Array.isArray(store) ? _toConsumableArray(store) : _objectSpread2$1({}, store);\n  if (!values) {\n    return newStore;\n  }\n  Object.keys(values).forEach(function(key2) {\n    var prevValue = newStore[key2];\n    var value = values[key2];\n    var recursive = isObject$3(prevValue) && isObject$3(value);\n    newStore[key2] = recursive ? internalSetValues(prevValue, value || {}) : value;\n  });\n  return newStore;\n}\nfunction setValues(store) {\n  for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    restValues[_key - 1] = arguments[_key];\n  }\n  return restValues.reduce(function(current, newStore) {\n    return internalSetValues(current, newStore);\n  }, store);\n}\nfunction matchNamePath(namePath, changedNamePath) {\n  if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {\n    return false;\n  }\n  return namePath.every(function(nameUnit, i) {\n    return changedNamePath[i] === nameUnit;\n  });\n}\nfunction isSimilar(source, target) {\n  if (source === target) {\n    return true;\n  }\n  if (!source && target || source && !target) {\n    return false;\n  }\n  if (!source || !target || _typeof$1(source) !== \"object\" || _typeof$1(target) !== \"object\") {\n    return false;\n  }\n  var sourceKeys = Object.keys(source);\n  var targetKeys = Object.keys(target);\n  var keys2 = new Set([].concat(_toConsumableArray(sourceKeys), _toConsumableArray(targetKeys)));\n  return _toConsumableArray(keys2).every(function(key2) {\n    var sourceValue = source[key2];\n    var targetValue = target[key2];\n    if (typeof sourceValue === \"function\" && typeof targetValue === \"function\") {\n      return true;\n    }\n    return sourceValue === targetValue;\n  });\n}\nfunction defaultGetValueFromEvent(valuePropName) {\n  var event = arguments.length <= 1 ? void 0 : arguments[1];\n  if (event && event.target && _typeof$1(event.target) === \"object\" && valuePropName in event.target) {\n    return event.target[valuePropName];\n  }\n  return event;\n}\nfunction move(array4, moveIndex, toIndex) {\n  var length = array4.length;\n  if (moveIndex < 0 || moveIndex >= length || toIndex < 0 || toIndex >= length) {\n    return array4;\n  }\n  var item = array4[moveIndex];\n  var diff = moveIndex - toIndex;\n  if (diff > 0) {\n    return [].concat(_toConsumableArray(array4.slice(0, toIndex)), [item], _toConsumableArray(array4.slice(toIndex, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, length)));\n  }\n  if (diff < 0) {\n    return [].concat(_toConsumableArray(array4.slice(0, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array4.slice(toIndex + 1, length)));\n  }\n  return array4;\n}\nvar AsyncValidator = Schema;\nfunction replaceMessage(template, kv) {\n  return template.replace(/\\$\\{\\w+\\}/g, function(str) {\n    var key2 = str.slice(2, -1);\n    return kv[key2];\n  });\n}\nfunction validateRule(_x, _x2, _x3, _x4, _x5) {\n  return _validateRule.apply(this, arguments);\n}\nfunction _validateRule() {\n  _validateRule = _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee2(name, value, rule, options, messageVariables) {\n    var cloneRule, subRuleField, validator, messages2, result, subResults, kv, fillVariableResult;\n    return regenerator.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            cloneRule = _objectSpread2$1({}, rule);\n            delete cloneRule.ruleIndex;\n            subRuleField = null;\n            if (cloneRule && cloneRule.type === \"array\" && cloneRule.defaultField) {\n              subRuleField = cloneRule.defaultField;\n              delete cloneRule.defaultField;\n            }\n            validator = new AsyncValidator(_defineProperty$1({}, name, [cloneRule]));\n            messages2 = setValues({}, defaultValidateMessages, options.validateMessages);\n            validator.messages(messages2);\n            result = [];\n            _context2.prev = 8;\n            _context2.next = 11;\n            return Promise.resolve(validator.validate(_defineProperty$1({}, name, value), _objectSpread2$1({}, options)));\n          case 11:\n            _context2.next = 16;\n            break;\n          case 13:\n            _context2.prev = 13;\n            _context2.t0 = _context2[\"catch\"](8);\n            if (_context2.t0.errors) {\n              result = _context2.t0.errors.map(function(_ref4, index2) {\n                var message2 = _ref4.message;\n                return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(message2) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(message2, {\n                  key: \"error_\".concat(index2)\n                }) : message2;\n              });\n            } else {\n              console.error(_context2.t0);\n              result = [messages2.default];\n            }\n          case 16:\n            if (!(!result.length && subRuleField)) {\n              _context2.next = 21;\n              break;\n            }\n            _context2.next = 19;\n            return Promise.all(value.map(function(subValue, i) {\n              return validateRule(\"\".concat(name, \".\").concat(i), subValue, subRuleField, options, messageVariables);\n            }));\n          case 19:\n            subResults = _context2.sent;\n            return _context2.abrupt(\"return\", subResults.reduce(function(prev, errors) {\n              return [].concat(_toConsumableArray(prev), _toConsumableArray(errors));\n            }, []));\n          case 21:\n            kv = _objectSpread2$1(_objectSpread2$1({}, rule), {}, {\n              name,\n              enum: (rule.enum || []).join(\", \")\n            }, messageVariables);\n            fillVariableResult = result.map(function(error) {\n              if (typeof error === \"string\") {\n                return replaceMessage(error, kv);\n              }\n              return error;\n            });\n            return _context2.abrupt(\"return\", fillVariableResult);\n          case 24:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[8, 13]]);\n  }));\n  return _validateRule.apply(this, arguments);\n}\nfunction validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {\n  var name = namePath.join(\".\");\n  var filledRules = rules2.map(function(currentRule, ruleIndex) {\n    var originValidatorFunc = currentRule.validator;\n    var cloneRule = _objectSpread2$1(_objectSpread2$1({}, currentRule), {}, {\n      ruleIndex\n    });\n    if (originValidatorFunc) {\n      cloneRule.validator = function(rule, val, callback) {\n        var hasPromise = false;\n        var wrappedCallback = function wrappedCallback2() {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          Promise.resolve().then(function() {\n            warningOnce(!hasPromise, \"Your validator function has already return a promise. `callback` will be ignored.\");\n            if (!hasPromise) {\n              callback.apply(void 0, args);\n            }\n          });\n        };\n        var promise = originValidatorFunc(rule, val, wrappedCallback);\n        hasPromise = promise && typeof promise.then === \"function\" && typeof promise.catch === \"function\";\n        warningOnce(hasPromise, \"`callback` is deprecated. Please return a promise instead.\");\n        if (hasPromise) {\n          promise.then(function() {\n            callback();\n          }).catch(function(err) {\n            callback(err || \" \");\n          });\n        }\n      };\n    }\n    return cloneRule;\n  }).sort(function(_ref, _ref2) {\n    var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;\n    var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;\n    if (!!w1 === !!w2) {\n      return i1 - i2;\n    }\n    if (w1) {\n      return 1;\n    }\n    return -1;\n  });\n  var summaryPromise;\n  if (validateFirst === true) {\n    summaryPromise = new Promise(/* @__PURE__ */ function() {\n      var _ref3 = _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee(resolve, reject) {\n        var i, rule, errors;\n        return regenerator.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                i = 0;\n              case 1:\n                if (!(i < filledRules.length)) {\n                  _context.next = 12;\n                  break;\n                }\n                rule = filledRules[i];\n                _context.next = 5;\n                return validateRule(name, value, rule, options, messageVariables);\n              case 5:\n                errors = _context.sent;\n                if (!errors.length) {\n                  _context.next = 9;\n                  break;\n                }\n                reject([{\n                  errors,\n                  rule\n                }]);\n                return _context.abrupt(\"return\");\n              case 9:\n                i += 1;\n                _context.next = 1;\n                break;\n              case 12:\n                resolve([]);\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function(_x6, _x7) {\n        return _ref3.apply(this, arguments);\n      };\n    }());\n  } else {\n    var rulePromises = filledRules.map(function(rule) {\n      return validateRule(name, value, rule, options, messageVariables).then(function(errors) {\n        return {\n          errors,\n          rule\n        };\n      });\n    });\n    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {\n      return Promise.reject(errors);\n    });\n  }\n  summaryPromise.catch(function(e2) {\n    return e2;\n  });\n  return summaryPromise;\n}\nfunction finishOnAllFailed(_x8) {\n  return _finishOnAllFailed.apply(this, arguments);\n}\nfunction _finishOnAllFailed() {\n  _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee3(rulePromises) {\n    return regenerator.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", Promise.all(rulePromises).then(function(errorsList) {\n              var _ref5;\n              var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));\n              return errors;\n            }));\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _finishOnAllFailed.apply(this, arguments);\n}\nfunction finishOnFirstFailed(_x9) {\n  return _finishOnFirstFailed.apply(this, arguments);\n}\nfunction _finishOnFirstFailed() {\n  _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee4(rulePromises) {\n    var count;\n    return regenerator.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            count = 0;\n            return _context4.abrupt(\"return\", new Promise(function(resolve) {\n              rulePromises.forEach(function(promise) {\n                promise.then(function(ruleError) {\n                  if (ruleError.errors.length) {\n                    resolve([ruleError]);\n                  }\n                  count += 1;\n                  if (count === rulePromises.length) {\n                    resolve([]);\n                  }\n                });\n              });\n            }));\n          case 2:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _finishOnFirstFailed.apply(this, arguments);\n}\nvar _excluded$3 = [\"name\"];\nvar EMPTY_ERRORS = [];\nfunction requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info) {\n  if (typeof shouldUpdate === \"function\") {\n    return shouldUpdate(prev, next, \"source\" in info ? {\n      source: info.source\n    } : {});\n  }\n  return prevValue !== nextValue;\n}\nvar Field = /* @__PURE__ */ function(_React$Component) {\n  _inherits(Field2, _React$Component);\n  var _super = _createSuper(Field2);\n  function Field2(props) {\n    var _this;\n    _classCallCheck(this, Field2);\n    _this = _super.call(this, props);\n    _this.state = {\n      resetCount: 0\n    };\n    _this.cancelRegisterFunc = null;\n    _this.mounted = false;\n    _this.touched = false;\n    _this.dirty = false;\n    _this.validatePromise = null;\n    _this.prevValidating = void 0;\n    _this.errors = EMPTY_ERRORS;\n    _this.warnings = EMPTY_ERRORS;\n    _this.cancelRegister = function() {\n      var _this$props = _this.props, preserve = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;\n      if (_this.cancelRegisterFunc) {\n        _this.cancelRegisterFunc(isListField, preserve, getNamePath(name));\n      }\n      _this.cancelRegisterFunc = null;\n    };\n    _this.getNamePath = function() {\n      var _this$props2 = _this.props, name = _this$props2.name, fieldContext = _this$props2.fieldContext;\n      var _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;\n      return name !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];\n    };\n    _this.getRules = function() {\n      var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules2 = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;\n      return rules2.map(function(rule) {\n        if (typeof rule === \"function\") {\n          return rule(fieldContext);\n        }\n        return rule;\n      });\n    };\n    _this.refresh = function() {\n      if (!_this.mounted)\n        return;\n      _this.setState(function(_ref) {\n        var resetCount = _ref.resetCount;\n        return {\n          resetCount: resetCount + 1\n        };\n      });\n    };\n    _this.triggerMetaEvent = function(destroy3) {\n      var onMetaChange = _this.props.onMetaChange;\n      onMetaChange === null || onMetaChange === void 0 ? void 0 : onMetaChange(_objectSpread2$1(_objectSpread2$1({}, _this.getMeta()), {}, {\n        destroy: destroy3\n      }));\n    };\n    _this.onStoreChange = function(prevStore, namePathList, info) {\n      var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;\n      var store = info.store;\n      var namePath = _this.getNamePath();\n      var prevValue = _this.getValue(prevStore);\n      var curValue = _this.getValue(store);\n      var namePathMatch = namePathList && containsNamePath(namePathList, namePath);\n      if (info.type === \"valueUpdate\" && info.source === \"external\" && prevValue !== curValue) {\n        _this.touched = true;\n        _this.dirty = true;\n        _this.validatePromise = null;\n        _this.errors = EMPTY_ERRORS;\n        _this.warnings = EMPTY_ERRORS;\n        _this.triggerMetaEvent();\n      }\n      switch (info.type) {\n        case \"reset\":\n          if (!namePathList || namePathMatch) {\n            _this.touched = false;\n            _this.dirty = false;\n            _this.validatePromise = null;\n            _this.errors = EMPTY_ERRORS;\n            _this.warnings = EMPTY_ERRORS;\n            _this.triggerMetaEvent();\n            onReset === null || onReset === void 0 ? void 0 : onReset();\n            _this.refresh();\n            return;\n          }\n          break;\n        case \"remove\": {\n          if (shouldUpdate) {\n            _this.reRender();\n            return;\n          }\n          break;\n        }\n        case \"setField\": {\n          if (namePathMatch) {\n            var data = info.data;\n            if (\"touched\" in data) {\n              _this.touched = data.touched;\n            }\n            if (\"validating\" in data && !(\"originRCField\" in data)) {\n              _this.validatePromise = data.validating ? Promise.resolve([]) : null;\n            }\n            if (\"errors\" in data) {\n              _this.errors = data.errors || EMPTY_ERRORS;\n            }\n            if (\"warnings\" in data) {\n              _this.warnings = data.warnings || EMPTY_ERRORS;\n            }\n            _this.dirty = true;\n            _this.triggerMetaEvent();\n            _this.reRender();\n            return;\n          }\n          if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n            _this.reRender();\n            return;\n          }\n          break;\n        }\n        case \"dependenciesUpdate\": {\n          var dependencyList = dependencies.map(getNamePath);\n          if (dependencyList.some(function(dependency) {\n            return containsNamePath(info.relatedFields, dependency);\n          })) {\n            _this.reRender();\n            return;\n          }\n          break;\n        }\n        default:\n          if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n            _this.reRender();\n            return;\n          }\n          break;\n      }\n      if (shouldUpdate === true) {\n        _this.reRender();\n      }\n    };\n    _this.validateRules = function(options) {\n      var namePath = _this.getNamePath();\n      var currentValue = _this.getValue();\n      var rootPromise = Promise.resolve().then(function() {\n        if (!_this.mounted) {\n          return [];\n        }\n        var _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables;\n        var _ref2 = options || {}, triggerName = _ref2.triggerName;\n        var filteredRules = _this.getRules();\n        if (triggerName) {\n          filteredRules = filteredRules.filter(function(rule) {\n            var validateTrigger = rule.validateTrigger;\n            if (!validateTrigger) {\n              return true;\n            }\n            var triggerList = toArray(validateTrigger);\n            return triggerList.includes(triggerName);\n          });\n        }\n        var promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);\n        promise.catch(function(e2) {\n          return e2;\n        }).then(function() {\n          var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;\n          if (_this.validatePromise === rootPromise) {\n            _this.validatePromise = null;\n            var nextErrors = [];\n            var nextWarnings = [];\n            ruleErrors.forEach(function(_ref3) {\n              var warningOnly = _ref3.rule.warningOnly, _ref3$errors = _ref3.errors, errors = _ref3$errors === void 0 ? EMPTY_ERRORS : _ref3$errors;\n              if (warningOnly) {\n                nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));\n              } else {\n                nextErrors.push.apply(nextErrors, _toConsumableArray(errors));\n              }\n            });\n            _this.errors = nextErrors;\n            _this.warnings = nextWarnings;\n            _this.triggerMetaEvent();\n            _this.reRender();\n          }\n        });\n        return promise;\n      });\n      _this.validatePromise = rootPromise;\n      _this.dirty = true;\n      _this.errors = EMPTY_ERRORS;\n      _this.warnings = EMPTY_ERRORS;\n      _this.triggerMetaEvent();\n      _this.reRender();\n      return rootPromise;\n    };\n    _this.isFieldValidating = function() {\n      return !!_this.validatePromise;\n    };\n    _this.isFieldTouched = function() {\n      return _this.touched;\n    };\n    _this.isFieldDirty = function() {\n      if (_this.dirty || _this.props.initialValue !== void 0) {\n        return true;\n      }\n      var fieldContext = _this.props.fieldContext;\n      var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;\n      if (getInitialValue(_this.getNamePath()) !== void 0) {\n        return true;\n      }\n      return false;\n    };\n    _this.getErrors = function() {\n      return _this.errors;\n    };\n    _this.getWarnings = function() {\n      return _this.warnings;\n    };\n    _this.isListField = function() {\n      return _this.props.isListField;\n    };\n    _this.isList = function() {\n      return _this.props.isList;\n    };\n    _this.isPreserve = function() {\n      return _this.props.preserve;\n    };\n    _this.getMeta = function() {\n      _this.prevValidating = _this.isFieldValidating();\n      var meta = {\n        touched: _this.isFieldTouched(),\n        validating: _this.prevValidating,\n        errors: _this.errors,\n        warnings: _this.warnings,\n        name: _this.getNamePath()\n      };\n      return meta;\n    };\n    _this.getOnlyChild = function(children) {\n      if (typeof children === \"function\") {\n        var meta = _this.getMeta();\n        return _objectSpread2$1(_objectSpread2$1({}, _this.getOnlyChild(children(_this.getControlled(), meta, _this.props.fieldContext))), {}, {\n          isFunction: true\n        });\n      }\n      var childList = toArray$1(children);\n      if (childList.length !== 1 || !/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(childList[0])) {\n        return {\n          child: childList,\n          isFunction: false\n        };\n      }\n      return {\n        child: childList[0],\n        isFunction: false\n      };\n    };\n    _this.getValue = function(store) {\n      var getFieldsValue = _this.props.fieldContext.getFieldsValue;\n      var namePath = _this.getNamePath();\n      return getValue$2(store || getFieldsValue(true), namePath);\n    };\n    _this.getControlled = function() {\n      var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n      var _this$props6 = _this.props, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;\n      var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;\n      var namePath = _this.getNamePath();\n      var getInternalHooks3 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;\n      var _getInternalHooks = getInternalHooks3(HOOK_MARK), dispatch = _getInternalHooks.dispatch;\n      var value = _this.getValue();\n      var mergedGetValueProps = getValueProps || function(val) {\n        return _defineProperty$1({}, valuePropName, val);\n      };\n      var originTriggerFunc = childProps[trigger];\n      var control = _objectSpread2$1(_objectSpread2$1({}, childProps), mergedGetValueProps(value));\n      control[trigger] = function() {\n        _this.touched = true;\n        _this.dirty = true;\n        _this.triggerMetaEvent();\n        var newValue;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        if (getValueFromEvent) {\n          newValue = getValueFromEvent.apply(void 0, args);\n        } else {\n          newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));\n        }\n        if (normalize2) {\n          newValue = normalize2(newValue, value, getFieldsValue(true));\n        }\n        dispatch({\n          type: \"updateValue\",\n          namePath,\n          value: newValue\n        });\n        if (originTriggerFunc) {\n          originTriggerFunc.apply(void 0, args);\n        }\n      };\n      var validateTriggerList = toArray(mergedValidateTrigger || []);\n      validateTriggerList.forEach(function(triggerName) {\n        var originTrigger = control[triggerName];\n        control[triggerName] = function() {\n          if (originTrigger) {\n            originTrigger.apply(void 0, arguments);\n          }\n          var rules2 = _this.props.rules;\n          if (rules2 && rules2.length) {\n            dispatch({\n              type: \"validateField\",\n              namePath,\n              triggerName\n            });\n          }\n        };\n      });\n      return control;\n    };\n    if (props.fieldContext) {\n      var getInternalHooks2 = props.fieldContext.getInternalHooks;\n      var _getInternalHooks2 = getInternalHooks2(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;\n      initEntityValue(_assertThisInitialized(_this));\n    }\n    return _this;\n  }\n  _createClass(Field2, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;\n      this.mounted = true;\n      if (fieldContext) {\n        var getInternalHooks2 = fieldContext.getInternalHooks;\n        var _getInternalHooks3 = getInternalHooks2(HOOK_MARK), registerField = _getInternalHooks3.registerField;\n        this.cancelRegisterFunc = registerField(this);\n      }\n      if (shouldUpdate === true) {\n        this.reRender();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.cancelRegister();\n      this.triggerMetaEvent(true);\n      this.mounted = false;\n    }\n  }, {\n    key: \"reRender\",\n    value: function reRender() {\n      if (!this.mounted)\n        return;\n      this.forceUpdate();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var resetCount = this.state.resetCount;\n      var children = this.props.children;\n      var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction2 = _this$getOnlyChild.isFunction;\n      var returnChildNode;\n      if (isFunction2) {\n        returnChildNode = child;\n      } else if (/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(child)) {\n        returnChildNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, this.getControlled(child.props));\n      } else {\n        warningOnce(!child, \"`children` of Field is not validate ReactElement.\");\n        returnChildNode = child;\n      }\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        key: resetCount\n      }, returnChildNode);\n    }\n  }]);\n  return Field2;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nField.contextType = Context;\nField.defaultProps = {\n  trigger: \"onChange\",\n  valuePropName: \"value\"\n};\nfunction WrapperField(_ref5) {\n  var name = _ref5.name, restProps = _objectWithoutProperties(_ref5, _excluded$3);\n  var fieldContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Context);\n  var namePath = name !== void 0 ? getNamePath(name) : void 0;\n  var key2 = \"keep\";\n  if (!restProps.isListField) {\n    key2 = \"_\".concat((namePath || []).join(\"_\"));\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Field, _extends$1({\n    key: key2,\n    name: namePath\n  }, restProps, {\n    fieldContext\n  }));\n}\nvar ListContext = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar List = function List2(_ref) {\n  var name = _ref.name, initialValue = _ref.initialValue, children = _ref.children, rules2 = _ref.rules, validateTrigger = _ref.validateTrigger;\n  var context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Context);\n  var keyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n    keys: [],\n    id: 0\n  });\n  var keyManager = keyRef.current;\n  var prefixName = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n    var parentPrefixName = getNamePath(context.prefixName) || [];\n    return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));\n  }, [context.prefixName, name]);\n  var fieldContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n    return _objectSpread2$1(_objectSpread2$1({}, context), {}, {\n      prefixName\n    });\n  }, [context, prefixName]);\n  var listContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n    return {\n      getKey: function getKey(namePath) {\n        var len = prefixName.length;\n        var pathName = namePath[len];\n        return [keyManager.keys[pathName], namePath.slice(len + 1)];\n      }\n    };\n  }, [prefixName]);\n  if (typeof children !== \"function\") {\n    warningOnce(false, \"Form.List only accepts function as children.\");\n    return null;\n  }\n  var shouldUpdate = function shouldUpdate2(prevValue, nextValue, _ref2) {\n    var source = _ref2.source;\n    if (source === \"internal\") {\n      return false;\n    }\n    return prevValue !== nextValue;\n  };\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ListContext.Provider, {\n    value: listContext\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Context.Provider, {\n    value: fieldContext\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(WrapperField, {\n    name: [],\n    shouldUpdate,\n    rules: rules2,\n    validateTrigger,\n    initialValue,\n    isList: true\n  }, function(_ref3, meta) {\n    var _ref3$value = _ref3.value, value = _ref3$value === void 0 ? [] : _ref3$value, onChange = _ref3.onChange;\n    var getFieldValue = context.getFieldValue;\n    var getNewValue = function getNewValue2() {\n      var values = getFieldValue(prefixName || []);\n      return values || [];\n    };\n    var operations = {\n      add: function add(defaultValue, index2) {\n        var newValue = getNewValue();\n        if (index2 >= 0 && index2 <= newValue.length) {\n          keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index2)));\n          onChange([].concat(_toConsumableArray(newValue.slice(0, index2)), [defaultValue], _toConsumableArray(newValue.slice(index2))));\n        } else {\n          keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);\n          onChange([].concat(_toConsumableArray(newValue), [defaultValue]));\n        }\n        keyManager.id += 1;\n      },\n      remove: function remove(index2) {\n        var newValue = getNewValue();\n        var indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);\n        if (indexSet.size <= 0) {\n          return;\n        }\n        keyManager.keys = keyManager.keys.filter(function(_, keysIndex) {\n          return !indexSet.has(keysIndex);\n        });\n        onChange(newValue.filter(function(_, valueIndex) {\n          return !indexSet.has(valueIndex);\n        }));\n      },\n      move: function move$1(from, to) {\n        if (from === to) {\n          return;\n        }\n        var newValue = getNewValue();\n        if (from < 0 || from >= newValue.length || to < 0 || to >= newValue.length) {\n          return;\n        }\n        keyManager.keys = move(keyManager.keys, from, to);\n        onChange(move(newValue, from, to));\n      }\n    };\n    var listValue = value || [];\n    if (!Array.isArray(listValue)) {\n      listValue = [];\n    }\n    return children(listValue.map(function(__, index2) {\n      var key2 = keyManager.keys[index2];\n      if (key2 === void 0) {\n        keyManager.keys[index2] = keyManager.id;\n        key2 = keyManager.keys[index2];\n        keyManager.id += 1;\n      }\n      return {\n        name: index2,\n        key: key2,\n        isListField: true\n      };\n    }), operations, meta);\n  })));\n};\nfunction allPromiseFinish(promiseList) {\n  var hasError = false;\n  var count = promiseList.length;\n  var results = [];\n  if (!promiseList.length) {\n    return Promise.resolve([]);\n  }\n  return new Promise(function(resolve, reject) {\n    promiseList.forEach(function(promise, index2) {\n      promise.catch(function(e2) {\n        hasError = true;\n        return e2;\n      }).then(function(result) {\n        count -= 1;\n        results[index2] = result;\n        if (count > 0) {\n          return;\n        }\n        if (hasError) {\n          reject(results);\n        }\n        resolve(results);\n      });\n    });\n  });\n}\nvar SPLIT = \"__@field_split__\";\nfunction normalize(namePath) {\n  return namePath.map(function(cell) {\n    return \"\".concat(_typeof$1(cell), \":\").concat(cell);\n  }).join(SPLIT);\n}\nvar NameMap = /* @__PURE__ */ function() {\n  function NameMap2() {\n    _classCallCheck(this, NameMap2);\n    this.kvs = /* @__PURE__ */ new Map();\n  }\n  _createClass(NameMap2, [{\n    key: \"set\",\n    value: function set2(key2, value) {\n      this.kvs.set(normalize(key2), value);\n    }\n  }, {\n    key: \"get\",\n    value: function get2(key2) {\n      return this.kvs.get(normalize(key2));\n    }\n  }, {\n    key: \"update\",\n    value: function update(key2, updater) {\n      var origin = this.get(key2);\n      var next = updater(origin);\n      if (!next) {\n        this.delete(key2);\n      } else {\n        this.set(key2, next);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key2) {\n      this.kvs.delete(normalize(key2));\n    }\n  }, {\n    key: \"map\",\n    value: function map(callback) {\n      return _toConsumableArray(this.kvs.entries()).map(function(_ref) {\n        var _ref2 = _slicedToArray(_ref, 2), key2 = _ref2[0], value = _ref2[1];\n        var cells = key2.split(SPLIT);\n        return callback({\n          key: cells.map(function(cell) {\n            var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray(_cell$match, 3), type4 = _cell$match2[1], unit = _cell$match2[2];\n            return type4 === \"number\" ? Number(unit) : unit;\n          }),\n          value\n        });\n      });\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {};\n      this.map(function(_ref3) {\n        var key2 = _ref3.key, value = _ref3.value;\n        json[key2.join(\".\")] = value;\n        return null;\n      });\n      return json;\n    }\n  }]);\n  return NameMap2;\n}();\nvar _excluded$2 = [\"name\", \"errors\"];\nvar FormStore = /* @__PURE__ */ _createClass(function FormStore2(forceRootUpdate) {\n  var _this = this;\n  _classCallCheck(this, FormStore2);\n  this.formHooked = false;\n  this.forceRootUpdate = void 0;\n  this.subscribable = true;\n  this.store = {};\n  this.fieldEntities = [];\n  this.initialValues = {};\n  this.callbacks = {};\n  this.validateMessages = null;\n  this.preserve = null;\n  this.lastValidatePromise = null;\n  this.getForm = function() {\n    return {\n      getFieldValue: _this.getFieldValue,\n      getFieldsValue: _this.getFieldsValue,\n      getFieldError: _this.getFieldError,\n      getFieldWarning: _this.getFieldWarning,\n      getFieldsError: _this.getFieldsError,\n      isFieldsTouched: _this.isFieldsTouched,\n      isFieldTouched: _this.isFieldTouched,\n      isFieldValidating: _this.isFieldValidating,\n      isFieldsValidating: _this.isFieldsValidating,\n      resetFields: _this.resetFields,\n      setFields: _this.setFields,\n      setFieldsValue: _this.setFieldsValue,\n      validateFields: _this.validateFields,\n      submit: _this.submit,\n      getInternalHooks: _this.getInternalHooks\n    };\n  };\n  this.getInternalHooks = function(key2) {\n    if (key2 === HOOK_MARK) {\n      _this.formHooked = true;\n      return {\n        dispatch: _this.dispatch,\n        initEntityValue: _this.initEntityValue,\n        registerField: _this.registerField,\n        useSubscribe: _this.useSubscribe,\n        setInitialValues: _this.setInitialValues,\n        setCallbacks: _this.setCallbacks,\n        setValidateMessages: _this.setValidateMessages,\n        getFields: _this.getFields,\n        setPreserve: _this.setPreserve,\n        getInitialValue: _this.getInitialValue\n      };\n    }\n    warningOnce(false, \"`getInternalHooks` is internal usage. Should not call directly.\");\n    return null;\n  };\n  this.useSubscribe = function(subscribable) {\n    _this.subscribable = subscribable;\n  };\n  this.setInitialValues = function(initialValues, init) {\n    _this.initialValues = initialValues || {};\n    if (init) {\n      _this.store = setValues({}, initialValues, _this.store);\n    }\n  };\n  this.getInitialValue = function(namePath) {\n    return getValue$2(_this.initialValues, namePath);\n  };\n  this.setCallbacks = function(callbacks) {\n    _this.callbacks = callbacks;\n  };\n  this.setValidateMessages = function(validateMessages) {\n    _this.validateMessages = validateMessages;\n  };\n  this.setPreserve = function(preserve) {\n    _this.preserve = preserve;\n  };\n  this.timeoutId = null;\n  this.warningUnhooked = function() {\n  };\n  this.getFieldEntities = function() {\n    var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    if (!pure) {\n      return _this.fieldEntities;\n    }\n    return _this.fieldEntities.filter(function(field) {\n      return field.getNamePath().length;\n    });\n  };\n  this.getFieldsMap = function() {\n    var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    var cache = new NameMap();\n    _this.getFieldEntities(pure).forEach(function(field) {\n      var namePath = field.getNamePath();\n      cache.set(namePath, field);\n    });\n    return cache;\n  };\n  this.getFieldEntitiesForNamePathList = function(nameList) {\n    if (!nameList) {\n      return _this.getFieldEntities(true);\n    }\n    var cache = _this.getFieldsMap(true);\n    return nameList.map(function(name) {\n      var namePath = getNamePath(name);\n      return cache.get(namePath) || {\n        INVALIDATE_NAME_PATH: getNamePath(name)\n      };\n    });\n  };\n  this.getFieldsValue = function(nameList, filterFunc) {\n    _this.warningUnhooked();\n    if (nameList === true && !filterFunc) {\n      return _this.store;\n    }\n    var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(nameList) ? nameList : null);\n    var filteredNameList = [];\n    fieldEntities.forEach(function(entity) {\n      var _entity$isListField;\n      var namePath = \"INVALIDATE_NAME_PATH\" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();\n      if (!nameList && ((_entity$isListField = entity.isListField) === null || _entity$isListField === void 0 ? void 0 : _entity$isListField.call(entity))) {\n        return;\n      }\n      if (!filterFunc) {\n        filteredNameList.push(namePath);\n      } else {\n        var meta = \"getMeta\" in entity ? entity.getMeta() : null;\n        if (filterFunc(meta)) {\n          filteredNameList.push(namePath);\n        }\n      }\n    });\n    return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));\n  };\n  this.getFieldValue = function(name) {\n    _this.warningUnhooked();\n    var namePath = getNamePath(name);\n    return getValue$2(_this.store, namePath);\n  };\n  this.getFieldsError = function(nameList) {\n    _this.warningUnhooked();\n    var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);\n    return fieldEntities.map(function(entity, index2) {\n      if (entity && !(\"INVALIDATE_NAME_PATH\" in entity)) {\n        return {\n          name: entity.getNamePath(),\n          errors: entity.getErrors(),\n          warnings: entity.getWarnings()\n        };\n      }\n      return {\n        name: getNamePath(nameList[index2]),\n        errors: [],\n        warnings: []\n      };\n    });\n  };\n  this.getFieldError = function(name) {\n    _this.warningUnhooked();\n    var namePath = getNamePath(name);\n    var fieldError = _this.getFieldsError([namePath])[0];\n    return fieldError.errors;\n  };\n  this.getFieldWarning = function(name) {\n    _this.warningUnhooked();\n    var namePath = getNamePath(name);\n    var fieldError = _this.getFieldsError([namePath])[0];\n    return fieldError.warnings;\n  };\n  this.isFieldsTouched = function() {\n    _this.warningUnhooked();\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var arg0 = args[0], arg1 = args[1];\n    var namePathList;\n    var isAllFieldsTouched = false;\n    if (args.length === 0) {\n      namePathList = null;\n    } else if (args.length === 1) {\n      if (Array.isArray(arg0)) {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = false;\n      } else {\n        namePathList = null;\n        isAllFieldsTouched = arg0;\n      }\n    } else {\n      namePathList = arg0.map(getNamePath);\n      isAllFieldsTouched = arg1;\n    }\n    var fieldEntities = _this.getFieldEntities(true);\n    var isFieldTouched = function isFieldTouched2(field) {\n      return field.isFieldTouched();\n    };\n    if (!namePathList) {\n      return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);\n    }\n    var map = new NameMap();\n    namePathList.forEach(function(shortNamePath) {\n      map.set(shortNamePath, []);\n    });\n    fieldEntities.forEach(function(field) {\n      var fieldNamePath = field.getNamePath();\n      namePathList.forEach(function(shortNamePath) {\n        if (shortNamePath.every(function(nameUnit, i) {\n          return fieldNamePath[i] === nameUnit;\n        })) {\n          map.update(shortNamePath, function(list) {\n            return [].concat(_toConsumableArray(list), [field]);\n          });\n        }\n      });\n    });\n    var isNamePathListTouched = function isNamePathListTouched2(entities) {\n      return entities.some(isFieldTouched);\n    };\n    var namePathListEntities = map.map(function(_ref) {\n      var value = _ref.value;\n      return value;\n    });\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n  };\n  this.isFieldTouched = function(name) {\n    _this.warningUnhooked();\n    return _this.isFieldsTouched([name]);\n  };\n  this.isFieldsValidating = function(nameList) {\n    _this.warningUnhooked();\n    var fieldEntities = _this.getFieldEntities();\n    if (!nameList) {\n      return fieldEntities.some(function(testField) {\n        return testField.isFieldValidating();\n      });\n    }\n    var namePathList = nameList.map(getNamePath);\n    return fieldEntities.some(function(testField) {\n      var fieldNamePath = testField.getNamePath();\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n    });\n  };\n  this.isFieldValidating = function(name) {\n    _this.warningUnhooked();\n    return _this.isFieldsValidating([name]);\n  };\n  this.resetWithFieldInitialValue = function() {\n    var info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    var cache = new NameMap();\n    var fieldEntities = _this.getFieldEntities(true);\n    fieldEntities.forEach(function(field) {\n      var initialValue = field.props.initialValue;\n      var namePath = field.getNamePath();\n      if (initialValue !== void 0) {\n        var records = cache.get(namePath) || /* @__PURE__ */ new Set();\n        records.add({\n          entity: field,\n          value: initialValue\n        });\n        cache.set(namePath, records);\n      }\n    });\n    var resetWithFields = function resetWithFields2(entities) {\n      entities.forEach(function(field) {\n        var initialValue = field.props.initialValue;\n        if (initialValue !== void 0) {\n          var namePath = field.getNamePath();\n          var formInitialValue = _this.getInitialValue(namePath);\n          if (formInitialValue !== void 0) {\n            warningOnce(false, \"Form already set 'initialValues' with path '\".concat(namePath.join(\".\"), \"'. Field can not overwrite it.\"));\n          } else {\n            var records = cache.get(namePath);\n            if (records && records.size > 1) {\n              warningOnce(false, \"Multiple Field with path '\".concat(namePath.join(\".\"), \"' set 'initialValue'. Can not decide which one to pick.\"));\n            } else if (records) {\n              var originValue = _this.getFieldValue(namePath);\n              if (!info.skipExist || originValue === void 0) {\n                _this.store = setValue(_this.store, namePath, _toConsumableArray(records)[0].value);\n              }\n            }\n          }\n        }\n      });\n    };\n    var requiredFieldEntities;\n    if (info.entities) {\n      requiredFieldEntities = info.entities;\n    } else if (info.namePathList) {\n      requiredFieldEntities = [];\n      info.namePathList.forEach(function(namePath) {\n        var records = cache.get(namePath);\n        if (records) {\n          var _requiredFieldEntitie;\n          (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r2) {\n            return r2.entity;\n          })));\n        }\n      });\n    } else {\n      requiredFieldEntities = fieldEntities;\n    }\n    resetWithFields(requiredFieldEntities);\n  };\n  this.resetFields = function(nameList) {\n    _this.warningUnhooked();\n    var prevStore = _this.store;\n    if (!nameList) {\n      _this.store = setValues({}, _this.initialValues);\n      _this.resetWithFieldInitialValue();\n      _this.notifyObservers(prevStore, null, {\n        type: \"reset\"\n      });\n      return;\n    }\n    var namePathList = nameList.map(getNamePath);\n    namePathList.forEach(function(namePath) {\n      var initialValue = _this.getInitialValue(namePath);\n      _this.store = setValue(_this.store, namePath, initialValue);\n    });\n    _this.resetWithFieldInitialValue({\n      namePathList\n    });\n    _this.notifyObservers(prevStore, namePathList, {\n      type: \"reset\"\n    });\n  };\n  this.setFields = function(fields) {\n    _this.warningUnhooked();\n    var prevStore = _this.store;\n    fields.forEach(function(fieldData) {\n      var name = fieldData.name;\n      fieldData.errors;\n      var data = _objectWithoutProperties(fieldData, _excluded$2);\n      var namePath = getNamePath(name);\n      if (\"value\" in data) {\n        _this.store = setValue(_this.store, namePath, data.value);\n      }\n      _this.notifyObservers(prevStore, [namePath], {\n        type: \"setField\",\n        data: fieldData\n      });\n    });\n  };\n  this.getFields = function() {\n    var entities = _this.getFieldEntities(true);\n    var fields = entities.map(function(field) {\n      var namePath = field.getNamePath();\n      var meta = field.getMeta();\n      var fieldData = _objectSpread2$1(_objectSpread2$1({}, meta), {}, {\n        name: namePath,\n        value: _this.getFieldValue(namePath)\n      });\n      Object.defineProperty(fieldData, \"originRCField\", {\n        value: true\n      });\n      return fieldData;\n    });\n    return fields;\n  };\n  this.initEntityValue = function(entity) {\n    var initialValue = entity.props.initialValue;\n    if (initialValue !== void 0) {\n      var namePath = entity.getNamePath();\n      var prevValue = getValue$2(_this.store, namePath);\n      if (prevValue === void 0) {\n        _this.store = setValue(_this.store, namePath, initialValue);\n      }\n    }\n  };\n  this.registerField = function(entity) {\n    _this.fieldEntities.push(entity);\n    if (entity.props.initialValue !== void 0) {\n      var prevStore = _this.store;\n      _this.resetWithFieldInitialValue({\n        entities: [entity],\n        skipExist: true\n      });\n      _this.notifyObservers(prevStore, [entity.getNamePath()], {\n        type: \"valueUpdate\",\n        source: \"internal\"\n      });\n    }\n    return function(isListField, preserve) {\n      var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n      _this.fieldEntities = _this.fieldEntities.filter(function(item) {\n        return item !== entity;\n      });\n      var mergedPreserve = preserve !== void 0 ? preserve : _this.preserve;\n      if (mergedPreserve === false && (!isListField || subNamePath.length > 1)) {\n        var namePath = entity.getNamePath();\n        var defaultValue = isListField ? void 0 : getValue$2(_this.initialValues, namePath);\n        if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {\n          return !matchNamePath(field.getNamePath(), namePath);\n        })) {\n          var _prevStore = _this.store;\n          _this.store = setValue(_prevStore, namePath, defaultValue, true);\n          _this.notifyObservers(_prevStore, [namePath], {\n            type: \"remove\"\n          });\n          _this.triggerDependenciesUpdate(_prevStore, namePath);\n        }\n      }\n    };\n  };\n  this.dispatch = function(action) {\n    switch (action.type) {\n      case \"updateValue\": {\n        var namePath = action.namePath, value = action.value;\n        _this.updateValue(namePath, value);\n        break;\n      }\n      case \"validateField\": {\n        var _namePath = action.namePath, triggerName = action.triggerName;\n        _this.validateFields([_namePath], {\n          triggerName\n        });\n        break;\n      }\n    }\n  };\n  this.notifyObservers = function(prevStore, namePathList, info) {\n    if (_this.subscribable) {\n      var mergedInfo = _objectSpread2$1(_objectSpread2$1({}, info), {}, {\n        store: _this.getFieldsValue(true)\n      });\n      _this.getFieldEntities().forEach(function(_ref2) {\n        var onStoreChange = _ref2.onStoreChange;\n        onStoreChange(prevStore, namePathList, mergedInfo);\n      });\n    } else {\n      _this.forceRootUpdate();\n    }\n  };\n  this.triggerDependenciesUpdate = function(prevStore, namePath) {\n    var childrenFields = _this.getDependencyChildrenFields(namePath);\n    if (childrenFields.length) {\n      _this.validateFields(childrenFields);\n    }\n    _this.notifyObservers(prevStore, childrenFields, {\n      type: \"dependenciesUpdate\",\n      relatedFields: [namePath].concat(_toConsumableArray(childrenFields))\n    });\n    return childrenFields;\n  };\n  this.updateValue = function(name, value) {\n    var namePath = getNamePath(name);\n    var prevStore = _this.store;\n    _this.store = setValue(_this.store, namePath, value);\n    _this.notifyObservers(prevStore, [namePath], {\n      type: \"valueUpdate\",\n      source: \"internal\"\n    });\n    var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);\n    var onValuesChange = _this.callbacks.onValuesChange;\n    if (onValuesChange) {\n      var changedValues = cloneByNamePathList(_this.store, [namePath]);\n      onValuesChange(changedValues, _this.getFieldsValue());\n    }\n    _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));\n  };\n  this.setFieldsValue = function(store) {\n    _this.warningUnhooked();\n    var prevStore = _this.store;\n    if (store) {\n      _this.store = setValues(_this.store, store);\n    }\n    _this.notifyObservers(prevStore, null, {\n      type: \"valueUpdate\",\n      source: \"external\"\n    });\n  };\n  this.getDependencyChildrenFields = function(rootNamePath) {\n    var children = /* @__PURE__ */ new Set();\n    var childrenFields = [];\n    var dependencies2fields = new NameMap();\n    _this.getFieldEntities().forEach(function(field) {\n      var dependencies = field.props.dependencies;\n      (dependencies || []).forEach(function(dependency) {\n        var dependencyNamePath = getNamePath(dependency);\n        dependencies2fields.update(dependencyNamePath, function() {\n          var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();\n          fields.add(field);\n          return fields;\n        });\n      });\n    });\n    var fillChildren = function fillChildren2(namePath) {\n      var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();\n      fields.forEach(function(field) {\n        if (!children.has(field)) {\n          children.add(field);\n          var fieldNamePath = field.getNamePath();\n          if (field.isFieldDirty() && fieldNamePath.length) {\n            childrenFields.push(fieldNamePath);\n            fillChildren2(fieldNamePath);\n          }\n        }\n      });\n    };\n    fillChildren(rootNamePath);\n    return childrenFields;\n  };\n  this.triggerOnFieldsChange = function(namePathList, filedErrors) {\n    var onFieldsChange = _this.callbacks.onFieldsChange;\n    if (onFieldsChange) {\n      var fields = _this.getFields();\n      if (filedErrors) {\n        var cache = new NameMap();\n        filedErrors.forEach(function(_ref3) {\n          var name = _ref3.name, errors = _ref3.errors;\n          cache.set(name, errors);\n        });\n        fields.forEach(function(field) {\n          field.errors = cache.get(field.name) || field.errors;\n        });\n      }\n      var changedFields = fields.filter(function(_ref4) {\n        var fieldName = _ref4.name;\n        return containsNamePath(namePathList, fieldName);\n      });\n      onFieldsChange(changedFields, fields);\n    }\n  };\n  this.validateFields = function(nameList, options) {\n    _this.warningUnhooked();\n    var provideNameList = !!nameList;\n    var namePathList = provideNameList ? nameList.map(getNamePath) : [];\n    var promiseList = [];\n    _this.getFieldEntities(true).forEach(function(field) {\n      if (!provideNameList) {\n        namePathList.push(field.getNamePath());\n      }\n      if ((options === null || options === void 0 ? void 0 : options.recursive) && provideNameList) {\n        var namePath = field.getNamePath();\n        if (namePath.every(function(nameUnit, i) {\n          return nameList[i] === nameUnit || nameList[i] === void 0;\n        })) {\n          namePathList.push(namePath);\n        }\n      }\n      if (!field.props.rules || !field.props.rules.length) {\n        return;\n      }\n      var fieldNamePath = field.getNamePath();\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {\n        var promise = field.validateRules(_objectSpread2$1({\n          validateMessages: _objectSpread2$1(_objectSpread2$1({}, defaultValidateMessages), _this.validateMessages)\n        }, options));\n        promiseList.push(promise.then(function() {\n          return {\n            name: fieldNamePath,\n            errors: [],\n            warnings: []\n          };\n        }).catch(function(ruleErrors) {\n          var mergedErrors = [];\n          var mergedWarnings = [];\n          ruleErrors.forEach(function(_ref5) {\n            var warningOnly = _ref5.rule.warningOnly, errors = _ref5.errors;\n            if (warningOnly) {\n              mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));\n            } else {\n              mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));\n            }\n          });\n          if (mergedErrors.length) {\n            return Promise.reject({\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            });\n          }\n          return {\n            name: fieldNamePath,\n            errors: mergedErrors,\n            warnings: mergedWarnings\n          };\n        }));\n      }\n    });\n    var summaryPromise = allPromiseFinish(promiseList);\n    _this.lastValidatePromise = summaryPromise;\n    summaryPromise.catch(function(results) {\n      return results;\n    }).then(function(results) {\n      var resultNamePathList = results.map(function(_ref6) {\n        var name = _ref6.name;\n        return name;\n      });\n      _this.notifyObservers(_this.store, resultNamePathList, {\n        type: \"validateFinish\"\n      });\n      _this.triggerOnFieldsChange(resultNamePathList, results);\n    });\n    var returnPromise = summaryPromise.then(function() {\n      if (_this.lastValidatePromise === summaryPromise) {\n        return Promise.resolve(_this.getFieldsValue(namePathList));\n      }\n      return Promise.reject([]);\n    }).catch(function(results) {\n      var errorList = results.filter(function(result) {\n        return result && result.errors.length;\n      });\n      return Promise.reject({\n        values: _this.getFieldsValue(namePathList),\n        errorFields: errorList,\n        outOfDate: _this.lastValidatePromise !== summaryPromise\n      });\n    });\n    returnPromise.catch(function(e2) {\n      return e2;\n    });\n    return returnPromise;\n  };\n  this.submit = function() {\n    _this.warningUnhooked();\n    _this.validateFields().then(function(values) {\n      var onFinish = _this.callbacks.onFinish;\n      if (onFinish) {\n        try {\n          onFinish(values);\n        } catch (err) {\n          console.error(err);\n        }\n      }\n    }).catch(function(e2) {\n      var onFinishFailed = _this.callbacks.onFinishFailed;\n      if (onFinishFailed) {\n        onFinishFailed(e2);\n      }\n    });\n  };\n  this.forceRootUpdate = forceRootUpdate;\n});\nfunction useForm(form) {\n  var formRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      var forceReRender = function forceReRender2() {\n        forceUpdate({});\n      };\n      var formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n  return [formRef.current];\n}\nvar FormContext = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  triggerFormChange: function triggerFormChange() {\n  },\n  triggerFormFinish: function triggerFormFinish() {\n  },\n  registerForm: function registerForm() {\n  },\n  unregisterForm: function unregisterForm() {\n  }\n});\nvar FormProvider = function FormProvider2(_ref) {\n  var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children;\n  var formContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FormContext);\n  var formsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormContext.Provider, {\n    value: _objectSpread2$1(_objectSpread2$1({}, formContext), {}, {\n      validateMessages: _objectSpread2$1(_objectSpread2$1({}, formContext.validateMessages), validateMessages),\n      triggerFormChange: function triggerFormChange2(name, changedFields) {\n        if (onFormChange) {\n          onFormChange(name, {\n            changedFields,\n            forms: formsRef.current\n          });\n        }\n        formContext.triggerFormChange(name, changedFields);\n      },\n      triggerFormFinish: function triggerFormFinish2(name, values) {\n        if (onFormFinish) {\n          onFormFinish(name, {\n            values,\n            forms: formsRef.current\n          });\n        }\n        formContext.triggerFormFinish(name, values);\n      },\n      registerForm: function registerForm2(name, form) {\n        if (name) {\n          formsRef.current = _objectSpread2$1(_objectSpread2$1({}, formsRef.current), {}, _defineProperty$1({}, name, form));\n        }\n        formContext.registerForm(name, form);\n      },\n      unregisterForm: function unregisterForm2(name) {\n        var newForms = _objectSpread2$1({}, formsRef.current);\n        delete newForms[name];\n        formsRef.current = newForms;\n        formContext.unregisterForm(name);\n      }\n    })\n  }, children);\n};\nvar _excluded$1 = [\"name\", \"initialValues\", \"fields\", \"form\", \"preserve\", \"children\", \"component\", \"validateMessages\", \"validateTrigger\", \"onValuesChange\", \"onFieldsChange\", \"onFinish\", \"onFinishFailed\"];\nvar Form = function Form2(_ref, ref) {\n  var name = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component2 = _ref$component === void 0 ? \"form\" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? \"onChange\" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, restProps = _objectWithoutProperties(_ref, _excluded$1);\n  var formContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FormContext);\n  var _useForm = useForm(form), _useForm2 = _slicedToArray(_useForm, 1), formInstance = _useForm2[0];\n  var _formInstance$getInte = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _formInstance$getInte.useSubscribe, setInitialValues = _formInstance$getInte.setInitialValues, setCallbacks = _formInstance$getInte.setCallbacks, setValidateMessages = _formInstance$getInte.setValidateMessages, setPreserve = _formInstance$getInte.setPreserve;\n  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(ref, function() {\n    return formInstance;\n  });\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    formContext.registerForm(name, formInstance);\n    return function() {\n      formContext.unregisterForm(name);\n    };\n  }, [formContext, formInstance, name]);\n  setValidateMessages(_objectSpread2$1(_objectSpread2$1({}, formContext.validateMessages), validateMessages));\n  setCallbacks({\n    onValuesChange,\n    onFieldsChange: function onFieldsChange(changedFields) {\n      formContext.triggerFormChange(name, changedFields);\n      if (_onFieldsChange) {\n        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          rest[_key - 1] = arguments[_key];\n        }\n        _onFieldsChange.apply(void 0, [changedFields].concat(rest));\n      }\n    },\n    onFinish: function onFinish(values2) {\n      formContext.triggerFormFinish(name, values2);\n      if (_onFinish) {\n        _onFinish(values2);\n      }\n    },\n    onFinishFailed\n  });\n  setPreserve(preserve);\n  var mountRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  setInitialValues(initialValues, !mountRef.current);\n  if (!mountRef.current) {\n    mountRef.current = true;\n  }\n  var childrenNode = children;\n  var childrenRenderProps = typeof children === \"function\";\n  if (childrenRenderProps) {\n    var values = formInstance.getFieldsValue(true);\n    childrenNode = children(values, formInstance);\n  }\n  useSubscribe(!childrenRenderProps);\n  var prevFieldsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    if (!isSimilar(prevFieldsRef.current || [], fields || [])) {\n      formInstance.setFields(fields || []);\n    }\n    prevFieldsRef.current = fields;\n  }, [fields, formInstance]);\n  var formContextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n    return _objectSpread2$1(_objectSpread2$1({}, formInstance), {}, {\n      validateTrigger\n    });\n  }, [formInstance, validateTrigger]);\n  var wrapperNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Context.Provider, {\n    value: formContextValue\n  }, childrenNode);\n  if (Component2 === false) {\n    return wrapperNode;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component2, _extends$1({}, restProps, {\n    onSubmit: function onSubmit(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      formInstance.submit();\n    },\n    onReset: function onReset(event) {\n      var _restProps$onReset;\n      event.preventDefault();\n      formInstance.resetFields();\n      (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 ? void 0 : _restProps$onReset.call(restProps, event);\n    }\n  }), wrapperNode);\n};\nvar InternalForm = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(Form);\nvar RefForm = InternalForm;\nRefForm.FormProvider = FormProvider;\nRefForm.Field = WrapperField;\nRefForm.List = List;\nRefForm.useForm = useForm;\nvar safeIsNaN = Number.isNaN || function ponyfill(value) {\n  return typeof value === \"number\" && value !== value;\n};\nfunction isEqual$1(first, second) {\n  if (first === second) {\n    return true;\n  }\n  if (safeIsNaN(first) && safeIsNaN(second)) {\n    return true;\n  }\n  return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n  if (newInputs.length !== lastInputs.length) {\n    return false;\n  }\n  for (var i = 0; i < newInputs.length; i++) {\n    if (!isEqual$1(newInputs[i], lastInputs[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction memoizeOne(resultFn, isEqual2) {\n  if (isEqual2 === void 0) {\n    isEqual2 = areInputsEqual;\n  }\n  var cache = null;\n  function memoized() {\n    var newArgs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      newArgs[_i] = arguments[_i];\n    }\n    if (cache && cache.lastThis === this && isEqual2(newArgs, cache.lastArgs)) {\n      return cache.lastResult;\n    }\n    var lastResult = resultFn.apply(this, newArgs);\n    cache = {\n      lastResult,\n      lastArgs: newArgs,\n      lastThis: this\n    };\n    return lastResult;\n  }\n  memoized.clear = function clear2() {\n    cache = null;\n  };\n  return memoized;\n}\nvar devWarning = function(valid, component, message2) {\n  warningOnce(valid, \"[antd: \".concat(component, \"] \").concat(message2));\n};\nvar Pagination = {\n  items_per_page: \"/ page\",\n  jump_to: \"Go to\",\n  jump_to_confirm: \"confirm\",\n  page: \"Page\",\n  prev_page: \"Previous Page\",\n  next_page: \"Next Page\",\n  prev_5: \"Previous 5 Pages\",\n  next_5: \"Next 5 Pages\",\n  prev_3: \"Previous 3 Pages\",\n  next_3: \"Next 3 Pages\",\n  page_size: \"Page Size\"\n};\nvar locale$2 = {\n  locale: \"en_US\",\n  today: \"Today\",\n  now: \"Now\",\n  backToToday: \"Back to today\",\n  ok: \"Ok\",\n  clear: \"Clear\",\n  month: \"Month\",\n  year: \"Year\",\n  timeSelect: \"select time\",\n  dateSelect: \"select date\",\n  weekSelect: \"Choose a week\",\n  monthSelect: \"Choose a month\",\n  yearSelect: \"Choose a year\",\n  decadeSelect: \"Choose a decade\",\n  yearFormat: \"YYYY\",\n  dateFormat: \"M/D/YYYY\",\n  dayFormat: \"D\",\n  dateTimeFormat: \"M/D/YYYY HH:mm:ss\",\n  monthBeforeYear: true,\n  previousMonth: \"Previous month (PageUp)\",\n  nextMonth: \"Next month (PageDown)\",\n  previousYear: \"Last year (Control + left)\",\n  nextYear: \"Next year (Control + right)\",\n  previousDecade: \"Last decade\",\n  nextDecade: \"Next decade\",\n  previousCentury: \"Last century\",\n  nextCentury: \"Next century\"\n};\nvar locale$1 = {\n  placeholder: \"Select time\",\n  rangePlaceholder: [\"Start time\", \"End time\"]\n};\nvar TimePicker = locale$1;\nvar locale = {\n  lang: _extends$1({\n    placeholder: \"Select date\",\n    yearPlaceholder: \"Select year\",\n    quarterPlaceholder: \"Select quarter\",\n    monthPlaceholder: \"Select month\",\n    weekPlaceholder: \"Select week\",\n    rangePlaceholder: [\"Start date\", \"End date\"],\n    rangeYearPlaceholder: [\"Start year\", \"End year\"],\n    rangeMonthPlaceholder: [\"Start month\", \"End month\"],\n    rangeWeekPlaceholder: [\"Start week\", \"End week\"]\n  }, locale$2),\n  timePickerLocale: _extends$1({}, TimePicker)\n};\nvar DatePicker = locale;\nvar typeTemplate = \"${label} is not a valid ${type}\";\nvar localeValues = {\n  locale: \"en\",\n  Pagination,\n  DatePicker,\n  TimePicker,\n  Calendar: DatePicker,\n  global: {\n    placeholder: \"Please select\"\n  },\n  Table: {\n    filterTitle: \"Filter menu\",\n    filterConfirm: \"OK\",\n    filterReset: \"Reset\",\n    filterEmptyText: \"No filters\",\n    filterCheckall: \"Select all items\",\n    filterSearchPlaceholder: \"Search in filters\",\n    emptyText: \"No data\",\n    selectAll: \"Select current page\",\n    selectInvert: \"Invert current page\",\n    selectNone: \"Clear all data\",\n    selectionAll: \"Select all data\",\n    sortTitle: \"Sort\",\n    expand: \"Expand row\",\n    collapse: \"Collapse row\",\n    triggerDesc: \"Click to sort descending\",\n    triggerAsc: \"Click to sort ascending\",\n    cancelSort: \"Click to cancel sorting\"\n  },\n  Modal: {\n    okText: \"OK\",\n    cancelText: \"Cancel\",\n    justOkText: \"OK\"\n  },\n  Popconfirm: {\n    okText: \"OK\",\n    cancelText: \"Cancel\"\n  },\n  Transfer: {\n    titles: [\"\", \"\"],\n    searchPlaceholder: \"Search here\",\n    itemUnit: \"item\",\n    itemsUnit: \"items\",\n    remove: \"Remove\",\n    selectCurrent: \"Select current page\",\n    removeCurrent: \"Remove current page\",\n    selectAll: \"Select all data\",\n    removeAll: \"Remove all data\",\n    selectInvert: \"Invert current page\"\n  },\n  Upload: {\n    uploading: \"Uploading...\",\n    removeFile: \"Remove file\",\n    uploadError: \"Upload error\",\n    previewFile: \"Preview file\",\n    downloadFile: \"Download file\"\n  },\n  Empty: {\n    description: \"No Data\"\n  },\n  Icon: {\n    icon: \"icon\"\n  },\n  Text: {\n    edit: \"Edit\",\n    copy: \"Copy\",\n    copied: \"Copied\",\n    expand: \"Expand\"\n  },\n  PageHeader: {\n    back: \"Back\"\n  },\n  Form: {\n    optional: \"(optional)\",\n    defaultValidateMessages: {\n      \"default\": \"Field validation error for ${label}\",\n      required: \"Please enter ${label}\",\n      \"enum\": \"${label} must be one of [${enum}]\",\n      whitespace: \"${label} cannot be a blank character\",\n      date: {\n        format: \"${label} date format is invalid\",\n        parse: \"${label} cannot be converted to a date\",\n        invalid: \"${label} is an invalid date\"\n      },\n      types: {\n        string: typeTemplate,\n        method: typeTemplate,\n        array: typeTemplate,\n        object: typeTemplate,\n        number: typeTemplate,\n        date: typeTemplate,\n        \"boolean\": typeTemplate,\n        integer: typeTemplate,\n        \"float\": typeTemplate,\n        regexp: typeTemplate,\n        email: typeTemplate,\n        url: typeTemplate,\n        hex: typeTemplate\n      },\n      string: {\n        len: \"${label} must be ${len} characters\",\n        min: \"${label} must be at least ${min} characters\",\n        max: \"${label} must be up to ${max} characters\",\n        range: \"${label} must be between ${min}-${max} characters\"\n      },\n      number: {\n        len: \"${label} must be equal to ${len}\",\n        min: \"${label} must be minimum ${min}\",\n        max: \"${label} must be maximum ${max}\",\n        range: \"${label} must be between ${min}-${max}\"\n      },\n      array: {\n        len: \"Must be ${len} ${label}\",\n        min: \"At least ${min} ${label}\",\n        max: \"At most ${max} ${label}\",\n        range: \"The amount of ${label} must be between ${min}-${max}\"\n      },\n      pattern: {\n        mismatch: \"${label} does not match the pattern ${pattern}\"\n      }\n    }\n  },\n  Image: {\n    preview: \"Preview\"\n  }\n};\nvar defaultLocale = localeValues;\nvar runtimeLocale = _extends$1({}, defaultLocale.Modal);\nfunction changeConfirmLocale(newLocale) {\n  if (newLocale) {\n    runtimeLocale = _extends$1(_extends$1({}, runtimeLocale), newLocale);\n  } else {\n    runtimeLocale = _extends$1({}, defaultLocale.Modal);\n  }\n}\nvar LocaleContext = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nvar LocaleContext$1 = LocaleContext;\nvar ANT_MARK = \"internalMark\";\nvar LocaleProvider = /* @__PURE__ */ function(_React$Component) {\n  _inherits(LocaleProvider2, _React$Component);\n  var _super = _createSuper(LocaleProvider2);\n  function LocaleProvider2(props) {\n    var _this;\n    _classCallCheck(this, LocaleProvider2);\n    _this = _super.call(this, props);\n    _this.getMemoizedContextValue = memoizeOne(function(localeValue) {\n      return _extends$1(_extends$1({}, localeValue), {\n        exist: true\n      });\n    });\n    changeConfirmLocale(props.locale && props.locale.Modal);\n    devWarning(props._ANT_MARK__ === ANT_MARK, \"LocaleProvider\", \"`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead: http://u.ant.design/locale\");\n    return _this;\n  }\n  _createClass(LocaleProvider2, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      changeConfirmLocale(this.props.locale && this.props.locale.Modal);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var locale2 = this.props.locale;\n      if (prevProps.locale !== locale2) {\n        changeConfirmLocale(locale2 && locale2.Modal);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      changeConfirmLocale();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props, locale2 = _this$props.locale, children = _this$props.children;\n      var contextValue = this.getMemoizedContextValue(locale2);\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocaleContext$1.Provider, {\n        value: contextValue\n      }, children);\n    }\n  }]);\n  return LocaleProvider2;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nLocaleProvider.defaultProps = {\n  locale: {}\n};\nvar LocaleReceiver = /* @__PURE__ */ function(_React$Component) {\n  _inherits(LocaleReceiver2, _React$Component);\n  var _super = _createSuper(LocaleReceiver2);\n  function LocaleReceiver2() {\n    _classCallCheck(this, LocaleReceiver2);\n    return _super.apply(this, arguments);\n  }\n  _createClass(LocaleReceiver2, [{\n    key: \"getLocale\",\n    value: function getLocale() {\n      var _this$props = this.props, componentName = _this$props.componentName, defaultLocale$1 = _this$props.defaultLocale;\n      var locale2 = defaultLocale$1 || defaultLocale[componentName !== null && componentName !== void 0 ? componentName : \"global\"];\n      var antLocale = this.context;\n      var localeFromContext = componentName && antLocale ? antLocale[componentName] : {};\n      return _extends$1(_extends$1({}, locale2 instanceof Function ? locale2() : locale2), localeFromContext || {});\n    }\n  }, {\n    key: \"getLocaleCode\",\n    value: function getLocaleCode() {\n      var antLocale = this.context;\n      var localeCode = antLocale && antLocale.locale;\n      if (antLocale && antLocale.exist && !localeCode) {\n        return defaultLocale.locale;\n      }\n      return localeCode;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.props.children(this.getLocale(), this.getLocaleCode(), this.context);\n    }\n  }]);\n  return LocaleReceiver2;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nLocaleReceiver.defaultProps = {\n  componentName: \"global\"\n};\nLocaleReceiver.contextType = LocaleContext$1;\nvar Empty$2 = function Empty() {\n  var _React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;\n  var prefixCls = getPrefixCls(\"empty-img-default\");\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n    className: prefixCls,\n    width: \"184\",\n    height: \"152\",\n    viewBox: \"0 0 184 152\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    fill: \"none\",\n    fillRule: \"evenodd\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    transform: \"translate(24 31.67)\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ellipse\", {\n    className: \"\".concat(prefixCls, \"-ellipse\"),\n    cx: \"67.797\",\n    cy: \"106.89\",\n    rx: \"67.797\",\n    ry: \"12.668\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    className: \"\".concat(prefixCls, \"-path-1\"),\n    d: \"M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    className: \"\".concat(prefixCls, \"-path-2\"),\n    d: \"M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z\",\n    transform: \"translate(13.56)\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    className: \"\".concat(prefixCls, \"-path-3\"),\n    d: \"M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    className: \"\".concat(prefixCls, \"-path-4\"),\n    d: \"M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z\"\n  })), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    className: \"\".concat(prefixCls, \"-path-5\"),\n    d: \"M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    className: \"\".concat(prefixCls, \"-g\"),\n    transform: \"translate(149.65 15.383)\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ellipse\", {\n    cx: \"20.654\",\n    cy: \"3.167\",\n    rx: \"2.849\",\n    ry: \"2.815\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z\"\n  }))));\n};\nvar DefaultEmptyImg = Empty$2;\nvar Simple = function Simple2() {\n  var _React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;\n  var prefixCls = getPrefixCls(\"empty-img-simple\");\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n    className: prefixCls,\n    width: \"64\",\n    height: \"41\",\n    viewBox: \"0 0 64 41\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    transform: \"translate(0 1)\",\n    fill: \"none\",\n    fillRule: \"evenodd\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ellipse\", {\n    className: \"\".concat(prefixCls, \"-ellipse\"),\n    cx: \"32\",\n    cy: \"33\",\n    rx: \"32\",\n    ry: \"7\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    className: \"\".concat(prefixCls, \"-g\"),\n    fillRule: \"nonzero\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z\",\n    className: \"\".concat(prefixCls, \"-path\")\n  }))));\n};\nvar SimpleEmptyImg = Simple;\nvar __rest$8 = globalThis && globalThis.__rest || function(s, e2) {\n  var t2 = {};\n  for (var p2 in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)\n      t2[p2] = s[p2];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {\n      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))\n        t2[p2[i]] = s[p2[i]];\n    }\n  return t2;\n};\nvar defaultEmptyImg = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultEmptyImg, null);\nvar simpleEmptyImg = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SimpleEmptyImg, null);\nvar Empty2 = function Empty3(_a) {\n  var className = _a.className, customizePrefixCls = _a.prefixCls, _a$image = _a.image, image = _a$image === void 0 ? defaultEmptyImg : _a$image, description = _a.description, children = _a.children, imageStyle = _a.imageStyle, restProps = __rest$8(_a, [\"className\", \"prefixCls\", \"image\", \"description\", \"children\", \"imageStyle\"]);\n  var _React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocaleReceiver, {\n    componentName: \"Empty\"\n  }, function(locale2) {\n    var _classNames;\n    var prefixCls = getPrefixCls(\"empty\", customizePrefixCls);\n    var des = typeof description !== \"undefined\" ? description : locale2.description;\n    var alt = typeof des === \"string\" ? des : \"empty\";\n    var imageNode = null;\n    if (typeof image === \"string\") {\n      imageNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n        alt,\n        src: image\n      });\n    } else {\n      imageNode = image;\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends$1({\n      className: classNames(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-normal\"), image === simpleEmptyImg), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-rtl\"), direction === \"rtl\"), _classNames), className)\n    }, restProps), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: \"\".concat(prefixCls, \"-image\"),\n      style: imageStyle\n    }, imageNode), des && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: \"\".concat(prefixCls, \"-description\")\n    }, des), children && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: \"\".concat(prefixCls, \"-footer\")\n    }, children));\n  });\n};\nEmpty2.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;\nEmpty2.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;\nvar Empty$1 = Empty2;\nvar renderEmpty = function renderEmpty2(componentName) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConfigConsumer, null, function(_ref) {\n    var getPrefixCls = _ref.getPrefixCls;\n    var prefix = getPrefixCls(\"empty\");\n    switch (componentName) {\n      case \"Table\":\n      case \"List\":\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Empty$1, {\n          image: Empty$1.PRESENTED_IMAGE_SIMPLE\n        });\n      case \"Select\":\n      case \"TreeSelect\":\n      case \"Cascader\":\n      case \"Transfer\":\n      case \"Mentions\":\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Empty$1, {\n          image: Empty$1.PRESENTED_IMAGE_SIMPLE,\n          className: \"\".concat(prefix, \"-small\")\n        });\n      default:\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Empty$1, null);\n    }\n  });\n};\nvar defaultRenderEmpty = renderEmpty;\nvar defaultGetPrefixCls = function defaultGetPrefixCls2(suffixCls, customizePrefixCls) {\n  if (customizePrefixCls)\n    return customizePrefixCls;\n  return suffixCls ? \"ant-\".concat(suffixCls) : \"ant\";\n};\nvar ConfigContext = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  getPrefixCls: defaultGetPrefixCls,\n  renderEmpty: defaultRenderEmpty\n});\nvar ConfigConsumer = ConfigContext.Consumer;\nvar SizeContext = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar SizeContextProvider = function SizeContextProvider2(_ref) {\n  var children = _ref.children, size = _ref.size;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SizeContext.Consumer, null, function(originSize) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SizeContext.Provider, {\n      value: size || originSize\n    }, children);\n  });\n};\nvar SizeContext$1 = SizeContext;\nvar CloseOutlined$2 = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"64 64 896 896\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z\" } }] }, \"name\": \"close\", \"theme\": \"outlined\" };\nvar CloseOutlinedSvg = CloseOutlined$2;\nvar CloseOutlined = function CloseOutlined2(props, ref) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {\n    ref,\n    icon: CloseOutlinedSvg\n  }));\n};\nCloseOutlined.displayName = \"CloseOutlined\";\nvar CloseOutlined$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(CloseOutlined);\nvar CheckCircleOutlined$2 = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"64 64 896 896\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z\" } }, { \"tag\": \"path\", \"attrs\": { \"d\": \"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z\" } }] }, \"name\": \"check-circle\", \"theme\": \"outlined\" };\nvar CheckCircleOutlinedSvg = CheckCircleOutlined$2;\nvar CheckCircleOutlined = function CheckCircleOutlined2(props, ref) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {\n    ref,\n    icon: CheckCircleOutlinedSvg\n  }));\n};\nCheckCircleOutlined.displayName = \"CheckCircleOutlined\";\nvar CheckCircleOutlined$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(CheckCircleOutlined);\nvar CloseCircleOutlined$2 = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"64 64 896 896\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M685.4 354.8c0-4.4-3.6-8-8-8l-66 .3L512 465.6l-99.3-118.4-66.1-.3c-4.4 0-8 3.5-8 8 0 1.9.7 3.7 1.9 5.2l130.1 155L340.5 670a8.32 8.32 0 00-1.9 5.2c0 4.4 3.6 8 8 8l66.1-.3L512 564.4l99.3 118.4 66 .3c4.4 0 8-3.5 8-8 0-1.9-.7-3.7-1.9-5.2L553.5 515l130.1-155c1.2-1.4 1.8-3.3 1.8-5.2z\" } }, { \"tag\": \"path\", \"attrs\": { \"d\": \"M512 65C264.6 65 64 265.6 64 513s200.6 448 448 448 448-200.6 448-448S759.4 65 512 65zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z\" } }] }, \"name\": \"close-circle\", \"theme\": \"outlined\" };\nvar CloseCircleOutlinedSvg = CloseCircleOutlined$2;\nvar CloseCircleOutlined = function CloseCircleOutlined2(props, ref) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {\n    ref,\n    icon: CloseCircleOutlinedSvg\n  }));\n};\nCloseCircleOutlined.displayName = \"CloseCircleOutlined\";\nvar CloseCircleOutlined$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(CloseCircleOutlined);\nvar ExclamationCircleOutlined$2 = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"64 64 896 896\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z\" } }, { \"tag\": \"path\", \"attrs\": { \"d\": \"M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z\" } }] }, \"name\": \"exclamation-circle\", \"theme\": \"outlined\" };\nvar ExclamationCircleOutlinedSvg = ExclamationCircleOutlined$2;\nvar ExclamationCircleOutlined = function ExclamationCircleOutlined2(props, ref) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {\n    ref,\n    icon: ExclamationCircleOutlinedSvg\n  }));\n};\nExclamationCircleOutlined.displayName = \"ExclamationCircleOutlined\";\nvar ExclamationCircleOutlined$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(ExclamationCircleOutlined);\nvar InfoCircleOutlined$2 = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"64 64 896 896\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z\" } }, { \"tag\": \"path\", \"attrs\": { \"d\": \"M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z\" } }] }, \"name\": \"info-circle\", \"theme\": \"outlined\" };\nvar InfoCircleOutlinedSvg = InfoCircleOutlined$2;\nvar InfoCircleOutlined = function InfoCircleOutlined2(props, ref) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {\n    ref,\n    icon: InfoCircleOutlinedSvg\n  }));\n};\nInfoCircleOutlined.displayName = \"InfoCircleOutlined\";\nvar InfoCircleOutlined$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(InfoCircleOutlined);\nfunction createUseNotification(getNotificationInstance2, getRCNoticeProps2) {\n  var useNotification$1 = function useNotification$12() {\n    var getPrefixCls;\n    var innerInstance = null;\n    var proxy = {\n      add: function add(noticeProps, holderCallback) {\n        innerInstance === null || innerInstance === void 0 ? void 0 : innerInstance.component.add(noticeProps, holderCallback);\n      }\n    };\n    var _useRCNotification = useNotification(proxy), _useRCNotification2 = _slicedToArray(_useRCNotification, 2), hookNotify = _useRCNotification2[0], holder = _useRCNotification2[1];\n    function notify(args) {\n      var customizePrefixCls = args.prefixCls;\n      var mergedPrefixCls = getPrefixCls(\"notification\", customizePrefixCls);\n      getNotificationInstance2(_extends$1(_extends$1({}, args), {\n        prefixCls: mergedPrefixCls\n      }), function(_ref) {\n        var prefixCls = _ref.prefixCls, instance = _ref.instance;\n        innerInstance = instance;\n        hookNotify(getRCNoticeProps2(args, prefixCls));\n      });\n    }\n    var hookApiRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n    hookApiRef.current.open = notify;\n    [\"success\", \"info\", \"warning\", \"error\"].forEach(function(type4) {\n      hookApiRef.current[type4] = function(args) {\n        return hookApiRef.current.open(_extends$1(_extends$1({}, args), {\n          type: type4\n        }));\n      };\n    });\n    return [hookApiRef.current, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConfigConsumer, {\n      key: \"holder\"\n    }, function(context) {\n      getPrefixCls = context.getPrefixCls;\n      return holder;\n    })];\n  };\n  return useNotification$1;\n}\nglobalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e2) {\n        reject(e2);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e2) {\n        reject(e2);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar notificationInstance = {};\nvar defaultDuration$1 = 4.5;\nvar defaultTop$1 = 24;\nvar defaultBottom = 24;\nvar defaultPrefixCls$1 = \"\";\nvar defaultPlacement = \"topRight\";\nvar defaultGetContainer;\nvar defaultCloseIcon;\nvar rtl$1 = false;\nvar maxCount$1;\nfunction setNotificationConfig(options) {\n  var duration = options.duration, placement = options.placement, bottom = options.bottom, top = options.top, getContainer2 = options.getContainer, closeIcon = options.closeIcon, prefixCls = options.prefixCls;\n  if (prefixCls !== void 0) {\n    defaultPrefixCls$1 = prefixCls;\n  }\n  if (duration !== void 0) {\n    defaultDuration$1 = duration;\n  }\n  if (placement !== void 0) {\n    defaultPlacement = placement;\n  } else if (options.rtl) {\n    defaultPlacement = \"topLeft\";\n  }\n  if (bottom !== void 0) {\n    defaultBottom = bottom;\n  }\n  if (top !== void 0) {\n    defaultTop$1 = top;\n  }\n  if (getContainer2 !== void 0) {\n    defaultGetContainer = getContainer2;\n  }\n  if (closeIcon !== void 0) {\n    defaultCloseIcon = closeIcon;\n  }\n  if (options.rtl !== void 0) {\n    rtl$1 = options.rtl;\n  }\n  if (options.maxCount !== void 0) {\n    maxCount$1 = options.maxCount;\n  }\n}\nfunction getPlacementStyle(placement) {\n  var top = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultTop$1;\n  var bottom = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultBottom;\n  var style2;\n  switch (placement) {\n    case \"topLeft\":\n      style2 = {\n        left: 0,\n        top,\n        bottom: \"auto\"\n      };\n      break;\n    case \"topRight\":\n      style2 = {\n        right: 0,\n        top,\n        bottom: \"auto\"\n      };\n      break;\n    case \"bottomLeft\":\n      style2 = {\n        left: 0,\n        top: \"auto\",\n        bottom\n      };\n      break;\n    default:\n      style2 = {\n        right: 0,\n        top: \"auto\",\n        bottom\n      };\n      break;\n  }\n  return style2;\n}\nfunction getNotificationInstance(args, callback) {\n  var _args$placement = args.placement, placement = _args$placement === void 0 ? defaultPlacement : _args$placement, top = args.top, bottom = args.bottom, _args$getContainer = args.getContainer, getContainer2 = _args$getContainer === void 0 ? defaultGetContainer : _args$getContainer, customizePrefixCls = args.prefixCls;\n  var _globalConfig = globalConfig(), getPrefixCls = _globalConfig.getPrefixCls, getIconPrefixCls = _globalConfig.getIconPrefixCls;\n  var prefixCls = getPrefixCls(\"notification\", customizePrefixCls || defaultPrefixCls$1);\n  var iconPrefixCls = getIconPrefixCls();\n  var cacheKey = \"\".concat(prefixCls, \"-\").concat(placement);\n  var cacheInstance = notificationInstance[cacheKey];\n  if (cacheInstance) {\n    Promise.resolve(cacheInstance).then(function(instance) {\n      callback({\n        prefixCls: \"\".concat(prefixCls, \"-notice\"),\n        iconPrefixCls,\n        instance\n      });\n    });\n    return;\n  }\n  var notificationClass = classNames(\"\".concat(prefixCls, \"-\").concat(placement), _defineProperty$1({}, \"\".concat(prefixCls, \"-rtl\"), rtl$1 === true));\n  notificationInstance[cacheKey] = new Promise(function(resolve) {\n    Notification.newInstance({\n      prefixCls,\n      className: notificationClass,\n      style: getPlacementStyle(placement, top, bottom),\n      getContainer: getContainer2,\n      maxCount: maxCount$1\n    }, function(notification2) {\n      resolve(notification2);\n      callback({\n        prefixCls: \"\".concat(prefixCls, \"-notice\"),\n        iconPrefixCls,\n        instance: notification2\n      });\n    });\n  });\n}\nvar typeToIcon$1 = {\n  success: CheckCircleOutlined$1,\n  info: InfoCircleOutlined$1,\n  error: CloseCircleOutlined$1,\n  warning: ExclamationCircleOutlined$1\n};\nfunction getRCNoticeProps$1(args, prefixCls, iconPrefixCls) {\n  var durationArg = args.duration, icon = args.icon, type4 = args.type, description = args.description, message2 = args.message, btn = args.btn, onClose2 = args.onClose, onClick = args.onClick, key2 = args.key, style2 = args.style, className = args.className, _args$closeIcon = args.closeIcon, closeIcon = _args$closeIcon === void 0 ? defaultCloseIcon : _args$closeIcon;\n  var duration = durationArg === void 0 ? defaultDuration$1 : durationArg;\n  var iconNode = null;\n  if (icon) {\n    iconNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n      className: \"\".concat(prefixCls, \"-icon\")\n    }, args.icon);\n  } else if (type4) {\n    iconNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(typeToIcon$1[type4] || null, {\n      className: \"\".concat(prefixCls, \"-icon \").concat(prefixCls, \"-icon-\").concat(type4)\n    });\n  }\n  var closeIconToRender = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n    className: \"\".concat(prefixCls, \"-close-x\")\n  }, closeIcon || /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CloseOutlined$1, {\n    className: \"\".concat(prefixCls, \"-close-icon\")\n  }));\n  var autoMarginTag = !description && iconNode ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n    className: \"\".concat(prefixCls, \"-message-single-line-auto-margin\")\n  }) : null;\n  return {\n    content: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConfigProvider, {\n      iconPrefixCls\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: iconNode ? \"\".concat(prefixCls, \"-with-icon\") : \"\",\n      role: \"alert\"\n    }, iconNode, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: \"\".concat(prefixCls, \"-message\")\n    }, autoMarginTag, message2), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: \"\".concat(prefixCls, \"-description\")\n    }, description), btn ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n      className: \"\".concat(prefixCls, \"-btn\")\n    }, btn) : null)),\n    duration,\n    closable: true,\n    closeIcon: closeIconToRender,\n    onClose: onClose2,\n    onClick,\n    key: key2,\n    style: style2 || {},\n    className: classNames(className, _defineProperty$1({}, \"\".concat(prefixCls, \"-\").concat(type4), !!type4))\n  };\n}\nfunction notice$1(args) {\n  getNotificationInstance(args, function(_ref) {\n    var prefixCls = _ref.prefixCls, iconPrefixCls = _ref.iconPrefixCls, instance = _ref.instance;\n    instance.notice(getRCNoticeProps$1(args, prefixCls, iconPrefixCls));\n  });\n}\nvar api$1 = {\n  open: notice$1,\n  close: function close(key2) {\n    Object.keys(notificationInstance).forEach(function(cacheKey) {\n      return Promise.resolve(notificationInstance[cacheKey]).then(function(instance) {\n        instance.removeNotice(key2);\n      });\n    });\n  },\n  config: setNotificationConfig,\n  destroy: function destroy() {\n    Object.keys(notificationInstance).forEach(function(cacheKey) {\n      Promise.resolve(notificationInstance[cacheKey]).then(function(instance) {\n        instance.destroy();\n      });\n      delete notificationInstance[cacheKey];\n    });\n  }\n};\n[\"success\", \"info\", \"warning\", \"error\"].forEach(function(type4) {\n  api$1[type4] = function(args) {\n    return api$1.open(_extends$1(_extends$1({}, args), {\n      type: type4\n    }));\n  };\n});\napi$1.warn = api$1.warning;\napi$1.useNotification = createUseNotification(getNotificationInstance, getRCNoticeProps$1);\nvar notification = api$1;\nvar dynamicStyleMark = \"-ant-\".concat(Date.now(), \"-\").concat(Math.random());\nfunction registerTheme(globalPrefixCls2, theme) {\n  var variables = {};\n  var formatColor = function formatColor2(color, updater) {\n    var clone2 = color.clone();\n    clone2 = (updater === null || updater === void 0 ? void 0 : updater(clone2)) || clone2;\n    return clone2.toRgbString();\n  };\n  var fillColor = function fillColor2(colorVal, type4) {\n    var baseColor = new TinyColor(colorVal);\n    var colorPalettes = generate$1(baseColor.toRgbString());\n    variables[\"\".concat(type4, \"-color\")] = formatColor(baseColor);\n    variables[\"\".concat(type4, \"-color-disabled\")] = colorPalettes[1];\n    variables[\"\".concat(type4, \"-color-hover\")] = colorPalettes[4];\n    variables[\"\".concat(type4, \"-color-active\")] = colorPalettes[7];\n    variables[\"\".concat(type4, \"-color-outline\")] = baseColor.clone().setAlpha(0.2).toRgbString();\n    variables[\"\".concat(type4, \"-color-deprecated-bg\")] = colorPalettes[1];\n    variables[\"\".concat(type4, \"-color-deprecated-border\")] = colorPalettes[3];\n  };\n  if (theme.primaryColor) {\n    fillColor(theme.primaryColor, \"primary\");\n    var primaryColor = new TinyColor(theme.primaryColor);\n    var primaryColors = generate$1(primaryColor.toRgbString());\n    primaryColors.forEach(function(color, index2) {\n      variables[\"primary-\".concat(index2 + 1)] = color;\n    });\n    variables[\"primary-color-deprecated-l-35\"] = formatColor(primaryColor, function(c2) {\n      return c2.lighten(35);\n    });\n    variables[\"primary-color-deprecated-l-20\"] = formatColor(primaryColor, function(c2) {\n      return c2.lighten(20);\n    });\n    variables[\"primary-color-deprecated-t-20\"] = formatColor(primaryColor, function(c2) {\n      return c2.tint(20);\n    });\n    variables[\"primary-color-deprecated-t-50\"] = formatColor(primaryColor, function(c2) {\n      return c2.tint(50);\n    });\n    variables[\"primary-color-deprecated-f-12\"] = formatColor(primaryColor, function(c2) {\n      return c2.setAlpha(c2.getAlpha() * 0.12);\n    });\n    var primaryActiveColor = new TinyColor(primaryColors[0]);\n    variables[\"primary-color-active-deprecated-f-30\"] = formatColor(primaryActiveColor, function(c2) {\n      return c2.setAlpha(c2.getAlpha() * 0.3);\n    });\n    variables[\"primary-color-active-deprecated-d-02\"] = formatColor(primaryActiveColor, function(c2) {\n      return c2.darken(2);\n    });\n  }\n  if (theme.successColor) {\n    fillColor(theme.successColor, \"success\");\n  }\n  if (theme.warningColor) {\n    fillColor(theme.warningColor, \"warning\");\n  }\n  if (theme.errorColor) {\n    fillColor(theme.errorColor, \"error\");\n  }\n  if (theme.infoColor) {\n    fillColor(theme.infoColor, \"info\");\n  }\n  var cssList = Object.keys(variables).map(function(key2) {\n    return \"--\".concat(globalPrefixCls2, \"-\").concat(key2, \": \").concat(variables[key2], \";\");\n  });\n  if (canUseDom()) {\n    updateCSS(\"\\n  :root {\\n    \".concat(cssList.join(\"\\n\"), \"\\n  }\\n  \"), \"\".concat(dynamicStyleMark, \"-dynamic-theme\"));\n  } else {\n    devWarning(false, \"ConfigProvider\", \"SSR do not support dynamic theme with css variables.\");\n  }\n}\nvar PASSED_PROPS = [\"getTargetContainer\", \"getPopupContainer\", \"renderEmpty\", \"pageHeader\", \"input\", \"form\"];\nvar defaultPrefixCls = \"ant\";\nvar defaultIconPrefixCls = \"anticon\";\nvar globalPrefixCls;\nvar globalIconPrefixCls;\nfunction getGlobalPrefixCls() {\n  return globalPrefixCls || defaultPrefixCls;\n}\nfunction getGlobalIconPrefixCls() {\n  return globalIconPrefixCls || defaultIconPrefixCls;\n}\nvar setGlobalConfig = function setGlobalConfig2(_ref) {\n  var prefixCls = _ref.prefixCls, iconPrefixCls = _ref.iconPrefixCls, theme = _ref.theme;\n  if (prefixCls !== void 0) {\n    globalPrefixCls = prefixCls;\n  }\n  if (iconPrefixCls !== void 0) {\n    globalIconPrefixCls = iconPrefixCls;\n  }\n  if (theme) {\n    registerTheme(getGlobalPrefixCls(), theme);\n  }\n};\nvar globalConfig = function globalConfig2() {\n  return {\n    getPrefixCls: function getPrefixCls(suffixCls, customizePrefixCls) {\n      if (customizePrefixCls)\n        return customizePrefixCls;\n      return suffixCls ? \"\".concat(getGlobalPrefixCls(), \"-\").concat(suffixCls) : getGlobalPrefixCls();\n    },\n    getIconPrefixCls: getGlobalIconPrefixCls,\n    getRootPrefixCls: function getRootPrefixCls(rootPrefixCls, customizePrefixCls) {\n      if (rootPrefixCls) {\n        return rootPrefixCls;\n      }\n      if (globalPrefixCls) {\n        return globalPrefixCls;\n      }\n      if (customizePrefixCls && customizePrefixCls.includes(\"-\")) {\n        return customizePrefixCls.replace(/^(.*)-[^-]*$/, \"$1\");\n      }\n      return getGlobalPrefixCls();\n    }\n  };\n};\nvar ProviderChildren = function ProviderChildren2(props) {\n  var _a, _b;\n  var children = props.children, csp = props.csp, autoInsertSpaceInButton = props.autoInsertSpaceInButton, form = props.form, locale2 = props.locale, componentSize = props.componentSize, direction = props.direction, space = props.space, virtual = props.virtual, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, legacyLocale = props.legacyLocale, parentContext = props.parentContext, iconPrefixCls = props.iconPrefixCls;\n  var getPrefixCls = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(suffixCls, customizePrefixCls) {\n    var prefixCls = props.prefixCls;\n    if (customizePrefixCls)\n      return customizePrefixCls;\n    var mergedPrefixCls = prefixCls || parentContext.getPrefixCls(\"\");\n    return suffixCls ? \"\".concat(mergedPrefixCls, \"-\").concat(suffixCls) : mergedPrefixCls;\n  }, [parentContext.getPrefixCls, props.prefixCls]);\n  var config = _extends$1(_extends$1({}, parentContext), {\n    csp,\n    autoInsertSpaceInButton,\n    locale: locale2 || legacyLocale,\n    direction,\n    space,\n    virtual,\n    dropdownMatchSelectWidth,\n    getPrefixCls\n  });\n  PASSED_PROPS.forEach(function(propName) {\n    var propValue = props[propName];\n    if (propValue) {\n      config[propName] = propValue;\n    }\n  });\n  var memoedConfig = useMemo(function() {\n    return config;\n  }, config, function(prevConfig, currentConfig) {\n    var prevKeys = Object.keys(prevConfig);\n    var currentKeys = Object.keys(currentConfig);\n    return prevKeys.length !== currentKeys.length || prevKeys.some(function(key2) {\n      return prevConfig[key2] !== currentConfig[key2];\n    });\n  });\n  var memoIconContextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n    return {\n      prefixCls: iconPrefixCls,\n      csp\n    };\n  }, [iconPrefixCls]);\n  var childNode = children;\n  var validateMessages = {};\n  if (locale2) {\n    validateMessages = ((_a = locale2.Form) === null || _a === void 0 ? void 0 : _a.defaultValidateMessages) || ((_b = defaultLocale.Form) === null || _b === void 0 ? void 0 : _b.defaultValidateMessages) || {};\n  }\n  if (form && form.validateMessages) {\n    validateMessages = _extends$1(_extends$1({}, validateMessages), form.validateMessages);\n  }\n  if (Object.keys(validateMessages).length > 0) {\n    childNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormProvider, {\n      validateMessages\n    }, children);\n  }\n  if (locale2) {\n    childNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocaleProvider, {\n      locale: locale2,\n      _ANT_MARK__: ANT_MARK\n    }, childNode);\n  }\n  if (iconPrefixCls) {\n    childNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(IconContext$1.Provider, {\n      value: memoIconContextValue\n    }, childNode);\n  }\n  if (componentSize) {\n    childNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SizeContextProvider, {\n      size: componentSize\n    }, childNode);\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConfigContext.Provider, {\n    value: memoedConfig\n  }, childNode);\n};\nvar ConfigProvider = function ConfigProvider2(props) {\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    if (props.direction) {\n      message.config({\n        rtl: props.direction === \"rtl\"\n      });\n      notification.config({\n        rtl: props.direction === \"rtl\"\n      });\n    }\n  }, [props.direction]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocaleReceiver, null, function(_, __, legacyLocale) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConfigConsumer, null, function(context) {\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ProviderChildren, _extends$1({\n        parentContext: context,\n        legacyLocale\n      }, props));\n    });\n  });\n};\nConfigProvider.ConfigContext = ConfigContext;\nConfigProvider.SizeContext = SizeContext$1;\nConfigProvider.config = setGlobalConfig;\nfunction createUseMessage(getRcNotificationInstance, getRCNoticeProps2) {\n  var useMessage = function useMessage2() {\n    var getPrefixCls;\n    var getPopupContainer;\n    var innerInstance = null;\n    var proxy = {\n      add: function add(noticeProps, holderCallback) {\n        innerInstance === null || innerInstance === void 0 ? void 0 : innerInstance.component.add(noticeProps, holderCallback);\n      }\n    };\n    var _useRCNotification = useNotification(proxy), _useRCNotification2 = _slicedToArray(_useRCNotification, 2), hookNotify = _useRCNotification2[0], holder = _useRCNotification2[1];\n    function notify(args) {\n      var customizePrefixCls = args.prefixCls;\n      var mergedPrefixCls = getPrefixCls(\"message\", customizePrefixCls);\n      var rootPrefixCls = getPrefixCls();\n      var target = args.key || getKeyThenIncreaseKey();\n      var closePromise = new Promise(function(resolve) {\n        var callback = function callback2() {\n          if (typeof args.onClose === \"function\") {\n            args.onClose();\n          }\n          return resolve(true);\n        };\n        getRcNotificationInstance(_extends$1(_extends$1({}, args), {\n          prefixCls: mergedPrefixCls,\n          rootPrefixCls,\n          getPopupContainer\n        }), function(_ref) {\n          var prefixCls = _ref.prefixCls, instance = _ref.instance;\n          innerInstance = instance;\n          hookNotify(getRCNoticeProps2(_extends$1(_extends$1({}, args), {\n            key: target,\n            onClose: callback\n          }), prefixCls));\n        });\n      });\n      var result = function result2() {\n        if (innerInstance) {\n          innerInstance.removeNotice(target);\n        }\n      };\n      result.then = function(filled, rejected) {\n        return closePromise.then(filled, rejected);\n      };\n      result.promise = closePromise;\n      return result;\n    }\n    var hookApiRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n    hookApiRef.current.open = notify;\n    [\"success\", \"info\", \"warning\", \"error\", \"loading\"].forEach(function(type4) {\n      return attachTypeApi(hookApiRef.current, type4);\n    });\n    return [hookApiRef.current, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConfigConsumer, {\n      key: \"holder\"\n    }, function(context) {\n      getPrefixCls = context.getPrefixCls;\n      getPopupContainer = context.getPopupContainer;\n      return holder;\n    })];\n  };\n  return useMessage;\n}\nvar messageInstance;\nvar defaultDuration = 3;\nvar defaultTop;\nvar key = 1;\nvar localPrefixCls = \"\";\nvar transitionName = \"move-up\";\nvar hasTransitionName = false;\nvar getContainer;\nvar maxCount;\nvar rtl = false;\nfunction getKeyThenIncreaseKey() {\n  return key++;\n}\nfunction setMessageConfig(options) {\n  if (options.top !== void 0) {\n    defaultTop = options.top;\n    messageInstance = null;\n  }\n  if (options.duration !== void 0) {\n    defaultDuration = options.duration;\n  }\n  if (options.prefixCls !== void 0) {\n    localPrefixCls = options.prefixCls;\n  }\n  if (options.getContainer !== void 0) {\n    getContainer = options.getContainer;\n    messageInstance = null;\n  }\n  if (options.transitionName !== void 0) {\n    transitionName = options.transitionName;\n    messageInstance = null;\n    hasTransitionName = true;\n  }\n  if (options.maxCount !== void 0) {\n    maxCount = options.maxCount;\n    messageInstance = null;\n  }\n  if (options.rtl !== void 0) {\n    rtl = options.rtl;\n  }\n}\nfunction getRCNotificationInstance(args, callback) {\n  var customizePrefixCls = args.prefixCls, getContextPopupContainer = args.getPopupContainer;\n  var _globalConfig = globalConfig(), getPrefixCls = _globalConfig.getPrefixCls, getRootPrefixCls = _globalConfig.getRootPrefixCls, getIconPrefixCls = _globalConfig.getIconPrefixCls;\n  var prefixCls = getPrefixCls(\"message\", customizePrefixCls || localPrefixCls);\n  var rootPrefixCls = getRootPrefixCls(args.rootPrefixCls, prefixCls);\n  var iconPrefixCls = getIconPrefixCls();\n  if (messageInstance) {\n    callback({\n      prefixCls,\n      rootPrefixCls,\n      iconPrefixCls,\n      instance: messageInstance\n    });\n    return;\n  }\n  var instanceConfig = {\n    prefixCls,\n    transitionName: hasTransitionName ? transitionName : \"\".concat(rootPrefixCls, \"-\").concat(transitionName),\n    style: {\n      top: defaultTop\n    },\n    getContainer: getContainer || getContextPopupContainer,\n    maxCount\n  };\n  Notification.newInstance(instanceConfig, function(instance) {\n    if (messageInstance) {\n      callback({\n        prefixCls,\n        rootPrefixCls,\n        iconPrefixCls,\n        instance: messageInstance\n      });\n      return;\n    }\n    messageInstance = instance;\n    callback({\n      prefixCls,\n      rootPrefixCls,\n      iconPrefixCls,\n      instance\n    });\n  });\n}\nvar typeToIcon = {\n  info: InfoCircleFilled$1,\n  success: CheckCircleFilled$1,\n  error: CloseCircleFilled$1,\n  warning: ExclamationCircleFilled$1,\n  loading: LoadingOutlined$1\n};\nfunction getRCNoticeProps(args, prefixCls, iconPrefixCls) {\n  var _classNames;\n  var duration = args.duration !== void 0 ? args.duration : defaultDuration;\n  var IconComponent = typeToIcon[args.type];\n  var messageClass = classNames(\"\".concat(prefixCls, \"-custom-content\"), (_classNames = {}, _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-\").concat(args.type), args.type), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-rtl\"), rtl === true), _classNames));\n  return {\n    key: args.key,\n    duration,\n    style: args.style || {},\n    className: args.className,\n    content: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConfigProvider, {\n      iconPrefixCls\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: messageClass\n    }, args.icon || IconComponent && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(IconComponent, null), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, args.content))),\n    onClose: args.onClose,\n    onClick: args.onClick\n  };\n}\nfunction notice(args) {\n  var target = args.key || getKeyThenIncreaseKey();\n  var closePromise = new Promise(function(resolve) {\n    var callback = function callback2() {\n      if (typeof args.onClose === \"function\") {\n        args.onClose();\n      }\n      return resolve(true);\n    };\n    getRCNotificationInstance(args, function(_ref) {\n      var prefixCls = _ref.prefixCls, iconPrefixCls = _ref.iconPrefixCls, instance = _ref.instance;\n      instance.notice(getRCNoticeProps(_extends$1(_extends$1({}, args), {\n        key: target,\n        onClose: callback\n      }), prefixCls, iconPrefixCls));\n    });\n  });\n  var result = function result2() {\n    if (messageInstance) {\n      messageInstance.removeNotice(target);\n    }\n  };\n  result.then = function(filled, rejected) {\n    return closePromise.then(filled, rejected);\n  };\n  result.promise = closePromise;\n  return result;\n}\nfunction isArgsProps(content) {\n  return Object.prototype.toString.call(content) === \"[object Object]\" && !!content.content;\n}\nvar api = {\n  open: notice,\n  config: setMessageConfig,\n  destroy: function destroy2(messageKey) {\n    if (messageInstance) {\n      if (messageKey) {\n        var _messageInstance = messageInstance, removeNotice = _messageInstance.removeNotice;\n        removeNotice(messageKey);\n      } else {\n        var _messageInstance2 = messageInstance, destroy3 = _messageInstance2.destroy;\n        destroy3();\n        messageInstance = null;\n      }\n    }\n  }\n};\nfunction attachTypeApi(originalApi, type4) {\n  originalApi[type4] = function(content, duration, onClose2) {\n    if (isArgsProps(content)) {\n      return originalApi.open(_extends$1(_extends$1({}, content), {\n        type: type4\n      }));\n    }\n    if (typeof duration === \"function\") {\n      onClose2 = duration;\n      duration = void 0;\n    }\n    return originalApi.open({\n      content,\n      duration,\n      type: type4,\n      onClose: onClose2\n    });\n  };\n}\n[\"success\", \"info\", \"warning\", \"error\", \"loading\"].forEach(function(type4) {\n  return attachTypeApi(api, type4);\n});\napi.warn = api.warning;\napi.useMessage = createUseMessage(getRCNotificationInstance, getRCNoticeProps);\nvar message = api;\nfunction omit(obj, fields) {\n  var clone2 = _objectSpread2$1({}, obj);\n  if (Array.isArray(fields)) {\n    fields.forEach(function(key2) {\n      delete clone2[key2];\n    });\n  }\n  return clone2;\n}\nvar __rest$7 = globalThis && globalThis.__rest || function(s, e2) {\n  var t2 = {};\n  for (var p2 in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)\n      t2[p2] = s[p2];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {\n      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))\n        t2[p2[i]] = s[p2[i]];\n    }\n  return t2;\n};\nvar CheckableTag = function CheckableTag2(_a) {\n  var _classNames;\n  var customizePrefixCls = _a.prefixCls, className = _a.className, checked = _a.checked, onChange = _a.onChange, onClick = _a.onClick, restProps = __rest$7(_a, [\"prefixCls\", \"className\", \"checked\", \"onChange\", \"onClick\"]);\n  var _React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;\n  var handleClick = function handleClick2(e2) {\n    onChange === null || onChange === void 0 ? void 0 : onChange(!checked);\n    onClick === null || onClick === void 0 ? void 0 : onClick(e2);\n  };\n  var prefixCls = getPrefixCls(\"tag\", customizePrefixCls);\n  var cls = classNames(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-checkable\"), true), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-checkable-checked\"), checked), _classNames), className);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", _extends$1({}, restProps, {\n    className: cls,\n    onClick: handleClick\n  }));\n};\nvar CheckableTag$1 = CheckableTag;\nvar tuple = function tuple2() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return args;\n};\nvar PresetStatusColorTypes = tuple(\"success\", \"processing\", \"error\", \"default\", \"warning\");\nvar PresetColorTypes = tuple(\"pink\", \"red\", \"yellow\", \"orange\", \"cyan\", \"green\", \"blue\", \"purple\", \"geekblue\", \"magenta\", \"volcano\", \"gold\", \"lime\");\nvar id = 0;\nvar ids = {};\nfunction wrapperRaf(callback) {\n  var delayFrames = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n  var myId = id++;\n  var restFrames = delayFrames;\n  function internalCallback() {\n    restFrames -= 1;\n    if (restFrames <= 0) {\n      callback();\n      delete ids[myId];\n    } else {\n      ids[myId] = wrapperRaf$1(internalCallback);\n    }\n  }\n  ids[myId] = wrapperRaf$1(internalCallback);\n  return myId;\n}\nwrapperRaf.cancel = function cancel(pid) {\n  if (pid === void 0)\n    return;\n  wrapperRaf$1.cancel(ids[pid]);\n  delete ids[pid];\n};\nwrapperRaf.ids = ids;\nvar isValidElement = react__WEBPACK_IMPORTED_MODULE_0__.isValidElement;\nfunction replaceElement(element, replacement, props) {\n  if (!isValidElement(element))\n    return replacement;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(element, typeof props === \"function\" ? props(element.props || {}) : props);\n}\nfunction cloneElement(element, props) {\n  return replaceElement(element, element, props);\n}\nvar styleForPseudo;\nfunction isHidden(element) {\n  return !element || element.offsetParent === null || element.hidden;\n}\nfunction isNotGrey(color) {\n  var match = (color || \"\").match(/rgba?\\((\\d*), (\\d*), (\\d*)(, [\\d.]*)?\\)/);\n  if (match && match[1] && match[2] && match[3]) {\n    return !(match[1] === match[2] && match[2] === match[3]);\n  }\n  return true;\n}\nvar Wave = /* @__PURE__ */ function(_React$Component) {\n  _inherits(Wave2, _React$Component);\n  var _super = _createSuper(Wave2);\n  function Wave2() {\n    var _this;\n    _classCallCheck(this, Wave2);\n    _this = _super.apply(this, arguments);\n    _this.containerRef = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n    _this.animationStart = false;\n    _this.destroyed = false;\n    _this.onClick = function(node, waveColor) {\n      var _a, _b;\n      var _this$props = _this.props, insertExtraNode = _this$props.insertExtraNode, disabled = _this$props.disabled;\n      if (disabled || !node || isHidden(node) || node.className.indexOf(\"-leave\") >= 0) {\n        return;\n      }\n      _this.extraNode = document.createElement(\"div\");\n      var _assertThisInitialize = _assertThisInitialized(_this), extraNode = _assertThisInitialize.extraNode;\n      var getPrefixCls = _this.context.getPrefixCls;\n      extraNode.className = \"\".concat(getPrefixCls(\"\"), \"-click-animating-node\");\n      var attributeName = _this.getAttributeName();\n      node.setAttribute(attributeName, \"true\");\n      if (waveColor && waveColor !== \"#ffffff\" && waveColor !== \"rgb(255, 255, 255)\" && isNotGrey(waveColor) && !/rgba\\((?:\\d*, ){3}0\\)/.test(waveColor) && waveColor !== \"transparent\") {\n        extraNode.style.borderColor = waveColor;\n        var nodeRoot = ((_a = node.getRootNode) === null || _a === void 0 ? void 0 : _a.call(node)) || node.ownerDocument;\n        var nodeBody = nodeRoot instanceof Document ? nodeRoot.body : (_b = nodeRoot.firstChild) !== null && _b !== void 0 ? _b : nodeRoot;\n        styleForPseudo = updateCSS(\"\\n      [\".concat(getPrefixCls(\"\"), \"-click-animating-without-extra-node='true']::after, .\").concat(getPrefixCls(\"\"), \"-click-animating-node {\\n        --antd-wave-shadow-color: \").concat(waveColor, \";\\n      }\"), \"antd-wave\", {\n          csp: _this.csp,\n          attachTo: nodeBody\n        });\n      }\n      if (insertExtraNode) {\n        node.appendChild(extraNode);\n      }\n      [\"transition\", \"animation\"].forEach(function(name) {\n        node.addEventListener(\"\".concat(name, \"start\"), _this.onTransitionStart);\n        node.addEventListener(\"\".concat(name, \"end\"), _this.onTransitionEnd);\n      });\n    };\n    _this.onTransitionStart = function(e2) {\n      if (_this.destroyed) {\n        return;\n      }\n      var node = _this.containerRef.current;\n      if (!e2 || e2.target !== node || _this.animationStart) {\n        return;\n      }\n      _this.resetEffect(node);\n    };\n    _this.onTransitionEnd = function(e2) {\n      if (!e2 || e2.animationName !== \"fadeEffect\") {\n        return;\n      }\n      _this.resetEffect(e2.target);\n    };\n    _this.bindAnimationEvent = function(node) {\n      if (!node || !node.getAttribute || node.getAttribute(\"disabled\") || node.className.indexOf(\"disabled\") >= 0) {\n        return;\n      }\n      var onClick = function onClick2(e2) {\n        if (e2.target.tagName === \"INPUT\" || isHidden(e2.target)) {\n          return;\n        }\n        _this.resetEffect(node);\n        var waveColor = getComputedStyle(node).getPropertyValue(\"border-top-color\") || getComputedStyle(node).getPropertyValue(\"border-color\") || getComputedStyle(node).getPropertyValue(\"background-color\");\n        _this.clickWaveTimeoutId = window.setTimeout(function() {\n          return _this.onClick(node, waveColor);\n        }, 0);\n        wrapperRaf.cancel(_this.animationStartId);\n        _this.animationStart = true;\n        _this.animationStartId = wrapperRaf(function() {\n          _this.animationStart = false;\n        }, 10);\n      };\n      node.addEventListener(\"click\", onClick, true);\n      return {\n        cancel: function cancel2() {\n          node.removeEventListener(\"click\", onClick, true);\n        }\n      };\n    };\n    _this.renderWave = function(_ref) {\n      var csp = _ref.csp;\n      var children = _this.props.children;\n      _this.csp = csp;\n      if (!/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(children))\n        return children;\n      var ref = _this.containerRef;\n      if (supportRef(children)) {\n        ref = composeRef(children.ref, _this.containerRef);\n      }\n      return cloneElement(children, {\n        ref\n      });\n    };\n    return _this;\n  }\n  _createClass(Wave2, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var node = this.containerRef.current;\n      if (!node || node.nodeType !== 1) {\n        return;\n      }\n      this.instance = this.bindAnimationEvent(node);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.instance) {\n        this.instance.cancel();\n      }\n      if (this.clickWaveTimeoutId) {\n        clearTimeout(this.clickWaveTimeoutId);\n      }\n      this.destroyed = true;\n    }\n  }, {\n    key: \"getAttributeName\",\n    value: function getAttributeName() {\n      var getPrefixCls = this.context.getPrefixCls;\n      var insertExtraNode = this.props.insertExtraNode;\n      return insertExtraNode ? \"\".concat(getPrefixCls(\"\"), \"-click-animating\") : \"\".concat(getPrefixCls(\"\"), \"-click-animating-without-extra-node\");\n    }\n  }, {\n    key: \"resetEffect\",\n    value: function resetEffect(node) {\n      var _this2 = this;\n      if (!node || node === this.extraNode || !(node instanceof Element)) {\n        return;\n      }\n      var insertExtraNode = this.props.insertExtraNode;\n      var attributeName = this.getAttributeName();\n      node.setAttribute(attributeName, \"false\");\n      if (styleForPseudo) {\n        styleForPseudo.innerHTML = \"\";\n      }\n      if (insertExtraNode && this.extraNode && node.contains(this.extraNode)) {\n        node.removeChild(this.extraNode);\n      }\n      [\"transition\", \"animation\"].forEach(function(name) {\n        node.removeEventListener(\"\".concat(name, \"start\"), _this2.onTransitionStart);\n        node.removeEventListener(\"\".concat(name, \"end\"), _this2.onTransitionEnd);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConfigConsumer, null, this.renderWave);\n    }\n  }]);\n  return Wave2;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nWave.contextType = ConfigContext;\nvar __rest$6 = globalThis && globalThis.__rest || function(s, e2) {\n  var t2 = {};\n  for (var p2 in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)\n      t2[p2] = s[p2];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {\n      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))\n        t2[p2[i]] = s[p2[i]];\n    }\n  return t2;\n};\nvar PresetColorRegex$1 = new RegExp(\"^(\".concat(PresetColorTypes.join(\"|\"), \")(-inverse)?$\"));\nvar PresetStatusColorRegex = new RegExp(\"^(\".concat(PresetStatusColorTypes.join(\"|\"), \")$\"));\nvar InternalTag = function InternalTag2(_a, ref) {\n  var _classNames;\n  var customizePrefixCls = _a.prefixCls, className = _a.className, style2 = _a.style, children = _a.children, icon = _a.icon, color = _a.color, onClose2 = _a.onClose, closeIcon = _a.closeIcon, _a$closable = _a.closable, closable = _a$closable === void 0 ? false : _a$closable, props = __rest$6(_a, [\"prefixCls\", \"className\", \"style\", \"children\", \"icon\", \"color\", \"onClose\", \"closeIcon\", \"closable\"]);\n  var _React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(true), _React$useState2 = _slicedToArray(_React$useState, 2), visible = _React$useState2[0], setVisible = _React$useState2[1];\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    if (\"visible\" in props) {\n      setVisible(props.visible);\n    }\n  }, [props.visible]);\n  var isPresetColor = function isPresetColor2() {\n    if (!color) {\n      return false;\n    }\n    return PresetColorRegex$1.test(color) || PresetStatusColorRegex.test(color);\n  };\n  var tagStyle = _extends$1({\n    backgroundColor: color && !isPresetColor() ? color : void 0\n  }, style2);\n  var presetColor = isPresetColor();\n  var prefixCls = getPrefixCls(\"tag\", customizePrefixCls);\n  var tagClassName = classNames(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-\").concat(color), presetColor), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-has-color\"), color && !presetColor), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-hidden\"), !visible), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-rtl\"), direction === \"rtl\"), _classNames), className);\n  var handleCloseClick = function handleCloseClick2(e2) {\n    e2.stopPropagation();\n    onClose2 === null || onClose2 === void 0 ? void 0 : onClose2(e2);\n    if (e2.defaultPrevented) {\n      return;\n    }\n    if (!(\"visible\" in props)) {\n      setVisible(false);\n    }\n  };\n  var renderCloseIcon = function renderCloseIcon2() {\n    if (closable) {\n      return closeIcon ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: \"\".concat(prefixCls, \"-close-icon\"),\n        onClick: handleCloseClick\n      }, closeIcon) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CloseOutlined$1, {\n        className: \"\".concat(prefixCls, \"-close-icon\"),\n        onClick: handleCloseClick\n      });\n    }\n    return null;\n  };\n  var isNeedWave = \"onClick\" in props || children && children.type === \"a\";\n  var tagProps = omit(props, [\"visible\"]);\n  var iconNode = icon || null;\n  var kids = iconNode ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, iconNode, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, children)) : children;\n  var tagNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", _extends$1({}, tagProps, {\n    ref,\n    className: tagClassName,\n    style: tagStyle\n  }), kids, renderCloseIcon());\n  return isNeedWave ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wave, null, tagNode) : tagNode;\n};\nvar Tag = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(InternalTag);\nTag.displayName = \"Tag\";\nTag.CheckableTag = CheckableTag$1;\nvar Tag$1 = Tag;\nfunction contains(root2, n2) {\n  if (!root2) {\n    return false;\n  }\n  return root2.contains(n2);\n}\nfunction addEventListenerWrap(target, eventType, cb, option) {\n  var callback = (react_dom__WEBPACK_IMPORTED_MODULE_1___default().unstable_batchedUpdates) ? function run(e2) {\n    react_dom__WEBPACK_IMPORTED_MODULE_1___default().unstable_batchedUpdates(cb, e2);\n  } : cb;\n  if (target.addEventListener) {\n    target.addEventListener(eventType, callback, option);\n  }\n  return {\n    remove: function remove() {\n      if (target.removeEventListener) {\n        target.removeEventListener(eventType, callback);\n      }\n    }\n  };\n}\nvar Portal = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(props, ref) {\n  var didUpdate = props.didUpdate, getContainer2 = props.getContainer, children = props.children;\n  var containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, function() {\n    return {};\n  });\n  var initRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  if (!initRef.current && canUseDom()) {\n    containerRef.current = getContainer2();\n    initRef.current = true;\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    didUpdate === null || didUpdate === void 0 ? void 0 : didUpdate(props);\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    return function() {\n      var _containerRef$current, _containerRef$current2;\n      (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.parentNode) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.removeChild(containerRef.current);\n    };\n  }, []);\n  return containerRef.current ? /* @__PURE__ */ react_dom__WEBPACK_IMPORTED_MODULE_1___default().createPortal(children, containerRef.current) : null;\n});\nfunction isPointsEq(a1, a2, isAlignPoint) {\n  if (isAlignPoint) {\n    return a1[0] === a2[0];\n  }\n  return a1[0] === a2[0] && a1[1] === a2[1];\n}\nfunction getAlignFromPlacement(builtinPlacements, placementStr, align) {\n  var baseAlign = builtinPlacements[placementStr] || {};\n  return _objectSpread2$1(_objectSpread2$1({}, baseAlign), align);\n}\nfunction getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {\n  var points = align.points;\n  var placements2 = Object.keys(builtinPlacements);\n  for (var i = 0; i < placements2.length; i += 1) {\n    var placement = placements2[i];\n    if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {\n      return \"\".concat(prefixCls, \"-placement-\").concat(placement);\n    }\n  }\n  return \"\";\n}\nvar isMobile = function() {\n  if (typeof navigator === \"undefined\" || typeof window === \"undefined\") {\n    return false;\n  }\n  var agent = navigator.userAgent || navigator.vendor || window.opera;\n  if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4))) {\n    return true;\n  }\n  return false;\n};\nfunction getMotion(_ref) {\n  var prefixCls = _ref.prefixCls, motion = _ref.motion, animation = _ref.animation, transitionName2 = _ref.transitionName;\n  if (motion) {\n    return motion;\n  }\n  if (animation) {\n    return {\n      motionName: \"\".concat(prefixCls, \"-\").concat(animation)\n    };\n  }\n  if (transitionName2) {\n    return {\n      motionName: transitionName2\n    };\n  }\n  return null;\n}\nfunction Mask(props) {\n  var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, mask = props.mask, maskMotion = props.maskMotion, maskAnimation = props.maskAnimation, maskTransitionName = props.maskTransitionName;\n  if (!mask) {\n    return null;\n  }\n  var motion = {};\n  if (maskMotion || maskTransitionName || maskAnimation) {\n    motion = _objectSpread2$1({\n      motionAppear: true\n    }, getMotion({\n      motion: maskMotion,\n      prefixCls,\n      transitionName: maskTransitionName,\n      animation: maskAnimation\n    }));\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CSSMotion, _extends$1({}, motion, {\n    visible,\n    removeOnLeave: true\n  }), function(_ref) {\n    var className = _ref.className;\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      style: {\n        zIndex\n      },\n      className: classNames(\"\".concat(prefixCls, \"-mask\"), className)\n    });\n  });\n}\nvar isVisible = function(element) {\n  if (!element) {\n    return false;\n  }\n  if (element.offsetParent) {\n    return true;\n  }\n  if (element.getBBox) {\n    var box = element.getBBox();\n    if (box.width || box.height) {\n      return true;\n    }\n  }\n  if (element.getBoundingClientRect) {\n    var _box = element.getBoundingClientRect();\n    if (_box.width || _box.height) {\n      return true;\n    }\n  }\n  return false;\n};\nfunction ownKeys(object4, enumerableOnly) {\n  var keys2 = Object.keys(object4);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object4);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;\n      });\n    }\n    keys2.push.apply(keys2, symbols);\n  }\n  return keys2;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function(key2) {\n        _defineProperty(target, key2, source[key2]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function(key2) {\n        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));\n      });\n    }\n  }\n  return target;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function(obj2) {\n      return typeof obj2;\n    };\n  } else {\n    _typeof = function(obj2) {\n      return obj2 && typeof Symbol === \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _defineProperty(obj, key2, value) {\n  if (key2 in obj) {\n    Object.defineProperty(obj, key2, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key2] = value;\n  }\n  return obj;\n}\nvar vendorPrefix;\nvar jsCssMap = {\n  Webkit: \"-webkit-\",\n  Moz: \"-moz-\",\n  ms: \"-ms-\",\n  O: \"-o-\"\n};\nfunction getVendorPrefix() {\n  if (vendorPrefix !== void 0) {\n    return vendorPrefix;\n  }\n  vendorPrefix = \"\";\n  var style2 = document.createElement(\"p\").style;\n  var testProp = \"Transform\";\n  for (var key2 in jsCssMap) {\n    if (key2 + testProp in style2) {\n      vendorPrefix = key2;\n    }\n  }\n  return vendorPrefix;\n}\nfunction getTransitionName$1() {\n  return getVendorPrefix() ? \"\".concat(getVendorPrefix(), \"TransitionProperty\") : \"transitionProperty\";\n}\nfunction getTransformName() {\n  return getVendorPrefix() ? \"\".concat(getVendorPrefix(), \"Transform\") : \"transform\";\n}\nfunction setTransitionProperty(node, value) {\n  var name = getTransitionName$1();\n  if (name) {\n    node.style[name] = value;\n    if (name !== \"transitionProperty\") {\n      node.style.transitionProperty = value;\n    }\n  }\n}\nfunction setTransform(node, value) {\n  var name = getTransformName();\n  if (name) {\n    node.style[name] = value;\n    if (name !== \"transform\") {\n      node.style.transform = value;\n    }\n  }\n}\nfunction getTransitionProperty(node) {\n  return node.style.transitionProperty || node.style[getTransitionName$1()];\n}\nfunction getTransformXY(node) {\n  var style2 = window.getComputedStyle(node, null);\n  var transform = style2.getPropertyValue(\"transform\") || style2.getPropertyValue(getTransformName());\n  if (transform && transform !== \"none\") {\n    var matrix = transform.replace(/[^0-9\\-.,]/g, \"\").split(\",\");\n    return {\n      x: parseFloat(matrix[12] || matrix[4], 0),\n      y: parseFloat(matrix[13] || matrix[5], 0)\n    };\n  }\n  return {\n    x: 0,\n    y: 0\n  };\n}\nvar matrix2d = /matrix\\((.*)\\)/;\nvar matrix3d = /matrix3d\\((.*)\\)/;\nfunction setTransformXY(node, xy) {\n  var style2 = window.getComputedStyle(node, null);\n  var transform = style2.getPropertyValue(\"transform\") || style2.getPropertyValue(getTransformName());\n  if (transform && transform !== \"none\") {\n    var arr;\n    var match2d = transform.match(matrix2d);\n    if (match2d) {\n      match2d = match2d[1];\n      arr = match2d.split(\",\").map(function(item) {\n        return parseFloat(item, 10);\n      });\n      arr[4] = xy.x;\n      arr[5] = xy.y;\n      setTransform(node, \"matrix(\".concat(arr.join(\",\"), \")\"));\n    } else {\n      var match3d = transform.match(matrix3d)[1];\n      arr = match3d.split(\",\").map(function(item) {\n        return parseFloat(item, 10);\n      });\n      arr[12] = xy.x;\n      arr[13] = xy.y;\n      setTransform(node, \"matrix3d(\".concat(arr.join(\",\"), \")\"));\n    }\n  } else {\n    setTransform(node, \"translateX(\".concat(xy.x, \"px) translateY(\").concat(xy.y, \"px) translateZ(0)\"));\n  }\n}\nvar RE_NUM = /[\\-+]?(?:\\d*\\.|)\\d+(?:[eE][\\-+]?\\d+|)/.source;\nvar getComputedStyleX;\nfunction forceRelayout(elem) {\n  var originalStyle = elem.style.display;\n  elem.style.display = \"none\";\n  elem.offsetHeight;\n  elem.style.display = originalStyle;\n}\nfunction css(el, name, v2) {\n  var value = v2;\n  if (_typeof(name) === \"object\") {\n    for (var i in name) {\n      if (name.hasOwnProperty(i)) {\n        css(el, i, name[i]);\n      }\n    }\n    return void 0;\n  }\n  if (typeof value !== \"undefined\") {\n    if (typeof value === \"number\") {\n      value = \"\".concat(value, \"px\");\n    }\n    el.style[name] = value;\n    return void 0;\n  }\n  return getComputedStyleX(el, name);\n}\nfunction getClientPosition(elem) {\n  var box;\n  var x2;\n  var y2;\n  var doc = elem.ownerDocument;\n  var body = doc.body;\n  var docElem = doc && doc.documentElement;\n  box = elem.getBoundingClientRect();\n  x2 = box.left;\n  y2 = box.top;\n  x2 -= docElem.clientLeft || body.clientLeft || 0;\n  y2 -= docElem.clientTop || body.clientTop || 0;\n  return {\n    left: x2,\n    top: y2\n  };\n}\nfunction getScroll(w2, top) {\n  var ret = w2[\"page\".concat(top ? \"Y\" : \"X\", \"Offset\")];\n  var method4 = \"scroll\".concat(top ? \"Top\" : \"Left\");\n  if (typeof ret !== \"number\") {\n    var d2 = w2.document;\n    ret = d2.documentElement[method4];\n    if (typeof ret !== \"number\") {\n      ret = d2.body[method4];\n    }\n  }\n  return ret;\n}\nfunction getScrollLeft(w2) {\n  return getScroll(w2);\n}\nfunction getScrollTop(w2) {\n  return getScroll(w2, true);\n}\nfunction getOffset(el) {\n  var pos = getClientPosition(el);\n  var doc = el.ownerDocument;\n  var w2 = doc.defaultView || doc.parentWindow;\n  pos.left += getScrollLeft(w2);\n  pos.top += getScrollTop(w2);\n  return pos;\n}\nfunction isWindow(obj) {\n  return obj !== null && obj !== void 0 && obj == obj.window;\n}\nfunction getDocument(node) {\n  if (isWindow(node)) {\n    return node.document;\n  }\n  if (node.nodeType === 9) {\n    return node;\n  }\n  return node.ownerDocument;\n}\nfunction _getComputedStyle(elem, name, cs) {\n  var computedStyle = cs;\n  var val = \"\";\n  var d2 = getDocument(elem);\n  computedStyle = computedStyle || d2.defaultView.getComputedStyle(elem, null);\n  if (computedStyle) {\n    val = computedStyle.getPropertyValue(name) || computedStyle[name];\n  }\n  return val;\n}\nvar _RE_NUM_NO_PX = new RegExp(\"^(\".concat(RE_NUM, \")(?!px)[a-z%]+$\"), \"i\");\nvar RE_POS = /^(top|right|bottom|left)$/;\nvar CURRENT_STYLE = \"currentStyle\";\nvar RUNTIME_STYLE = \"runtimeStyle\";\nvar LEFT = \"left\";\nvar PX = \"px\";\nfunction _getComputedStyleIE(elem, name) {\n  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];\n  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {\n    var style2 = elem.style;\n    var left = style2[LEFT];\n    var rsLeft = elem[RUNTIME_STYLE][LEFT];\n    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];\n    style2[LEFT] = name === \"fontSize\" ? \"1em\" : ret || 0;\n    ret = style2.pixelLeft + PX;\n    style2[LEFT] = left;\n    elem[RUNTIME_STYLE][LEFT] = rsLeft;\n  }\n  return ret === \"\" ? \"auto\" : ret;\n}\nif (typeof window !== \"undefined\") {\n  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;\n}\nfunction getOffsetDirection(dir, option) {\n  if (dir === \"left\") {\n    return option.useCssRight ? \"right\" : dir;\n  }\n  return option.useCssBottom ? \"bottom\" : dir;\n}\nfunction oppositeOffsetDirection(dir) {\n  if (dir === \"left\") {\n    return \"right\";\n  } else if (dir === \"right\") {\n    return \"left\";\n  } else if (dir === \"top\") {\n    return \"bottom\";\n  } else if (dir === \"bottom\") {\n    return \"top\";\n  }\n}\nfunction setLeftTop(elem, offset2, option) {\n  if (css(elem, \"position\") === \"static\") {\n    elem.style.position = \"relative\";\n  }\n  var presetH = -999;\n  var presetV = -999;\n  var horizontalProperty = getOffsetDirection(\"left\", option);\n  var verticalProperty = getOffsetDirection(\"top\", option);\n  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);\n  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);\n  if (horizontalProperty !== \"left\") {\n    presetH = 999;\n  }\n  if (verticalProperty !== \"top\") {\n    presetV = 999;\n  }\n  var originalTransition = \"\";\n  var originalOffset = getOffset(elem);\n  if (\"left\" in offset2 || \"top\" in offset2) {\n    originalTransition = getTransitionProperty(elem) || \"\";\n    setTransitionProperty(elem, \"none\");\n  }\n  if (\"left\" in offset2) {\n    elem.style[oppositeHorizontalProperty] = \"\";\n    elem.style[horizontalProperty] = \"\".concat(presetH, \"px\");\n  }\n  if (\"top\" in offset2) {\n    elem.style[oppositeVerticalProperty] = \"\";\n    elem.style[verticalProperty] = \"\".concat(presetV, \"px\");\n  }\n  forceRelayout(elem);\n  var old = getOffset(elem);\n  var originalStyle = {};\n  for (var key2 in offset2) {\n    if (offset2.hasOwnProperty(key2)) {\n      var dir = getOffsetDirection(key2, option);\n      var preset = key2 === \"left\" ? presetH : presetV;\n      var off = originalOffset[key2] - old[key2];\n      if (dir === key2) {\n        originalStyle[dir] = preset + off;\n      } else {\n        originalStyle[dir] = preset - off;\n      }\n    }\n  }\n  css(elem, originalStyle);\n  forceRelayout(elem);\n  if (\"left\" in offset2 || \"top\" in offset2) {\n    setTransitionProperty(elem, originalTransition);\n  }\n  var ret = {};\n  for (var _key in offset2) {\n    if (offset2.hasOwnProperty(_key)) {\n      var _dir = getOffsetDirection(_key, option);\n      var _off = offset2[_key] - originalOffset[_key];\n      if (_key === _dir) {\n        ret[_dir] = originalStyle[_dir] + _off;\n      } else {\n        ret[_dir] = originalStyle[_dir] - _off;\n      }\n    }\n  }\n  css(elem, ret);\n}\nfunction setTransform$1(elem, offset2) {\n  var originalOffset = getOffset(elem);\n  var originalXY = getTransformXY(elem);\n  var resultXY = {\n    x: originalXY.x,\n    y: originalXY.y\n  };\n  if (\"left\" in offset2) {\n    resultXY.x = originalXY.x + offset2.left - originalOffset.left;\n  }\n  if (\"top\" in offset2) {\n    resultXY.y = originalXY.y + offset2.top - originalOffset.top;\n  }\n  setTransformXY(elem, resultXY);\n}\nfunction setOffset(elem, offset2, option) {\n  if (option.ignoreShake) {\n    var oriOffset = getOffset(elem);\n    var oLeft = oriOffset.left.toFixed(0);\n    var oTop = oriOffset.top.toFixed(0);\n    var tLeft = offset2.left.toFixed(0);\n    var tTop = offset2.top.toFixed(0);\n    if (oLeft === tLeft && oTop === tTop) {\n      return;\n    }\n  }\n  if (option.useCssRight || option.useCssBottom) {\n    setLeftTop(elem, offset2, option);\n  } else if (option.useCssTransform && getTransformName() in document.body.style) {\n    setTransform$1(elem, offset2);\n  } else {\n    setLeftTop(elem, offset2, option);\n  }\n}\nfunction each(arr, fn) {\n  for (var i = 0; i < arr.length; i++) {\n    fn(arr[i]);\n  }\n}\nfunction isBorderBoxFn(elem) {\n  return getComputedStyleX(elem, \"boxSizing\") === \"border-box\";\n}\nvar BOX_MODELS = [\"margin\", \"border\", \"padding\"];\nvar CONTENT_INDEX = -1;\nvar PADDING_INDEX = 2;\nvar BORDER_INDEX = 1;\nvar MARGIN_INDEX = 0;\nfunction swap(elem, options, callback) {\n  var old = {};\n  var style2 = elem.style;\n  var name;\n  for (name in options) {\n    if (options.hasOwnProperty(name)) {\n      old[name] = style2[name];\n      style2[name] = options[name];\n    }\n  }\n  callback.call(elem);\n  for (name in options) {\n    if (options.hasOwnProperty(name)) {\n      style2[name] = old[name];\n    }\n  }\n}\nfunction getPBMWidth(elem, props, which) {\n  var value = 0;\n  var prop;\n  var j;\n  var i;\n  for (j = 0; j < props.length; j++) {\n    prop = props[j];\n    if (prop) {\n      for (i = 0; i < which.length; i++) {\n        var cssProp = void 0;\n        if (prop === \"border\") {\n          cssProp = \"\".concat(prop).concat(which[i], \"Width\");\n        } else {\n          cssProp = prop + which[i];\n        }\n        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;\n      }\n    }\n  }\n  return value;\n}\nvar domUtils = {\n  getParent: function getParent(element) {\n    var parent = element;\n    do {\n      if (parent.nodeType === 11 && parent.host) {\n        parent = parent.host;\n      } else {\n        parent = parent.parentNode;\n      }\n    } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);\n    return parent;\n  }\n};\neach([\"Width\", \"Height\"], function(name) {\n  domUtils[\"doc\".concat(name)] = function(refWin) {\n    var d2 = refWin.document;\n    return Math.max(d2.documentElement[\"scroll\".concat(name)], d2.body[\"scroll\".concat(name)], domUtils[\"viewport\".concat(name)](d2));\n  };\n  domUtils[\"viewport\".concat(name)] = function(win) {\n    var prop = \"client\".concat(name);\n    var doc = win.document;\n    var body = doc.body;\n    var documentElement = doc.documentElement;\n    var documentElementProp = documentElement[prop];\n    return doc.compatMode === \"CSS1Compat\" && documentElementProp || body && body[prop] || documentElementProp;\n  };\n});\nfunction getWH(elem, name, ex) {\n  var extra = ex;\n  if (isWindow(elem)) {\n    return name === \"width\" ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);\n  } else if (elem.nodeType === 9) {\n    return name === \"width\" ? domUtils.docWidth(elem) : domUtils.docHeight(elem);\n  }\n  var which = name === \"width\" ? [\"Left\", \"Right\"] : [\"Top\", \"Bottom\"];\n  var borderBoxValue = name === \"width\" ? elem.getBoundingClientRect().width : elem.getBoundingClientRect().height;\n  var isBorderBox = isBorderBoxFn(elem);\n  var cssBoxValue = 0;\n  if (borderBoxValue === null || borderBoxValue === void 0 || borderBoxValue <= 0) {\n    borderBoxValue = void 0;\n    cssBoxValue = getComputedStyleX(elem, name);\n    if (cssBoxValue === null || cssBoxValue === void 0 || Number(cssBoxValue) < 0) {\n      cssBoxValue = elem.style[name] || 0;\n    }\n    cssBoxValue = parseFloat(cssBoxValue) || 0;\n  }\n  if (extra === void 0) {\n    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;\n  }\n  var borderBoxValueOrIsBorderBox = borderBoxValue !== void 0 || isBorderBox;\n  var val = borderBoxValue || cssBoxValue;\n  if (extra === CONTENT_INDEX) {\n    if (borderBoxValueOrIsBorderBox) {\n      return val - getPBMWidth(elem, [\"border\", \"padding\"], which);\n    }\n    return cssBoxValue;\n  } else if (borderBoxValueOrIsBorderBox) {\n    if (extra === BORDER_INDEX) {\n      return val;\n    }\n    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, [\"border\"], which) : getPBMWidth(elem, [\"margin\"], which));\n  }\n  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);\n}\nvar cssShow = {\n  position: \"absolute\",\n  visibility: \"hidden\",\n  display: \"block\"\n};\nfunction getWHIgnoreDisplay() {\n  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  var val;\n  var elem = args[0];\n  if (elem.offsetWidth !== 0) {\n    val = getWH.apply(void 0, args);\n  } else {\n    swap(elem, cssShow, function() {\n      val = getWH.apply(void 0, args);\n    });\n  }\n  return val;\n}\neach([\"width\", \"height\"], function(name) {\n  var first = name.charAt(0).toUpperCase() + name.slice(1);\n  domUtils[\"outer\".concat(first)] = function(el, includeMargin) {\n    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);\n  };\n  var which = name === \"width\" ? [\"Left\", \"Right\"] : [\"Top\", \"Bottom\"];\n  domUtils[name] = function(elem, v2) {\n    var val = v2;\n    if (val !== void 0) {\n      if (elem) {\n        var isBorderBox = isBorderBoxFn(elem);\n        if (isBorderBox) {\n          val += getPBMWidth(elem, [\"padding\", \"border\"], which);\n        }\n        return css(elem, name, val);\n      }\n      return void 0;\n    }\n    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);\n  };\n});\nfunction mix(to, from) {\n  for (var i in from) {\n    if (from.hasOwnProperty(i)) {\n      to[i] = from[i];\n    }\n  }\n  return to;\n}\nvar utils = {\n  getWindow: function getWindow(node) {\n    if (node && node.document && node.setTimeout) {\n      return node;\n    }\n    var doc = node.ownerDocument || node;\n    return doc.defaultView || doc.parentWindow;\n  },\n  getDocument,\n  offset: function offset(el, value, option) {\n    if (typeof value !== \"undefined\") {\n      setOffset(el, value, option || {});\n    } else {\n      return getOffset(el);\n    }\n  },\n  isWindow,\n  each,\n  css,\n  clone: function clone(obj) {\n    var i;\n    var ret = {};\n    for (i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        ret[i] = obj[i];\n      }\n    }\n    var overflow = obj.overflow;\n    if (overflow) {\n      for (i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          ret.overflow[i] = obj.overflow[i];\n        }\n      }\n    }\n    return ret;\n  },\n  mix,\n  getWindowScrollLeft: function getWindowScrollLeft(w2) {\n    return getScrollLeft(w2);\n  },\n  getWindowScrollTop: function getWindowScrollTop(w2) {\n    return getScrollTop(w2);\n  },\n  merge: function merge() {\n    var ret = {};\n    for (var i = 0; i < arguments.length; i++) {\n      utils.mix(ret, i < 0 || arguments.length <= i ? void 0 : arguments[i]);\n    }\n    return ret;\n  },\n  viewportWidth: 0,\n  viewportHeight: 0\n};\nmix(utils, domUtils);\nvar getParent2 = utils.getParent;\nfunction getOffsetParent(element) {\n  if (utils.isWindow(element) || element.nodeType === 9) {\n    return null;\n  }\n  var doc = utils.getDocument(element);\n  var body = doc.body;\n  var parent;\n  var positionStyle = utils.css(element, \"position\");\n  var skipStatic = positionStyle === \"fixed\" || positionStyle === \"absolute\";\n  if (!skipStatic) {\n    return element.nodeName.toLowerCase() === \"html\" ? null : getParent2(element);\n  }\n  for (parent = getParent2(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent2(parent)) {\n    positionStyle = utils.css(parent, \"position\");\n    if (positionStyle !== \"static\") {\n      return parent;\n    }\n  }\n  return null;\n}\nvar getParent$1 = utils.getParent;\nfunction isAncestorFixed(element) {\n  if (utils.isWindow(element) || element.nodeType === 9) {\n    return false;\n  }\n  var doc = utils.getDocument(element);\n  var body = doc.body;\n  var parent = null;\n  for (parent = getParent$1(element); parent && parent !== body && parent !== doc; parent = getParent$1(parent)) {\n    var positionStyle = utils.css(parent, \"position\");\n    if (positionStyle === \"fixed\") {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getVisibleRectForElement(element, alwaysByViewport) {\n  var visibleRect = {\n    left: 0,\n    right: Infinity,\n    top: 0,\n    bottom: Infinity\n  };\n  var el = getOffsetParent(element);\n  var doc = utils.getDocument(element);\n  var win = doc.defaultView || doc.parentWindow;\n  var body = doc.body;\n  var documentElement = doc.documentElement;\n  while (el) {\n    if ((navigator.userAgent.indexOf(\"MSIE\") === -1 || el.clientWidth !== 0) && el !== body && el !== documentElement && utils.css(el, \"overflow\") !== \"visible\") {\n      var pos = utils.offset(el);\n      pos.left += el.clientLeft;\n      pos.top += el.clientTop;\n      visibleRect.top = Math.max(visibleRect.top, pos.top);\n      visibleRect.right = Math.min(visibleRect.right, pos.left + el.clientWidth);\n      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);\n      visibleRect.left = Math.max(visibleRect.left, pos.left);\n    } else if (el === body || el === documentElement) {\n      break;\n    }\n    el = getOffsetParent(el);\n  }\n  var originalPosition = null;\n  if (!utils.isWindow(element) && element.nodeType !== 9) {\n    originalPosition = element.style.position;\n    var position = utils.css(element, \"position\");\n    if (position === \"absolute\") {\n      element.style.position = \"fixed\";\n    }\n  }\n  var scrollX = utils.getWindowScrollLeft(win);\n  var scrollY = utils.getWindowScrollTop(win);\n  var viewportWidth = utils.viewportWidth(win);\n  var viewportHeight = utils.viewportHeight(win);\n  var documentWidth = documentElement.scrollWidth;\n  var documentHeight = documentElement.scrollHeight;\n  var bodyStyle = window.getComputedStyle(body);\n  if (bodyStyle.overflowX === \"hidden\") {\n    documentWidth = win.innerWidth;\n  }\n  if (bodyStyle.overflowY === \"hidden\") {\n    documentHeight = win.innerHeight;\n  }\n  if (element.style) {\n    element.style.position = originalPosition;\n  }\n  if (alwaysByViewport || isAncestorFixed(element)) {\n    visibleRect.left = Math.max(visibleRect.left, scrollX);\n    visibleRect.top = Math.max(visibleRect.top, scrollY);\n    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);\n    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);\n  } else {\n    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);\n    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);\n    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);\n    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);\n  }\n  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;\n}\nfunction adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {\n  var pos = utils.clone(elFuturePos);\n  var size = {\n    width: elRegion.width,\n    height: elRegion.height\n  };\n  if (overflow.adjustX && pos.left < visibleRect.left) {\n    pos.left = visibleRect.left;\n  }\n  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {\n    size.width -= pos.left + size.width - visibleRect.right;\n  }\n  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {\n    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);\n  }\n  if (overflow.adjustY && pos.top < visibleRect.top) {\n    pos.top = visibleRect.top;\n  }\n  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {\n    size.height -= pos.top + size.height - visibleRect.bottom;\n  }\n  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {\n    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);\n  }\n  return utils.mix(pos, size);\n}\nfunction getRegion(node) {\n  var offset2;\n  var w2;\n  var h;\n  if (!utils.isWindow(node) && node.nodeType !== 9) {\n    offset2 = utils.offset(node);\n    w2 = utils.outerWidth(node);\n    h = utils.outerHeight(node);\n  } else {\n    var win = utils.getWindow(node);\n    offset2 = {\n      left: utils.getWindowScrollLeft(win),\n      top: utils.getWindowScrollTop(win)\n    };\n    w2 = utils.viewportWidth(win);\n    h = utils.viewportHeight(win);\n  }\n  offset2.width = w2;\n  offset2.height = h;\n  return offset2;\n}\nfunction getAlignOffset(region, align) {\n  var V = align.charAt(0);\n  var H = align.charAt(1);\n  var w2 = region.width;\n  var h = region.height;\n  var x2 = region.left;\n  var y2 = region.top;\n  if (V === \"c\") {\n    y2 += h / 2;\n  } else if (V === \"b\") {\n    y2 += h;\n  }\n  if (H === \"c\") {\n    x2 += w2 / 2;\n  } else if (H === \"r\") {\n    x2 += w2;\n  }\n  return {\n    left: x2,\n    top: y2\n  };\n}\nfunction getElFuturePos(elRegion, refNodeRegion, points, offset2, targetOffset2) {\n  var p1 = getAlignOffset(refNodeRegion, points[1]);\n  var p2 = getAlignOffset(elRegion, points[0]);\n  var diff = [p2.left - p1.left, p2.top - p1.top];\n  return {\n    left: Math.round(elRegion.left - diff[0] + offset2[0] - targetOffset2[0]),\n    top: Math.round(elRegion.top - diff[1] + offset2[1] - targetOffset2[1])\n  };\n}\nfunction isFailX(elFuturePos, elRegion, visibleRect) {\n  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;\n}\nfunction isFailY(elFuturePos, elRegion, visibleRect) {\n  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;\n}\nfunction isCompleteFailX(elFuturePos, elRegion, visibleRect) {\n  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;\n}\nfunction isCompleteFailY(elFuturePos, elRegion, visibleRect) {\n  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;\n}\nfunction flip(points, reg, map) {\n  var ret = [];\n  utils.each(points, function(p2) {\n    ret.push(p2.replace(reg, function(m2) {\n      return map[m2];\n    }));\n  });\n  return ret;\n}\nfunction flipOffset(offset2, index2) {\n  offset2[index2] = -offset2[index2];\n  return offset2;\n}\nfunction convertOffset(str, offsetLen) {\n  var n2;\n  if (/%$/.test(str)) {\n    n2 = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;\n  } else {\n    n2 = parseInt(str, 10);\n  }\n  return n2 || 0;\n}\nfunction normalizeOffset(offset2, el) {\n  offset2[0] = convertOffset(offset2[0], el.width);\n  offset2[1] = convertOffset(offset2[1], el.height);\n}\nfunction doAlign(el, tgtRegion, align, isTgtRegionVisible) {\n  var points = align.points;\n  var offset2 = align.offset || [0, 0];\n  var targetOffset2 = align.targetOffset || [0, 0];\n  var overflow = align.overflow;\n  var source = align.source || el;\n  offset2 = [].concat(offset2);\n  targetOffset2 = [].concat(targetOffset2);\n  overflow = overflow || {};\n  var newOverflowCfg = {};\n  var fail = 0;\n  var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);\n  var visibleRect = getVisibleRectForElement(source, alwaysByViewport);\n  var elRegion = getRegion(source);\n  normalizeOffset(offset2, elRegion);\n  normalizeOffset(targetOffset2, tgtRegion);\n  var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset2, targetOffset2);\n  var newElRegion = utils.merge(elRegion, elFuturePos);\n  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {\n    if (overflow.adjustX) {\n      if (isFailX(elFuturePos, elRegion, visibleRect)) {\n        var newPoints = flip(points, /[lr]/gi, {\n          l: \"r\",\n          r: \"l\"\n        });\n        var newOffset = flipOffset(offset2, 0);\n        var newTargetOffset = flipOffset(targetOffset2, 0);\n        var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);\n        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {\n          fail = 1;\n          points = newPoints;\n          offset2 = newOffset;\n          targetOffset2 = newTargetOffset;\n        }\n      }\n    }\n    if (overflow.adjustY) {\n      if (isFailY(elFuturePos, elRegion, visibleRect)) {\n        var _newPoints = flip(points, /[tb]/gi, {\n          t: \"b\",\n          b: \"t\"\n        });\n        var _newOffset = flipOffset(offset2, 1);\n        var _newTargetOffset = flipOffset(targetOffset2, 1);\n        var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);\n        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {\n          fail = 1;\n          points = _newPoints;\n          offset2 = _newOffset;\n          targetOffset2 = _newTargetOffset;\n        }\n      }\n    }\n    if (fail) {\n      elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset2, targetOffset2);\n      utils.mix(newElRegion, elFuturePos);\n    }\n    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);\n    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);\n    if (isStillFailX || isStillFailY) {\n      var _newPoints2 = points;\n      if (isStillFailX) {\n        _newPoints2 = flip(points, /[lr]/gi, {\n          l: \"r\",\n          r: \"l\"\n        });\n      }\n      if (isStillFailY) {\n        _newPoints2 = flip(points, /[tb]/gi, {\n          t: \"b\",\n          b: \"t\"\n        });\n      }\n      points = _newPoints2;\n      offset2 = align.offset || [0, 0];\n      targetOffset2 = align.targetOffset || [0, 0];\n    }\n    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;\n    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;\n    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {\n      newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);\n    }\n  }\n  if (newElRegion.width !== elRegion.width) {\n    utils.css(source, \"width\", utils.width(source) + newElRegion.width - elRegion.width);\n  }\n  if (newElRegion.height !== elRegion.height) {\n    utils.css(source, \"height\", utils.height(source) + newElRegion.height - elRegion.height);\n  }\n  utils.offset(source, {\n    left: newElRegion.left,\n    top: newElRegion.top\n  }, {\n    useCssRight: align.useCssRight,\n    useCssBottom: align.useCssBottom,\n    useCssTransform: align.useCssTransform,\n    ignoreShake: align.ignoreShake\n  });\n  return {\n    points,\n    offset: offset2,\n    targetOffset: targetOffset2,\n    overflow: newOverflowCfg\n  };\n}\nfunction isOutOfVisibleRect(target, alwaysByViewport) {\n  var visibleRect = getVisibleRectForElement(target, alwaysByViewport);\n  var targetRegion = getRegion(target);\n  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;\n}\nfunction alignElement(el, refNode, align) {\n  var target = align.target || refNode;\n  var refNodeRegion = getRegion(target);\n  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);\n  return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);\n}\nalignElement.__getOffsetParent = getOffsetParent;\nalignElement.__getVisibleRectForElement = getVisibleRectForElement;\nfunction alignPoint(el, tgtPoint, align) {\n  var pageX;\n  var pageY;\n  var doc = utils.getDocument(el);\n  var win = doc.defaultView || doc.parentWindow;\n  var scrollX = utils.getWindowScrollLeft(win);\n  var scrollY = utils.getWindowScrollTop(win);\n  var viewportWidth = utils.viewportWidth(win);\n  var viewportHeight = utils.viewportHeight(win);\n  if (\"pageX\" in tgtPoint) {\n    pageX = tgtPoint.pageX;\n  } else {\n    pageX = scrollX + tgtPoint.clientX;\n  }\n  if (\"pageY\" in tgtPoint) {\n    pageY = tgtPoint.pageY;\n  } else {\n    pageY = scrollY + tgtPoint.clientY;\n  }\n  var tgtRegion = {\n    left: pageX,\n    top: pageY,\n    width: 0,\n    height: 0\n  };\n  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;\n  var points = [align.points[0], \"cc\"];\n  return doAlign(el, tgtRegion, _objectSpread2(_objectSpread2({}, align), {}, {\n    points\n  }), pointInView);\n}\nfunction listCacheClear$1() {\n  this.__data__ = [];\n  this.size = 0;\n}\nvar _listCacheClear = listCacheClear$1;\nfunction eq$2(value, other) {\n  return value === other || value !== value && other !== other;\n}\nvar eq_1 = eq$2;\nvar eq$1 = eq_1;\nfunction assocIndexOf$4(array4, key2) {\n  var length = array4.length;\n  while (length--) {\n    if (eq$1(array4[length][0], key2)) {\n      return length;\n    }\n  }\n  return -1;\n}\nvar _assocIndexOf = assocIndexOf$4;\nvar assocIndexOf$3 = _assocIndexOf;\nvar arrayProto = Array.prototype;\nvar splice = arrayProto.splice;\nfunction listCacheDelete$1(key2) {\n  var data = this.__data__, index2 = assocIndexOf$3(data, key2);\n  if (index2 < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index2 == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index2, 1);\n  }\n  --this.size;\n  return true;\n}\nvar _listCacheDelete = listCacheDelete$1;\nvar assocIndexOf$2 = _assocIndexOf;\nfunction listCacheGet$1(key2) {\n  var data = this.__data__, index2 = assocIndexOf$2(data, key2);\n  return index2 < 0 ? void 0 : data[index2][1];\n}\nvar _listCacheGet = listCacheGet$1;\nvar assocIndexOf$1 = _assocIndexOf;\nfunction listCacheHas$1(key2) {\n  return assocIndexOf$1(this.__data__, key2) > -1;\n}\nvar _listCacheHas = listCacheHas$1;\nvar assocIndexOf = _assocIndexOf;\nfunction listCacheSet$1(key2, value) {\n  var data = this.__data__, index2 = assocIndexOf(data, key2);\n  if (index2 < 0) {\n    ++this.size;\n    data.push([key2, value]);\n  } else {\n    data[index2][1] = value;\n  }\n  return this;\n}\nvar _listCacheSet = listCacheSet$1;\nvar listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;\nfunction ListCache$4(entries) {\n  var index2 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index2 < length) {\n    var entry = entries[index2];\n    this.set(entry[0], entry[1]);\n  }\n}\nListCache$4.prototype.clear = listCacheClear;\nListCache$4.prototype[\"delete\"] = listCacheDelete;\nListCache$4.prototype.get = listCacheGet;\nListCache$4.prototype.has = listCacheHas;\nListCache$4.prototype.set = listCacheSet;\nvar _ListCache = ListCache$4;\nvar ListCache$3 = _ListCache;\nfunction stackClear$1() {\n  this.__data__ = new ListCache$3();\n  this.size = 0;\n}\nvar _stackClear = stackClear$1;\nfunction stackDelete$1(key2) {\n  var data = this.__data__, result = data[\"delete\"](key2);\n  this.size = data.size;\n  return result;\n}\nvar _stackDelete = stackDelete$1;\nfunction stackGet$1(key2) {\n  return this.__data__.get(key2);\n}\nvar _stackGet = stackGet$1;\nfunction stackHas$1(key2) {\n  return this.__data__.has(key2);\n}\nvar _stackHas = stackHas$1;\nvar freeGlobal$1 = typeof commonjsGlobal == \"object\" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\nvar _freeGlobal = freeGlobal$1;\nvar freeGlobal = _freeGlobal;\nvar freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\nvar root$8 = freeGlobal || freeSelf || Function(\"return this\")();\nvar _root = root$8;\nvar root$7 = _root;\nvar Symbol$4 = root$7.Symbol;\nvar _Symbol = Symbol$4;\nvar Symbol$3 = _Symbol;\nvar objectProto$b = Object.prototype;\nvar hasOwnProperty$9 = objectProto$b.hasOwnProperty;\nvar nativeObjectToString$1 = objectProto$b.toString;\nvar symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;\nfunction getRawTag$1(value) {\n  var isOwn = hasOwnProperty$9.call(value, symToStringTag$1), tag = value[symToStringTag$1];\n  try {\n    value[symToStringTag$1] = void 0;\n    var unmasked = true;\n  } catch (e2) {\n  }\n  var result = nativeObjectToString$1.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\nvar _getRawTag = getRawTag$1;\nvar objectProto$a = Object.prototype;\nvar nativeObjectToString = objectProto$a.toString;\nfunction objectToString$1(value) {\n  return nativeObjectToString.call(value);\n}\nvar _objectToString = objectToString$1;\nvar Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;\nvar nullTag = \"[object Null]\", undefinedTag = \"[object Undefined]\";\nvar symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;\nfunction baseGetTag$4(value) {\n  if (value == null) {\n    return value === void 0 ? undefinedTag : nullTag;\n  }\n  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\nvar _baseGetTag = baseGetTag$4;\nfunction isObject$2(value) {\n  var type4 = typeof value;\n  return value != null && (type4 == \"object\" || type4 == \"function\");\n}\nvar isObject_1 = isObject$2;\nvar baseGetTag$3 = _baseGetTag, isObject$1 = isObject_1;\nvar asyncTag = \"[object AsyncFunction]\", funcTag$1 = \"[object Function]\", genTag = \"[object GeneratorFunction]\", proxyTag = \"[object Proxy]\";\nfunction isFunction$2(value) {\n  if (!isObject$1(value)) {\n    return false;\n  }\n  var tag = baseGetTag$3(value);\n  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\nvar isFunction_1 = isFunction$2;\nvar root$6 = _root;\nvar coreJsData$1 = root$6[\"__core-js_shared__\"];\nvar _coreJsData = coreJsData$1;\nvar coreJsData = _coreJsData;\nvar maskSrcKey = function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \"\");\n  return uid ? \"Symbol(src)_1.\" + uid : \"\";\n}();\nfunction isMasked$1(func) {\n  return !!maskSrcKey && maskSrcKey in func;\n}\nvar _isMasked = isMasked$1;\nvar funcProto$1 = Function.prototype;\nvar funcToString$1 = funcProto$1.toString;\nfunction toSource$2(func) {\n  if (func != null) {\n    try {\n      return funcToString$1.call(func);\n    } catch (e2) {\n    }\n    try {\n      return func + \"\";\n    } catch (e2) {\n    }\n  }\n  return \"\";\n}\nvar _toSource = toSource$2;\nvar isFunction$1 = isFunction_1, isMasked = _isMasked, isObject = isObject_1, toSource$1 = _toSource;\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\nvar funcProto = Function.prototype, objectProto$9 = Object.prototype;\nvar funcToString = funcProto.toString;\nvar hasOwnProperty$8 = objectProto$9.hasOwnProperty;\nvar reIsNative = RegExp(\"^\" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\nfunction baseIsNative$1(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern4 = isFunction$1(value) ? reIsNative : reIsHostCtor;\n  return pattern4.test(toSource$1(value));\n}\nvar _baseIsNative = baseIsNative$1;\nfunction getValue$1(object4, key2) {\n  return object4 == null ? void 0 : object4[key2];\n}\nvar _getValue = getValue$1;\nvar baseIsNative = _baseIsNative, getValue = _getValue;\nfunction getNative$6(object4, key2) {\n  var value = getValue(object4, key2);\n  return baseIsNative(value) ? value : void 0;\n}\nvar _getNative = getNative$6;\nvar getNative$5 = _getNative, root$5 = _root;\nvar Map$4 = getNative$5(root$5, \"Map\");\nvar _Map = Map$4;\nvar getNative$4 = _getNative;\nvar nativeCreate$4 = getNative$4(Object, \"create\");\nvar _nativeCreate = nativeCreate$4;\nvar nativeCreate$3 = _nativeCreate;\nfunction hashClear$1() {\n  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};\n  this.size = 0;\n}\nvar _hashClear = hashClear$1;\nfunction hashDelete$1(key2) {\n  var result = this.has(key2) && delete this.__data__[key2];\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar _hashDelete = hashDelete$1;\nvar nativeCreate$2 = _nativeCreate;\nvar HASH_UNDEFINED$2 = \"__lodash_hash_undefined__\";\nvar objectProto$8 = Object.prototype;\nvar hasOwnProperty$7 = objectProto$8.hasOwnProperty;\nfunction hashGet$1(key2) {\n  var data = this.__data__;\n  if (nativeCreate$2) {\n    var result = data[key2];\n    return result === HASH_UNDEFINED$2 ? void 0 : result;\n  }\n  return hasOwnProperty$7.call(data, key2) ? data[key2] : void 0;\n}\nvar _hashGet = hashGet$1;\nvar nativeCreate$1 = _nativeCreate;\nvar objectProto$7 = Object.prototype;\nvar hasOwnProperty$6 = objectProto$7.hasOwnProperty;\nfunction hashHas$1(key2) {\n  var data = this.__data__;\n  return nativeCreate$1 ? data[key2] !== void 0 : hasOwnProperty$6.call(data, key2);\n}\nvar _hashHas = hashHas$1;\nvar nativeCreate = _nativeCreate;\nvar HASH_UNDEFINED$1 = \"__lodash_hash_undefined__\";\nfunction hashSet$1(key2, value) {\n  var data = this.__data__;\n  this.size += this.has(key2) ? 0 : 1;\n  data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;\n  return this;\n}\nvar _hashSet = hashSet$1;\nvar hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;\nfunction Hash$1(entries) {\n  var index2 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index2 < length) {\n    var entry = entries[index2];\n    this.set(entry[0], entry[1]);\n  }\n}\nHash$1.prototype.clear = hashClear;\nHash$1.prototype[\"delete\"] = hashDelete;\nHash$1.prototype.get = hashGet;\nHash$1.prototype.has = hashHas;\nHash$1.prototype.set = hashSet;\nvar _Hash = Hash$1;\nvar Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;\nfunction mapCacheClear$1() {\n  this.size = 0;\n  this.__data__ = {\n    \"hash\": new Hash(),\n    \"map\": new (Map$3 || ListCache$2)(),\n    \"string\": new Hash()\n  };\n}\nvar _mapCacheClear = mapCacheClear$1;\nfunction isKeyable$1(value) {\n  var type4 = typeof value;\n  return type4 == \"string\" || type4 == \"number\" || type4 == \"symbol\" || type4 == \"boolean\" ? value !== \"__proto__\" : value === null;\n}\nvar _isKeyable = isKeyable$1;\nvar isKeyable = _isKeyable;\nfunction getMapData$4(map, key2) {\n  var data = map.__data__;\n  return isKeyable(key2) ? data[typeof key2 == \"string\" ? \"string\" : \"hash\"] : data.map;\n}\nvar _getMapData = getMapData$4;\nvar getMapData$3 = _getMapData;\nfunction mapCacheDelete$1(key2) {\n  var result = getMapData$3(this, key2)[\"delete\"](key2);\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar _mapCacheDelete = mapCacheDelete$1;\nvar getMapData$2 = _getMapData;\nfunction mapCacheGet$1(key2) {\n  return getMapData$2(this, key2).get(key2);\n}\nvar _mapCacheGet = mapCacheGet$1;\nvar getMapData$1 = _getMapData;\nfunction mapCacheHas$1(key2) {\n  return getMapData$1(this, key2).has(key2);\n}\nvar _mapCacheHas = mapCacheHas$1;\nvar getMapData = _getMapData;\nfunction mapCacheSet$1(key2, value) {\n  var data = getMapData(this, key2), size = data.size;\n  data.set(key2, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\nvar _mapCacheSet = mapCacheSet$1;\nvar mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;\nfunction MapCache$2(entries) {\n  var index2 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index2 < length) {\n    var entry = entries[index2];\n    this.set(entry[0], entry[1]);\n  }\n}\nMapCache$2.prototype.clear = mapCacheClear;\nMapCache$2.prototype[\"delete\"] = mapCacheDelete;\nMapCache$2.prototype.get = mapCacheGet;\nMapCache$2.prototype.has = mapCacheHas;\nMapCache$2.prototype.set = mapCacheSet;\nvar _MapCache = MapCache$2;\nvar ListCache$1 = _ListCache, Map$2 = _Map, MapCache$1 = _MapCache;\nvar LARGE_ARRAY_SIZE = 200;\nfunction stackSet$1(key2, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache$1) {\n    var pairs = data.__data__;\n    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {\n      pairs.push([key2, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache$1(pairs);\n  }\n  data.set(key2, value);\n  this.size = data.size;\n  return this;\n}\nvar _stackSet = stackSet$1;\nvar ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;\nfunction Stack$1(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\nStack$1.prototype.clear = stackClear;\nStack$1.prototype[\"delete\"] = stackDelete;\nStack$1.prototype.get = stackGet;\nStack$1.prototype.has = stackHas;\nStack$1.prototype.set = stackSet;\nvar _Stack = Stack$1;\nvar HASH_UNDEFINED = \"__lodash_hash_undefined__\";\nfunction setCacheAdd$1(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\nvar _setCacheAdd = setCacheAdd$1;\nfunction setCacheHas$1(value) {\n  return this.__data__.has(value);\n}\nvar _setCacheHas = setCacheHas$1;\nvar MapCache = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;\nfunction SetCache$1(values) {\n  var index2 = -1, length = values == null ? 0 : values.length;\n  this.__data__ = new MapCache();\n  while (++index2 < length) {\n    this.add(values[index2]);\n  }\n}\nSetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;\nSetCache$1.prototype.has = setCacheHas;\nvar _SetCache = SetCache$1;\nfunction arraySome$1(array4, predicate) {\n  var index2 = -1, length = array4 == null ? 0 : array4.length;\n  while (++index2 < length) {\n    if (predicate(array4[index2], index2, array4)) {\n      return true;\n    }\n  }\n  return false;\n}\nvar _arraySome = arraySome$1;\nfunction cacheHas$1(cache, key2) {\n  return cache.has(key2);\n}\nvar _cacheHas = cacheHas$1;\nvar SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;\nvar COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;\nfunction equalArrays$2(array4, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array4.length, othLength = other.length;\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  var arrStacked = stack.get(array4);\n  var othStacked = stack.get(other);\n  if (arrStacked && othStacked) {\n    return arrStacked == other && othStacked == array4;\n  }\n  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;\n  stack.set(array4, other);\n  stack.set(other, array4);\n  while (++index2 < arrLength) {\n    var arrValue = array4[index2], othValue = other[index2];\n    if (customizer) {\n      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack) : customizer(arrValue, othValue, index2, array4, other, stack);\n    }\n    if (compared !== void 0) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    if (seen) {\n      if (!arraySome(other, function(othValue2, othIndex) {\n        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {\n          return seen.push(othIndex);\n        }\n      })) {\n        result = false;\n        break;\n      }\n    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n      result = false;\n      break;\n    }\n  }\n  stack[\"delete\"](array4);\n  stack[\"delete\"](other);\n  return result;\n}\nvar _equalArrays = equalArrays$2;\nvar root$4 = _root;\nvar Uint8Array$1 = root$4.Uint8Array;\nvar _Uint8Array = Uint8Array$1;\nfunction mapToArray$1(map) {\n  var index2 = -1, result = Array(map.size);\n  map.forEach(function(value, key2) {\n    result[++index2] = [key2, value];\n  });\n  return result;\n}\nvar _mapToArray = mapToArray$1;\nfunction setToArray$1(set2) {\n  var index2 = -1, result = Array(set2.size);\n  set2.forEach(function(value) {\n    result[++index2] = value;\n  });\n  return result;\n}\nvar _setToArray = setToArray$1;\nvar Symbol$1 = _Symbol, Uint8Array2 = _Uint8Array, eq = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;\nvar COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;\nvar boolTag$1 = \"[object Boolean]\", dateTag$1 = \"[object Date]\", errorTag$1 = \"[object Error]\", mapTag$2 = \"[object Map]\", numberTag$1 = \"[object Number]\", regexpTag$1 = \"[object RegExp]\", setTag$2 = \"[object Set]\", stringTag$1 = \"[object String]\", symbolTag = \"[object Symbol]\";\nvar arrayBufferTag$1 = \"[object ArrayBuffer]\", dataViewTag$2 = \"[object DataView]\";\nvar symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;\nfunction equalByTag$1(object4, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag$2:\n      if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {\n        return false;\n      }\n      object4 = object4.buffer;\n      other = other.buffer;\n    case arrayBufferTag$1:\n      if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object4), new Uint8Array2(other))) {\n        return false;\n      }\n      return true;\n    case boolTag$1:\n    case dateTag$1:\n    case numberTag$1:\n      return eq(+object4, +other);\n    case errorTag$1:\n      return object4.name == other.name && object4.message == other.message;\n    case regexpTag$1:\n    case stringTag$1:\n      return object4 == other + \"\";\n    case mapTag$2:\n      var convert = mapToArray;\n    case setTag$2:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;\n      convert || (convert = setToArray);\n      if (object4.size != other.size && !isPartial) {\n        return false;\n      }\n      var stacked = stack.get(object4);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n      stack.set(object4, other);\n      var result = equalArrays$1(convert(object4), convert(other), bitmask, customizer, equalFunc, stack);\n      stack[\"delete\"](object4);\n      return result;\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object4) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\nvar _equalByTag = equalByTag$1;\nfunction arrayPush$1(array4, values) {\n  var index2 = -1, length = values.length, offset2 = array4.length;\n  while (++index2 < length) {\n    array4[offset2 + index2] = values[index2];\n  }\n  return array4;\n}\nvar _arrayPush = arrayPush$1;\nvar isArray$3 = Array.isArray;\nvar isArray_1 = isArray$3;\nvar arrayPush = _arrayPush, isArray$2 = isArray_1;\nfunction baseGetAllKeys$1(object4, keysFunc, symbolsFunc) {\n  var result = keysFunc(object4);\n  return isArray$2(object4) ? result : arrayPush(result, symbolsFunc(object4));\n}\nvar _baseGetAllKeys = baseGetAllKeys$1;\nfunction arrayFilter$1(array4, predicate) {\n  var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result = [];\n  while (++index2 < length) {\n    var value = array4[index2];\n    if (predicate(value, index2, array4)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\nvar _arrayFilter = arrayFilter$1;\nfunction stubArray$1() {\n  return [];\n}\nvar stubArray_1 = stubArray$1;\nvar arrayFilter = _arrayFilter, stubArray = stubArray_1;\nvar objectProto$6 = Object.prototype;\nvar propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\nvar getSymbols$1 = !nativeGetSymbols ? stubArray : function(object4) {\n  if (object4 == null) {\n    return [];\n  }\n  object4 = Object(object4);\n  return arrayFilter(nativeGetSymbols(object4), function(symbol) {\n    return propertyIsEnumerable$1.call(object4, symbol);\n  });\n};\nvar _getSymbols = getSymbols$1;\nfunction baseTimes$1(n2, iteratee) {\n  var index2 = -1, result = Array(n2);\n  while (++index2 < n2) {\n    result[index2] = iteratee(index2);\n  }\n  return result;\n}\nvar _baseTimes = baseTimes$1;\nfunction isObjectLike$4(value) {\n  return value != null && typeof value == \"object\";\n}\nvar isObjectLike_1 = isObjectLike$4;\nvar baseGetTag$2 = _baseGetTag, isObjectLike$3 = isObjectLike_1;\nvar argsTag$2 = \"[object Arguments]\";\nfunction baseIsArguments$1(value) {\n  return isObjectLike$3(value) && baseGetTag$2(value) == argsTag$2;\n}\nvar _baseIsArguments = baseIsArguments$1;\nvar baseIsArguments = _baseIsArguments, isObjectLike$2 = isObjectLike_1;\nvar objectProto$5 = Object.prototype;\nvar hasOwnProperty$5 = objectProto$5.hasOwnProperty;\nvar propertyIsEnumerable = objectProto$5.propertyIsEnumerable;\nvar isArguments$1 = baseIsArguments(function() {\n  return arguments;\n}()) ? baseIsArguments : function(value) {\n  return isObjectLike$2(value) && hasOwnProperty$5.call(value, \"callee\") && !propertyIsEnumerable.call(value, \"callee\");\n};\nvar isArguments_1 = isArguments$1;\nvar isBuffer$2 = { exports: {} };\nfunction stubFalse() {\n  return false;\n}\nvar stubFalse_1 = stubFalse;\n(function(module, exports) {\n  var root2 = _root, stubFalse2 = stubFalse_1;\n  var freeExports = exports && !exports.nodeType && exports;\n  var freeModule = freeExports && true && module && !module.nodeType && module;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var Buffer2 = moduleExports ? root2.Buffer : void 0;\n  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;\n  var isBuffer2 = nativeIsBuffer || stubFalse2;\n  module.exports = isBuffer2;\n})(isBuffer$2, isBuffer$2.exports);\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\nfunction isIndex$1(value, length) {\n  var type4 = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER$1 : length;\n  return !!length && (type4 == \"number\" || type4 != \"symbol\" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);\n}\nvar _isIndex = isIndex$1;\nvar MAX_SAFE_INTEGER = 9007199254740991;\nfunction isLength$2(value) {\n  return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\nvar isLength_1 = isLength$2;\nvar baseGetTag$1 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$1 = isObjectLike_1;\nvar argsTag$1 = \"[object Arguments]\", arrayTag$1 = \"[object Array]\", boolTag = \"[object Boolean]\", dateTag = \"[object Date]\", errorTag = \"[object Error]\", funcTag = \"[object Function]\", mapTag$1 = \"[object Map]\", numberTag = \"[object Number]\", objectTag$2 = \"[object Object]\", regexpTag = \"[object RegExp]\", setTag$1 = \"[object Set]\", stringTag = \"[object String]\", weakMapTag$1 = \"[object WeakMap]\";\nvar arrayBufferTag = \"[object ArrayBuffer]\", dataViewTag$1 = \"[object DataView]\", float32Tag = \"[object Float32Array]\", float64Tag = \"[object Float64Array]\", int8Tag = \"[object Int8Array]\", int16Tag = \"[object Int16Array]\", int32Tag = \"[object Int32Array]\", uint8Tag = \"[object Uint8Array]\", uint8ClampedTag = \"[object Uint8ClampedArray]\", uint16Tag = \"[object Uint16Array]\", uint32Tag = \"[object Uint32Array]\";\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;\nfunction baseIsTypedArray$1(value) {\n  return isObjectLike$1(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];\n}\nvar _baseIsTypedArray = baseIsTypedArray$1;\nfunction baseUnary$1(func) {\n  return function(value) {\n    return func(value);\n  };\n}\nvar _baseUnary = baseUnary$1;\nvar _nodeUtil = { exports: {} };\n(function(module, exports) {\n  var freeGlobal2 = _freeGlobal;\n  var freeExports = exports && !exports.nodeType && exports;\n  var freeModule = freeExports && true && module && !module.nodeType && module;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var freeProcess = moduleExports && freeGlobal2.process;\n  var nodeUtil2 = function() {\n    try {\n      var types2 = freeModule && freeModule.require && freeModule.require(\"util\").types;\n      if (types2) {\n        return types2;\n      }\n      return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n    } catch (e2) {\n    }\n  }();\n  module.exports = nodeUtil2;\n})(_nodeUtil, _nodeUtil.exports);\nvar baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\nvar isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\nvar isTypedArray_1 = isTypedArray$2;\nvar baseTimes = _baseTimes, isArguments = isArguments_1, isArray$1 = isArray_1, isBuffer$1 = isBuffer$2.exports, isIndex = _isIndex, isTypedArray$1 = isTypedArray_1;\nvar objectProto$4 = Object.prototype;\nvar hasOwnProperty$4 = objectProto$4.hasOwnProperty;\nfunction arrayLikeKeys$1(value, inherited) {\n  var isArr = isArray$1(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;\n  for (var key2 in value) {\n    if ((inherited || hasOwnProperty$4.call(value, key2)) && !(skipIndexes && (key2 == \"length\" || isBuff && (key2 == \"offset\" || key2 == \"parent\") || isType && (key2 == \"buffer\" || key2 == \"byteLength\" || key2 == \"byteOffset\") || isIndex(key2, length)))) {\n      result.push(key2);\n    }\n  }\n  return result;\n}\nvar _arrayLikeKeys = arrayLikeKeys$1;\nvar objectProto$3 = Object.prototype;\nfunction isPrototype$1(value) {\n  var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto$3;\n  return value === proto;\n}\nvar _isPrototype = isPrototype$1;\nfunction overArg$1(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\nvar _overArg = overArg$1;\nvar overArg = _overArg;\nvar nativeKeys$1 = overArg(Object.keys, Object);\nvar _nativeKeys = nativeKeys$1;\nvar isPrototype = _isPrototype, nativeKeys = _nativeKeys;\nvar objectProto$2 = Object.prototype;\nvar hasOwnProperty$3 = objectProto$2.hasOwnProperty;\nfunction baseKeys$1(object4) {\n  if (!isPrototype(object4)) {\n    return nativeKeys(object4);\n  }\n  var result = [];\n  for (var key2 in Object(object4)) {\n    if (hasOwnProperty$3.call(object4, key2) && key2 != \"constructor\") {\n      result.push(key2);\n    }\n  }\n  return result;\n}\nvar _baseKeys = baseKeys$1;\nvar isFunction = isFunction_1, isLength = isLength_1;\nfunction isArrayLike$1(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\nvar isArrayLike_1 = isArrayLike$1;\nvar arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike = isArrayLike_1;\nfunction keys$1(object4) {\n  return isArrayLike(object4) ? arrayLikeKeys(object4) : baseKeys(object4);\n}\nvar keys_1 = keys$1;\nvar baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys = keys_1;\nfunction getAllKeys$1(object4) {\n  return baseGetAllKeys(object4, keys, getSymbols);\n}\nvar _getAllKeys = getAllKeys$1;\nvar getAllKeys = _getAllKeys;\nvar COMPARE_PARTIAL_FLAG$1 = 1;\nvar objectProto$1 = Object.prototype;\nvar hasOwnProperty$2 = objectProto$1.hasOwnProperty;\nfunction equalObjects$1(object4, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object4), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index2 = objLength;\n  while (index2--) {\n    var key2 = objProps[index2];\n    if (!(isPartial ? key2 in other : hasOwnProperty$2.call(other, key2))) {\n      return false;\n    }\n  }\n  var objStacked = stack.get(object4);\n  var othStacked = stack.get(other);\n  if (objStacked && othStacked) {\n    return objStacked == other && othStacked == object4;\n  }\n  var result = true;\n  stack.set(object4, other);\n  stack.set(other, object4);\n  var skipCtor = isPartial;\n  while (++index2 < objLength) {\n    key2 = objProps[index2];\n    var objValue = object4[key2], othValue = other[key2];\n    if (customizer) {\n      var compared = isPartial ? customizer(othValue, objValue, key2, other, object4, stack) : customizer(objValue, othValue, key2, object4, other, stack);\n    }\n    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key2 == \"constructor\");\n  }\n  if (result && !skipCtor) {\n    var objCtor = object4.constructor, othCtor = other.constructor;\n    if (objCtor != othCtor && (\"constructor\" in object4 && \"constructor\" in other) && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack[\"delete\"](object4);\n  stack[\"delete\"](other);\n  return result;\n}\nvar _equalObjects = equalObjects$1;\nvar getNative$3 = _getNative, root$3 = _root;\nvar DataView$1 = getNative$3(root$3, \"DataView\");\nvar _DataView = DataView$1;\nvar getNative$2 = _getNative, root$2 = _root;\nvar Promise$2 = getNative$2(root$2, \"Promise\");\nvar _Promise = Promise$2;\nvar getNative$1 = _getNative, root$1 = _root;\nvar Set$2 = getNative$1(root$1, \"Set\");\nvar _Set = Set$2;\nvar getNative = _getNative, root = _root;\nvar WeakMap$2 = getNative(root, \"WeakMap\");\nvar _WeakMap = WeakMap$2;\nvar DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag = _baseGetTag, toSource = _toSource;\nvar mapTag = \"[object Map]\", objectTag$1 = \"[object Object]\", promiseTag = \"[object Promise]\", setTag = \"[object Set]\", weakMapTag = \"[object WeakMap]\";\nvar dataViewTag = \"[object DataView]\";\nvar dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);\nvar getTag$1 = baseGetTag;\nif (DataView && getTag$1(new DataView(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag || WeakMap$1 && getTag$1(new WeakMap$1()) != weakMapTag) {\n  getTag$1 = function(value) {\n    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : \"\";\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString:\n          return dataViewTag;\n        case mapCtorString:\n          return mapTag;\n        case promiseCtorString:\n          return promiseTag;\n        case setCtorString:\n          return setTag;\n        case weakMapCtorString:\n          return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\nvar _getTag = getTag$1;\nvar Stack = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray = isArray_1, isBuffer = isBuffer$2.exports, isTypedArray = isTypedArray_1;\nvar COMPARE_PARTIAL_FLAG = 1;\nvar argsTag = \"[object Arguments]\", arrayTag = \"[object Array]\", objectTag = \"[object Object]\";\nvar objectProto = Object.prototype;\nvar hasOwnProperty$1 = objectProto.hasOwnProperty;\nfunction baseIsEqualDeep$1(object4, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object4), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object4), othTag = othIsArr ? arrayTag : getTag(other);\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;\n  if (isSameTag && isBuffer(object4)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack());\n    return objIsArr || isTypedArray(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object4, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, \"__wrapped__\");\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;\n      stack || (stack = new Stack());\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack());\n  return equalObjects(object4, other, bitmask, customizer, equalFunc, stack);\n}\nvar _baseIsEqualDeep = baseIsEqualDeep$1;\nvar baseIsEqualDeep = _baseIsEqualDeep, isObjectLike = isObjectLike_1;\nfunction baseIsEqual$1(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$1, stack);\n}\nvar _baseIsEqual = baseIsEqual$1;\nvar baseIsEqual = _baseIsEqual;\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\nvar isEqual_1 = isEqual;\nvar MapShim = function() {\n  if (typeof Map !== \"undefined\") {\n    return Map;\n  }\n  function getIndex(arr, key2) {\n    var result = -1;\n    arr.some(function(entry, index2) {\n      if (entry[0] === key2) {\n        result = index2;\n        return true;\n      }\n      return false;\n    });\n    return result;\n  }\n  return function() {\n    function class_1() {\n      this.__entries__ = [];\n    }\n    Object.defineProperty(class_1.prototype, \"size\", {\n      get: function() {\n        return this.__entries__.length;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    class_1.prototype.get = function(key2) {\n      var index2 = getIndex(this.__entries__, key2);\n      var entry = this.__entries__[index2];\n      return entry && entry[1];\n    };\n    class_1.prototype.set = function(key2, value) {\n      var index2 = getIndex(this.__entries__, key2);\n      if (~index2) {\n        this.__entries__[index2][1] = value;\n      } else {\n        this.__entries__.push([key2, value]);\n      }\n    };\n    class_1.prototype.delete = function(key2) {\n      var entries = this.__entries__;\n      var index2 = getIndex(entries, key2);\n      if (~index2) {\n        entries.splice(index2, 1);\n      }\n    };\n    class_1.prototype.has = function(key2) {\n      return !!~getIndex(this.__entries__, key2);\n    };\n    class_1.prototype.clear = function() {\n      this.__entries__.splice(0);\n    };\n    class_1.prototype.forEach = function(callback, ctx) {\n      if (ctx === void 0) {\n        ctx = null;\n      }\n      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\n        var entry = _a[_i];\n        callback.call(ctx, entry[1], entry[0]);\n      }\n    };\n    return class_1;\n  }();\n}();\nvar isBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\" && window.document === document;\nvar global$1 = function() {\n  if (typeof global !== \"undefined\" && global.Math === Math) {\n    return global;\n  }\n  if (typeof self !== \"undefined\" && self.Math === Math) {\n    return self;\n  }\n  if (typeof window !== \"undefined\" && window.Math === Math) {\n    return window;\n  }\n  return Function(\"return this\")();\n}();\nvar requestAnimationFrame$1 = function() {\n  if (typeof requestAnimationFrame === \"function\") {\n    return requestAnimationFrame.bind(global$1);\n  }\n  return function(callback) {\n    return setTimeout(function() {\n      return callback(Date.now());\n    }, 1e3 / 60);\n  };\n}();\nvar trailingTimeout = 2;\nfunction throttle(callback, delay) {\n  var leadingCall = false, trailingCall = false, lastCallTime = 0;\n  function resolvePending() {\n    if (leadingCall) {\n      leadingCall = false;\n      callback();\n    }\n    if (trailingCall) {\n      proxy();\n    }\n  }\n  function timeoutCallback() {\n    requestAnimationFrame$1(resolvePending);\n  }\n  function proxy() {\n    var timeStamp = Date.now();\n    if (leadingCall) {\n      if (timeStamp - lastCallTime < trailingTimeout) {\n        return;\n      }\n      trailingCall = true;\n    } else {\n      leadingCall = true;\n      trailingCall = false;\n      setTimeout(timeoutCallback, delay);\n    }\n    lastCallTime = timeStamp;\n  }\n  return proxy;\n}\nvar REFRESH_DELAY = 20;\nvar transitionKeys = [\"top\", \"right\", \"bottom\", \"left\", \"width\", \"height\", \"size\", \"weight\"];\nvar mutationObserverSupported = typeof MutationObserver !== \"undefined\";\nvar ResizeObserverController = function() {\n  function ResizeObserverController2() {\n    this.connected_ = false;\n    this.mutationEventsAdded_ = false;\n    this.mutationsObserver_ = null;\n    this.observers_ = [];\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n  }\n  ResizeObserverController2.prototype.addObserver = function(observer) {\n    if (!~this.observers_.indexOf(observer)) {\n      this.observers_.push(observer);\n    }\n    if (!this.connected_) {\n      this.connect_();\n    }\n  };\n  ResizeObserverController2.prototype.removeObserver = function(observer) {\n    var observers2 = this.observers_;\n    var index2 = observers2.indexOf(observer);\n    if (~index2) {\n      observers2.splice(index2, 1);\n    }\n    if (!observers2.length && this.connected_) {\n      this.disconnect_();\n    }\n  };\n  ResizeObserverController2.prototype.refresh = function() {\n    var changesDetected = this.updateObservers_();\n    if (changesDetected) {\n      this.refresh();\n    }\n  };\n  ResizeObserverController2.prototype.updateObservers_ = function() {\n    var activeObservers = this.observers_.filter(function(observer) {\n      return observer.gatherActive(), observer.hasActive();\n    });\n    activeObservers.forEach(function(observer) {\n      return observer.broadcastActive();\n    });\n    return activeObservers.length > 0;\n  };\n  ResizeObserverController2.prototype.connect_ = function() {\n    if (!isBrowser || this.connected_) {\n      return;\n    }\n    document.addEventListener(\"transitionend\", this.onTransitionEnd_);\n    window.addEventListener(\"resize\", this.refresh);\n    if (mutationObserverSupported) {\n      this.mutationsObserver_ = new MutationObserver(this.refresh);\n      this.mutationsObserver_.observe(document, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true\n      });\n    } else {\n      document.addEventListener(\"DOMSubtreeModified\", this.refresh);\n      this.mutationEventsAdded_ = true;\n    }\n    this.connected_ = true;\n  };\n  ResizeObserverController2.prototype.disconnect_ = function() {\n    if (!isBrowser || !this.connected_) {\n      return;\n    }\n    document.removeEventListener(\"transitionend\", this.onTransitionEnd_);\n    window.removeEventListener(\"resize\", this.refresh);\n    if (this.mutationsObserver_) {\n      this.mutationsObserver_.disconnect();\n    }\n    if (this.mutationEventsAdded_) {\n      document.removeEventListener(\"DOMSubtreeModified\", this.refresh);\n    }\n    this.mutationsObserver_ = null;\n    this.mutationEventsAdded_ = false;\n    this.connected_ = false;\n  };\n  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {\n    var _b = _a.propertyName, propertyName = _b === void 0 ? \"\" : _b;\n    var isReflowProperty = transitionKeys.some(function(key2) {\n      return !!~propertyName.indexOf(key2);\n    });\n    if (isReflowProperty) {\n      this.refresh();\n    }\n  };\n  ResizeObserverController2.getInstance = function() {\n    if (!this.instance_) {\n      this.instance_ = new ResizeObserverController2();\n    }\n    return this.instance_;\n  };\n  ResizeObserverController2.instance_ = null;\n  return ResizeObserverController2;\n}();\nvar defineConfigurable = function(target, props) {\n  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\n    var key2 = _a[_i];\n    Object.defineProperty(target, key2, {\n      value: props[key2],\n      enumerable: false,\n      writable: false,\n      configurable: true\n    });\n  }\n  return target;\n};\nvar getWindowOf = function(target) {\n  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\n  return ownerGlobal || global$1;\n};\nvar emptyRect = createRectInit(0, 0, 0, 0);\nfunction toFloat(value) {\n  return parseFloat(value) || 0;\n}\nfunction getBordersSize(styles2) {\n  var positions = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    positions[_i - 1] = arguments[_i];\n  }\n  return positions.reduce(function(size, position) {\n    var value = styles2[\"border-\" + position + \"-width\"];\n    return size + toFloat(value);\n  }, 0);\n}\nfunction getPaddings(styles2) {\n  var positions = [\"top\", \"right\", \"bottom\", \"left\"];\n  var paddings = {};\n  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\n    var position = positions_1[_i];\n    var value = styles2[\"padding-\" + position];\n    paddings[position] = toFloat(value);\n  }\n  return paddings;\n}\nfunction getSVGContentRect(target) {\n  var bbox = target.getBBox();\n  return createRectInit(0, 0, bbox.width, bbox.height);\n}\nfunction getHTMLElementContentRect(target) {\n  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\n  if (!clientWidth && !clientHeight) {\n    return emptyRect;\n  }\n  var styles2 = getWindowOf(target).getComputedStyle(target);\n  var paddings = getPaddings(styles2);\n  var horizPad = paddings.left + paddings.right;\n  var vertPad = paddings.top + paddings.bottom;\n  var width = toFloat(styles2.width), height = toFloat(styles2.height);\n  if (styles2.boxSizing === \"border-box\") {\n    if (Math.round(width + horizPad) !== clientWidth) {\n      width -= getBordersSize(styles2, \"left\", \"right\") + horizPad;\n    }\n    if (Math.round(height + vertPad) !== clientHeight) {\n      height -= getBordersSize(styles2, \"top\", \"bottom\") + vertPad;\n    }\n  }\n  if (!isDocumentElement(target)) {\n    var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n    var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n    if (Math.abs(vertScrollbar) !== 1) {\n      width -= vertScrollbar;\n    }\n    if (Math.abs(horizScrollbar) !== 1) {\n      height -= horizScrollbar;\n    }\n  }\n  return createRectInit(paddings.left, paddings.top, width, height);\n}\nvar isSVGGraphicsElement = function() {\n  if (typeof SVGGraphicsElement !== \"undefined\") {\n    return function(target) {\n      return target instanceof getWindowOf(target).SVGGraphicsElement;\n    };\n  }\n  return function(target) {\n    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === \"function\";\n  };\n}();\nfunction isDocumentElement(target) {\n  return target === getWindowOf(target).document.documentElement;\n}\nfunction getContentRect(target) {\n  if (!isBrowser) {\n    return emptyRect;\n  }\n  if (isSVGGraphicsElement(target)) {\n    return getSVGContentRect(target);\n  }\n  return getHTMLElementContentRect(target);\n}\nfunction createReadOnlyRect(_a) {\n  var x2 = _a.x, y2 = _a.y, width = _a.width, height = _a.height;\n  var Constr = typeof DOMRectReadOnly !== \"undefined\" ? DOMRectReadOnly : Object;\n  var rect = Object.create(Constr.prototype);\n  defineConfigurable(rect, {\n    x: x2,\n    y: y2,\n    width,\n    height,\n    top: y2,\n    right: x2 + width,\n    bottom: height + y2,\n    left: x2\n  });\n  return rect;\n}\nfunction createRectInit(x2, y2, width, height) {\n  return { x: x2, y: y2, width, height };\n}\nvar ResizeObservation = function() {\n  function ResizeObservation2(target) {\n    this.broadcastWidth = 0;\n    this.broadcastHeight = 0;\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\n    this.target = target;\n  }\n  ResizeObservation2.prototype.isActive = function() {\n    var rect = getContentRect(this.target);\n    this.contentRect_ = rect;\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n  };\n  ResizeObservation2.prototype.broadcastRect = function() {\n    var rect = this.contentRect_;\n    this.broadcastWidth = rect.width;\n    this.broadcastHeight = rect.height;\n    return rect;\n  };\n  return ResizeObservation2;\n}();\nvar ResizeObserverEntry = function() {\n  function ResizeObserverEntry2(target, rectInit) {\n    var contentRect = createReadOnlyRect(rectInit);\n    defineConfigurable(this, { target, contentRect });\n  }\n  return ResizeObserverEntry2;\n}();\nvar ResizeObserverSPI = function() {\n  function ResizeObserverSPI2(callback, controller, callbackCtx) {\n    this.activeObservations_ = [];\n    this.observations_ = new MapShim();\n    if (typeof callback !== \"function\") {\n      throw new TypeError(\"The callback provided as parameter 1 is not a function.\");\n    }\n    this.callback_ = callback;\n    this.controller_ = controller;\n    this.callbackCtx_ = callbackCtx;\n  }\n  ResizeObserverSPI2.prototype.observe = function(target) {\n    if (!arguments.length) {\n      throw new TypeError(\"1 argument required, but only 0 present.\");\n    }\n    if (typeof Element === \"undefined\" || !(Element instanceof Object)) {\n      return;\n    }\n    if (!(target instanceof getWindowOf(target).Element)) {\n      throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n    var observations = this.observations_;\n    if (observations.has(target)) {\n      return;\n    }\n    observations.set(target, new ResizeObservation(target));\n    this.controller_.addObserver(this);\n    this.controller_.refresh();\n  };\n  ResizeObserverSPI2.prototype.unobserve = function(target) {\n    if (!arguments.length) {\n      throw new TypeError(\"1 argument required, but only 0 present.\");\n    }\n    if (typeof Element === \"undefined\" || !(Element instanceof Object)) {\n      return;\n    }\n    if (!(target instanceof getWindowOf(target).Element)) {\n      throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n    var observations = this.observations_;\n    if (!observations.has(target)) {\n      return;\n    }\n    observations.delete(target);\n    if (!observations.size) {\n      this.controller_.removeObserver(this);\n    }\n  };\n  ResizeObserverSPI2.prototype.disconnect = function() {\n    this.clearActive();\n    this.observations_.clear();\n    this.controller_.removeObserver(this);\n  };\n  ResizeObserverSPI2.prototype.gatherActive = function() {\n    var _this = this;\n    this.clearActive();\n    this.observations_.forEach(function(observation) {\n      if (observation.isActive()) {\n        _this.activeObservations_.push(observation);\n      }\n    });\n  };\n  ResizeObserverSPI2.prototype.broadcastActive = function() {\n    if (!this.hasActive()) {\n      return;\n    }\n    var ctx = this.callbackCtx_;\n    var entries = this.activeObservations_.map(function(observation) {\n      return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n    });\n    this.callback_.call(ctx, entries, ctx);\n    this.clearActive();\n  };\n  ResizeObserverSPI2.prototype.clearActive = function() {\n    this.activeObservations_.splice(0);\n  };\n  ResizeObserverSPI2.prototype.hasActive = function() {\n    return this.activeObservations_.length > 0;\n  };\n  return ResizeObserverSPI2;\n}();\nvar observers = typeof WeakMap !== \"undefined\" ? /* @__PURE__ */ new WeakMap() : new MapShim();\nvar ResizeObserver$1 = function() {\n  function ResizeObserver2(callback) {\n    if (!(this instanceof ResizeObserver2)) {\n      throw new TypeError(\"Cannot call a class as a function.\");\n    }\n    if (!arguments.length) {\n      throw new TypeError(\"1 argument required, but only 0 present.\");\n    }\n    var controller = ResizeObserverController.getInstance();\n    var observer = new ResizeObserverSPI(callback, controller, this);\n    observers.set(this, observer);\n  }\n  return ResizeObserver2;\n}();\n[\n  \"observe\",\n  \"unobserve\",\n  \"disconnect\"\n].forEach(function(method4) {\n  ResizeObserver$1.prototype[method4] = function() {\n    var _a;\n    return (_a = observers.get(this))[method4].apply(_a, arguments);\n  };\n});\nvar index = function() {\n  if (typeof global$1.ResizeObserver !== \"undefined\") {\n    return global$1.ResizeObserver;\n  }\n  return ResizeObserver$1;\n}();\nfunction isSamePoint(prev, next) {\n  if (prev === next)\n    return true;\n  if (!prev || !next)\n    return false;\n  if (\"pageX\" in next && \"pageY\" in next) {\n    return prev.pageX === next.pageX && prev.pageY === next.pageY;\n  }\n  if (\"clientX\" in next && \"clientY\" in next) {\n    return prev.clientX === next.clientX && prev.clientY === next.clientY;\n  }\n  return false;\n}\nfunction restoreFocus(activeElement, container) {\n  if (activeElement !== document.activeElement && contains(container, activeElement) && typeof activeElement.focus === \"function\") {\n    activeElement.focus();\n  }\n}\nfunction monitorResize(element, callback) {\n  var prevWidth = null;\n  var prevHeight = null;\n  function onResize2(_ref) {\n    var _ref2 = _slicedToArray(_ref, 1), target = _ref2[0].target;\n    if (!document.documentElement.contains(target))\n      return;\n    var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;\n    var fixedWidth = Math.floor(width);\n    var fixedHeight = Math.floor(height);\n    if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {\n      Promise.resolve().then(function() {\n        callback({\n          width: fixedWidth,\n          height: fixedHeight\n        });\n      });\n    }\n    prevWidth = fixedWidth;\n    prevHeight = fixedHeight;\n  }\n  var resizeObserver2 = new index(onResize2);\n  if (element) {\n    resizeObserver2.observe(element);\n  }\n  return function() {\n    resizeObserver2.disconnect();\n  };\n}\nvar useBuffer = function(callback, buffer) {\n  var calledRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(false);\n  var timeoutRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n  function cancelTrigger() {\n    window.clearTimeout(timeoutRef.current);\n  }\n  function trigger(force) {\n    if (!calledRef.current || force === true) {\n      if (callback() === false) {\n        return;\n      }\n      calledRef.current = true;\n      cancelTrigger();\n      timeoutRef.current = window.setTimeout(function() {\n        calledRef.current = false;\n      }, buffer);\n    } else {\n      cancelTrigger();\n      timeoutRef.current = window.setTimeout(function() {\n        calledRef.current = false;\n        trigger();\n      }, buffer);\n    }\n  }\n  return [trigger, function() {\n    calledRef.current = false;\n    cancelTrigger();\n  }];\n};\nfunction getElement(func) {\n  if (typeof func !== \"function\")\n    return null;\n  return func();\n}\nfunction getPoint(point) {\n  if (_typeof$1(point) !== \"object\" || !point)\n    return null;\n  return point;\n}\nvar Align = function Align2(_ref, ref) {\n  var children = _ref.children, disabled = _ref.disabled, target = _ref.target, align = _ref.align, onAlign = _ref.onAlign, monitorWindowResize = _ref.monitorWindowResize, _ref$monitorBufferTim = _ref.monitorBufferTime, monitorBufferTime = _ref$monitorBufferTim === void 0 ? 0 : _ref$monitorBufferTim;\n  var cacheRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef({});\n  var nodeRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n  var childNode = react__WEBPACK_IMPORTED_MODULE_0___default().Children.only(children);\n  var forceAlignPropsRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef({});\n  forceAlignPropsRef.current.disabled = disabled;\n  forceAlignPropsRef.current.target = target;\n  forceAlignPropsRef.current.align = align;\n  forceAlignPropsRef.current.onAlign = onAlign;\n  var _useBuffer = useBuffer(function() {\n    var _forceAlignPropsRef$c = forceAlignPropsRef.current, latestDisabled = _forceAlignPropsRef$c.disabled, latestTarget = _forceAlignPropsRef$c.target, latestAlign = _forceAlignPropsRef$c.align, latestOnAlign = _forceAlignPropsRef$c.onAlign;\n    if (!latestDisabled && latestTarget) {\n      var source = nodeRef.current;\n      var result;\n      var element = getElement(latestTarget);\n      var point = getPoint(latestTarget);\n      cacheRef.current.element = element;\n      cacheRef.current.point = point;\n      cacheRef.current.align = latestAlign;\n      var _document = document, activeElement = _document.activeElement;\n      if (element && isVisible(element)) {\n        result = alignElement(source, element, latestAlign);\n      } else if (point) {\n        result = alignPoint(source, point, latestAlign);\n      }\n      restoreFocus(activeElement, source);\n      if (latestOnAlign && result) {\n        latestOnAlign(source, result);\n      }\n      return true;\n    }\n    return false;\n  }, monitorBufferTime), _useBuffer2 = _slicedToArray(_useBuffer, 2), _forceAlign = _useBuffer2[0], cancelForceAlign = _useBuffer2[1];\n  var resizeMonitor = react__WEBPACK_IMPORTED_MODULE_0___default().useRef({\n    cancel: function cancel2() {\n    }\n  });\n  var sourceResizeMonitor = react__WEBPACK_IMPORTED_MODULE_0___default().useRef({\n    cancel: function cancel2() {\n    }\n  });\n  react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n    var element = getElement(target);\n    var point = getPoint(target);\n    if (nodeRef.current !== sourceResizeMonitor.current.element) {\n      sourceResizeMonitor.current.cancel();\n      sourceResizeMonitor.current.element = nodeRef.current;\n      sourceResizeMonitor.current.cancel = monitorResize(nodeRef.current, _forceAlign);\n    }\n    if (cacheRef.current.element !== element || !isSamePoint(cacheRef.current.point, point) || !isEqual_1(cacheRef.current.align, align)) {\n      _forceAlign();\n      if (resizeMonitor.current.element !== element) {\n        resizeMonitor.current.cancel();\n        resizeMonitor.current.element = element;\n        resizeMonitor.current.cancel = monitorResize(element, _forceAlign);\n      }\n    }\n  });\n  react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n    if (!disabled) {\n      _forceAlign();\n    } else {\n      cancelForceAlign();\n    }\n  }, [disabled]);\n  var winResizeRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n    if (monitorWindowResize) {\n      if (!winResizeRef.current) {\n        winResizeRef.current = addEventListenerWrap(window, \"resize\", _forceAlign);\n      }\n    } else if (winResizeRef.current) {\n      winResizeRef.current.remove();\n      winResizeRef.current = null;\n    }\n  }, [monitorWindowResize]);\n  react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n    return function() {\n      resizeMonitor.current.cancel();\n      sourceResizeMonitor.current.cancel();\n      if (winResizeRef.current)\n        winResizeRef.current.remove();\n      cancelForceAlign();\n    };\n  }, []);\n  react__WEBPACK_IMPORTED_MODULE_0___default().useImperativeHandle(ref, function() {\n    return {\n      forceAlign: function forceAlign() {\n        return _forceAlign(true);\n      }\n    };\n  });\n  if (/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().isValidElement(childNode)) {\n    childNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().cloneElement(childNode, {\n      ref: composeRef(childNode.ref, nodeRef)\n    });\n  }\n  return childNode;\n};\nvar RcAlign = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(Align);\nRcAlign.displayName = \"Align\";\nvar StatusQueue = [\"measure\", \"align\", null, \"motion\"];\nvar useVisibleStatus = function(visible, doMeasure) {\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), _useState2 = _slicedToArray(_useState, 2), status = _useState2[0], setInternalStatus = _useState2[1];\n  var rafRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  var destroyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  function setStatus(nextStatus) {\n    if (!destroyRef.current) {\n      setInternalStatus(nextStatus);\n    }\n  }\n  function cancelRaf() {\n    wrapperRaf$1.cancel(rafRef.current);\n  }\n  function goNextStatus(callback) {\n    cancelRaf();\n    rafRef.current = wrapperRaf$1(function() {\n      setStatus(function(prev) {\n        switch (status) {\n          case \"align\":\n            return \"motion\";\n          case \"motion\":\n            return \"stable\";\n        }\n        return prev;\n      });\n      callback === null || callback === void 0 ? void 0 : callback();\n    });\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    setStatus(\"measure\");\n  }, [visible]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    switch (status) {\n      case \"measure\":\n        doMeasure();\n        break;\n    }\n    if (status) {\n      rafRef.current = wrapperRaf$1(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee() {\n        var index2, nextStatus;\n        return regenerator.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                index2 = StatusQueue.indexOf(status);\n                nextStatus = StatusQueue[index2 + 1];\n                if (nextStatus && index2 !== -1) {\n                  setStatus(nextStatus);\n                }\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      })));\n    }\n  }, [status]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    return function() {\n      destroyRef.current = true;\n      cancelRaf();\n    };\n  }, []);\n  return [status, goNextStatus];\n};\nvar useStretchStyle = function(stretch) {\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    width: 0,\n    height: 0\n  }), _React$useState2 = _slicedToArray(_React$useState, 2), targetSize = _React$useState2[0], setTargetSize = _React$useState2[1];\n  function measureStretch(element) {\n    setTargetSize({\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    });\n  }\n  var style2 = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n    var sizeStyle = {};\n    if (stretch) {\n      var width = targetSize.width, height = targetSize.height;\n      if (stretch.indexOf(\"height\") !== -1 && height) {\n        sizeStyle.height = height;\n      } else if (stretch.indexOf(\"minHeight\") !== -1 && height) {\n        sizeStyle.minHeight = height;\n      }\n      if (stretch.indexOf(\"width\") !== -1 && width) {\n        sizeStyle.width = width;\n      } else if (stretch.indexOf(\"minWidth\") !== -1 && width) {\n        sizeStyle.minWidth = width;\n      }\n    }\n    return sizeStyle;\n  }, [stretch, targetSize]);\n  return [style2, measureStretch];\n};\nvar PopupInner = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(props, ref) {\n  var visible = props.visible, prefixCls = props.prefixCls, className = props.className, style2 = props.style, children = props.children, zIndex = props.zIndex, stretch = props.stretch, destroyPopupOnHide = props.destroyPopupOnHide, forceRender = props.forceRender, align = props.align, point = props.point, getRootDomNode = props.getRootDomNode, getClassNameFromAlign = props.getClassNameFromAlign, onAlign = props.onAlign, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onMouseDown = props.onMouseDown, onTouchStart = props.onTouchStart;\n  var alignRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  var elementRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), _useState2 = _slicedToArray(_useState, 2), alignedClassName = _useState2[0], setAlignedClassName = _useState2[1];\n  var _useStretchStyle = useStretchStyle(stretch), _useStretchStyle2 = _slicedToArray(_useStretchStyle, 2), stretchStyle = _useStretchStyle2[0], measureStretchStyle = _useStretchStyle2[1];\n  function doMeasure() {\n    if (stretch) {\n      measureStretchStyle(getRootDomNode());\n    }\n  }\n  var _useVisibleStatus = useVisibleStatus(visible, doMeasure), _useVisibleStatus2 = _slicedToArray(_useVisibleStatus, 2), status = _useVisibleStatus2[0], goNextStatus = _useVisibleStatus2[1];\n  var prepareResolveRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  function getAlignTarget() {\n    if (point) {\n      return point;\n    }\n    return getRootDomNode;\n  }\n  function forceAlign() {\n    var _alignRef$current;\n    (_alignRef$current = alignRef.current) === null || _alignRef$current === void 0 ? void 0 : _alignRef$current.forceAlign();\n  }\n  function onInternalAlign(popupDomNode, matchAlign) {\n    var nextAlignedClassName = getClassNameFromAlign(matchAlign);\n    if (alignedClassName !== nextAlignedClassName) {\n      setAlignedClassName(nextAlignedClassName);\n    }\n    if (status === \"align\") {\n      if (alignedClassName !== nextAlignedClassName) {\n        Promise.resolve().then(function() {\n          forceAlign();\n        });\n      } else {\n        goNextStatus(function() {\n          var _prepareResolveRef$cu;\n          (_prepareResolveRef$cu = prepareResolveRef.current) === null || _prepareResolveRef$cu === void 0 ? void 0 : _prepareResolveRef$cu.call(prepareResolveRef);\n        });\n      }\n      onAlign === null || onAlign === void 0 ? void 0 : onAlign(popupDomNode, matchAlign);\n    }\n  }\n  var motion = _objectSpread2$1({}, getMotion(props));\n  [\"onAppearEnd\", \"onEnterEnd\", \"onLeaveEnd\"].forEach(function(eventName) {\n    var originHandler = motion[eventName];\n    motion[eventName] = function(element, event) {\n      goNextStatus();\n      return originHandler === null || originHandler === void 0 ? void 0 : originHandler(element, event);\n    };\n  });\n  function onShowPrepare() {\n    return new Promise(function(resolve) {\n      prepareResolveRef.current = resolve;\n    });\n  }\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    if (!motion.motionName && status === \"motion\") {\n      goNextStatus();\n    }\n  }, [motion.motionName, status]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(ref, function() {\n    return {\n      forceAlign,\n      getElement: function getElement2() {\n        return elementRef.current;\n      }\n    };\n  });\n  var mergedStyle = _objectSpread2$1(_objectSpread2$1({}, stretchStyle), {}, {\n    zIndex,\n    opacity: status === \"motion\" || status === \"stable\" || !visible ? void 0 : 0,\n    pointerEvents: status === \"stable\" ? void 0 : \"none\"\n  }, style2);\n  var alignDisabled = true;\n  if ((align === null || align === void 0 ? void 0 : align.points) && (status === \"align\" || status === \"stable\")) {\n    alignDisabled = false;\n  }\n  var childNode = children;\n  if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children) > 1) {\n    childNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: \"\".concat(prefixCls, \"-content\")\n    }, children);\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CSSMotion, _extends$1({\n    visible,\n    ref: elementRef,\n    leavedClassName: \"\".concat(prefixCls, \"-hidden\")\n  }, motion, {\n    onAppearPrepare: onShowPrepare,\n    onEnterPrepare: onShowPrepare,\n    removeOnLeave: destroyPopupOnHide,\n    forceRender\n  }), function(_ref, motionRef) {\n    var motionClassName = _ref.className, motionStyle = _ref.style;\n    var mergedClassName = classNames(prefixCls, className, alignedClassName, motionClassName);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RcAlign, {\n      target: getAlignTarget(),\n      key: \"popup\",\n      ref: alignRef,\n      monitorWindowResize: true,\n      disabled: alignDisabled,\n      align,\n      onAlign: onInternalAlign\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      ref: motionRef,\n      className: mergedClassName,\n      onMouseEnter,\n      onMouseLeave,\n      onMouseDownCapture: onMouseDown,\n      onTouchStartCapture: onTouchStart,\n      style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), mergedStyle)\n    }, childNode));\n  });\n});\nPopupInner.displayName = \"PopupInner\";\nvar MobilePopupInner = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(props, ref) {\n  var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, children = props.children, _props$mobile = props.mobile;\n  _props$mobile = _props$mobile === void 0 ? {} : _props$mobile;\n  var popupClassName = _props$mobile.popupClassName, popupStyle = _props$mobile.popupStyle, _props$mobile$popupMo = _props$mobile.popupMotion, popupMotion = _props$mobile$popupMo === void 0 ? {} : _props$mobile$popupMo, popupRender = _props$mobile.popupRender;\n  var elementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(ref, function() {\n    return {\n      forceAlign: function forceAlign() {\n      },\n      getElement: function getElement2() {\n        return elementRef.current;\n      }\n    };\n  });\n  var mergedStyle = _objectSpread2$1({\n    zIndex\n  }, popupStyle);\n  var childNode = children;\n  if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children) > 1) {\n    childNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: \"\".concat(prefixCls, \"-content\")\n    }, children);\n  }\n  if (popupRender) {\n    childNode = popupRender(childNode);\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CSSMotion, _extends$1({\n    visible,\n    ref: elementRef,\n    removeOnLeave: true\n  }, popupMotion), function(_ref, motionRef) {\n    var motionClassName = _ref.className, motionStyle = _ref.style;\n    var mergedClassName = classNames(prefixCls, popupClassName, motionClassName);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      ref: motionRef,\n      className: mergedClassName,\n      style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), mergedStyle)\n    }, childNode);\n  });\n});\nMobilePopupInner.displayName = \"MobilePopupInner\";\nvar _excluded = [\"visible\", \"mobile\"];\nvar Popup = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(_ref, ref) {\n  var visible = _ref.visible, mobile = _ref.mobile, props = _objectWithoutProperties(_ref, _excluded);\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(visible), _useState2 = _slicedToArray(_useState, 2), innerVisible = _useState2[0], serInnerVisible = _useState2[1];\n  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false), _useState4 = _slicedToArray(_useState3, 2), inMobile = _useState4[0], setInMobile = _useState4[1];\n  var cloneProps = _objectSpread2$1(_objectSpread2$1({}, props), {}, {\n    visible: innerVisible\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    serInnerVisible(visible);\n    if (visible && mobile) {\n      setInMobile(isMobile());\n    }\n  }, [visible, mobile]);\n  var popupNode = inMobile ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MobilePopupInner, _extends$1({}, cloneProps, {\n    mobile,\n    ref\n  })) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PopupInner, _extends$1({}, cloneProps, {\n    ref\n  }));\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Mask, cloneProps), popupNode);\n});\nPopup.displayName = \"Popup\";\nvar TriggerContext = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction noop() {\n}\nfunction returnEmptyString() {\n  return \"\";\n}\nfunction returnDocument(element) {\n  if (element) {\n    return element.ownerDocument;\n  }\n  return window.document;\n}\nvar ALL_HANDLERS = [\"onClick\", \"onMouseDown\", \"onTouchStart\", \"onMouseEnter\", \"onMouseLeave\", \"onFocus\", \"onBlur\", \"onContextMenu\"];\nfunction generateTrigger(PortalComponent) {\n  var Trigger2 = /* @__PURE__ */ function(_React$Component) {\n    _inherits(Trigger3, _React$Component);\n    var _super = _createSuper(Trigger3);\n    function Trigger3(props) {\n      var _this;\n      _classCallCheck(this, Trigger3);\n      _this = _super.call(this, props);\n      _this.popupRef = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n      _this.triggerRef = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n      _this.attachId = void 0;\n      _this.clickOutsideHandler = void 0;\n      _this.touchOutsideHandler = void 0;\n      _this.contextMenuOutsideHandler1 = void 0;\n      _this.contextMenuOutsideHandler2 = void 0;\n      _this.mouseDownTimeout = void 0;\n      _this.focusTime = void 0;\n      _this.preClickTime = void 0;\n      _this.preTouchTime = void 0;\n      _this.delayTimer = void 0;\n      _this.hasPopupMouseDown = void 0;\n      _this.onMouseEnter = function(e2) {\n        var mouseEnterDelay = _this.props.mouseEnterDelay;\n        _this.fireEvents(\"onMouseEnter\", e2);\n        _this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e2);\n      };\n      _this.onMouseMove = function(e2) {\n        _this.fireEvents(\"onMouseMove\", e2);\n        _this.setPoint(e2);\n      };\n      _this.onMouseLeave = function(e2) {\n        _this.fireEvents(\"onMouseLeave\", e2);\n        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);\n      };\n      _this.onPopupMouseEnter = function() {\n        _this.clearDelayTimer();\n      };\n      _this.onPopupMouseLeave = function(e2) {\n        var _this$popupRef$curren;\n        if (e2.relatedTarget && !e2.relatedTarget.setTimeout && contains((_this$popupRef$curren = _this.popupRef.current) === null || _this$popupRef$curren === void 0 ? void 0 : _this$popupRef$curren.getElement(), e2.relatedTarget)) {\n          return;\n        }\n        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);\n      };\n      _this.onFocus = function(e2) {\n        _this.fireEvents(\"onFocus\", e2);\n        _this.clearDelayTimer();\n        if (_this.isFocusToShow()) {\n          _this.focusTime = Date.now();\n          _this.delaySetPopupVisible(true, _this.props.focusDelay);\n        }\n      };\n      _this.onMouseDown = function(e2) {\n        _this.fireEvents(\"onMouseDown\", e2);\n        _this.preClickTime = Date.now();\n      };\n      _this.onTouchStart = function(e2) {\n        _this.fireEvents(\"onTouchStart\", e2);\n        _this.preTouchTime = Date.now();\n      };\n      _this.onBlur = function(e2) {\n        _this.fireEvents(\"onBlur\", e2);\n        _this.clearDelayTimer();\n        if (_this.isBlurToHide()) {\n          _this.delaySetPopupVisible(false, _this.props.blurDelay);\n        }\n      };\n      _this.onContextMenu = function(e2) {\n        e2.preventDefault();\n        _this.fireEvents(\"onContextMenu\", e2);\n        _this.setPopupVisible(true, e2);\n      };\n      _this.onContextMenuClose = function() {\n        if (_this.isContextMenuToShow()) {\n          _this.close();\n        }\n      };\n      _this.onClick = function(event) {\n        _this.fireEvents(\"onClick\", event);\n        if (_this.focusTime) {\n          var preTime;\n          if (_this.preClickTime && _this.preTouchTime) {\n            preTime = Math.min(_this.preClickTime, _this.preTouchTime);\n          } else if (_this.preClickTime) {\n            preTime = _this.preClickTime;\n          } else if (_this.preTouchTime) {\n            preTime = _this.preTouchTime;\n          }\n          if (Math.abs(preTime - _this.focusTime) < 20) {\n            return;\n          }\n          _this.focusTime = 0;\n        }\n        _this.preClickTime = 0;\n        _this.preTouchTime = 0;\n        if (_this.isClickToShow() && (_this.isClickToHide() || _this.isBlurToHide()) && event && event.preventDefault) {\n          event.preventDefault();\n        }\n        var nextVisible = !_this.state.popupVisible;\n        if (_this.isClickToHide() && !nextVisible || nextVisible && _this.isClickToShow()) {\n          _this.setPopupVisible(!_this.state.popupVisible, event);\n        }\n      };\n      _this.onPopupMouseDown = function() {\n        _this.hasPopupMouseDown = true;\n        clearTimeout(_this.mouseDownTimeout);\n        _this.mouseDownTimeout = window.setTimeout(function() {\n          _this.hasPopupMouseDown = false;\n        }, 0);\n        if (_this.context) {\n          var _this$context;\n          (_this$context = _this.context).onPopupMouseDown.apply(_this$context, arguments);\n        }\n      };\n      _this.onDocumentClick = function(event) {\n        if (_this.props.mask && !_this.props.maskClosable) {\n          return;\n        }\n        var target = event.target;\n        var root2 = _this.getRootDomNode();\n        var popupNode = _this.getPopupDomNode();\n        if ((!contains(root2, target) || _this.isContextMenuOnly()) && !contains(popupNode, target) && !_this.hasPopupMouseDown) {\n          _this.close();\n        }\n      };\n      _this.getRootDomNode = function() {\n        var getTriggerDOMNode = _this.props.getTriggerDOMNode;\n        if (getTriggerDOMNode) {\n          return getTriggerDOMNode(_this.triggerRef.current);\n        }\n        try {\n          var domNode = findDOMNode(_this.triggerRef.current);\n          if (domNode) {\n            return domNode;\n          }\n        } catch (err) {\n        }\n        return react_dom__WEBPACK_IMPORTED_MODULE_1___default().findDOMNode(_assertThisInitialized(_this));\n      };\n      _this.getPopupClassNameFromAlign = function(align) {\n        var className = [];\n        var _this$props = _this.props, popupPlacement = _this$props.popupPlacement, builtinPlacements = _this$props.builtinPlacements, prefixCls = _this$props.prefixCls, alignPoint2 = _this$props.alignPoint, getPopupClassNameFromAlign = _this$props.getPopupClassNameFromAlign;\n        if (popupPlacement && builtinPlacements) {\n          className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint2));\n        }\n        if (getPopupClassNameFromAlign) {\n          className.push(getPopupClassNameFromAlign(align));\n        }\n        return className.join(\" \");\n      };\n      _this.getComponent = function() {\n        var _this$props2 = _this.props, prefixCls = _this$props2.prefixCls, destroyPopupOnHide = _this$props2.destroyPopupOnHide, popupClassName = _this$props2.popupClassName, onPopupAlign = _this$props2.onPopupAlign, popupMotion = _this$props2.popupMotion, popupAnimation = _this$props2.popupAnimation, popupTransitionName = _this$props2.popupTransitionName, popupStyle = _this$props2.popupStyle, mask = _this$props2.mask, maskAnimation = _this$props2.maskAnimation, maskTransitionName = _this$props2.maskTransitionName, maskMotion = _this$props2.maskMotion, zIndex = _this$props2.zIndex, popup = _this$props2.popup, stretch = _this$props2.stretch, alignPoint2 = _this$props2.alignPoint, mobile = _this$props2.mobile, forceRender = _this$props2.forceRender;\n        var _this$state = _this.state, popupVisible = _this$state.popupVisible, point = _this$state.point;\n        var align = _this.getPopupAlign();\n        var mouseProps = {};\n        if (_this.isMouseEnterToShow()) {\n          mouseProps.onMouseEnter = _this.onPopupMouseEnter;\n        }\n        if (_this.isMouseLeaveToHide()) {\n          mouseProps.onMouseLeave = _this.onPopupMouseLeave;\n        }\n        mouseProps.onMouseDown = _this.onPopupMouseDown;\n        mouseProps.onTouchStart = _this.onPopupMouseDown;\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Popup, _extends$1({\n          prefixCls,\n          destroyPopupOnHide,\n          visible: popupVisible,\n          point: alignPoint2 && point,\n          className: popupClassName,\n          align,\n          onAlign: onPopupAlign,\n          animation: popupAnimation,\n          getClassNameFromAlign: _this.getPopupClassNameFromAlign\n        }, mouseProps, {\n          stretch,\n          getRootDomNode: _this.getRootDomNode,\n          style: popupStyle,\n          mask,\n          zIndex,\n          transitionName: popupTransitionName,\n          maskAnimation,\n          maskTransitionName,\n          maskMotion,\n          ref: _this.popupRef,\n          motion: popupMotion,\n          mobile,\n          forceRender\n        }), typeof popup === \"function\" ? popup() : popup);\n      };\n      _this.attachParent = function(popupContainer) {\n        wrapperRaf$1.cancel(_this.attachId);\n        var _this$props3 = _this.props, getPopupContainer = _this$props3.getPopupContainer, getDocument2 = _this$props3.getDocument;\n        var domNode = _this.getRootDomNode();\n        var mountNode;\n        if (!getPopupContainer) {\n          mountNode = getDocument2(_this.getRootDomNode()).body;\n        } else if (domNode || getPopupContainer.length === 0) {\n          mountNode = getPopupContainer(domNode);\n        }\n        if (mountNode) {\n          mountNode.appendChild(popupContainer);\n        } else {\n          _this.attachId = wrapperRaf$1(function() {\n            _this.attachParent(popupContainer);\n          });\n        }\n      };\n      _this.getContainer = function() {\n        var getDocument2 = _this.props.getDocument;\n        var popupContainer = getDocument2(_this.getRootDomNode()).createElement(\"div\");\n        popupContainer.style.position = \"absolute\";\n        popupContainer.style.top = \"0\";\n        popupContainer.style.left = \"0\";\n        popupContainer.style.width = \"100%\";\n        _this.attachParent(popupContainer);\n        return popupContainer;\n      };\n      _this.setPoint = function(point) {\n        var alignPoint2 = _this.props.alignPoint;\n        if (!alignPoint2 || !point)\n          return;\n        _this.setState({\n          point: {\n            pageX: point.pageX,\n            pageY: point.pageY\n          }\n        });\n      };\n      _this.handlePortalUpdate = function() {\n        if (_this.state.prevPopupVisible !== _this.state.popupVisible) {\n          _this.props.afterPopupVisibleChange(_this.state.popupVisible);\n        }\n      };\n      _this.triggerContextValue = {\n        onPopupMouseDown: _this.onPopupMouseDown\n      };\n      var _popupVisible;\n      if (\"popupVisible\" in props) {\n        _popupVisible = !!props.popupVisible;\n      } else {\n        _popupVisible = !!props.defaultPopupVisible;\n      }\n      _this.state = {\n        prevPopupVisible: _popupVisible,\n        popupVisible: _popupVisible\n      };\n      ALL_HANDLERS.forEach(function(h) {\n        _this[\"fire\".concat(h)] = function(e2) {\n          _this.fireEvents(h, e2);\n        };\n      });\n      return _this;\n    }\n    _createClass(Trigger3, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        this.componentDidUpdate();\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate() {\n        var props = this.props;\n        var state = this.state;\n        if (state.popupVisible) {\n          var currentDocument;\n          if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextMenuToShow())) {\n            currentDocument = props.getDocument(this.getRootDomNode());\n            this.clickOutsideHandler = addEventListenerWrap(currentDocument, \"mousedown\", this.onDocumentClick);\n          }\n          if (!this.touchOutsideHandler) {\n            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());\n            this.touchOutsideHandler = addEventListenerWrap(currentDocument, \"touchstart\", this.onDocumentClick);\n          }\n          if (!this.contextMenuOutsideHandler1 && this.isContextMenuToShow()) {\n            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());\n            this.contextMenuOutsideHandler1 = addEventListenerWrap(currentDocument, \"scroll\", this.onContextMenuClose);\n          }\n          if (!this.contextMenuOutsideHandler2 && this.isContextMenuToShow()) {\n            this.contextMenuOutsideHandler2 = addEventListenerWrap(window, \"blur\", this.onContextMenuClose);\n          }\n          return;\n        }\n        this.clearOutsideHandler();\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this.clearDelayTimer();\n        this.clearOutsideHandler();\n        clearTimeout(this.mouseDownTimeout);\n        wrapperRaf$1.cancel(this.attachId);\n      }\n    }, {\n      key: \"getPopupDomNode\",\n      value: function getPopupDomNode() {\n        var _this$popupRef$curren2;\n        return ((_this$popupRef$curren2 = this.popupRef.current) === null || _this$popupRef$curren2 === void 0 ? void 0 : _this$popupRef$curren2.getElement()) || null;\n      }\n    }, {\n      key: \"getPopupAlign\",\n      value: function getPopupAlign() {\n        var props = this.props;\n        var popupPlacement = props.popupPlacement, popupAlign = props.popupAlign, builtinPlacements = props.builtinPlacements;\n        if (popupPlacement && builtinPlacements) {\n          return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);\n        }\n        return popupAlign;\n      }\n    }, {\n      key: \"setPopupVisible\",\n      value: function setPopupVisible(popupVisible, event) {\n        var alignPoint2 = this.props.alignPoint;\n        var prevPopupVisible = this.state.popupVisible;\n        this.clearDelayTimer();\n        if (prevPopupVisible !== popupVisible) {\n          if (!(\"popupVisible\" in this.props)) {\n            this.setState({\n              popupVisible,\n              prevPopupVisible\n            });\n          }\n          this.props.onPopupVisibleChange(popupVisible);\n        }\n        if (alignPoint2 && event && popupVisible) {\n          this.setPoint(event);\n        }\n      }\n    }, {\n      key: \"delaySetPopupVisible\",\n      value: function delaySetPopupVisible(visible, delayS, event) {\n        var _this2 = this;\n        var delay = delayS * 1e3;\n        this.clearDelayTimer();\n        if (delay) {\n          var point = event ? {\n            pageX: event.pageX,\n            pageY: event.pageY\n          } : null;\n          this.delayTimer = window.setTimeout(function() {\n            _this2.setPopupVisible(visible, point);\n            _this2.clearDelayTimer();\n          }, delay);\n        } else {\n          this.setPopupVisible(visible, event);\n        }\n      }\n    }, {\n      key: \"clearDelayTimer\",\n      value: function clearDelayTimer() {\n        if (this.delayTimer) {\n          clearTimeout(this.delayTimer);\n          this.delayTimer = null;\n        }\n      }\n    }, {\n      key: \"clearOutsideHandler\",\n      value: function clearOutsideHandler() {\n        if (this.clickOutsideHandler) {\n          this.clickOutsideHandler.remove();\n          this.clickOutsideHandler = null;\n        }\n        if (this.contextMenuOutsideHandler1) {\n          this.contextMenuOutsideHandler1.remove();\n          this.contextMenuOutsideHandler1 = null;\n        }\n        if (this.contextMenuOutsideHandler2) {\n          this.contextMenuOutsideHandler2.remove();\n          this.contextMenuOutsideHandler2 = null;\n        }\n        if (this.touchOutsideHandler) {\n          this.touchOutsideHandler.remove();\n          this.touchOutsideHandler = null;\n        }\n      }\n    }, {\n      key: \"createTwoChains\",\n      value: function createTwoChains(event) {\n        var childPros = this.props.children.props;\n        var props = this.props;\n        if (childPros[event] && props[event]) {\n          return this[\"fire\".concat(event)];\n        }\n        return childPros[event] || props[event];\n      }\n    }, {\n      key: \"isClickToShow\",\n      value: function isClickToShow() {\n        var _this$props4 = this.props, action = _this$props4.action, showAction = _this$props4.showAction;\n        return action.indexOf(\"click\") !== -1 || showAction.indexOf(\"click\") !== -1;\n      }\n    }, {\n      key: \"isContextMenuOnly\",\n      value: function isContextMenuOnly() {\n        var action = this.props.action;\n        return action === \"contextMenu\" || action.length === 1 && action[0] === \"contextMenu\";\n      }\n    }, {\n      key: \"isContextMenuToShow\",\n      value: function isContextMenuToShow() {\n        var _this$props5 = this.props, action = _this$props5.action, showAction = _this$props5.showAction;\n        return action.indexOf(\"contextMenu\") !== -1 || showAction.indexOf(\"contextMenu\") !== -1;\n      }\n    }, {\n      key: \"isClickToHide\",\n      value: function isClickToHide() {\n        var _this$props6 = this.props, action = _this$props6.action, hideAction = _this$props6.hideAction;\n        return action.indexOf(\"click\") !== -1 || hideAction.indexOf(\"click\") !== -1;\n      }\n    }, {\n      key: \"isMouseEnterToShow\",\n      value: function isMouseEnterToShow() {\n        var _this$props7 = this.props, action = _this$props7.action, showAction = _this$props7.showAction;\n        return action.indexOf(\"hover\") !== -1 || showAction.indexOf(\"mouseEnter\") !== -1;\n      }\n    }, {\n      key: \"isMouseLeaveToHide\",\n      value: function isMouseLeaveToHide() {\n        var _this$props8 = this.props, action = _this$props8.action, hideAction = _this$props8.hideAction;\n        return action.indexOf(\"hover\") !== -1 || hideAction.indexOf(\"mouseLeave\") !== -1;\n      }\n    }, {\n      key: \"isFocusToShow\",\n      value: function isFocusToShow() {\n        var _this$props9 = this.props, action = _this$props9.action, showAction = _this$props9.showAction;\n        return action.indexOf(\"focus\") !== -1 || showAction.indexOf(\"focus\") !== -1;\n      }\n    }, {\n      key: \"isBlurToHide\",\n      value: function isBlurToHide() {\n        var _this$props10 = this.props, action = _this$props10.action, hideAction = _this$props10.hideAction;\n        return action.indexOf(\"focus\") !== -1 || hideAction.indexOf(\"blur\") !== -1;\n      }\n    }, {\n      key: \"forcePopupAlign\",\n      value: function forcePopupAlign() {\n        if (this.state.popupVisible) {\n          var _this$popupRef$curren3;\n          (_this$popupRef$curren3 = this.popupRef.current) === null || _this$popupRef$curren3 === void 0 ? void 0 : _this$popupRef$curren3.forceAlign();\n        }\n      }\n    }, {\n      key: \"fireEvents\",\n      value: function fireEvents(type4, e2) {\n        var childCallback = this.props.children.props[type4];\n        if (childCallback) {\n          childCallback(e2);\n        }\n        var callback = this.props[type4];\n        if (callback) {\n          callback(e2);\n        }\n      }\n    }, {\n      key: \"close\",\n      value: function close2() {\n        this.setPopupVisible(false);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var popupVisible = this.state.popupVisible;\n        var _this$props11 = this.props, children = _this$props11.children, forceRender = _this$props11.forceRender, alignPoint2 = _this$props11.alignPoint, className = _this$props11.className, autoDestroy = _this$props11.autoDestroy;\n        var child = react__WEBPACK_IMPORTED_MODULE_0__.Children.only(children);\n        var newChildProps = {\n          key: \"trigger\"\n        };\n        if (this.isContextMenuToShow()) {\n          newChildProps.onContextMenu = this.onContextMenu;\n        } else {\n          newChildProps.onContextMenu = this.createTwoChains(\"onContextMenu\");\n        }\n        if (this.isClickToHide() || this.isClickToShow()) {\n          newChildProps.onClick = this.onClick;\n          newChildProps.onMouseDown = this.onMouseDown;\n          newChildProps.onTouchStart = this.onTouchStart;\n        } else {\n          newChildProps.onClick = this.createTwoChains(\"onClick\");\n          newChildProps.onMouseDown = this.createTwoChains(\"onMouseDown\");\n          newChildProps.onTouchStart = this.createTwoChains(\"onTouchStart\");\n        }\n        if (this.isMouseEnterToShow()) {\n          newChildProps.onMouseEnter = this.onMouseEnter;\n          if (alignPoint2) {\n            newChildProps.onMouseMove = this.onMouseMove;\n          }\n        } else {\n          newChildProps.onMouseEnter = this.createTwoChains(\"onMouseEnter\");\n        }\n        if (this.isMouseLeaveToHide()) {\n          newChildProps.onMouseLeave = this.onMouseLeave;\n        } else {\n          newChildProps.onMouseLeave = this.createTwoChains(\"onMouseLeave\");\n        }\n        if (this.isFocusToShow() || this.isBlurToHide()) {\n          newChildProps.onFocus = this.onFocus;\n          newChildProps.onBlur = this.onBlur;\n        } else {\n          newChildProps.onFocus = this.createTwoChains(\"onFocus\");\n          newChildProps.onBlur = this.createTwoChains(\"onBlur\");\n        }\n        var childrenClassName = classNames(child && child.props && child.props.className, className);\n        if (childrenClassName) {\n          newChildProps.className = childrenClassName;\n        }\n        var cloneProps = _objectSpread2$1({}, newChildProps);\n        if (supportRef(child)) {\n          cloneProps.ref = composeRef(this.triggerRef, child.ref);\n        }\n        var trigger = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, cloneProps);\n        var portal;\n        if (popupVisible || this.popupRef.current || forceRender) {\n          portal = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PortalComponent, {\n            key: \"portal\",\n            getContainer: this.getContainer,\n            didUpdate: this.handlePortalUpdate\n          }, this.getComponent());\n        }\n        if (!popupVisible && autoDestroy) {\n          portal = null;\n        }\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TriggerContext.Provider, {\n          value: this.triggerContextValue\n        }, trigger, portal);\n      }\n    }], [{\n      key: \"getDerivedStateFromProps\",\n      value: function getDerivedStateFromProps(_ref, prevState) {\n        var popupVisible = _ref.popupVisible;\n        var newState = {};\n        if (popupVisible !== void 0 && prevState.popupVisible !== popupVisible) {\n          newState.popupVisible = popupVisible;\n          newState.prevPopupVisible = prevState.popupVisible;\n        }\n        return newState;\n      }\n    }]);\n    return Trigger3;\n  }(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n  Trigger2.contextType = TriggerContext;\n  Trigger2.defaultProps = {\n    prefixCls: \"rc-trigger-popup\",\n    getPopupClassNameFromAlign: returnEmptyString,\n    getDocument: returnDocument,\n    onPopupVisibleChange: noop,\n    afterPopupVisibleChange: noop,\n    onPopupAlign: noop,\n    popupClassName: \"\",\n    mouseEnterDelay: 0,\n    mouseLeaveDelay: 0.1,\n    focusDelay: 0,\n    blurDelay: 0.15,\n    popupStyle: {},\n    destroyPopupOnHide: false,\n    popupAlign: {},\n    defaultPopupVisible: false,\n    mask: false,\n    maskClosable: true,\n    action: [],\n    showAction: [],\n    hideAction: [],\n    autoDestroy: false\n  };\n  return Trigger2;\n}\nvar Trigger = generateTrigger(Portal);\nvar autoAdjustOverflow = {\n  adjustX: 1,\n  adjustY: 1\n};\nvar targetOffset$1 = [0, 0];\nvar placements = {\n  left: {\n    points: [\"cr\", \"cl\"],\n    overflow: autoAdjustOverflow,\n    offset: [-4, 0],\n    targetOffset: targetOffset$1\n  },\n  right: {\n    points: [\"cl\", \"cr\"],\n    overflow: autoAdjustOverflow,\n    offset: [4, 0],\n    targetOffset: targetOffset$1\n  },\n  top: {\n    points: [\"bc\", \"tc\"],\n    overflow: autoAdjustOverflow,\n    offset: [0, -4],\n    targetOffset: targetOffset$1\n  },\n  bottom: {\n    points: [\"tc\", \"bc\"],\n    overflow: autoAdjustOverflow,\n    offset: [0, 4],\n    targetOffset: targetOffset$1\n  },\n  topLeft: {\n    points: [\"bl\", \"tl\"],\n    overflow: autoAdjustOverflow,\n    offset: [0, -4],\n    targetOffset: targetOffset$1\n  },\n  leftTop: {\n    points: [\"tr\", \"tl\"],\n    overflow: autoAdjustOverflow,\n    offset: [-4, 0],\n    targetOffset: targetOffset$1\n  },\n  topRight: {\n    points: [\"br\", \"tr\"],\n    overflow: autoAdjustOverflow,\n    offset: [0, -4],\n    targetOffset: targetOffset$1\n  },\n  rightTop: {\n    points: [\"tl\", \"tr\"],\n    overflow: autoAdjustOverflow,\n    offset: [4, 0],\n    targetOffset: targetOffset$1\n  },\n  bottomRight: {\n    points: [\"tr\", \"br\"],\n    overflow: autoAdjustOverflow,\n    offset: [0, 4],\n    targetOffset: targetOffset$1\n  },\n  rightBottom: {\n    points: [\"bl\", \"br\"],\n    overflow: autoAdjustOverflow,\n    offset: [4, 0],\n    targetOffset: targetOffset$1\n  },\n  bottomLeft: {\n    points: [\"tl\", \"bl\"],\n    overflow: autoAdjustOverflow,\n    offset: [0, 4],\n    targetOffset: targetOffset$1\n  },\n  leftBottom: {\n    points: [\"br\", \"bl\"],\n    overflow: autoAdjustOverflow,\n    offset: [-4, 0],\n    targetOffset: targetOffset$1\n  }\n};\nvar Content = function Content2(props) {\n  var overlay = props.overlay, prefixCls = props.prefixCls, id2 = props.id, overlayInnerStyle = props.overlayInnerStyle;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"\".concat(prefixCls, \"-inner\"),\n    id: id2,\n    role: \"tooltip\",\n    style: overlayInnerStyle\n  }, typeof overlay === \"function\" ? overlay() : overlay);\n};\nvar Tooltip$2 = function Tooltip(props, ref) {\n  var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? [\"hover\"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? \"rc-tooltip\" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName2 = props.transitionName, animation = props.animation, motion = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? \"right\" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle, restProps = _objectWithoutProperties(props, [\"overlayClassName\", \"trigger\", \"mouseEnterDelay\", \"mouseLeaveDelay\", \"overlayStyle\", \"prefixCls\", \"children\", \"onVisibleChange\", \"afterVisibleChange\", \"transitionName\", \"animation\", \"motion\", \"placement\", \"align\", \"destroyTooltipOnHide\", \"defaultVisible\", \"getTooltipContainer\", \"overlayInnerStyle\"]);\n  var domRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, function() {\n    return domRef.current;\n  });\n  var extraProps = _objectSpread2$1({}, restProps);\n  if (\"visible\" in props) {\n    extraProps.popupVisible = props.visible;\n  }\n  var getPopupElement = function getPopupElement2() {\n    var _props$arrowContent = props.arrowContent, arrowContent = _props$arrowContent === void 0 ? null : _props$arrowContent, overlay = props.overlay, id2 = props.id;\n    return [/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: \"\".concat(prefixCls, \"-arrow\"),\n      key: \"arrow\"\n    }, arrowContent), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Content, {\n      key: \"content\",\n      prefixCls,\n      id: id2,\n      overlay,\n      overlayInnerStyle\n    })];\n  };\n  var destroyTooltip = false;\n  var autoDestroy = false;\n  if (typeof destroyTooltipOnHide === \"boolean\") {\n    destroyTooltip = destroyTooltipOnHide;\n  } else if (destroyTooltipOnHide && _typeof$1(destroyTooltipOnHide) === \"object\") {\n    var keepParent = destroyTooltipOnHide.keepParent;\n    destroyTooltip = keepParent === true;\n    autoDestroy = keepParent === false;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Trigger, _extends$1({\n    popupClassName: overlayClassName,\n    prefixCls,\n    popup: getPopupElement,\n    action: trigger,\n    builtinPlacements: placements,\n    popupPlacement: placement,\n    ref: domRef,\n    popupAlign: align,\n    getPopupContainer: getTooltipContainer,\n    onPopupVisibleChange: onVisibleChange,\n    afterPopupVisibleChange: afterVisibleChange,\n    popupTransitionName: transitionName2,\n    popupAnimation: animation,\n    popupMotion: motion,\n    defaultPopupVisible: defaultVisible,\n    destroyPopupOnHide: destroyTooltip,\n    autoDestroy,\n    mouseLeaveDelay,\n    popupStyle: overlayStyle,\n    mouseEnterDelay\n  }, extraProps), children);\n};\nvar Tooltip$3 = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(Tooltip$2);\nfunction useControlledState(defaultStateValue, option) {\n  var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange = _ref.onChange, postState = _ref.postState;\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(function() {\n    if (value !== void 0) {\n      return value;\n    }\n    if (defaultValue !== void 0) {\n      return typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n    }\n    return typeof defaultStateValue === \"function\" ? defaultStateValue() : defaultStateValue;\n  }), _React$useState2 = _slicedToArray(_React$useState, 2), innerValue = _React$useState2[0], setInnerValue = _React$useState2[1];\n  var mergedValue = value !== void 0 ? value : innerValue;\n  if (postState) {\n    mergedValue = postState(mergedValue);\n  }\n  var onChangeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onChange);\n  onChangeRef.current = onChange;\n  var triggerChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(newValue) {\n    setInnerValue(newValue);\n    if (mergedValue !== newValue && onChangeRef.current) {\n      onChangeRef.current(newValue, mergedValue);\n    }\n  }, [mergedValue, onChangeRef]);\n  var firstRenderRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    if (firstRenderRef.current) {\n      firstRenderRef.current = false;\n      return;\n    }\n    if (value === void 0) {\n      setInnerValue(value);\n    }\n  }, [value]);\n  return [mergedValue, triggerChange];\n}\nvar autoAdjustOverflowEnabled = {\n  adjustX: 1,\n  adjustY: 1\n};\nvar autoAdjustOverflowDisabled = {\n  adjustX: 0,\n  adjustY: 0\n};\nvar targetOffset = [0, 0];\nfunction getOverflowOptions(autoAdjustOverflow2) {\n  if (typeof autoAdjustOverflow2 === \"boolean\") {\n    return autoAdjustOverflow2 ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;\n  }\n  return _extends$1(_extends$1({}, autoAdjustOverflowDisabled), autoAdjustOverflow2);\n}\nfunction getPlacements(config) {\n  var _config$arrowWidth = config.arrowWidth, arrowWidth = _config$arrowWidth === void 0 ? 4 : _config$arrowWidth, _config$horizontalArr = config.horizontalArrowShift, horizontalArrowShift = _config$horizontalArr === void 0 ? 16 : _config$horizontalArr, _config$verticalArrow = config.verticalArrowShift, verticalArrowShift = _config$verticalArrow === void 0 ? 8 : _config$verticalArrow, autoAdjustOverflow2 = config.autoAdjustOverflow;\n  var placementMap = {\n    left: {\n      points: [\"cr\", \"cl\"],\n      offset: [-4, 0]\n    },\n    right: {\n      points: [\"cl\", \"cr\"],\n      offset: [4, 0]\n    },\n    top: {\n      points: [\"bc\", \"tc\"],\n      offset: [0, -4]\n    },\n    bottom: {\n      points: [\"tc\", \"bc\"],\n      offset: [0, 4]\n    },\n    topLeft: {\n      points: [\"bl\", \"tc\"],\n      offset: [-(horizontalArrowShift + arrowWidth), -4]\n    },\n    leftTop: {\n      points: [\"tr\", \"cl\"],\n      offset: [-4, -(verticalArrowShift + arrowWidth)]\n    },\n    topRight: {\n      points: [\"br\", \"tc\"],\n      offset: [horizontalArrowShift + arrowWidth, -4]\n    },\n    rightTop: {\n      points: [\"tl\", \"cr\"],\n      offset: [4, -(verticalArrowShift + arrowWidth)]\n    },\n    bottomRight: {\n      points: [\"tr\", \"bc\"],\n      offset: [horizontalArrowShift + arrowWidth, 4]\n    },\n    rightBottom: {\n      points: [\"bl\", \"cr\"],\n      offset: [4, verticalArrowShift + arrowWidth]\n    },\n    bottomLeft: {\n      points: [\"tl\", \"bc\"],\n      offset: [-(horizontalArrowShift + arrowWidth), 4]\n    },\n    leftBottom: {\n      points: [\"br\", \"cl\"],\n      offset: [-4, verticalArrowShift + arrowWidth]\n    }\n  };\n  Object.keys(placementMap).forEach(function(key2) {\n    placementMap[key2] = config.arrowPointAtCenter ? _extends$1(_extends$1({}, placementMap[key2]), {\n      overflow: getOverflowOptions(autoAdjustOverflow2),\n      targetOffset\n    }) : _extends$1(_extends$1({}, placements[key2]), {\n      overflow: getOverflowOptions(autoAdjustOverflow2)\n    });\n    placementMap[key2].ignoreShake = true;\n  });\n  return placementMap;\n}\nvar getTransitionName = function getTransitionName2(rootPrefixCls, motion, transitionName2) {\n  if (transitionName2 !== void 0) {\n    return transitionName2;\n  }\n  return \"\".concat(rootPrefixCls, \"-\").concat(motion);\n};\nvar __rest$5 = globalThis && globalThis.__rest || function(s, e2) {\n  var t2 = {};\n  for (var p2 in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)\n      t2[p2] = s[p2];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {\n      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))\n        t2[p2[i]] = s[p2[i]];\n    }\n  return t2;\n};\nvar splitObject = function splitObject2(obj, keys2) {\n  var picked = {};\n  var omitted = _extends$1({}, obj);\n  keys2.forEach(function(key2) {\n    if (obj && key2 in obj) {\n      picked[key2] = obj[key2];\n      delete omitted[key2];\n    }\n  });\n  return {\n    picked,\n    omitted\n  };\n};\nvar PresetColorRegex = new RegExp(\"^(\".concat(PresetColorTypes.join(\"|\"), \")(-inverse)?$\"));\nfunction getDisabledCompatibleChildren(element, prefixCls) {\n  var elementType = element.type;\n  if ((elementType.__ANT_BUTTON === true || element.type === \"button\") && element.props.disabled || elementType.__ANT_SWITCH === true && (element.props.disabled || element.props.loading)) {\n    var _splitObject = splitObject(element.props.style, [\"position\", \"left\", \"right\", \"top\", \"bottom\", \"float\", \"display\", \"zIndex\"]), picked = _splitObject.picked, omitted = _splitObject.omitted;\n    var spanStyle = _extends$1(_extends$1({\n      display: \"inline-block\"\n    }, picked), {\n      cursor: \"not-allowed\",\n      width: element.props.block ? \"100%\" : null\n    });\n    var buttonStyle = _extends$1(_extends$1({}, omitted), {\n      pointerEvents: \"none\"\n    });\n    var child = cloneElement(element, {\n      style: buttonStyle,\n      className: null\n    });\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n      style: spanStyle,\n      className: classNames(element.props.className, \"\".concat(prefixCls, \"-disabled-compatible-wrapper\"))\n    }, child);\n  }\n  return element;\n}\nvar Tooltip2 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(props, ref) {\n  var _classNames2;\n  var _React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ConfigContext), getContextPopupContainer = _React$useContext.getPopupContainer, getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;\n  var _useMergedState = useControlledState(false, {\n    value: props.visible,\n    defaultValue: props.defaultVisible\n  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), visible = _useMergedState2[0], setVisible = _useMergedState2[1];\n  var isNoTitle = function isNoTitle2() {\n    var title = props.title, overlay = props.overlay;\n    return !title && !overlay && title !== 0;\n  };\n  var onVisibleChange = function onVisibleChange2(vis) {\n    var _a;\n    setVisible(isNoTitle() ? false : vis);\n    if (!isNoTitle()) {\n      (_a = props.onVisibleChange) === null || _a === void 0 ? void 0 : _a.call(props, vis);\n    }\n  };\n  var getTooltipPlacements = function getTooltipPlacements2() {\n    var builtinPlacements = props.builtinPlacements, arrowPointAtCenter = props.arrowPointAtCenter, autoAdjustOverflow2 = props.autoAdjustOverflow;\n    return builtinPlacements || getPlacements({\n      arrowPointAtCenter,\n      autoAdjustOverflow: autoAdjustOverflow2\n    });\n  };\n  var onPopupAlign = function onPopupAlign2(domNode, align) {\n    var placements2 = getTooltipPlacements();\n    var placement = Object.keys(placements2).filter(function(key2) {\n      return placements2[key2].points[0] === align.points[0] && placements2[key2].points[1] === align.points[1];\n    })[0];\n    if (!placement) {\n      return;\n    }\n    var rect = domNode.getBoundingClientRect();\n    var transformOrigin = {\n      top: \"50%\",\n      left: \"50%\"\n    };\n    if (placement.indexOf(\"top\") >= 0 || placement.indexOf(\"Bottom\") >= 0) {\n      transformOrigin.top = \"\".concat(rect.height - align.offset[1], \"px\");\n    } else if (placement.indexOf(\"Top\") >= 0 || placement.indexOf(\"bottom\") >= 0) {\n      transformOrigin.top = \"\".concat(-align.offset[1], \"px\");\n    }\n    if (placement.indexOf(\"left\") >= 0 || placement.indexOf(\"Right\") >= 0) {\n      transformOrigin.left = \"\".concat(rect.width - align.offset[0], \"px\");\n    } else if (placement.indexOf(\"right\") >= 0 || placement.indexOf(\"Left\") >= 0) {\n      transformOrigin.left = \"\".concat(-align.offset[0], \"px\");\n    }\n    domNode.style.transformOrigin = \"\".concat(transformOrigin.left, \" \").concat(transformOrigin.top);\n  };\n  var getOverlay = function getOverlay2() {\n    var title = props.title, overlay = props.overlay;\n    if (title === 0) {\n      return title;\n    }\n    return overlay || title || \"\";\n  };\n  var getPopupContainer = props.getPopupContainer, otherProps = __rest$5(props, [\"getPopupContainer\"]);\n  var customizePrefixCls = props.prefixCls, openClassName = props.openClassName, getTooltipContainer = props.getTooltipContainer, overlayClassName = props.overlayClassName, color = props.color, overlayInnerStyle = props.overlayInnerStyle, children = props.children;\n  var prefixCls = getPrefixCls(\"tooltip\", customizePrefixCls);\n  var rootPrefixCls = getPrefixCls();\n  var tempVisible = visible;\n  if (!(\"visible\" in props) && isNoTitle()) {\n    tempVisible = false;\n  }\n  var child = getDisabledCompatibleChildren(isValidElement(children) ? children : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, children), prefixCls);\n  var childProps = child.props;\n  var childCls = classNames(childProps.className, _defineProperty$1({}, openClassName || \"\".concat(prefixCls, \"-open\"), true));\n  var customOverlayClassName = classNames(overlayClassName, (_classNames2 = {}, _defineProperty$1(_classNames2, \"\".concat(prefixCls, \"-rtl\"), direction === \"rtl\"), _defineProperty$1(_classNames2, \"\".concat(prefixCls, \"-\").concat(color), color && PresetColorRegex.test(color)), _classNames2));\n  var formattedOverlayInnerStyle = overlayInnerStyle;\n  var arrowContentStyle;\n  if (color && !PresetColorRegex.test(color)) {\n    formattedOverlayInnerStyle = _extends$1(_extends$1({}, overlayInnerStyle), {\n      background: color\n    });\n    arrowContentStyle = {\n      background: color\n    };\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tooltip$3, _extends$1({}, otherProps, {\n    prefixCls,\n    overlayClassName: customOverlayClassName,\n    getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,\n    ref,\n    builtinPlacements: getTooltipPlacements(),\n    overlay: getOverlay(),\n    visible: tempVisible,\n    onVisibleChange,\n    onPopupAlign,\n    overlayInnerStyle: formattedOverlayInnerStyle,\n    arrowContent: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n      className: \"\".concat(prefixCls, \"-arrow-content\"),\n      style: arrowContentStyle\n    }),\n    motion: {\n      motionName: getTransitionName(rootPrefixCls, \"zoom-big-fast\", props.transitionName),\n      motionDeadline: 1e3\n    }\n  }), tempVisible ? cloneElement(child, {\n    className: childCls\n  }) : child);\n});\nTooltip2.displayName = \"Tooltip\";\nTooltip2.defaultProps = {\n  placement: \"top\",\n  mouseEnterDelay: 0.1,\n  mouseLeaveDelay: 0.1,\n  arrowPointAtCenter: false,\n  autoAdjustOverflow: true\n};\nvar Tooltip$1 = Tooltip2;\nfunction getInputClassName(prefixCls, bordered, size, disabled, direction) {\n  var _classNames;\n  return classNames(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-sm\"), size === \"small\"), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-lg\"), size === \"large\"), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-disabled\"), disabled), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-rtl\"), direction === \"rtl\"), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-borderless\"), !bordered), _classNames));\n}\nfunction hasPrefixSuffix(props) {\n  return !!(props.prefix || props.suffix || props.allowClear);\n}\nvar ClearableInputType = tuple(\"text\", \"input\");\nfunction hasAddon(props) {\n  return !!(props.addonBefore || props.addonAfter);\n}\nvar ClearableLabeledInput = /* @__PURE__ */ function(_React$Component) {\n  _inherits(ClearableLabeledInput2, _React$Component);\n  var _super = _createSuper(ClearableLabeledInput2);\n  function ClearableLabeledInput2() {\n    var _this;\n    _classCallCheck(this, ClearableLabeledInput2);\n    _this = _super.apply(this, arguments);\n    _this.containerRef = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n    _this.onInputMouseUp = function(e2) {\n      var _a;\n      if ((_a = _this.containerRef.current) === null || _a === void 0 ? void 0 : _a.contains(e2.target)) {\n        var triggerFocus2 = _this.props.triggerFocus;\n        triggerFocus2 === null || triggerFocus2 === void 0 ? void 0 : triggerFocus2();\n      }\n    };\n    return _this;\n  }\n  _createClass(ClearableLabeledInput2, [{\n    key: \"renderClearIcon\",\n    value: function renderClearIcon(prefixCls) {\n      var _classNames;\n      var _this$props = this.props, allowClear = _this$props.allowClear, value = _this$props.value, disabled = _this$props.disabled, readOnly = _this$props.readOnly, handleReset = _this$props.handleReset, suffix = _this$props.suffix;\n      if (!allowClear) {\n        return null;\n      }\n      var needClear = !disabled && !readOnly && value;\n      var className = \"\".concat(prefixCls, \"-clear-icon\");\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CloseCircleFilled$1, {\n        onClick: handleReset,\n        onMouseDown: function onMouseDown(e2) {\n          return e2.preventDefault();\n        },\n        className: classNames((_classNames = {}, _defineProperty$1(_classNames, \"\".concat(className, \"-hidden\"), !needClear), _defineProperty$1(_classNames, \"\".concat(className, \"-has-suffix\"), !!suffix), _classNames), className),\n        role: \"button\"\n      });\n    }\n  }, {\n    key: \"renderSuffix\",\n    value: function renderSuffix(prefixCls) {\n      var _this$props2 = this.props, suffix = _this$props2.suffix, allowClear = _this$props2.allowClear;\n      if (suffix || allowClear) {\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n          className: \"\".concat(prefixCls, \"-suffix\")\n        }, this.renderClearIcon(prefixCls), suffix);\n      }\n      return null;\n    }\n  }, {\n    key: \"renderLabeledIcon\",\n    value: function renderLabeledIcon(prefixCls, element) {\n      var _classNames2;\n      var _this$props3 = this.props, focused = _this$props3.focused, value = _this$props3.value, prefix = _this$props3.prefix, className = _this$props3.className, size = _this$props3.size, suffix = _this$props3.suffix, disabled = _this$props3.disabled, allowClear = _this$props3.allowClear, direction = _this$props3.direction, style2 = _this$props3.style, readOnly = _this$props3.readOnly, bordered = _this$props3.bordered, hidden = _this$props3.hidden;\n      if (!hasPrefixSuffix(this.props)) {\n        return cloneElement(element, {\n          value\n        });\n      }\n      var suffixNode = this.renderSuffix(prefixCls);\n      var prefixNode = prefix ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: \"\".concat(prefixCls, \"-prefix\")\n      }, prefix) : null;\n      var affixWrapperCls = classNames(\"\".concat(prefixCls, \"-affix-wrapper\"), (_classNames2 = {}, _defineProperty$1(_classNames2, \"\".concat(prefixCls, \"-affix-wrapper-focused\"), focused), _defineProperty$1(_classNames2, \"\".concat(prefixCls, \"-affix-wrapper-disabled\"), disabled), _defineProperty$1(_classNames2, \"\".concat(prefixCls, \"-affix-wrapper-sm\"), size === \"small\"), _defineProperty$1(_classNames2, \"\".concat(prefixCls, \"-affix-wrapper-lg\"), size === \"large\"), _defineProperty$1(_classNames2, \"\".concat(prefixCls, \"-affix-wrapper-input-with-clear-btn\"), suffix && allowClear && value), _defineProperty$1(_classNames2, \"\".concat(prefixCls, \"-affix-wrapper-rtl\"), direction === \"rtl\"), _defineProperty$1(_classNames2, \"\".concat(prefixCls, \"-affix-wrapper-readonly\"), readOnly), _defineProperty$1(_classNames2, \"\".concat(prefixCls, \"-affix-wrapper-borderless\"), !bordered), _defineProperty$1(_classNames2, \"\".concat(className), !hasAddon(this.props) && className), _classNames2));\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        ref: this.containerRef,\n        className: affixWrapperCls,\n        style: style2,\n        onMouseUp: this.onInputMouseUp,\n        hidden\n      }, prefixNode, cloneElement(element, {\n        style: null,\n        value,\n        className: getInputClassName(prefixCls, bordered, size, disabled)\n      }), suffixNode);\n    }\n  }, {\n    key: \"renderInputWithLabel\",\n    value: function renderInputWithLabel(prefixCls, labeledElement) {\n      var _classNames4;\n      var _this$props4 = this.props, addonBefore = _this$props4.addonBefore, addonAfter = _this$props4.addonAfter, style2 = _this$props4.style, size = _this$props4.size, className = _this$props4.className, direction = _this$props4.direction, hidden = _this$props4.hidden;\n      if (!hasAddon(this.props)) {\n        return labeledElement;\n      }\n      var wrapperClassName = \"\".concat(prefixCls, \"-group\");\n      var addonClassName = \"\".concat(wrapperClassName, \"-addon\");\n      var addonBeforeNode = addonBefore ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: addonClassName\n      }, addonBefore) : null;\n      var addonAfterNode = addonAfter ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: addonClassName\n      }, addonAfter) : null;\n      var mergedWrapperClassName = classNames(\"\".concat(prefixCls, \"-wrapper\"), wrapperClassName, _defineProperty$1({}, \"\".concat(wrapperClassName, \"-rtl\"), direction === \"rtl\"));\n      var mergedGroupClassName = classNames(\"\".concat(prefixCls, \"-group-wrapper\"), (_classNames4 = {}, _defineProperty$1(_classNames4, \"\".concat(prefixCls, \"-group-wrapper-sm\"), size === \"small\"), _defineProperty$1(_classNames4, \"\".concat(prefixCls, \"-group-wrapper-lg\"), size === \"large\"), _defineProperty$1(_classNames4, \"\".concat(prefixCls, \"-group-wrapper-rtl\"), direction === \"rtl\"), _classNames4), className);\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: mergedGroupClassName,\n        style: style2,\n        hidden\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: mergedWrapperClassName\n      }, addonBeforeNode, cloneElement(labeledElement, {\n        style: null\n      }), addonAfterNode));\n    }\n  }, {\n    key: \"renderTextAreaWithClearIcon\",\n    value: function renderTextAreaWithClearIcon(prefixCls, element) {\n      var _classNames5;\n      var _this$props5 = this.props, value = _this$props5.value, allowClear = _this$props5.allowClear, className = _this$props5.className, style2 = _this$props5.style, direction = _this$props5.direction, bordered = _this$props5.bordered, hidden = _this$props5.hidden;\n      if (!allowClear) {\n        return cloneElement(element, {\n          value\n        });\n      }\n      var affixWrapperCls = classNames(\"\".concat(prefixCls, \"-affix-wrapper\"), \"\".concat(prefixCls, \"-affix-wrapper-textarea-with-clear-btn\"), (_classNames5 = {}, _defineProperty$1(_classNames5, \"\".concat(prefixCls, \"-affix-wrapper-rtl\"), direction === \"rtl\"), _defineProperty$1(_classNames5, \"\".concat(prefixCls, \"-affix-wrapper-borderless\"), !bordered), _defineProperty$1(_classNames5, \"\".concat(className), !hasAddon(this.props) && className), _classNames5));\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: affixWrapperCls,\n        style: style2,\n        hidden\n      }, cloneElement(element, {\n        style: null,\n        value\n      }), this.renderClearIcon(prefixCls));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props6 = this.props, prefixCls = _this$props6.prefixCls, inputType = _this$props6.inputType, element = _this$props6.element;\n      if (inputType === ClearableInputType[0]) {\n        return this.renderTextAreaWithClearIcon(prefixCls, element);\n      }\n      return this.renderInputWithLabel(prefixCls, this.renderLabeledIcon(prefixCls, element));\n    }\n  }]);\n  return ClearableLabeledInput2;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nvar ClearableLabeledInput$1 = ClearableLabeledInput;\nfunction fixControlledValue(value) {\n  if (typeof value === \"undefined\" || value === null) {\n    return \"\";\n  }\n  return String(value);\n}\nfunction resolveOnChange(target, e2, onChange, targetValue) {\n  if (!onChange) {\n    return;\n  }\n  var event = e2;\n  if (e2.type === \"click\") {\n    var currentTarget = target.cloneNode(true);\n    event = Object.create(e2, {\n      target: {\n        value: currentTarget\n      },\n      currentTarget: {\n        value: currentTarget\n      }\n    });\n    currentTarget.value = \"\";\n    onChange(event);\n    return;\n  }\n  if (targetValue !== void 0) {\n    event = Object.create(e2, {\n      target: {\n        value: target\n      },\n      currentTarget: {\n        value: target\n      }\n    });\n    target.value = targetValue;\n    onChange(event);\n    return;\n  }\n  onChange(event);\n}\nfunction triggerFocus(element, option) {\n  if (!element)\n    return;\n  element.focus(option);\n  var _ref = option || {}, cursor = _ref.cursor;\n  if (cursor) {\n    var len = element.value.length;\n    switch (cursor) {\n      case \"start\":\n        element.setSelectionRange(0, 0);\n        break;\n      case \"end\":\n        element.setSelectionRange(len, len);\n        break;\n      default:\n        element.setSelectionRange(0, len);\n    }\n  }\n}\nvar Input = /* @__PURE__ */ function(_React$Component) {\n  _inherits(Input2, _React$Component);\n  var _super = _createSuper(Input2);\n  function Input2(props) {\n    var _this;\n    _classCallCheck(this, Input2);\n    _this = _super.call(this, props);\n    _this.direction = \"ltr\";\n    _this.focus = function(option) {\n      triggerFocus(_this.input, option);\n    };\n    _this.saveClearableInput = function(input2) {\n      _this.clearableInput = input2;\n    };\n    _this.saveInput = function(input2) {\n      _this.input = input2;\n    };\n    _this.onFocus = function(e2) {\n      var onFocus = _this.props.onFocus;\n      _this.setState({\n        focused: true\n      }, _this.clearPasswordValueAttribute);\n      onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);\n    };\n    _this.onBlur = function(e2) {\n      var onBlur = _this.props.onBlur;\n      _this.setState({\n        focused: false\n      }, _this.clearPasswordValueAttribute);\n      onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);\n    };\n    _this.handleReset = function(e2) {\n      _this.setValue(\"\", function() {\n        _this.focus();\n      });\n      resolveOnChange(_this.input, e2, _this.props.onChange);\n    };\n    _this.renderInput = function(prefixCls, size, bordered) {\n      var input2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n      var _this$props = _this.props, className = _this$props.className, addonBefore = _this$props.addonBefore, addonAfter = _this$props.addonAfter, customizeSize = _this$props.size, disabled = _this$props.disabled, htmlSize = _this$props.htmlSize;\n      var otherProps = omit(_this.props, [\n        \"prefixCls\",\n        \"onPressEnter\",\n        \"addonBefore\",\n        \"addonAfter\",\n        \"prefix\",\n        \"suffix\",\n        \"allowClear\",\n        \"defaultValue\",\n        \"size\",\n        \"inputType\",\n        \"bordered\",\n        \"htmlSize\",\n        \"showCount\"\n      ]);\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"input\", _extends$1({\n        autoComplete: input2.autoComplete\n      }, otherProps, {\n        onChange: _this.handleChange,\n        onFocus: _this.onFocus,\n        onBlur: _this.onBlur,\n        onKeyDown: _this.handleKeyDown,\n        className: classNames(getInputClassName(prefixCls, bordered, customizeSize || size, disabled, _this.direction), _defineProperty$1({}, className, className && !addonBefore && !addonAfter)),\n        ref: _this.saveInput,\n        size: htmlSize\n      }));\n    };\n    _this.clearPasswordValueAttribute = function() {\n      _this.removePasswordTimeout = setTimeout(function() {\n        if (_this.input && _this.input.getAttribute(\"type\") === \"password\" && _this.input.hasAttribute(\"value\")) {\n          _this.input.removeAttribute(\"value\");\n        }\n      });\n    };\n    _this.handleChange = function(e2) {\n      _this.setValue(e2.target.value, _this.clearPasswordValueAttribute);\n      resolveOnChange(_this.input, e2, _this.props.onChange);\n    };\n    _this.handleKeyDown = function(e2) {\n      var _this$props2 = _this.props, onPressEnter = _this$props2.onPressEnter, onKeyDown = _this$props2.onKeyDown;\n      if (onPressEnter && e2.keyCode === 13) {\n        onPressEnter(e2);\n      }\n      onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e2);\n    };\n    _this.renderShowCountSuffix = function(prefixCls) {\n      var value2 = _this.state.value;\n      var _this$props3 = _this.props, maxLength = _this$props3.maxLength, suffix = _this$props3.suffix, showCount = _this$props3.showCount;\n      var hasMaxLength = Number(maxLength) > 0;\n      if (suffix || showCount) {\n        var valueLength = _toConsumableArray(fixControlledValue(value2)).length;\n        var dataCount = null;\n        if (_typeof$1(showCount) === \"object\") {\n          dataCount = showCount.formatter({\n            count: valueLength,\n            maxLength\n          });\n        } else {\n          dataCount = \"\".concat(valueLength).concat(hasMaxLength ? \" / \".concat(maxLength) : \"\");\n        }\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, !!showCount && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n          className: classNames(\"\".concat(prefixCls, \"-show-count-suffix\"), _defineProperty$1({}, \"\".concat(prefixCls, \"-show-count-has-suffix\"), !!suffix))\n        }, dataCount), suffix);\n      }\n      return null;\n    };\n    _this.renderComponent = function(_ref2) {\n      var getPrefixCls = _ref2.getPrefixCls, direction = _ref2.direction, input2 = _ref2.input;\n      var _this$state = _this.state, value2 = _this$state.value, focused = _this$state.focused;\n      var _this$props4 = _this.props, customizePrefixCls = _this$props4.prefixCls, _this$props4$bordered = _this$props4.bordered, bordered = _this$props4$bordered === void 0 ? true : _this$props4$bordered;\n      var prefixCls = getPrefixCls(\"input\", customizePrefixCls);\n      _this.direction = direction;\n      var showCountSuffix = _this.renderShowCountSuffix(prefixCls);\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SizeContext$1.Consumer, null, function(size) {\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClearableLabeledInput$1, _extends$1({\n          size\n        }, _this.props, {\n          prefixCls,\n          inputType: \"input\",\n          value: fixControlledValue(value2),\n          element: _this.renderInput(prefixCls, size, bordered, input2),\n          handleReset: _this.handleReset,\n          ref: _this.saveClearableInput,\n          direction,\n          focused,\n          triggerFocus: _this.focus,\n          bordered,\n          suffix: showCountSuffix\n        }));\n      });\n    };\n    var value = typeof props.value === \"undefined\" ? props.defaultValue : props.value;\n    _this.state = {\n      value,\n      focused: false,\n      prevValue: props.value\n    };\n    return _this;\n  }\n  _createClass(Input2, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.clearPasswordValueAttribute();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n    }\n  }, {\n    key: \"getSnapshotBeforeUpdate\",\n    value: function getSnapshotBeforeUpdate(prevProps) {\n      if (hasPrefixSuffix(prevProps) !== hasPrefixSuffix(this.props)) {\n        devWarning(this.input !== document.activeElement, \"Input\", \"When Input is focused, dynamic add or remove prefix / suffix will make it lose focus caused by dom structure change. Read more: https://ant.design/components/input/#FAQ\");\n      }\n      return null;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.removePasswordTimeout) {\n        clearTimeout(this.removePasswordTimeout);\n      }\n    }\n  }, {\n    key: \"blur\",\n    value: function blur() {\n      this.input.blur();\n    }\n  }, {\n    key: \"setSelectionRange\",\n    value: function setSelectionRange(start, end, direction) {\n      this.input.setSelectionRange(start, end, direction);\n    }\n  }, {\n    key: \"select\",\n    value: function select() {\n      this.input.select();\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue2(value, callback) {\n      if (this.props.value === void 0) {\n        this.setState({\n          value\n        }, callback);\n      } else {\n        callback === null || callback === void 0 ? void 0 : callback();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConfigConsumer, null, this.renderComponent);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, _ref3) {\n      var prevValue = _ref3.prevValue;\n      var newState = {\n        prevValue: nextProps.value\n      };\n      if (nextProps.value !== void 0 || prevValue !== nextProps.value) {\n        newState.value = nextProps.value;\n      }\n      if (nextProps.disabled) {\n        newState.focused = false;\n      }\n      return newState;\n    }\n  }]);\n  return Input2;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nInput.defaultProps = {\n  type: \"text\"\n};\nvar Input$1 = Input;\nvar Group$1 = function Group(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConfigConsumer, null, function(_ref) {\n    var _classNames;\n    var getPrefixCls = _ref.getPrefixCls, direction = _ref.direction;\n    var customizePrefixCls = props.prefixCls, _props$className = props.className, className = _props$className === void 0 ? \"\" : _props$className;\n    var prefixCls = getPrefixCls(\"input-group\", customizePrefixCls);\n    var cls = classNames(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-lg\"), props.size === \"large\"), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-sm\"), props.size === \"small\"), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-compact\"), props.compact), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-rtl\"), direction === \"rtl\"), _classNames), className);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n      className: cls,\n      style: props.style,\n      onMouseEnter: props.onMouseEnter,\n      onMouseLeave: props.onMouseLeave,\n      onFocus: props.onFocus,\n      onBlur: props.onBlur\n    }, props.children);\n  });\n};\nvar Group$2 = Group$1;\nvar SearchOutlined$2 = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"64 64 896 896\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z\" } }] }, \"name\": \"search\", \"theme\": \"outlined\" };\nvar SearchOutlinedSvg = SearchOutlined$2;\nvar SearchOutlined = function SearchOutlined2(props, ref) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {\n    ref,\n    icon: SearchOutlinedSvg\n  }));\n};\nSearchOutlined.displayName = \"SearchOutlined\";\nvar SearchOutlined$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(SearchOutlined);\nvar UnreachableException = /* @__PURE__ */ _createClass(function UnreachableException2(value) {\n  _classCallCheck(this, UnreachableException2);\n  this.error = new Error(\"unreachable case: \".concat(JSON.stringify(value)));\n});\nvar __rest$4 = globalThis && globalThis.__rest || function(s, e2) {\n  var t2 = {};\n  for (var p2 in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)\n      t2[p2] = s[p2];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {\n      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))\n        t2[p2[i]] = s[p2[i]];\n    }\n  return t2;\n};\nvar ButtonGroup = function ButtonGroup2(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConfigConsumer, null, function(_ref) {\n    var _classNames;\n    var getPrefixCls = _ref.getPrefixCls, direction = _ref.direction;\n    var customizePrefixCls = props.prefixCls, size = props.size, className = props.className, others = __rest$4(props, [\"prefixCls\", \"size\", \"className\"]);\n    var prefixCls = getPrefixCls(\"btn-group\", customizePrefixCls);\n    var sizeCls = \"\";\n    switch (size) {\n      case \"large\":\n        sizeCls = \"lg\";\n        break;\n      case \"small\":\n        sizeCls = \"sm\";\n        break;\n      case \"middle\":\n      case void 0:\n        break;\n      default:\n        console.warn(new UnreachableException(size).error);\n    }\n    var classes = classNames(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-\").concat(sizeCls), sizeCls), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-rtl\"), direction === \"rtl\"), _classNames), className);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends$1({}, others, {\n      className: classes\n    }));\n  });\n};\nvar Group2 = ButtonGroup;\nvar getCollapsedWidth = function getCollapsedWidth2() {\n  return {\n    width: 0,\n    opacity: 0,\n    transform: \"scale(0)\"\n  };\n};\nvar getRealWidth = function getRealWidth2(node) {\n  return {\n    width: node.scrollWidth,\n    opacity: 1,\n    transform: \"scale(1)\"\n  };\n};\nvar LoadingIcon = function LoadingIcon2(_ref) {\n  var prefixCls = _ref.prefixCls, loading = _ref.loading, existIcon = _ref.existIcon;\n  var visible = !!loading;\n  if (existIcon) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n      className: \"\".concat(prefixCls, \"-loading-icon\")\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LoadingOutlined$1, null));\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CSSMotion, {\n    visible,\n    motionName: \"\".concat(prefixCls, \"-loading-icon-motion\"),\n    removeOnLeave: true,\n    onAppearStart: getCollapsedWidth,\n    onAppearActive: getRealWidth,\n    onEnterStart: getCollapsedWidth,\n    onEnterActive: getRealWidth,\n    onLeaveStart: getRealWidth,\n    onLeaveActive: getCollapsedWidth\n  }, function(_ref2, ref) {\n    var className = _ref2.className, style2 = _ref2.style;\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n      className: \"\".concat(prefixCls, \"-loading-icon\"),\n      style: style2,\n      ref\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LoadingOutlined$1, {\n      className\n    }));\n  });\n};\nvar LoadingIcon$1 = LoadingIcon;\nvar __rest$3 = globalThis && globalThis.__rest || function(s, e2) {\n  var t2 = {};\n  for (var p2 in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)\n      t2[p2] = s[p2];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {\n      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))\n        t2[p2[i]] = s[p2[i]];\n    }\n  return t2;\n};\nvar rxTwoCNChar = /^[\\u4e00-\\u9fa5]{2}$/;\nvar isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);\nfunction isString(str) {\n  return typeof str === \"string\";\n}\nfunction isUnborderedButtonType(type4) {\n  return type4 === \"text\" || type4 === \"link\";\n}\nfunction isReactFragment(node) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(node) && node.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment;\n}\nfunction insertSpace(child, needInserted) {\n  if (child == null) {\n    return;\n  }\n  var SPACE = needInserted ? \" \" : \"\";\n  if (typeof child !== \"string\" && typeof child !== \"number\" && isString(child.type) && isTwoCNChar(child.props.children)) {\n    return cloneElement(child, {\n      children: child.props.children.split(\"\").join(SPACE)\n    });\n  }\n  if (typeof child === \"string\") {\n    return isTwoCNChar(child) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, child.split(\"\").join(SPACE)) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, child);\n  }\n  if (isReactFragment(child)) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, child);\n  }\n  return child;\n}\nfunction spaceChildren(children, needInserted) {\n  var isPrevChildPure = false;\n  var childList = [];\n  react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, function(child) {\n    var type4 = _typeof$1(child);\n    var isCurrentChildPure = type4 === \"string\" || type4 === \"number\";\n    if (isPrevChildPure && isCurrentChildPure) {\n      var lastIndex = childList.length - 1;\n      var lastChild = childList[lastIndex];\n      childList[lastIndex] = \"\".concat(lastChild).concat(child);\n    } else {\n      childList.push(child);\n    }\n    isPrevChildPure = isCurrentChildPure;\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(childList, function(child) {\n    return insertSpace(child, needInserted);\n  });\n}\ntuple(\"default\", \"primary\", \"ghost\", \"dashed\", \"link\", \"text\");\ntuple(\"default\", \"circle\", \"round\");\ntuple(\"submit\", \"button\", \"reset\");\nvar InternalButton = function InternalButton2(props, ref) {\n  var _classNames;\n  var _props$loading = props.loading, loading = _props$loading === void 0 ? false : _props$loading, customizePrefixCls = props.prefixCls, _props$type = props.type, type4 = _props$type === void 0 ? \"default\" : _props$type, danger = props.danger, _props$shape = props.shape, shape = _props$shape === void 0 ? \"default\" : _props$shape, customizeSize = props.size, className = props.className, children = props.children, icon = props.icon, _props$ghost = props.ghost, ghost = _props$ghost === void 0 ? false : _props$ghost, _props$block = props.block, block = _props$block === void 0 ? false : _props$block, _props$htmlType = props.htmlType, htmlType = _props$htmlType === void 0 ? \"button\" : _props$htmlType, rest = __rest$3(props, [\"loading\", \"prefixCls\", \"type\", \"danger\", \"shape\", \"size\", \"className\", \"children\", \"icon\", \"ghost\", \"block\", \"htmlType\"]);\n  var size = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SizeContext$1);\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(!!loading), _React$useState2 = _slicedToArray(_React$useState, 2), innerLoading = _React$useState2[0], setLoading = _React$useState2[1];\n  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), hasTwoCNChar = _React$useState4[0], setHasTwoCNChar = _React$useState4[1];\n  var _React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, autoInsertSpaceInButton = _React$useContext.autoInsertSpaceInButton, direction = _React$useContext.direction;\n  var buttonRef = ref || /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n  var isNeedInserted = function isNeedInserted2() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children) === 1 && !icon && !isUnborderedButtonType(type4);\n  };\n  var fixTwoCNChar = function fixTwoCNChar2() {\n    if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {\n      return;\n    }\n    var buttonText = buttonRef.current.textContent;\n    if (isNeedInserted() && isTwoCNChar(buttonText)) {\n      if (!hasTwoCNChar) {\n        setHasTwoCNChar(true);\n      }\n    } else if (hasTwoCNChar) {\n      setHasTwoCNChar(false);\n    }\n  };\n  var loadingOrDelay = _typeof$1(loading) === \"object\" && loading.delay ? loading.delay || true : !!loading;\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    var delayTimer = null;\n    if (typeof loadingOrDelay === \"number\") {\n      delayTimer = window.setTimeout(function() {\n        delayTimer = null;\n        setLoading(loadingOrDelay);\n      }, loadingOrDelay);\n    } else {\n      setLoading(loadingOrDelay);\n    }\n    return function() {\n      if (delayTimer) {\n        window.clearTimeout(delayTimer);\n        delayTimer = null;\n      }\n    };\n  }, [loadingOrDelay]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(fixTwoCNChar, [buttonRef]);\n  var handleClick = function handleClick2(e2) {\n    var _a;\n    var onClick = props.onClick, disabled = props.disabled;\n    if (innerLoading || disabled) {\n      e2.preventDefault();\n      return;\n    }\n    (_a = onClick) === null || _a === void 0 ? void 0 : _a(e2);\n  };\n  devWarning(!(typeof icon === \"string\" && icon.length > 2), \"Button\", \"`icon` is using ReactNode instead of string naming in v4. Please check `\".concat(icon, \"` at https://ant.design/components/icon\"));\n  devWarning(!(ghost && isUnborderedButtonType(type4)), \"Button\", \"`link` or `text` button can't be a `ghost` button.\");\n  var prefixCls = getPrefixCls(\"btn\", customizePrefixCls);\n  var autoInsertSpace = autoInsertSpaceInButton !== false;\n  var sizeClassNameMap = {\n    large: \"lg\",\n    small: \"sm\",\n    middle: void 0\n  };\n  var sizeFullname = customizeSize || size;\n  var sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || \"\" : \"\";\n  var iconType = innerLoading ? \"loading\" : icon;\n  var classes = classNames(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-\").concat(shape), shape !== \"default\" && shape), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-\").concat(type4), type4), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-\").concat(sizeCls), sizeCls), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-icon-only\"), !children && children !== 0 && !!iconType), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-background-ghost\"), ghost && !isUnborderedButtonType(type4)), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-loading\"), innerLoading), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-two-chinese-chars\"), hasTwoCNChar && autoInsertSpace), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-block\"), block), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-dangerous\"), !!danger), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-rtl\"), direction === \"rtl\"), _classNames), className);\n  var iconNode = icon && !innerLoading ? icon : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LoadingIcon$1, {\n    existIcon: !!icon,\n    prefixCls,\n    loading: !!innerLoading\n  });\n  var kids = children || children === 0 ? spaceChildren(children, isNeedInserted() && autoInsertSpace) : null;\n  var linkButtonRestProps = omit(rest, [\"navigate\"]);\n  if (linkButtonRestProps.href !== void 0) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", _extends$1({}, linkButtonRestProps, {\n      className: classes,\n      onClick: handleClick,\n      ref: buttonRef\n    }), iconNode, kids);\n  }\n  var buttonNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", _extends$1({}, rest, {\n    type: htmlType,\n    className: classes,\n    onClick: handleClick,\n    ref: buttonRef\n  }), iconNode, kids);\n  if (isUnborderedButtonType(type4)) {\n    return buttonNode;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wave, {\n    disabled: !!innerLoading\n  }, buttonNode);\n};\nvar Button = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(InternalButton);\nButton.displayName = \"Button\";\nButton.Group = Group2;\nButton.__ANT_BUTTON = true;\nvar Button$1 = Button;\nvar __rest$2 = globalThis && globalThis.__rest || function(s, e2) {\n  var t2 = {};\n  for (var p2 in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)\n      t2[p2] = s[p2];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {\n      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))\n        t2[p2[i]] = s[p2[i]];\n    }\n  return t2;\n};\nvar Search = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(props, ref) {\n  var _classNames;\n  var customizePrefixCls = props.prefixCls, customizeInputPrefixCls = props.inputPrefixCls, className = props.className, customizeSize = props.size, suffix = props.suffix, _props$enterButton = props.enterButton, enterButton = _props$enterButton === void 0 ? false : _props$enterButton, addonAfter = props.addonAfter, loading = props.loading, disabled = props.disabled, customOnSearch = props.onSearch, customOnChange = props.onChange, restProps = __rest$2(props, [\"prefixCls\", \"inputPrefixCls\", \"className\", \"size\", \"suffix\", \"enterButton\", \"addonAfter\", \"loading\", \"disabled\", \"onSearch\", \"onChange\"]);\n  var _React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;\n  var contextSize = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SizeContext$1);\n  var size = customizeSize || contextSize;\n  var inputRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  var onChange = function onChange2(e2) {\n    if (e2 && e2.target && e2.type === \"click\" && customOnSearch) {\n      customOnSearch(e2.target.value, e2);\n    }\n    if (customOnChange) {\n      customOnChange(e2);\n    }\n  };\n  var onMouseDown = function onMouseDown2(e2) {\n    var _a;\n    if (document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input)) {\n      e2.preventDefault();\n    }\n  };\n  var onSearch = function onSearch2(e2) {\n    var _a;\n    if (customOnSearch) {\n      customOnSearch((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input.value, e2);\n    }\n  };\n  var prefixCls = getPrefixCls(\"input-search\", customizePrefixCls);\n  var inputPrefixCls = getPrefixCls(\"input\", customizeInputPrefixCls);\n  var searchIcon = typeof enterButton === \"boolean\" ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SearchOutlined$1, null) : null;\n  var btnClassName = \"\".concat(prefixCls, \"-button\");\n  var button;\n  var enterButtonAsElement = enterButton || {};\n  var isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;\n  if (isAntdButton || enterButtonAsElement.type === \"button\") {\n    button = cloneElement(enterButtonAsElement, _extends$1({\n      onMouseDown,\n      onClick: function onClick(e2) {\n        var _a, _b;\n        (_b = (_a = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e2);\n        onSearch(e2);\n      },\n      key: \"enterButton\"\n    }, isAntdButton ? {\n      className: btnClassName,\n      size\n    } : {}));\n  } else {\n    button = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Button$1, {\n      className: btnClassName,\n      type: enterButton ? \"primary\" : void 0,\n      size,\n      disabled,\n      key: \"enterButton\",\n      onMouseDown,\n      onClick: onSearch,\n      loading,\n      icon: searchIcon\n    }, enterButton);\n  }\n  if (addonAfter) {\n    button = [button, cloneElement(addonAfter, {\n      key: \"addonAfter\"\n    })];\n  }\n  var cls = classNames(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-rtl\"), direction === \"rtl\"), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-\").concat(size), !!size), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-with-button\"), !!enterButton), _classNames), className);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Input$1, _extends$1({\n    ref: composeRef(inputRef, ref),\n    onPressEnter: onSearch\n  }, restProps, {\n    size,\n    prefixCls: inputPrefixCls,\n    addonAfter: button,\n    suffix,\n    onChange,\n    className: cls,\n    disabled\n  }));\n});\nSearch.displayName = \"Search\";\nvar Search$1 = Search;\nvar elementListeners = /* @__PURE__ */ new Map();\nfunction onResize(entities) {\n  entities.forEach(function(entity) {\n    var _elementListeners$get;\n    var target = entity.target;\n    (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 ? void 0 : _elementListeners$get.forEach(function(listener) {\n      return listener(target);\n    });\n  });\n}\nvar resizeObserver = new index(onResize);\nfunction observe(element, callback) {\n  if (!elementListeners.has(element)) {\n    elementListeners.set(element, /* @__PURE__ */ new Set());\n    resizeObserver.observe(element);\n  }\n  elementListeners.get(element).add(callback);\n}\nfunction unobserve(element, callback) {\n  if (elementListeners.has(element)) {\n    elementListeners.get(element).delete(callback);\n    if (!elementListeners.get(element).size) {\n      resizeObserver.unobserve(element);\n      elementListeners.delete(element);\n    }\n  }\n}\nvar DomWrapper = /* @__PURE__ */ function(_React$Component) {\n  _inherits(DomWrapper2, _React$Component);\n  var _super = _createSuper(DomWrapper2);\n  function DomWrapper2() {\n    _classCallCheck(this, DomWrapper2);\n    return _super.apply(this, arguments);\n  }\n  _createClass(DomWrapper2, [{\n    key: \"render\",\n    value: function render() {\n      return this.props.children;\n    }\n  }]);\n  return DomWrapper2;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nvar CollectionContext = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction Collection(_ref) {\n  var children = _ref.children, onBatchResize = _ref.onBatchResize;\n  var resizeIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n  var resizeInfosRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n  var onCollectionResize = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CollectionContext);\n  var onResize2 = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(size, element, data) {\n    resizeIdRef.current += 1;\n    var currentId = resizeIdRef.current;\n    resizeInfosRef.current.push({\n      size,\n      element,\n      data\n    });\n    Promise.resolve().then(function() {\n      if (currentId === resizeIdRef.current) {\n        onBatchResize === null || onBatchResize === void 0 ? void 0 : onBatchResize(resizeInfosRef.current);\n        resizeInfosRef.current = [];\n      }\n    });\n    onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(size, element, data);\n  }, [onBatchResize, onCollectionResize]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CollectionContext.Provider, {\n    value: onResize2\n  }, children);\n}\nfunction SingleObserver(props) {\n  var children = props.children, disabled = props.disabled;\n  var elementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  var wrapperRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  var onCollectionResize = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CollectionContext);\n  var isRenderProps = typeof children === \"function\";\n  var mergedChildren = isRenderProps ? children(elementRef) : children;\n  var sizeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n    width: -1,\n    height: -1,\n    offsetWidth: -1,\n    offsetHeight: -1\n  });\n  var canRef = !isRenderProps && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(mergedChildren) && supportRef(mergedChildren);\n  var originRef = canRef ? mergedChildren.ref : null;\n  var mergedRef = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n    return composeRef(originRef, elementRef);\n  }, [originRef, elementRef]);\n  var propsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(props);\n  propsRef.current = props;\n  var onInternalResize = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(target) {\n    var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data = _propsRef$current.data;\n    var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;\n    var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;\n    var fixedWidth = Math.floor(width);\n    var fixedHeight = Math.floor(height);\n    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {\n      var size = {\n        width: fixedWidth,\n        height: fixedHeight,\n        offsetWidth,\n        offsetHeight\n      };\n      sizeRef.current = size;\n      var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;\n      var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;\n      var sizeInfo = _objectSpread2$1(_objectSpread2$1({}, size), {}, {\n        offsetWidth: mergedOffsetWidth,\n        offsetHeight: mergedOffsetHeight\n      });\n      onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(sizeInfo, target, data);\n      if (onResize2) {\n        Promise.resolve().then(function() {\n          onResize2(sizeInfo, target);\n        });\n      }\n    }\n  }, []);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    var currentElement = findDOMNode(elementRef.current) || findDOMNode(wrapperRef.current);\n    if (currentElement && !disabled) {\n      observe(currentElement, onInternalResize);\n    }\n    return function() {\n      return unobserve(currentElement, onInternalResize);\n    };\n  }, [elementRef.current, disabled]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DomWrapper, {\n    ref: wrapperRef\n  }, canRef ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(mergedChildren, {\n    ref: mergedRef\n  }) : mergedChildren);\n}\nvar INTERNAL_PREFIX_KEY = \"rc-observer-key\";\nfunction ResizeObserver(props) {\n  var children = props.children;\n  var childNodes = typeof children === \"function\" ? [children] : toArray$1(children);\n  return childNodes.map(function(child, index2) {\n    var key2 = (child === null || child === void 0 ? void 0 : child.key) || \"\".concat(INTERNAL_PREFIX_KEY, \"-\").concat(index2);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SingleObserver, _extends$1({}, props, {\n      key: key2\n    }), child);\n  });\n}\nResizeObserver.Collection = Collection;\nvar HIDDEN_TEXTAREA_STYLE = \"\\n  min-height:0 !important;\\n  max-height:none !important;\\n  height:0 !important;\\n  visibility:hidden !important;\\n  overflow:hidden !important;\\n  position:absolute !important;\\n  z-index:-1000 !important;\\n  top:0 !important;\\n  right:0 !important\\n\";\nvar SIZING_STYLE = [\"letter-spacing\", \"line-height\", \"padding-top\", \"padding-bottom\", \"font-family\", \"font-weight\", \"font-size\", \"font-variant\", \"text-rendering\", \"text-transform\", \"width\", \"text-indent\", \"padding-left\", \"padding-right\", \"border-width\", \"box-sizing\", \"word-break\"];\nvar computedStyleCache = {};\nvar hiddenTextarea;\nfunction calculateNodeStyling(node) {\n  var useCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n  var nodeRef = node.getAttribute(\"id\") || node.getAttribute(\"data-reactid\") || node.getAttribute(\"name\");\n  if (useCache && computedStyleCache[nodeRef]) {\n    return computedStyleCache[nodeRef];\n  }\n  var style2 = window.getComputedStyle(node);\n  var boxSizing = style2.getPropertyValue(\"box-sizing\") || style2.getPropertyValue(\"-moz-box-sizing\") || style2.getPropertyValue(\"-webkit-box-sizing\");\n  var paddingSize = parseFloat(style2.getPropertyValue(\"padding-bottom\")) + parseFloat(style2.getPropertyValue(\"padding-top\"));\n  var borderSize = parseFloat(style2.getPropertyValue(\"border-bottom-width\")) + parseFloat(style2.getPropertyValue(\"border-top-width\"));\n  var sizingStyle = SIZING_STYLE.map(function(name) {\n    return \"\".concat(name, \":\").concat(style2.getPropertyValue(name));\n  }).join(\";\");\n  var nodeInfo = {\n    sizingStyle,\n    paddingSize,\n    borderSize,\n    boxSizing\n  };\n  if (useCache && nodeRef) {\n    computedStyleCache[nodeRef] = nodeInfo;\n  }\n  return nodeInfo;\n}\nfunction calculateNodeHeight(uiTextNode) {\n  var useCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n  var minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n  var maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n  if (!hiddenTextarea) {\n    hiddenTextarea = document.createElement(\"textarea\");\n    hiddenTextarea.setAttribute(\"tab-index\", \"-1\");\n    hiddenTextarea.setAttribute(\"aria-hidden\", \"true\");\n    document.body.appendChild(hiddenTextarea);\n  }\n  if (uiTextNode.getAttribute(\"wrap\")) {\n    hiddenTextarea.setAttribute(\"wrap\", uiTextNode.getAttribute(\"wrap\"));\n  } else {\n    hiddenTextarea.removeAttribute(\"wrap\");\n  }\n  var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;\n  hiddenTextarea.setAttribute(\"style\", \"\".concat(sizingStyle, \";\").concat(HIDDEN_TEXTAREA_STYLE));\n  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || \"\";\n  var minHeight = Number.MIN_SAFE_INTEGER;\n  var maxHeight = Number.MAX_SAFE_INTEGER;\n  var height = hiddenTextarea.scrollHeight;\n  var overflowY;\n  if (boxSizing === \"border-box\") {\n    height += borderSize;\n  } else if (boxSizing === \"content-box\") {\n    height -= paddingSize;\n  }\n  if (minRows !== null || maxRows !== null) {\n    hiddenTextarea.value = \" \";\n    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;\n    if (minRows !== null) {\n      minHeight = singleRowHeight * minRows;\n      if (boxSizing === \"border-box\") {\n        minHeight = minHeight + paddingSize + borderSize;\n      }\n      height = Math.max(minHeight, height);\n    }\n    if (maxRows !== null) {\n      maxHeight = singleRowHeight * maxRows;\n      if (boxSizing === \"border-box\") {\n        maxHeight = maxHeight + paddingSize + borderSize;\n      }\n      overflowY = height > maxHeight ? \"\" : \"hidden\";\n      height = Math.min(maxHeight, height);\n    }\n  }\n  return {\n    height,\n    minHeight,\n    maxHeight,\n    overflowY,\n    resize: \"none\"\n  };\n}\nvar shallowequal = function shallowEqual(objA, objB, compare, compareContext) {\n  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;\n  if (ret !== void 0) {\n    return !!ret;\n  }\n  if (objA === objB) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || !objA || typeof objB !== \"object\" || !objB) {\n    return false;\n  }\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n  for (var idx = 0; idx < keysA.length; idx++) {\n    var key2 = keysA[idx];\n    if (!bHasOwnProperty(key2)) {\n      return false;\n    }\n    var valueA = objA[key2];\n    var valueB = objB[key2];\n    ret = compare ? compare.call(compareContext, valueA, valueB, key2) : void 0;\n    if (ret === false || ret === void 0 && valueA !== valueB) {\n      return false;\n    }\n  }\n  return true;\n};\nvar RESIZE_STATUS;\n(function(RESIZE_STATUS2) {\n  RESIZE_STATUS2[RESIZE_STATUS2[\"NONE\"] = 0] = \"NONE\";\n  RESIZE_STATUS2[RESIZE_STATUS2[\"RESIZING\"] = 1] = \"RESIZING\";\n  RESIZE_STATUS2[RESIZE_STATUS2[\"RESIZED\"] = 2] = \"RESIZED\";\n})(RESIZE_STATUS || (RESIZE_STATUS = {}));\nvar ResizableTextArea = /* @__PURE__ */ function(_React$Component) {\n  _inherits(ResizableTextArea2, _React$Component);\n  var _super = _createSuper(ResizableTextArea2);\n  function ResizableTextArea2(props) {\n    var _this;\n    _classCallCheck(this, ResizableTextArea2);\n    _this = _super.call(this, props);\n    _this.nextFrameActionId = void 0;\n    _this.resizeFrameId = void 0;\n    _this.textArea = void 0;\n    _this.saveTextArea = function(textArea) {\n      _this.textArea = textArea;\n    };\n    _this.handleResize = function(size) {\n      var resizeStatus = _this.state.resizeStatus;\n      var _this$props = _this.props, autoSize = _this$props.autoSize, onResize2 = _this$props.onResize;\n      if (resizeStatus !== RESIZE_STATUS.NONE) {\n        return;\n      }\n      if (typeof onResize2 === \"function\") {\n        onResize2(size);\n      }\n      if (autoSize) {\n        _this.resizeOnNextFrame();\n      }\n    };\n    _this.resizeOnNextFrame = function() {\n      cancelAnimationFrame(_this.nextFrameActionId);\n      _this.nextFrameActionId = requestAnimationFrame(_this.resizeTextarea);\n    };\n    _this.resizeTextarea = function() {\n      var autoSize = _this.props.autoSize;\n      if (!autoSize || !_this.textArea) {\n        return;\n      }\n      var minRows = autoSize.minRows, maxRows = autoSize.maxRows;\n      var textareaStyles = calculateNodeHeight(_this.textArea, false, minRows, maxRows);\n      _this.setState({\n        textareaStyles,\n        resizeStatus: RESIZE_STATUS.RESIZING\n      }, function() {\n        cancelAnimationFrame(_this.resizeFrameId);\n        _this.resizeFrameId = requestAnimationFrame(function() {\n          _this.setState({\n            resizeStatus: RESIZE_STATUS.RESIZED\n          }, function() {\n            _this.resizeFrameId = requestAnimationFrame(function() {\n              _this.setState({\n                resizeStatus: RESIZE_STATUS.NONE\n              });\n              _this.fixFirefoxAutoScroll();\n            });\n          });\n        });\n      });\n    };\n    _this.renderTextArea = function() {\n      var _this$props2 = _this.props, _this$props2$prefixCl = _this$props2.prefixCls, prefixCls = _this$props2$prefixCl === void 0 ? \"rc-textarea\" : _this$props2$prefixCl, autoSize = _this$props2.autoSize, onResize2 = _this$props2.onResize, className = _this$props2.className, disabled = _this$props2.disabled;\n      var _this$state = _this.state, textareaStyles = _this$state.textareaStyles, resizeStatus = _this$state.resizeStatus;\n      var otherProps = omit(_this.props, [\"prefixCls\", \"onPressEnter\", \"autoSize\", \"defaultValue\", \"onResize\"]);\n      var cls = classNames(prefixCls, className, _defineProperty$1({}, \"\".concat(prefixCls, \"-disabled\"), disabled));\n      if (\"value\" in otherProps) {\n        otherProps.value = otherProps.value || \"\";\n      }\n      var style2 = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, _this.props.style), textareaStyles), resizeStatus === RESIZE_STATUS.RESIZING ? {\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      } : null);\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResizeObserver, {\n        onResize: _this.handleResize,\n        disabled: !(autoSize || onResize2)\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"textarea\", _extends$1({}, otherProps, {\n        className: cls,\n        style: style2,\n        ref: _this.saveTextArea\n      })));\n    };\n    _this.state = {\n      textareaStyles: {},\n      resizeStatus: RESIZE_STATUS.NONE\n    };\n    return _this;\n  }\n  _createClass(ResizableTextArea2, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.value !== this.props.value || !shallowequal(prevProps.autoSize, this.props.autoSize)) {\n        this.resizeTextarea();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      cancelAnimationFrame(this.nextFrameActionId);\n      cancelAnimationFrame(this.resizeFrameId);\n    }\n  }, {\n    key: \"fixFirefoxAutoScroll\",\n    value: function fixFirefoxAutoScroll() {\n      try {\n        if (document.activeElement === this.textArea) {\n          var currentStart = this.textArea.selectionStart;\n          var currentEnd = this.textArea.selectionEnd;\n          this.textArea.setSelectionRange(currentStart, currentEnd);\n        }\n      } catch (e2) {\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.renderTextArea();\n    }\n  }]);\n  return ResizableTextArea2;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nvar TextArea$2 = /* @__PURE__ */ function(_React$Component) {\n  _inherits(TextArea2, _React$Component);\n  var _super = _createSuper(TextArea2);\n  function TextArea2(props) {\n    var _this;\n    _classCallCheck(this, TextArea2);\n    _this = _super.call(this, props);\n    _this.resizableTextArea = void 0;\n    _this.focus = function() {\n      _this.resizableTextArea.textArea.focus();\n    };\n    _this.saveTextArea = function(resizableTextArea) {\n      _this.resizableTextArea = resizableTextArea;\n    };\n    _this.handleChange = function(e2) {\n      var onChange = _this.props.onChange;\n      _this.setValue(e2.target.value, function() {\n        _this.resizableTextArea.resizeTextarea();\n      });\n      if (onChange) {\n        onChange(e2);\n      }\n    };\n    _this.handleKeyDown = function(e2) {\n      var _this$props = _this.props, onPressEnter = _this$props.onPressEnter, onKeyDown = _this$props.onKeyDown;\n      if (e2.keyCode === 13 && onPressEnter) {\n        onPressEnter(e2);\n      }\n      if (onKeyDown) {\n        onKeyDown(e2);\n      }\n    };\n    var value = typeof props.value === \"undefined\" || props.value === null ? props.defaultValue : props.value;\n    _this.state = {\n      value\n    };\n    return _this;\n  }\n  _createClass(TextArea2, [{\n    key: \"setValue\",\n    value: function setValue2(value, callback) {\n      if (!(\"value\" in this.props)) {\n        this.setState({\n          value\n        }, callback);\n      }\n    }\n  }, {\n    key: \"blur\",\n    value: function blur() {\n      this.resizableTextArea.textArea.blur();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResizableTextArea, _extends$1({}, this.props, {\n        value: this.state.value,\n        onKeyDown: this.handleKeyDown,\n        onChange: this.handleChange,\n        ref: this.saveTextArea\n      }));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps) {\n      if (\"value\" in nextProps) {\n        return {\n          value: nextProps.value\n        };\n      }\n      return null;\n    }\n  }]);\n  return TextArea2;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nvar __rest$1 = globalThis && globalThis.__rest || function(s, e2) {\n  var t2 = {};\n  for (var p2 in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)\n      t2[p2] = s[p2];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {\n      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))\n        t2[p2[i]] = s[p2[i]];\n    }\n  return t2;\n};\nfunction fixEmojiLength(value, maxLength) {\n  return _toConsumableArray(value || \"\").slice(0, maxLength).join(\"\");\n}\nfunction setTriggerValue(isCursorInEnd, preValue, triggerValue, maxLength) {\n  var newTriggerValue = triggerValue;\n  if (isCursorInEnd) {\n    newTriggerValue = fixEmojiLength(triggerValue, maxLength);\n  } else if (_toConsumableArray(preValue || \"\").length < triggerValue.length && _toConsumableArray(triggerValue || \"\").length > maxLength) {\n    newTriggerValue = preValue;\n  }\n  return newTriggerValue;\n}\nvar TextArea = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(_a, ref) {\n  var _classNames;\n  var customizePrefixCls = _a.prefixCls, _a$bordered = _a.bordered, bordered = _a$bordered === void 0 ? true : _a$bordered, _a$showCount = _a.showCount, showCount = _a$showCount === void 0 ? false : _a$showCount, maxLength = _a.maxLength, className = _a.className, style2 = _a.style, customizeSize = _a.size, onCompositionStart = _a.onCompositionStart, onCompositionEnd = _a.onCompositionEnd, onChange = _a.onChange, props = __rest$1(_a, [\"prefixCls\", \"bordered\", \"showCount\", \"maxLength\", \"className\", \"style\", \"size\", \"onCompositionStart\", \"onCompositionEnd\", \"onChange\"]);\n  var _React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;\n  var size = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SizeContext$1);\n  var innerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  var clearableInputRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), compositing = _React$useState2[0], setCompositing = _React$useState2[1];\n  var oldCompositionValueRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  var oldSelectionStartRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n  var _useMergedState = useControlledState(props.defaultValue, {\n    value: props.value\n  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue2 = _useMergedState2[1];\n  var hidden = props.hidden;\n  var handleSetValue = function handleSetValue2(val2, callback) {\n    if (props.value === void 0) {\n      setValue2(val2);\n      callback === null || callback === void 0 ? void 0 : callback();\n    }\n  };\n  var hasMaxLength = Number(maxLength) > 0;\n  var onInternalCompositionStart = function onInternalCompositionStart2(e2) {\n    setCompositing(true);\n    oldCompositionValueRef.current = value;\n    oldSelectionStartRef.current = e2.currentTarget.selectionStart;\n    onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);\n  };\n  var onInternalCompositionEnd = function onInternalCompositionEnd2(e2) {\n    var _a2;\n    setCompositing(false);\n    var triggerValue = e2.currentTarget.value;\n    if (hasMaxLength) {\n      var isCursorInEnd = oldSelectionStartRef.current >= maxLength + 1 || oldSelectionStartRef.current === ((_a2 = oldCompositionValueRef.current) === null || _a2 === void 0 ? void 0 : _a2.length);\n      triggerValue = setTriggerValue(isCursorInEnd, oldCompositionValueRef.current, triggerValue, maxLength);\n    }\n    if (triggerValue !== value) {\n      handleSetValue(triggerValue);\n      resolveOnChange(e2.currentTarget, e2, onChange, triggerValue);\n    }\n    onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);\n  };\n  var handleChange = function handleChange2(e2) {\n    var triggerValue = e2.target.value;\n    if (!compositing && hasMaxLength) {\n      var isCursorInEnd = e2.target.selectionStart >= maxLength + 1 || e2.target.selectionStart === triggerValue.length || !e2.target.selectionStart;\n      triggerValue = setTriggerValue(isCursorInEnd, value, triggerValue, maxLength);\n    }\n    handleSetValue(triggerValue);\n    resolveOnChange(e2.currentTarget, e2, onChange, triggerValue);\n  };\n  var handleReset = function handleReset2(e2) {\n    var _a2, _b;\n    handleSetValue(\"\", function() {\n      var _a3;\n      (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus();\n    });\n    resolveOnChange((_b = (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, e2, onChange);\n  };\n  var prefixCls = getPrefixCls(\"input\", customizePrefixCls);\n  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(ref, function() {\n    var _a2;\n    return {\n      resizableTextArea: (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea,\n      focus: function focus(option) {\n        var _a3, _b;\n        triggerFocus((_b = (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);\n      },\n      blur: function blur() {\n        var _a3;\n        return (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.blur();\n      }\n    };\n  });\n  var textArea = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TextArea$2, _extends$1({}, omit(props, [\"allowClear\"]), {\n    className: classNames((_classNames = {}, _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-borderless\"), !bordered), _defineProperty$1(_classNames, className, className && !showCount), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-sm\"), size === \"small\" || customizeSize === \"small\"), _defineProperty$1(_classNames, \"\".concat(prefixCls, \"-lg\"), size === \"large\" || customizeSize === \"large\"), _classNames)),\n    style: showCount ? void 0 : style2,\n    prefixCls,\n    onCompositionStart: onInternalCompositionStart,\n    onChange: handleChange,\n    onCompositionEnd: onInternalCompositionEnd,\n    ref: innerRef\n  }));\n  var val = fixControlledValue(value);\n  if (!compositing && hasMaxLength && (props.value === null || props.value === void 0)) {\n    val = fixEmojiLength(val, maxLength);\n  }\n  var textareaNode = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClearableLabeledInput$1, _extends$1({}, props, {\n    prefixCls,\n    direction,\n    inputType: \"text\",\n    value: val,\n    element: textArea,\n    handleReset,\n    ref: clearableInputRef,\n    bordered,\n    style: showCount ? void 0 : style2\n  }));\n  if (showCount) {\n    var valueLength = _toConsumableArray(val).length;\n    var dataCount = \"\";\n    if (_typeof$1(showCount) === \"object\") {\n      dataCount = showCount.formatter({\n        count: valueLength,\n        maxLength\n      });\n    } else {\n      dataCount = \"\".concat(valueLength).concat(hasMaxLength ? \" / \".concat(maxLength) : \"\");\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      hidden,\n      className: classNames(\"\".concat(prefixCls, \"-textarea\"), _defineProperty$1({}, \"\".concat(prefixCls, \"-textarea-rtl\"), direction === \"rtl\"), \"\".concat(prefixCls, \"-textarea-show-count\"), className),\n      style: style2,\n      \"data-count\": dataCount\n    }, textareaNode);\n  }\n  return textareaNode;\n});\nvar TextArea$1 = TextArea;\nvar EyeOutlined$2 = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"64 64 896 896\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z\" } }] }, \"name\": \"eye\", \"theme\": \"outlined\" };\nvar EyeOutlinedSvg = EyeOutlined$2;\nvar EyeOutlined = function EyeOutlined2(props, ref) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {\n    ref,\n    icon: EyeOutlinedSvg\n  }));\n};\nEyeOutlined.displayName = \"EyeOutlined\";\nvar EyeOutlined$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(EyeOutlined);\nvar EyeInvisibleOutlined$2 = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"64 64 896 896\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z\" } }, { \"tag\": \"path\", \"attrs\": { \"d\": \"M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z\" } }] }, \"name\": \"eye-invisible\", \"theme\": \"outlined\" };\nvar EyeInvisibleOutlinedSvg = EyeInvisibleOutlined$2;\nvar EyeInvisibleOutlined = function EyeInvisibleOutlined2(props, ref) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {\n    ref,\n    icon: EyeInvisibleOutlinedSvg\n  }));\n};\nEyeInvisibleOutlined.displayName = \"EyeInvisibleOutlined\";\nvar EyeInvisibleOutlined$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(EyeInvisibleOutlined);\nvar __rest = globalThis && globalThis.__rest || function(s, e2) {\n  var t2 = {};\n  for (var p2 in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)\n      t2[p2] = s[p2];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {\n      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))\n        t2[p2[i]] = s[p2[i]];\n    }\n  return t2;\n};\nvar ActionMap = {\n  click: \"onClick\",\n  hover: \"onMouseOver\"\n};\nvar Password = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(props, ref) {\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false), _useState2 = _slicedToArray(_useState, 2), visible = _useState2[0], setVisible = _useState2[1];\n  var onVisibleChange = function onVisibleChange2() {\n    var disabled = props.disabled;\n    if (disabled) {\n      return;\n    }\n    setVisible(!visible);\n  };\n  var getIcon = function getIcon2(prefixCls) {\n    var _iconProps;\n    var action = props.action, _props$iconRender = props.iconRender, iconRender2 = _props$iconRender === void 0 ? function() {\n      return null;\n    } : _props$iconRender;\n    var iconTrigger = ActionMap[action] || \"\";\n    var icon = iconRender2(visible);\n    var iconProps = (_iconProps = {}, _defineProperty$1(_iconProps, iconTrigger, onVisibleChange), _defineProperty$1(_iconProps, \"className\", \"\".concat(prefixCls, \"-icon\")), _defineProperty$1(_iconProps, \"key\", \"passwordIcon\"), _defineProperty$1(_iconProps, \"onMouseDown\", function onMouseDown(e2) {\n      e2.preventDefault();\n    }), _defineProperty$1(_iconProps, \"onMouseUp\", function onMouseUp(e2) {\n      e2.preventDefault();\n    }), _iconProps);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(icon) ? icon : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, icon), iconProps);\n  };\n  var renderPassword = function renderPassword2(_ref) {\n    var getPrefixCls = _ref.getPrefixCls;\n    var className = props.className, customizePrefixCls = props.prefixCls, customizeInputPrefixCls = props.inputPrefixCls, size = props.size, visibilityToggle = props.visibilityToggle, restProps = __rest(props, [\"className\", \"prefixCls\", \"inputPrefixCls\", \"size\", \"visibilityToggle\"]);\n    var inputPrefixCls = getPrefixCls(\"input\", customizeInputPrefixCls);\n    var prefixCls = getPrefixCls(\"input-password\", customizePrefixCls);\n    var suffixIcon = visibilityToggle && getIcon(prefixCls);\n    var inputClassName = classNames(prefixCls, className, _defineProperty$1({}, \"\".concat(prefixCls, \"-\").concat(size), !!size));\n    var omittedProps = _extends$1(_extends$1({}, omit(restProps, [\"suffix\", \"iconRender\"])), {\n      type: visible ? \"text\" : \"password\",\n      className: inputClassName,\n      prefixCls: inputPrefixCls,\n      suffix: suffixIcon\n    });\n    if (size) {\n      omittedProps.size = size;\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Input$1, _extends$1({\n      ref\n    }, omittedProps));\n  };\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConfigConsumer, null, renderPassword);\n});\nPassword.defaultProps = {\n  action: \"click\",\n  visibilityToggle: true,\n  iconRender: function iconRender(visible) {\n    return visible ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EyeOutlined$1, null) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EyeInvisibleOutlined$1, null);\n  }\n};\nPassword.displayName = \"Password\";\nvar Password$1 = Password;\nInput$1.Group = Group$2;\nInput$1.Search = Search$1;\nInput$1.TextArea = TextArea$1;\nInput$1.Password = Password$1;\nconst tagInput = \"_tagInput_16veo_1\";\nconst input = \"_input_16veo_1\";\nconst clear = \"_clear_16veo_5\";\nvar styles = {\n  tagInput,\n  input,\n  clear\n};\nvar jsxRuntime = { exports: {} };\nvar reactJsxRuntime_production_min = {};\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\nfunction toObject(val) {\n  if (val === null || val === void 0) {\n    throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n  }\n  return Object(val);\n}\nfunction shouldUseNative() {\n  try {\n    if (!Object.assign) {\n      return false;\n    }\n    var test1 = new String(\"abc\");\n    test1[5] = \"de\";\n    if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n      return false;\n    }\n    var test2 = {};\n    for (var i = 0; i < 10; i++) {\n      test2[\"_\" + String.fromCharCode(i)] = i;\n    }\n    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {\n      return test2[n2];\n    });\n    if (order2.join(\"\") !== \"0123456789\") {\n      return false;\n    }\n    var test3 = {};\n    \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n      test3[letter] = letter;\n    });\n    if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n      return false;\n    }\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\nshouldUseNative() ? Object.assign : function(target, source) {\n  var from;\n  var to = toObject(target);\n  var symbols;\n  for (var s = 1; s < arguments.length; s++) {\n    from = Object(arguments[s]);\n    for (var key2 in from) {\n      if (hasOwnProperty.call(from, key2)) {\n        to[key2] = from[key2];\n      }\n    }\n    if (getOwnPropertySymbols) {\n      symbols = getOwnPropertySymbols(from);\n      for (var i = 0; i < symbols.length; i++) {\n        if (propIsEnumerable.call(from, symbols[i])) {\n          to[symbols[i]] = from[symbols[i]];\n        }\n      }\n    }\n  }\n  return to;\n};\n/** @license React v17.0.2\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar f = (react__WEBPACK_IMPORTED_MODULE_0___default()), g = 60103;\nreactJsxRuntime_production_min.Fragment = 60107;\nif (typeof Symbol === \"function\" && Symbol.for) {\n  var h = Symbol.for;\n  g = h(\"react.element\");\n  reactJsxRuntime_production_min.Fragment = h(\"react.fragment\");\n}\nvar m = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n = Object.prototype.hasOwnProperty, p = { key: true, ref: true, __self: true, __source: true };\nfunction q(c2, a, k2) {\n  var b2, d2 = {}, e2 = null, l2 = null;\n  k2 !== void 0 && (e2 = \"\" + k2);\n  a.key !== void 0 && (e2 = \"\" + a.key);\n  a.ref !== void 0 && (l2 = a.ref);\n  for (b2 in a)\n    n.call(a, b2) && !p.hasOwnProperty(b2) && (d2[b2] = a[b2]);\n  if (c2 && c2.defaultProps)\n    for (b2 in a = c2.defaultProps, a)\n      d2[b2] === void 0 && (d2[b2] = a[b2]);\n  return { $$typeof: g, type: c2, key: e2, ref: l2, props: d2, _owner: m.current };\n}\nreactJsxRuntime_production_min.jsx = q;\nreactJsxRuntime_production_min.jsxs = q;\n{\n  jsxRuntime.exports = reactJsxRuntime_production_min;\n}\nconst jsx = jsxRuntime.exports.jsx;\nconst jsxs = jsxRuntime.exports.jsxs;\nconst TagInput = (_a) => {\n  var _b = _a, {\n    value = [],\n    onChange,\n    placeholder\n  } = _b, props = __objRest(_b, [\n    \"value\",\n    \"onChange\",\n    \"placeholder\"\n  ]);\n  const [content, setContent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  const inputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const handleDelete = (tag) => {\n    const newArr = value.filter((i) => i !== tag);\n    onChange(newArr);\n    message.destroy();\n  };\n  const handleChange = (e2) => {\n    setContent(e2.target.value);\n  };\n  const handleBlur = () => {\n    if (content) {\n      if (value.includes(content)) {\n        message.warn(`[tag: ${content}] already exists`);\n        return;\n      }\n      onChange([...value, content]);\n      setContent(\"\");\n    }\n  };\n  const handleKeyPress = (e2) => e2.key === \"Enter\" && e2.preventDefault();\n  const handleKeyUp = (e2) => {\n    if (e2.key === \"Enter\" && content) {\n      if (value.includes(content)) {\n        message.warn(`[tag: ${content}] already exists`);\n        return;\n      }\n      onChange([...value, content]);\n      setContent(\"\");\n    }\n  };\n  const handleClear = () => {\n    onChange([]);\n  };\n  return /* @__PURE__ */ jsxs(\"div\", __spreadProps(__spreadValues({\n    className: `${styles.tagInput} ant-input`,\n    onClick: () => {\n      var _a2;\n      return (_a2 = inputRef.current) == null ? void 0 : _a2.focus();\n    }\n  }, props), {\n    children: [value.map((item) => item.length > 20 ? /* @__PURE__ */ jsx(Tooltip$1, {\n      title: item,\n      children: /* @__PURE__ */ jsx(Tag$1, {\n        closable: true,\n        onClose: () => handleDelete(item),\n        children: `${item.slice(0, 20)}...`\n      })\n    }, item) : /* @__PURE__ */ jsx(Tag$1, {\n      closable: true,\n      onClose: () => handleDelete(item),\n      children: item\n    }, item)), /* @__PURE__ */ jsx(Input$1, {\n      ref: inputRef,\n      bordered: false,\n      placeholder: !value.length ? placeholder : \"\",\n      className: styles.input,\n      value: content,\n      onChange: handleChange,\n      onBlur: handleBlur,\n      onKeyPress: handleKeyPress,\n      onKeyUp: handleKeyUp\n    }), /* @__PURE__ */ jsx(\"span\", {\n      className: `${styles.clear} ant-input-suffix`,\n      onClick: handleClear,\n      children: /* @__PURE__ */ jsx(\"span\", {\n        role: \"button\",\n        \"aria-label\": \"close-circle\",\n        className: \"anticon anticon-close-circle ant-input-clear-icon\",\n        children: /* @__PURE__ */ jsx(\"svg\", {\n          viewBox: \"64 64 896 896\",\n          focusable: \"false\",\n          className: \"\",\n          \"data-icon\": \"close-circle\",\n          width: \"1em\",\n          height: \"1em\",\n          fill: \"currentColor\",\n          \"aria-hidden\": \"true\",\n          children: /* @__PURE__ */ jsx(\"path\", {\n            d: \"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z\"\n          })\n        })\n      })\n    })]\n  }));\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYW50ZC10YWctaW5wdXQvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRiw2REFBNkQ7QUFDOUk7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0I7QUFDNkg7QUFDM0g7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNERBQW9CO0FBQzdCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUNBQVksR0FBRztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxz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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUU7QUFDM0QseUJBQXlCLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRTtBQUMzRCx5QkFBeUIsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRTtBQUMzRSx5QkFBeUIsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVDQUF1QztBQUM5RCx1QkFBdUIsd0NBQXdDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QixtQ0FBbUMsa0RBQWtEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsYUFBYTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxXQUFXO0FBQ3JFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFdBQVc7QUFDdEU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdF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UCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsY0FBYztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvREFBb0Q7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZDQUE2QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFlBQVk7QUFDNUU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlCQUF5QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsZUFBZSw0REFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0RBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQVE7QUFDeEMsbUJBQW1CLDZDQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QyxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQytCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVjaHdhdmUtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2FudGQtdGFnLWlucHV0L2Rpc3QvaW5kZXguZXMuanM/NDFiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXkyLCB2YWx1ZSkgPT4ga2V5MiBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXkyLCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleTJdID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYjIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiMiB8fCAoYjIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIyLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiMltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiMikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiMiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiMltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiMikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiMikpO1xudmFyIF9fb2JqUmVzdCA9IChzb3VyY2UsIGV4Y2x1ZGUpID0+IHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSAmJiBleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBpZiAoc291cmNlICE9IG51bGwgJiYgX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKSkge1xuICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDAgJiYgX19wcm9wSXNFbnVtLmNhbGwoc291cmNlLCBwcm9wKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBSZWFjdF9fZGVmYXVsdCwgeyB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgQ29tcG9uZW50LCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCBmb3J3YXJkUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xudmFyIF9kZWZhdWx0ID0gXCJcIjtcbnZhciBpbmRleCQ1ID0gXCJcIjtcbnZhciBpbmRleCQ0ID0gXCJcIjtcbnZhciBpbmRleCQzID0gXCJcIjtcbnZhciBpbmRleCQyID0gXCJcIjtcbnZhciBpbmRleCQxID0gXCJcIjtcbmZ1bmN0aW9uIF9leHRlbmRzJDEoKSB7XG4gIF9leHRlbmRzJDEgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5MiBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleTIpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleTJdID0gc291cmNlW2tleTJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcyQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkkMShvYmosIGtleTIsIHZhbHVlKSB7XG4gIGlmIChrZXkyIGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleTIsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleTJdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDoge307XG52YXIgY2xhc3NuYW1lcyA9IHsgZXhwb3J0czoge30gfTtcbi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTggSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbihmdW5jdGlvbihtb2R1bGUpIHtcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICBmdW5jdGlvbiBjbGFzc05hbWVzMigpIHtcbiAgICAgIHZhciBjbGFzc2VzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAoIWFyZylcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuICAgICAgICBpZiAoYXJnVHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBhcmdUeXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY2xhc3Nlcy5wdXNoKGFyZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgaWYgKGFyZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBpbm5lciA9IGNsYXNzTmFtZXMyLmFwcGx5KG51bGwsIGFyZyk7XG4gICAgICAgICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGlubmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmIChhcmcudG9TdHJpbmcgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleTIgaW4gYXJnKSB7XG4gICAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChhcmcsIGtleTIpICYmIGFyZ1trZXkyXSkge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChrZXkyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goYXJnLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNsYXNzZXMuam9pbihcIiBcIik7XG4gICAgfVxuICAgIGlmIChtb2R1bGUuZXhwb3J0cykge1xuICAgICAgY2xhc3NOYW1lczIuZGVmYXVsdCA9IGNsYXNzTmFtZXMyO1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzMjtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzMjtcbiAgICB9XG4gIH0pKCk7XG59KShjbGFzc25hbWVzKTtcbnZhciBjbGFzc05hbWVzID0gY2xhc3NuYW1lcy5leHBvcnRzO1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpXG4gICAgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleTIsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5MiA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5MikgPj0gMClcbiAgICAgIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXkyXSA9IHNvdXJjZVtrZXkyXTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKVxuICAgIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5MiwgaTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5MiA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkyKSA+PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5MikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleTJdID0gc291cmNlW2tleTJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gb3duS2V5cyQxKG9iamVjdDQsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzMiA9IE9iamVjdC5rZXlzKG9iamVjdDQpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3Q0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0NCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5czIucHVzaC5hcHBseShrZXlzMiwgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXMyO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIkMSh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpICUgMiA/IG93bktleXMkMShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbihrZXkyKSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkkMSh0YXJnZXQsIGtleTIsIHNvdXJjZVtrZXkyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24oa2V5Mikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5MiwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleTIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpXG4gICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpXG4gICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKVxuICAgIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mJDEobywgcDIpIHtcbiAgX3NldFByb3RvdHlwZU9mJDEgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mMihvMiwgcDMpIHtcbiAgICBvMi5fX3Byb3RvX18gPSBwMztcbiAgICByZXR1cm4gbzI7XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YkMShvLCBwMik7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKVxuICAgIF9zZXRQcm90b3R5cGVPZiQxKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZiQxKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mJDEgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YyKG8yKSB7XG4gICAgcmV0dXJuIG8yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YobzIpO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mJDEobyk7XG59XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge1xuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZTIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIF90eXBlb2YkMShvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuICByZXR1cm4gX3R5cGVvZiQxID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24ob2JqMikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqMjtcbiAgfSA6IGZ1bmN0aW9uKG9iajIpIHtcbiAgICByZXR1cm4gb2JqMiAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBvYmoyLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqMiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqMjtcbiAgfSwgX3R5cGVvZiQxKG9iaik7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYyKSB7XG4gIGlmIChzZWxmMiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG4gIHJldHVybiBzZWxmMjtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYyLCBjYWxsMikge1xuICBpZiAoY2FsbDIgJiYgKF90eXBlb2YkMShjYWxsMikgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwyID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGwyO1xuICB9IGVsc2UgaWYgKGNhbGwyICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZjIpO1xufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZiQxKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YkMSh0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKF9pID09IG51bGwpXG4gICAgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9zLCBfZTtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpXG4gICAgICAgIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZClcbiAgICAgICAgdGhyb3cgX2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfYXJyO1xufVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpXG4gICAgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuICByZXR1cm4gYXJyMjtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKVxuICAgIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbjIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobjIgPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcilcbiAgICBuMiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4yID09PSBcIk1hcFwiIHx8IG4yID09PSBcIlNldFwiKVxuICAgIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobjIgPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobjIpKVxuICAgIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuZnVuY3Rpb24gZmluZERPTU5vZGUobm9kZSkge1xuICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmV0dXJuIFJlYWN0RE9NLmZpbmRET01Ob2RlKG5vZGUpO1xufVxudmFyIHJlYWN0SXMgPSB7IGV4cG9ydHM6IHt9IH07XG52YXIgcmVhY3RJc19wcm9kdWN0aW9uX21pbiA9IHt9O1xuLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgYiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuZm9yLCBjID0gYiA/IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpIDogNjAxMDMsIGQgPSBiID8gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSA6IDYwMTA2LCBlID0gYiA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSA6IDYwMTA3LCBmJDEgPSBiID8gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpIDogNjAxMDgsIGckMSA9IGIgPyBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIikgOiA2MDExNCwgaCQxID0gYiA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSA6IDYwMTA5LCBrID0gYiA/IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpIDogNjAxMTAsIGwgPSBiID8gU3ltYm9sLmZvcihcInJlYWN0LmFzeW5jX21vZGVcIikgOiA2MDExMSwgbSQxID0gYiA/IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIikgOiA2MDExMSwgbiQxID0gYiA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSA6IDYwMTEyLCBwJDEgPSBiID8gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpIDogNjAxMTMsIHEkMSA9IGIgPyBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSA6IDYwMTIwLCByID0gYiA/IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpIDogNjAxMTUsIHQgPSBiID8gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIikgOiA2MDExNiwgdiA9IGIgPyBTeW1ib2wuZm9yKFwicmVhY3QuYmxvY2tcIikgOiA2MDEyMSwgdyA9IGIgPyBTeW1ib2wuZm9yKFwicmVhY3QuZnVuZGFtZW50YWxcIikgOiA2MDExNywgeCA9IGIgPyBTeW1ib2wuZm9yKFwicmVhY3QucmVzcG9uZGVyXCIpIDogNjAxMTgsIHkgPSBiID8gU3ltYm9sLmZvcihcInJlYWN0LnNjb3BlXCIpIDogNjAxMTk7XG5mdW5jdGlvbiB6KGEpIHtcbiAgaWYgKHR5cGVvZiBhID09PSBcIm9iamVjdFwiICYmIGEgIT09IG51bGwpIHtcbiAgICB2YXIgdSA9IGEuJCR0eXBlb2Y7XG4gICAgc3dpdGNoICh1KSB7XG4gICAgICBjYXNlIGM6XG4gICAgICAgIHN3aXRjaCAoYSA9IGEudHlwZSwgYSkge1xuICAgICAgICAgIGNhc2UgbDpcbiAgICAgICAgICBjYXNlIG0kMTpcbiAgICAgICAgICBjYXNlIGU6XG4gICAgICAgICAgY2FzZSBnJDE6XG4gICAgICAgICAgY2FzZSBmJDE6XG4gICAgICAgICAgY2FzZSBwJDE6XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3dpdGNoIChhID0gYSAmJiBhLiQkdHlwZW9mLCBhKSB7XG4gICAgICAgICAgICAgIGNhc2UgazpcbiAgICAgICAgICAgICAgY2FzZSBuJDE6XG4gICAgICAgICAgICAgIGNhc2UgdDpcbiAgICAgICAgICAgICAgY2FzZSByOlxuICAgICAgICAgICAgICBjYXNlIGgkMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSBkOlxuICAgICAgICByZXR1cm4gdTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEEoYSkge1xuICByZXR1cm4geihhKSA9PT0gbSQxO1xufVxucmVhY3RJc19wcm9kdWN0aW9uX21pbi5Bc3luY01vZGUgPSBsO1xucmVhY3RJc19wcm9kdWN0aW9uX21pbi5Db25jdXJyZW50TW9kZSA9IG0kMTtcbnJlYWN0SXNfcHJvZHVjdGlvbl9taW4uQ29udGV4dENvbnN1bWVyID0gaztcbnJlYWN0SXNfcHJvZHVjdGlvbl9taW4uQ29udGV4dFByb3ZpZGVyID0gaCQxO1xucmVhY3RJc19wcm9kdWN0aW9uX21pbi5FbGVtZW50ID0gYztcbnJlYWN0SXNfcHJvZHVjdGlvbl9taW4uRm9yd2FyZFJlZiA9IG4kMTtcbnJlYWN0SXNfcHJvZHVjdGlvbl9taW4uRnJhZ21lbnQgPSBlO1xucmVhY3RJc19wcm9kdWN0aW9uX21pbi5MYXp5ID0gdDtcbnJlYWN0SXNfcHJvZHVjdGlvbl9taW4uTWVtbyA9IHI7XG5yZWFjdElzX3Byb2R1Y3Rpb25fbWluLlBvcnRhbCA9IGQ7XG5yZWFjdElzX3Byb2R1Y3Rpb25fbWluLlByb2ZpbGVyID0gZyQxO1xucmVhY3RJc19wcm9kdWN0aW9uX21pbi5TdHJpY3RNb2RlID0gZiQxO1xucmVhY3RJc19wcm9kdWN0aW9uX21pbi5TdXNwZW5zZSA9IHAkMTtcbnJlYWN0SXNfcHJvZHVjdGlvbl9taW4uaXNBc3luY01vZGUgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiBBKGEpIHx8IHooYSkgPT09IGw7XG59O1xucmVhY3RJc19wcm9kdWN0aW9uX21pbi5pc0NvbmN1cnJlbnRNb2RlID0gQTtcbnJlYWN0SXNfcHJvZHVjdGlvbl9taW4uaXNDb250ZXh0Q29uc3VtZXIgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiB6KGEpID09PSBrO1xufTtcbnJlYWN0SXNfcHJvZHVjdGlvbl9taW4uaXNDb250ZXh0UHJvdmlkZXIgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiB6KGEpID09PSBoJDE7XG59O1xucmVhY3RJc19wcm9kdWN0aW9uX21pbi5pc0VsZW1lbnQgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiB0eXBlb2YgYSA9PT0gXCJvYmplY3RcIiAmJiBhICE9PSBudWxsICYmIGEuJCR0eXBlb2YgPT09IGM7XG59O1xucmVhY3RJc19wcm9kdWN0aW9uX21pbi5pc0ZvcndhcmRSZWYgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiB6KGEpID09PSBuJDE7XG59O1xucmVhY3RJc19wcm9kdWN0aW9uX21pbi5pc0ZyYWdtZW50ID0gZnVuY3Rpb24oYSkge1xuICByZXR1cm4geihhKSA9PT0gZTtcbn07XG5yZWFjdElzX3Byb2R1Y3Rpb25fbWluLmlzTGF6eSA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIHooYSkgPT09IHQ7XG59O1xucmVhY3RJc19wcm9kdWN0aW9uX21pbi5pc01lbW8gPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiB6KGEpID09PSByO1xufTtcbnJlYWN0SXNfcHJvZHVjdGlvbl9taW4uaXNQb3J0YWwgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiB6KGEpID09PSBkO1xufTtcbnJlYWN0SXNfcHJvZHVjdGlvbl9taW4uaXNQcm9maWxlciA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIHooYSkgPT09IGckMTtcbn07XG5yZWFjdElzX3Byb2R1Y3Rpb25fbWluLmlzU3RyaWN0TW9kZSA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIHooYSkgPT09IGYkMTtcbn07XG5yZWFjdElzX3Byb2R1Y3Rpb25fbWluLmlzU3VzcGVuc2UgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiB6KGEpID09PSBwJDE7XG59O1xucmVhY3RJc19wcm9kdWN0aW9uX21pbi5pc1ZhbGlkRWxlbWVudFR5cGUgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiB0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgYSA9PT0gXCJmdW5jdGlvblwiIHx8IGEgPT09IGUgfHwgYSA9PT0gbSQxIHx8IGEgPT09IGckMSB8fCBhID09PSBmJDEgfHwgYSA9PT0gcCQxIHx8IGEgPT09IHEkMSB8fCB0eXBlb2YgYSA9PT0gXCJvYmplY3RcIiAmJiBhICE9PSBudWxsICYmIChhLiQkdHlwZW9mID09PSB0IHx8IGEuJCR0eXBlb2YgPT09IHIgfHwgYS4kJHR5cGVvZiA9PT0gaCQxIHx8IGEuJCR0eXBlb2YgPT09IGsgfHwgYS4kJHR5cGVvZiA9PT0gbiQxIHx8IGEuJCR0eXBlb2YgPT09IHcgfHwgYS4kJHR5cGVvZiA9PT0geCB8fCBhLiQkdHlwZW9mID09PSB5IHx8IGEuJCR0eXBlb2YgPT09IHYpO1xufTtcbnJlYWN0SXNfcHJvZHVjdGlvbl9taW4udHlwZU9mID0gejtcbntcbiAgcmVhY3RJcy5leHBvcnRzID0gcmVhY3RJc19wcm9kdWN0aW9uX21pbjtcbn1cbmZ1bmN0aW9uIHVzZU1lbW8oZ2V0VmFsdWUyLCBjb25kaXRpb24sIHNob3VsZFVwZGF0ZSkge1xuICB2YXIgY2FjaGVSZWYgPSBSZWFjdC51c2VSZWYoe30pO1xuICBpZiAoIShcInZhbHVlXCIgaW4gY2FjaGVSZWYuY3VycmVudCkgfHwgc2hvdWxkVXBkYXRlKGNhY2hlUmVmLmN1cnJlbnQuY29uZGl0aW9uLCBjb25kaXRpb24pKSB7XG4gICAgY2FjaGVSZWYuY3VycmVudC52YWx1ZSA9IGdldFZhbHVlMigpO1xuICAgIGNhY2hlUmVmLmN1cnJlbnQuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICB9XG4gIHJldHVybiBjYWNoZVJlZi5jdXJyZW50LnZhbHVlO1xufVxuZnVuY3Rpb24gZmlsbFJlZihyZWYsIG5vZGUpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJlZihub2RlKTtcbiAgfSBlbHNlIGlmIChfdHlwZW9mJDEocmVmKSA9PT0gXCJvYmplY3RcIiAmJiByZWYgJiYgXCJjdXJyZW50XCIgaW4gcmVmKSB7XG4gICAgcmVmLmN1cnJlbnQgPSBub2RlO1xuICB9XG59XG5mdW5jdGlvbiBjb21wb3NlUmVmKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVmcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICByZWZzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHZhciByZWZMaXN0ID0gcmVmcy5maWx0ZXIoZnVuY3Rpb24ocmVmKSB7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSk7XG4gIGlmIChyZWZMaXN0Lmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuIHJlZkxpc3RbMF07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZWZzLmZvckVhY2goZnVuY3Rpb24ocmVmKSB7XG4gICAgICBmaWxsUmVmKHJlZiwgbm9kZSk7XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBzdXBwb3J0UmVmKG5vZGVPckNvbXBvbmVudCkge1xuICB2YXIgX3R5cGUkcHJvdG90eXBlLCBfbm9kZU9yQ29tcG9uZW50JHByb3Q7XG4gIHZhciB0eXBlNCA9IHJlYWN0SXMuZXhwb3J0cy5pc01lbW8obm9kZU9yQ29tcG9uZW50KSA/IG5vZGVPckNvbXBvbmVudC50eXBlLnR5cGUgOiBub2RlT3JDb21wb25lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiB0eXBlNCA9PT0gXCJmdW5jdGlvblwiICYmICEoKF90eXBlJHByb3RvdHlwZSA9IHR5cGU0LnByb3RvdHlwZSkgPT09IG51bGwgfHwgX3R5cGUkcHJvdG90eXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdHlwZSRwcm90b3R5cGUucmVuZGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIG5vZGVPckNvbXBvbmVudCA9PT0gXCJmdW5jdGlvblwiICYmICEoKF9ub2RlT3JDb21wb25lbnQkcHJvdCA9IG5vZGVPckNvbXBvbmVudC5wcm90b3R5cGUpID09PSBudWxsIHx8IF9ub2RlT3JDb21wb25lbnQkcHJvdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGVPckNvbXBvbmVudCRwcm90LnJlbmRlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjYW5Vc2VEb20oKSB7XG4gIHJldHVybiAhISh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG59XG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuICBwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV0gPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcHJlZml4ZXNbXCJXZWJraXRcIi5jb25jYXQoc3R5bGVQcm9wKV0gPSBcIndlYmtpdFwiLmNvbmNhdChldmVudE5hbWUpO1xuICBwcmVmaXhlc1tcIk1velwiLmNvbmNhdChzdHlsZVByb3ApXSA9IFwibW96XCIuY29uY2F0KGV2ZW50TmFtZSk7XG4gIHByZWZpeGVzW1wibXNcIi5jb25jYXQoc3R5bGVQcm9wKV0gPSBcIk1TXCIuY29uY2F0KGV2ZW50TmFtZSk7XG4gIHByZWZpeGVzW1wiT1wiLmNvbmNhdChzdHlsZVByb3ApXSA9IFwib1wiLmNvbmNhdChldmVudE5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIHJldHVybiBwcmVmaXhlcztcbn1cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVzKGRvbVN1cHBvcnQsIHdpbikge1xuICB2YXIgcHJlZml4ZXMgPSB7XG4gICAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKFwiQW5pbWF0aW9uXCIsIFwiQW5pbWF0aW9uRW5kXCIpLFxuICAgIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoXCJUcmFuc2l0aW9uXCIsIFwiVHJhbnNpdGlvbkVuZFwiKVxuICB9O1xuICBpZiAoZG9tU3VwcG9ydCkge1xuICAgIGlmICghKFwiQW5pbWF0aW9uRXZlbnRcIiBpbiB3aW4pKSB7XG4gICAgICBkZWxldGUgcHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICB9XG4gICAgaWYgKCEoXCJUcmFuc2l0aW9uRXZlbnRcIiBpbiB3aW4pKSB7XG4gICAgICBkZWxldGUgcHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJlZml4ZXM7XG59XG52YXIgdmVuZG9yUHJlZml4ZXMgPSBnZXRWZW5kb3JQcmVmaXhlcyhjYW5Vc2VEb20oKSwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KTtcbnZhciBzdHlsZSA9IHt9O1xuaWYgKGNhblVzZURvbSgpKSB7XG4gIHZhciBfZG9jdW1lbnQkY3JlYXRlRWxlbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBzdHlsZSA9IF9kb2N1bWVudCRjcmVhdGVFbGVtZS5zdHlsZTtcbn1cbnZhciBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fTtcbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH1cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG4gIGlmIChwcmVmaXhNYXApIHtcbiAgICB2YXIgc3R5bGVQcm9wTGlzdCA9IE9iamVjdC5rZXlzKHByZWZpeE1hcCk7XG4gICAgdmFyIGxlbiA9IHN0eWxlUHJvcExpc3QubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHZhciBzdHlsZVByb3AgPSBzdHlsZVByb3BMaXN0W2ldO1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcmVmaXhNYXAsIHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICAgIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdID0gcHJlZml4TWFwW3N0eWxlUHJvcF07XG4gICAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG52YXIgaW50ZXJuYWxBbmltYXRpb25FbmROYW1lID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoXCJhbmltYXRpb25lbmRcIik7XG52YXIgaW50ZXJuYWxUcmFuc2l0aW9uRW5kTmFtZSA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwidHJhbnNpdGlvbmVuZFwiKTtcbnZhciBzdXBwb3J0VHJhbnNpdGlvbiA9ICEhKGludGVybmFsQW5pbWF0aW9uRW5kTmFtZSAmJiBpbnRlcm5hbFRyYW5zaXRpb25FbmROYW1lKTtcbnZhciBhbmltYXRpb25FbmROYW1lID0gaW50ZXJuYWxBbmltYXRpb25FbmROYW1lIHx8IFwiYW5pbWF0aW9uZW5kXCI7XG52YXIgdHJhbnNpdGlvbkVuZE5hbWUgPSBpbnRlcm5hbFRyYW5zaXRpb25FbmROYW1lIHx8IFwidHJhbnNpdGlvbmVuZFwiO1xuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbk5hbWUkMih0cmFuc2l0aW9uTmFtZTIsIHRyYW5zaXRpb25UeXBlKSB7XG4gIGlmICghdHJhbnNpdGlvbk5hbWUyKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoX3R5cGVvZiQxKHRyYW5zaXRpb25OYW1lMikgPT09IFwib2JqZWN0XCIpIHtcbiAgICB2YXIgdHlwZTQgPSB0cmFuc2l0aW9uVHlwZS5yZXBsYWNlKC8tXFx3L2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2hbMV0udG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk5hbWUyW3R5cGU0XTtcbiAgfVxuICByZXR1cm4gXCJcIi5jb25jYXQodHJhbnNpdGlvbk5hbWUyLCBcIi1cIikuY29uY2F0KHRyYW5zaXRpb25UeXBlKTtcbn1cbnZhciBTVEFUVVNfTk9ORSA9IFwibm9uZVwiO1xudmFyIFNUQVRVU19BUFBFQVIgPSBcImFwcGVhclwiO1xudmFyIFNUQVRVU19FTlRFUiA9IFwiZW50ZXJcIjtcbnZhciBTVEFUVVNfTEVBVkUgPSBcImxlYXZlXCI7XG52YXIgU1RFUF9OT05FID0gXCJub25lXCI7XG52YXIgU1RFUF9QUkVQQVJFID0gXCJwcmVwYXJlXCI7XG52YXIgU1RFUF9TVEFSVCA9IFwic3RhcnRcIjtcbnZhciBTVEVQX0FDVElWRSA9IFwiYWN0aXZlXCI7XG52YXIgU1RFUF9BQ1RJVkFURUQgPSBcImVuZFwiO1xuZnVuY3Rpb24gdXNlTW91bnRTdGF0dXMoZGVmYXVsdFZhbHVlKSB7XG4gIHZhciBkZXN0cm95UmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKGRlZmF1bHRWYWx1ZSksIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLCB2YWwgPSBfdXNlU3RhdGUyWzBdLCBzZXRWYWwgPSBfdXNlU3RhdGUyWzFdO1xuICBmdW5jdGlvbiBzZXRWYWx1ZTIobmV4dCkge1xuICAgIGlmICghZGVzdHJveVJlZi5jdXJyZW50KSB7XG4gICAgICBzZXRWYWwobmV4dCk7XG4gICAgfVxuICB9XG4gIHVzZUVmZmVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBkZXN0cm95UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFt2YWwsIHNldFZhbHVlMl07XG59XG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGNhblVzZURvbSgpID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xudmFyIHJhZiA9IGZ1bmN0aW9uIHJhZjIoY2FsbGJhY2spIHtcbiAgcmV0dXJuICtzZXRUaW1lb3V0KGNhbGxiYWNrLCAxNik7XG59O1xudmFyIGNhZiA9IGZ1bmN0aW9uIGNhZjIobnVtKSB7XG4gIHJldHVybiBjbGVhclRpbWVvdXQobnVtKTtcbn07XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiIGluIHdpbmRvdykge1xuICByYWYgPSBmdW5jdGlvbiByYWYzKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICB9O1xuICBjYWYgPSBmdW5jdGlvbiBjYWYzKGhhbmRsZSkge1xuICAgIHJldHVybiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgfTtcbn1cbnZhciByYWZVVUlEID0gMDtcbnZhciByYWZJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gY2xlYW51cChpZDIpIHtcbiAgcmFmSWRzLmRlbGV0ZShpZDIpO1xufVxuZnVuY3Rpb24gd3JhcHBlclJhZiQxKGNhbGxiYWNrKSB7XG4gIHZhciB0aW1lcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogMTtcbiAgcmFmVVVJRCArPSAxO1xuICB2YXIgaWQyID0gcmFmVVVJRDtcbiAgZnVuY3Rpb24gY2FsbFJlZihsZWZ0VGltZXMpIHtcbiAgICBpZiAobGVmdFRpbWVzID09PSAwKSB7XG4gICAgICBjbGVhbnVwKGlkMik7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVhbElkID0gcmFmKGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsUmVmKGxlZnRUaW1lcyAtIDEpO1xuICAgICAgfSk7XG4gICAgICByYWZJZHMuc2V0KGlkMiwgcmVhbElkKTtcbiAgICB9XG4gIH1cbiAgY2FsbFJlZih0aW1lcyk7XG4gIHJldHVybiBpZDI7XG59XG53cmFwcGVyUmFmJDEuY2FuY2VsID0gZnVuY3Rpb24oaWQyKSB7XG4gIHZhciByZWFsSWQgPSByYWZJZHMuZ2V0KGlkMik7XG4gIGNsZWFudXAocmVhbElkKTtcbiAgcmV0dXJuIGNhZihyZWFsSWQpO1xufTtcbnZhciB1c2VOZXh0RnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5leHRGcmFtZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgZnVuY3Rpb24gY2FuY2VsTmV4dEZyYW1lKCkge1xuICAgIHdyYXBwZXJSYWYkMS5jYW5jZWwobmV4dEZyYW1lUmVmLmN1cnJlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIG5leHRGcmFtZShjYWxsYmFjaykge1xuICAgIHZhciBkZWxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogMjtcbiAgICBjYW5jZWxOZXh0RnJhbWUoKTtcbiAgICB2YXIgbmV4dEZyYW1lSWQgPSB3cmFwcGVyUmFmJDEoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZGVsYXkgPD0gMSkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgaXNDYW5jZWxlZDogZnVuY3Rpb24gaXNDYW5jZWxlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0RnJhbWVJZCAhPT0gbmV4dEZyYW1lUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRGcmFtZShjYWxsYmFjaywgZGVsYXkgLSAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBuZXh0RnJhbWVSZWYuY3VycmVudCA9IG5leHRGcmFtZUlkO1xuICB9XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjYW5jZWxOZXh0RnJhbWUoKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBbbmV4dEZyYW1lLCBjYW5jZWxOZXh0RnJhbWVdO1xufTtcbnZhciBTVEVQX1FVRVVFID0gW1NURVBfUFJFUEFSRSwgU1RFUF9TVEFSVCwgU1RFUF9BQ1RJVkUsIFNURVBfQUNUSVZBVEVEXTtcbnZhciBTa2lwU3RlcCA9IGZhbHNlO1xudmFyIERvU3RlcCA9IHRydWU7XG5mdW5jdGlvbiBpc0FjdGl2ZShzdGVwKSB7XG4gIHJldHVybiBzdGVwID09PSBTVEVQX0FDVElWRSB8fCBzdGVwID09PSBTVEVQX0FDVElWQVRFRDtcbn1cbnZhciB1c2VTdGVwUXVldWUgPSBmdW5jdGlvbihzdGF0dXMsIGNhbGxiYWNrKSB7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VNb3VudFN0YXR1cyhTVEVQX05PTkUpLCBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSwgc3RlcCA9IF91c2VTdGF0ZTJbMF0sIHNldFN0ZXAgPSBfdXNlU3RhdGUyWzFdO1xuICB2YXIgX3VzZU5leHRGcmFtZSA9IHVzZU5leHRGcmFtZSgpLCBfdXNlTmV4dEZyYW1lMiA9IF9zbGljZWRUb0FycmF5KF91c2VOZXh0RnJhbWUsIDIpLCBuZXh0RnJhbWUgPSBfdXNlTmV4dEZyYW1lMlswXSwgY2FuY2VsTmV4dEZyYW1lID0gX3VzZU5leHRGcmFtZTJbMV07XG4gIGZ1bmN0aW9uIHN0YXJ0UXVldWUoKSB7XG4gICAgc2V0U3RlcChTVEVQX1BSRVBBUkUpO1xuICB9XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHN0ZXAgIT09IFNURVBfTk9ORSAmJiBzdGVwICE9PSBTVEVQX0FDVElWQVRFRCkge1xuICAgICAgdmFyIGluZGV4MiA9IFNURVBfUVVFVUUuaW5kZXhPZihzdGVwKTtcbiAgICAgIHZhciBuZXh0U3RlcCA9IFNURVBfUVVFVUVbaW5kZXgyICsgMV07XG4gICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soc3RlcCk7XG4gICAgICBpZiAocmVzdWx0ID09PSBTa2lwU3RlcCkge1xuICAgICAgICBzZXRTdGVwKG5leHRTdGVwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRGcmFtZShmdW5jdGlvbihpbmZvKSB7XG4gICAgICAgICAgZnVuY3Rpb24gZG9OZXh0KCkge1xuICAgICAgICAgICAgaWYgKGluZm8uaXNDYW5jZWxlZCgpKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZXRTdGVwKG5leHRTdGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZG9OZXh0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4oZG9OZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW3N0YXR1cywgc3RlcF0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY2FuY2VsTmV4dEZyYW1lKCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gW3N0YXJ0UXVldWUsIHN0ZXBdO1xufTtcbnZhciB1c2VEb21Nb3Rpb25FdmVudHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgY2FjaGVFbGVtZW50UmVmID0gdXNlUmVmKCk7XG4gIHZhciBjYWxsYmFja1JlZiA9IHVzZVJlZihjYWxsYmFjayk7XG4gIGNhbGxiYWNrUmVmLmN1cnJlbnQgPSBjYWxsYmFjaztcbiAgdmFyIG9uSW50ZXJuYWxNb3Rpb25FbmQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbihldmVudCkge1xuICAgIGNhbGxiYWNrUmVmLmN1cnJlbnQoZXZlbnQpO1xuICB9LCBbXSk7XG4gIGZ1bmN0aW9uIHJlbW92ZU1vdGlvbkV2ZW50cyhlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kTmFtZSwgb25JbnRlcm5hbE1vdGlvbkVuZCk7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoYW5pbWF0aW9uRW5kTmFtZSwgb25JbnRlcm5hbE1vdGlvbkVuZCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhdGNoTW90aW9uRXZlbnRzKGVsZW1lbnQpIHtcbiAgICBpZiAoY2FjaGVFbGVtZW50UmVmLmN1cnJlbnQgJiYgY2FjaGVFbGVtZW50UmVmLmN1cnJlbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgIHJlbW92ZU1vdGlvbkV2ZW50cyhjYWNoZUVsZW1lbnRSZWYuY3VycmVudCk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQgIT09IGNhY2hlRWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZE5hbWUsIG9uSW50ZXJuYWxNb3Rpb25FbmQpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGFuaW1hdGlvbkVuZE5hbWUsIG9uSW50ZXJuYWxNb3Rpb25FbmQpO1xuICAgICAgY2FjaGVFbGVtZW50UmVmLmN1cnJlbnQgPSBlbGVtZW50O1xuICAgIH1cbiAgfVxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmVtb3ZlTW90aW9uRXZlbnRzKGNhY2hlRWxlbWVudFJlZi5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBbcGF0Y2hNb3Rpb25FdmVudHMsIHJlbW92ZU1vdGlvbkV2ZW50c107XG59O1xuZnVuY3Rpb24gdXNlU3RhdHVzKHN1cHBvcnRNb3Rpb24sIHZpc2libGUsIGdldEVsZW1lbnQyLCBfcmVmKSB7XG4gIHZhciBfcmVmJG1vdGlvbkVudGVyID0gX3JlZi5tb3Rpb25FbnRlciwgbW90aW9uRW50ZXIgPSBfcmVmJG1vdGlvbkVudGVyID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRtb3Rpb25FbnRlciwgX3JlZiRtb3Rpb25BcHBlYXIgPSBfcmVmLm1vdGlvbkFwcGVhciwgbW90aW9uQXBwZWFyID0gX3JlZiRtb3Rpb25BcHBlYXIgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJG1vdGlvbkFwcGVhciwgX3JlZiRtb3Rpb25MZWF2ZSA9IF9yZWYubW90aW9uTGVhdmUsIG1vdGlvbkxlYXZlID0gX3JlZiRtb3Rpb25MZWF2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkbW90aW9uTGVhdmUsIG1vdGlvbkRlYWRsaW5lID0gX3JlZi5tb3Rpb25EZWFkbGluZSwgbW90aW9uTGVhdmVJbW1lZGlhdGVseSA9IF9yZWYubW90aW9uTGVhdmVJbW1lZGlhdGVseSwgb25BcHBlYXJQcmVwYXJlID0gX3JlZi5vbkFwcGVhclByZXBhcmUsIG9uRW50ZXJQcmVwYXJlID0gX3JlZi5vbkVudGVyUHJlcGFyZSwgb25MZWF2ZVByZXBhcmUgPSBfcmVmLm9uTGVhdmVQcmVwYXJlLCBvbkFwcGVhclN0YXJ0ID0gX3JlZi5vbkFwcGVhclN0YXJ0LCBvbkVudGVyU3RhcnQgPSBfcmVmLm9uRW50ZXJTdGFydCwgb25MZWF2ZVN0YXJ0ID0gX3JlZi5vbkxlYXZlU3RhcnQsIG9uQXBwZWFyQWN0aXZlID0gX3JlZi5vbkFwcGVhckFjdGl2ZSwgb25FbnRlckFjdGl2ZSA9IF9yZWYub25FbnRlckFjdGl2ZSwgb25MZWF2ZUFjdGl2ZSA9IF9yZWYub25MZWF2ZUFjdGl2ZSwgb25BcHBlYXJFbmQgPSBfcmVmLm9uQXBwZWFyRW5kLCBvbkVudGVyRW5kID0gX3JlZi5vbkVudGVyRW5kLCBvbkxlYXZlRW5kID0gX3JlZi5vbkxlYXZlRW5kLCBvblZpc2libGVDaGFuZ2VkID0gX3JlZi5vblZpc2libGVDaGFuZ2VkO1xuICB2YXIgX3VzZVN0YXRlID0gdXNlTW91bnRTdGF0dXMoKSwgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksIGFzeW5jVmlzaWJsZSA9IF91c2VTdGF0ZTJbMF0sIHNldEFzeW5jVmlzaWJsZSA9IF91c2VTdGF0ZTJbMV07XG4gIHZhciBfdXNlU3RhdGUzID0gdXNlTW91bnRTdGF0dXMoU1RBVFVTX05PTkUpLCBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMiksIHN0YXR1cyA9IF91c2VTdGF0ZTRbMF0sIHNldFN0YXR1cyA9IF91c2VTdGF0ZTRbMV07XG4gIHZhciBfdXNlU3RhdGU1ID0gdXNlTW91bnRTdGF0dXMobnVsbCksIF91c2VTdGF0ZTYgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGU1LCAyKSwgc3R5bGUyID0gX3VzZVN0YXRlNlswXSwgc2V0U3R5bGUgPSBfdXNlU3RhdGU2WzFdO1xuICB2YXIgbW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIHZhciBkZWFkbGluZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGRlc3Ryb3llZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIHZhciBjYWNoZUVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGZ1bmN0aW9uIGdldERvbUVsZW1lbnQoKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBnZXRFbGVtZW50MigpO1xuICAgIHJldHVybiBlbGVtZW50IHx8IGNhY2hlRWxlbWVudFJlZi5jdXJyZW50O1xuICB9XG4gIHZhciBhY3RpdmVSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICBmdW5jdGlvbiBvbkludGVybmFsTW90aW9uRW5kKGV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBnZXREb21FbGVtZW50KCk7XG4gICAgaWYgKGV2ZW50ICYmICFldmVudC5kZWFkbGluZSAmJiBldmVudC50YXJnZXQgIT09IGVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNhbkVuZDtcbiAgICBpZiAoc3RhdHVzID09PSBTVEFUVVNfQVBQRUFSICYmIGFjdGl2ZVJlZi5jdXJyZW50KSB7XG4gICAgICBjYW5FbmQgPSBvbkFwcGVhckVuZCA9PT0gbnVsbCB8fCBvbkFwcGVhckVuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25BcHBlYXJFbmQoZWxlbWVudCwgZXZlbnQpO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBTVEFUVVNfRU5URVIgJiYgYWN0aXZlUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNhbkVuZCA9IG9uRW50ZXJFbmQgPT09IG51bGwgfHwgb25FbnRlckVuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25FbnRlckVuZChlbGVtZW50LCBldmVudCk7XG4gICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFNUQVRVU19MRUFWRSAmJiBhY3RpdmVSZWYuY3VycmVudCkge1xuICAgICAgY2FuRW5kID0gb25MZWF2ZUVuZCA9PT0gbnVsbCB8fCBvbkxlYXZlRW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkxlYXZlRW5kKGVsZW1lbnQsIGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGNhbkVuZCAhPT0gZmFsc2UgJiYgIWRlc3Ryb3llZFJlZi5jdXJyZW50KSB7XG4gICAgICBzZXRTdGF0dXMoU1RBVFVTX05PTkUpO1xuICAgICAgc2V0U3R5bGUobnVsbCk7XG4gICAgfVxuICB9XG4gIHZhciBfdXNlRG9tTW90aW9uRXZlbnRzID0gdXNlRG9tTW90aW9uRXZlbnRzKG9uSW50ZXJuYWxNb3Rpb25FbmQpLCBfdXNlRG9tTW90aW9uRXZlbnRzMiA9IF9zbGljZWRUb0FycmF5KF91c2VEb21Nb3Rpb25FdmVudHMsIDEpLCBwYXRjaE1vdGlvbkV2ZW50cyA9IF91c2VEb21Nb3Rpb25FdmVudHMyWzBdO1xuICB2YXIgZXZlbnRIYW5kbGVycyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9yZWYyLCBfcmVmMywgX3JlZjQ7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgU1RBVFVTX0FQUEVBUjpcbiAgICAgICAgcmV0dXJuIF9yZWYyID0ge30sIF9kZWZpbmVQcm9wZXJ0eSQxKF9yZWYyLCBTVEVQX1BSRVBBUkUsIG9uQXBwZWFyUHJlcGFyZSksIF9kZWZpbmVQcm9wZXJ0eSQxKF9yZWYyLCBTVEVQX1NUQVJULCBvbkFwcGVhclN0YXJ0KSwgX2RlZmluZVByb3BlcnR5JDEoX3JlZjIsIFNURVBfQUNUSVZFLCBvbkFwcGVhckFjdGl2ZSksIF9yZWYyO1xuICAgICAgY2FzZSBTVEFUVVNfRU5URVI6XG4gICAgICAgIHJldHVybiBfcmVmMyA9IHt9LCBfZGVmaW5lUHJvcGVydHkkMShfcmVmMywgU1RFUF9QUkVQQVJFLCBvbkVudGVyUHJlcGFyZSksIF9kZWZpbmVQcm9wZXJ0eSQxKF9yZWYzLCBTVEVQX1NUQVJULCBvbkVudGVyU3RhcnQpLCBfZGVmaW5lUHJvcGVydHkkMShfcmVmMywgU1RFUF9BQ1RJVkUsIG9uRW50ZXJBY3RpdmUpLCBfcmVmMztcbiAgICAgIGNhc2UgU1RBVFVTX0xFQVZFOlxuICAgICAgICByZXR1cm4gX3JlZjQgPSB7fSwgX2RlZmluZVByb3BlcnR5JDEoX3JlZjQsIFNURVBfUFJFUEFSRSwgb25MZWF2ZVByZXBhcmUpLCBfZGVmaW5lUHJvcGVydHkkMShfcmVmNCwgU1RFUF9TVEFSVCwgb25MZWF2ZVN0YXJ0KSwgX2RlZmluZVByb3BlcnR5JDEoX3JlZjQsIFNURVBfQUNUSVZFLCBvbkxlYXZlQWN0aXZlKSwgX3JlZjQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICB9LCBbc3RhdHVzXSk7XG4gIHZhciBfdXNlU3RlcFF1ZXVlID0gdXNlU3RlcFF1ZXVlKHN0YXR1cywgZnVuY3Rpb24obmV3U3RlcCkge1xuICAgIGlmIChuZXdTdGVwID09PSBTVEVQX1BSRVBBUkUpIHtcbiAgICAgIHZhciBvblByZXBhcmUgPSBldmVudEhhbmRsZXJzW1NURVBfUFJFUEFSRV07XG4gICAgICBpZiAoIW9uUHJlcGFyZSkge1xuICAgICAgICByZXR1cm4gU2tpcFN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gb25QcmVwYXJlKGdldERvbUVsZW1lbnQoKSk7XG4gICAgfVxuICAgIGlmIChzdGVwIGluIGV2ZW50SGFuZGxlcnMpIHtcbiAgICAgIHZhciBfZXZlbnRIYW5kbGVycyRzdGVwO1xuICAgICAgc2V0U3R5bGUoKChfZXZlbnRIYW5kbGVycyRzdGVwID0gZXZlbnRIYW5kbGVyc1tzdGVwXSkgPT09IG51bGwgfHwgX2V2ZW50SGFuZGxlcnMkc3RlcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2ZW50SGFuZGxlcnMkc3RlcC5jYWxsKGV2ZW50SGFuZGxlcnMsIGdldERvbUVsZW1lbnQoKSwgbnVsbCkpIHx8IG51bGwpO1xuICAgIH1cbiAgICBpZiAoc3RlcCA9PT0gU1RFUF9BQ1RJVkUpIHtcbiAgICAgIHBhdGNoTW90aW9uRXZlbnRzKGdldERvbUVsZW1lbnQoKSk7XG4gICAgICBpZiAobW90aW9uRGVhZGxpbmUgPiAwKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChkZWFkbGluZVJlZi5jdXJyZW50KTtcbiAgICAgICAgZGVhZGxpbmVSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgb25JbnRlcm5hbE1vdGlvbkVuZCh7XG4gICAgICAgICAgICBkZWFkbGluZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBtb3Rpb25EZWFkbGluZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBEb1N0ZXA7XG4gIH0pLCBfdXNlU3RlcFF1ZXVlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGVwUXVldWUsIDIpLCBzdGFydFN0ZXAgPSBfdXNlU3RlcFF1ZXVlMlswXSwgc3RlcCA9IF91c2VTdGVwUXVldWUyWzFdO1xuICB2YXIgYWN0aXZlID0gaXNBY3RpdmUoc3RlcCk7XG4gIGFjdGl2ZVJlZi5jdXJyZW50ID0gYWN0aXZlO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgIHNldEFzeW5jVmlzaWJsZSh2aXNpYmxlKTtcbiAgICB2YXIgaXNNb3VudGVkID0gbW91bnRlZFJlZi5jdXJyZW50O1xuICAgIG1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgaWYgKCFzdXBwb3J0TW90aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXh0U3RhdHVzO1xuICAgIGlmICghaXNNb3VudGVkICYmIHZpc2libGUgJiYgbW90aW9uQXBwZWFyKSB7XG4gICAgICBuZXh0U3RhdHVzID0gU1RBVFVTX0FQUEVBUjtcbiAgICB9XG4gICAgaWYgKGlzTW91bnRlZCAmJiB2aXNpYmxlICYmIG1vdGlvbkVudGVyKSB7XG4gICAgICBuZXh0U3RhdHVzID0gU1RBVFVTX0VOVEVSO1xuICAgIH1cbiAgICBpZiAoaXNNb3VudGVkICYmICF2aXNpYmxlICYmIG1vdGlvbkxlYXZlIHx8ICFpc01vdW50ZWQgJiYgbW90aW9uTGVhdmVJbW1lZGlhdGVseSAmJiAhdmlzaWJsZSAmJiBtb3Rpb25MZWF2ZSkge1xuICAgICAgbmV4dFN0YXR1cyA9IFNUQVRVU19MRUFWRTtcbiAgICB9XG4gICAgaWYgKG5leHRTdGF0dXMpIHtcbiAgICAgIHNldFN0YXR1cyhuZXh0U3RhdHVzKTtcbiAgICAgIHN0YXJ0U3RlcCgpO1xuICAgIH1cbiAgfSwgW3Zpc2libGVdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgIGlmIChzdGF0dXMgPT09IFNUQVRVU19BUFBFQVIgJiYgIW1vdGlvbkFwcGVhciB8fCBzdGF0dXMgPT09IFNUQVRVU19FTlRFUiAmJiAhbW90aW9uRW50ZXIgfHwgc3RhdHVzID09PSBTVEFUVVNfTEVBVkUgJiYgIW1vdGlvbkxlYXZlKSB7XG4gICAgICBzZXRTdGF0dXMoU1RBVFVTX05PTkUpO1xuICAgIH1cbiAgfSwgW21vdGlvbkFwcGVhciwgbW90aW9uRW50ZXIsIG1vdGlvbkxlYXZlXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZGVhZGxpbmVSZWYuY3VycmVudCk7XG4gICAgICBkZXN0cm95ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24oKSB7XG4gICAgaWYgKGFzeW5jVmlzaWJsZSAhPT0gdm9pZCAwICYmIHN0YXR1cyA9PT0gU1RBVFVTX05PTkUpIHtcbiAgICAgIG9uVmlzaWJsZUNoYW5nZWQgPT09IG51bGwgfHwgb25WaXNpYmxlQ2hhbmdlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25WaXNpYmxlQ2hhbmdlZChhc3luY1Zpc2libGUpO1xuICAgIH1cbiAgfSwgW2FzeW5jVmlzaWJsZSwgc3RhdHVzXSk7XG4gIHZhciBtZXJnZWRTdHlsZSA9IHN0eWxlMjtcbiAgaWYgKGV2ZW50SGFuZGxlcnNbU1RFUF9QUkVQQVJFXSAmJiBzdGVwID09PSBTVEVQX1NUQVJUKSB7XG4gICAgbWVyZ2VkU3R5bGUgPSBfb2JqZWN0U3ByZWFkMiQxKHtcbiAgICAgIHRyYW5zaXRpb246IFwibm9uZVwiXG4gICAgfSwgbWVyZ2VkU3R5bGUpO1xuICB9XG4gIHJldHVybiBbc3RhdHVzLCBzdGVwLCBtZXJnZWRTdHlsZSwgYXN5bmNWaXNpYmxlICE9PSBudWxsICYmIGFzeW5jVmlzaWJsZSAhPT0gdm9pZCAwID8gYXN5bmNWaXNpYmxlIDogdmlzaWJsZV07XG59XG52YXIgRG9tV3JhcHBlciQxID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKERvbVdyYXBwZXIyLCBfUmVhY3QkQ29tcG9uZW50KTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEb21XcmFwcGVyMik7XG4gIGZ1bmN0aW9uIERvbVdyYXBwZXIyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb21XcmFwcGVyMik7XG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhEb21XcmFwcGVyMiwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRG9tV3JhcHBlcjI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5mdW5jdGlvbiBnZW5DU1NNb3Rpb24oY29uZmlnKSB7XG4gIHZhciB0cmFuc2l0aW9uU3VwcG9ydCA9IGNvbmZpZztcbiAgaWYgKF90eXBlb2YkMShjb25maWcpID09PSBcIm9iamVjdFwiKSB7XG4gICAgdHJhbnNpdGlvblN1cHBvcnQgPSBjb25maWcudHJhbnNpdGlvblN1cHBvcnQ7XG4gIH1cbiAgZnVuY3Rpb24gaXNTdXBwb3J0VHJhbnNpdGlvbihwcm9wcykge1xuICAgIHJldHVybiAhIShwcm9wcy5tb3Rpb25OYW1lICYmIHRyYW5zaXRpb25TdXBwb3J0KTtcbiAgfVxuICB2YXIgQ1NTTW90aW9uMiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uKHByb3BzLCByZWYpIHtcbiAgICB2YXIgX3Byb3BzJHZpc2libGUgPSBwcm9wcy52aXNpYmxlLCB2aXNpYmxlID0gX3Byb3BzJHZpc2libGUgPT09IHZvaWQgMCA/IHRydWUgOiBfcHJvcHMkdmlzaWJsZSwgX3Byb3BzJHJlbW92ZU9uTGVhdmUgPSBwcm9wcy5yZW1vdmVPbkxlYXZlLCByZW1vdmVPbkxlYXZlID0gX3Byb3BzJHJlbW92ZU9uTGVhdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfcHJvcHMkcmVtb3ZlT25MZWF2ZSwgZm9yY2VSZW5kZXIgPSBwcm9wcy5mb3JjZVJlbmRlciwgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbiwgbW90aW9uTmFtZSA9IHByb3BzLm1vdGlvbk5hbWUsIGxlYXZlZENsYXNzTmFtZSA9IHByb3BzLmxlYXZlZENsYXNzTmFtZSwgZXZlbnRQcm9wcyA9IHByb3BzLmV2ZW50UHJvcHM7XG4gICAgdmFyIHN1cHBvcnRNb3Rpb24gPSBpc1N1cHBvcnRUcmFuc2l0aW9uKHByb3BzKTtcbiAgICB2YXIgbm9kZVJlZiA9IHVzZVJlZigpO1xuICAgIHZhciB3cmFwcGVyTm9kZVJlZiA9IHVzZVJlZigpO1xuICAgIGZ1bmN0aW9uIGdldERvbUVsZW1lbnQoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbm9kZVJlZi5jdXJyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBub2RlUmVmLmN1cnJlbnQgOiBmaW5kRE9NTm9kZSh3cmFwcGVyTm9kZVJlZi5jdXJyZW50KTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgX3VzZVN0YXR1cyA9IHVzZVN0YXR1cyhzdXBwb3J0TW90aW9uLCB2aXNpYmxlLCBnZXREb21FbGVtZW50LCBwcm9wcyksIF91c2VTdGF0dXMyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXR1cywgNCksIHN0YXR1cyA9IF91c2VTdGF0dXMyWzBdLCBzdGF0dXNTdGVwID0gX3VzZVN0YXR1czJbMV0sIHN0YXR1c1N0eWxlID0gX3VzZVN0YXR1czJbMl0sIG1lcmdlZFZpc2libGUgPSBfdXNlU3RhdHVzMlszXTtcbiAgICB2YXIgcmVuZGVyZWRSZWYgPSBSZWFjdC51c2VSZWYobWVyZ2VkVmlzaWJsZSk7XG4gICAgaWYgKG1lcmdlZFZpc2libGUpIHtcbiAgICAgIHJlbmRlcmVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgc2V0Tm9kZVJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBmaWxsUmVmKHJlZiwgbm9kZSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBtb3Rpb25DaGlsZHJlbjtcbiAgICB2YXIgbWVyZ2VkUHJvcHMgPSBfb2JqZWN0U3ByZWFkMiQxKF9vYmplY3RTcHJlYWQyJDEoe30sIGV2ZW50UHJvcHMpLCB7fSwge1xuICAgICAgdmlzaWJsZVxuICAgIH0pO1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIG1vdGlvbkNoaWxkcmVuID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gU1RBVFVTX05PTkUgfHwgIWlzU3VwcG9ydFRyYW5zaXRpb24ocHJvcHMpKSB7XG4gICAgICBpZiAobWVyZ2VkVmlzaWJsZSkge1xuICAgICAgICBtb3Rpb25DaGlsZHJlbiA9IGNoaWxkcmVuKF9vYmplY3RTcHJlYWQyJDEoe30sIG1lcmdlZFByb3BzKSwgc2V0Tm9kZVJlZik7XG4gICAgICB9IGVsc2UgaWYgKCFyZW1vdmVPbkxlYXZlICYmIHJlbmRlcmVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgbW90aW9uQ2hpbGRyZW4gPSBjaGlsZHJlbihfb2JqZWN0U3ByZWFkMiQxKF9vYmplY3RTcHJlYWQyJDEoe30sIG1lcmdlZFByb3BzKSwge30sIHtcbiAgICAgICAgICBjbGFzc05hbWU6IGxlYXZlZENsYXNzTmFtZVxuICAgICAgICB9KSwgc2V0Tm9kZVJlZik7XG4gICAgICB9IGVsc2UgaWYgKGZvcmNlUmVuZGVyKSB7XG4gICAgICAgIG1vdGlvbkNoaWxkcmVuID0gY2hpbGRyZW4oX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBtZXJnZWRQcm9wcyksIHt9LCB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgICAgICAgfVxuICAgICAgICB9KSwgc2V0Tm9kZVJlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3Rpb25DaGlsZHJlbiA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY2xhc3NOYW1lcztcbiAgICAgIHZhciBzdGF0dXNTdWZmaXg7XG4gICAgICBpZiAoc3RhdHVzU3RlcCA9PT0gU1RFUF9QUkVQQVJFKSB7XG4gICAgICAgIHN0YXR1c1N1ZmZpeCA9IFwicHJlcGFyZVwiO1xuICAgICAgfSBlbHNlIGlmIChpc0FjdGl2ZShzdGF0dXNTdGVwKSkge1xuICAgICAgICBzdGF0dXNTdWZmaXggPSBcImFjdGl2ZVwiO1xuICAgICAgfSBlbHNlIGlmIChzdGF0dXNTdGVwID09PSBTVEVQX1NUQVJUKSB7XG4gICAgICAgIHN0YXR1c1N1ZmZpeCA9IFwic3RhcnRcIjtcbiAgICAgIH1cbiAgICAgIG1vdGlvbkNoaWxkcmVuID0gY2hpbGRyZW4oX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBtZXJnZWRQcm9wcyksIHt9LCB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhnZXRUcmFuc2l0aW9uTmFtZSQyKG1vdGlvbk5hbWUsIHN0YXR1cyksIChfY2xhc3NOYW1lcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lcywgZ2V0VHJhbnNpdGlvbk5hbWUkMihtb3Rpb25OYW1lLCBcIlwiLmNvbmNhdChzdGF0dXMsIFwiLVwiKS5jb25jYXQoc3RhdHVzU3VmZml4KSksIHN0YXR1c1N1ZmZpeCksIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzLCBtb3Rpb25OYW1lLCB0eXBlb2YgbW90aW9uTmFtZSA9PT0gXCJzdHJpbmdcIiksIF9jbGFzc05hbWVzKSksXG4gICAgICAgIHN0eWxlOiBzdGF0dXNTdHlsZVxuICAgICAgfSksIHNldE5vZGVSZWYpO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRG9tV3JhcHBlciQxLCB7XG4gICAgICByZWY6IHdyYXBwZXJOb2RlUmVmXG4gICAgfSwgbW90aW9uQ2hpbGRyZW4pO1xuICB9KTtcbiAgQ1NTTW90aW9uMi5kaXNwbGF5TmFtZSA9IFwiQ1NTTW90aW9uXCI7XG4gIHJldHVybiBDU1NNb3Rpb24yO1xufVxudmFyIENTU01vdGlvbiA9IGdlbkNTU01vdGlvbihzdXBwb3J0VHJhbnNpdGlvbik7XG52YXIgU1RBVFVTX0FERCA9IFwiYWRkXCI7XG52YXIgU1RBVFVTX0tFRVAgPSBcImtlZXBcIjtcbnZhciBTVEFUVVNfUkVNT1ZFID0gXCJyZW1vdmVcIjtcbnZhciBTVEFUVVNfUkVNT1ZFRCA9IFwicmVtb3ZlZFwiO1xuZnVuY3Rpb24gd3JhcEtleVRvT2JqZWN0KGtleTIpIHtcbiAgdmFyIGtleU9iajtcbiAgaWYgKGtleTIgJiYgX3R5cGVvZiQxKGtleTIpID09PSBcIm9iamVjdFwiICYmIFwia2V5XCIgaW4ga2V5Mikge1xuICAgIGtleU9iaiA9IGtleTI7XG4gIH0gZWxzZSB7XG4gICAga2V5T2JqID0ge1xuICAgICAga2V5OiBrZXkyXG4gICAgfTtcbiAgfVxuICByZXR1cm4gX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBrZXlPYmopLCB7fSwge1xuICAgIGtleTogU3RyaW5nKGtleU9iai5rZXkpXG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VLZXlzKCkge1xuICB2YXIga2V5czIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICByZXR1cm4ga2V5czIubWFwKHdyYXBLZXlUb09iamVjdCk7XG59XG5mdW5jdGlvbiBkaWZmS2V5cygpIHtcbiAgdmFyIHByZXZLZXlzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgdmFyIGN1cnJlbnRLZXlzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgdmFyIGxpc3QgPSBbXTtcbiAgdmFyIGN1cnJlbnRJbmRleCA9IDA7XG4gIHZhciBjdXJyZW50TGVuID0gY3VycmVudEtleXMubGVuZ3RoO1xuICB2YXIgcHJldktleU9iamVjdHMgPSBwYXJzZUtleXMocHJldktleXMpO1xuICB2YXIgY3VycmVudEtleU9iamVjdHMgPSBwYXJzZUtleXMoY3VycmVudEtleXMpO1xuICBwcmV2S2V5T2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKGtleU9iaikge1xuICAgIHZhciBoaXQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gY3VycmVudEluZGV4OyBpIDwgY3VycmVudExlbjsgaSArPSAxKSB7XG4gICAgICB2YXIgY3VycmVudEtleU9iaiA9IGN1cnJlbnRLZXlPYmplY3RzW2ldO1xuICAgICAgaWYgKGN1cnJlbnRLZXlPYmoua2V5ID09PSBrZXlPYmoua2V5KSB7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPCBpKSB7XG4gICAgICAgICAgbGlzdCA9IGxpc3QuY29uY2F0KGN1cnJlbnRLZXlPYmplY3RzLnNsaWNlKGN1cnJlbnRJbmRleCwgaSkubWFwKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwgb2JqKSwge30sIHtcbiAgICAgICAgICAgICAgc3RhdHVzOiBTVEFUVVNfQUREXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgY3VycmVudEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0LnB1c2goX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBjdXJyZW50S2V5T2JqKSwge30sIHtcbiAgICAgICAgICBzdGF0dXM6IFNUQVRVU19LRUVQXG4gICAgICAgIH0pKTtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IDE7XG4gICAgICAgIGhpdCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWhpdCkge1xuICAgICAgbGlzdC5wdXNoKF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwga2V5T2JqKSwge30sIHtcbiAgICAgICAgc3RhdHVzOiBTVEFUVVNfUkVNT1ZFXG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcbiAgaWYgKGN1cnJlbnRJbmRleCA8IGN1cnJlbnRMZW4pIHtcbiAgICBsaXN0ID0gbGlzdC5jb25jYXQoY3VycmVudEtleU9iamVjdHMuc2xpY2UoY3VycmVudEluZGV4KS5tYXAoZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBvYmopLCB7fSwge1xuICAgICAgICBzdGF0dXM6IFNUQVRVU19BRERcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfVxuICB2YXIga2V5czIgPSB7fTtcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uKF9yZWYpIHtcbiAgICB2YXIga2V5MiA9IF9yZWYua2V5O1xuICAgIGtleXMyW2tleTJdID0gKGtleXMyW2tleTJdIHx8IDApICsgMTtcbiAgfSk7XG4gIHZhciBkdXBsaWNhdGVkS2V5cyA9IE9iamVjdC5rZXlzKGtleXMyKS5maWx0ZXIoZnVuY3Rpb24oa2V5Mikge1xuICAgIHJldHVybiBrZXlzMltrZXkyXSA+IDE7XG4gIH0pO1xuICBkdXBsaWNhdGVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKG1hdGNoS2V5KSB7XG4gICAgbGlzdCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uKF9yZWYyKSB7XG4gICAgICB2YXIga2V5MiA9IF9yZWYyLmtleSwgc3RhdHVzID0gX3JlZjIuc3RhdHVzO1xuICAgICAgcmV0dXJuIGtleTIgIT09IG1hdGNoS2V5IHx8IHN0YXR1cyAhPT0gU1RBVFVTX1JFTU9WRTtcbiAgICB9KTtcbiAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUua2V5ID09PSBtYXRjaEtleSkge1xuICAgICAgICBub2RlLnN0YXR1cyA9IFNUQVRVU19LRUVQO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGxpc3Q7XG59XG52YXIgX2V4Y2x1ZGVkJDYgPSBbXCJjb21wb25lbnRcIiwgXCJjaGlsZHJlblwiLCBcIm9uVmlzaWJsZUNoYW5nZWRcIl0sIF9leGNsdWRlZDIgPSBbXCJzdGF0dXNcIl07XG52YXIgTU9USU9OX1BST1BfTkFNRVMgPSBbXCJldmVudFByb3BzXCIsIFwidmlzaWJsZVwiLCBcImNoaWxkcmVuXCIsIFwibW90aW9uTmFtZVwiLCBcIm1vdGlvbkFwcGVhclwiLCBcIm1vdGlvbkVudGVyXCIsIFwibW90aW9uTGVhdmVcIiwgXCJtb3Rpb25MZWF2ZUltbWVkaWF0ZWx5XCIsIFwibW90aW9uRGVhZGxpbmVcIiwgXCJyZW1vdmVPbkxlYXZlXCIsIFwibGVhdmVkQ2xhc3NOYW1lXCIsIFwib25BcHBlYXJTdGFydFwiLCBcIm9uQXBwZWFyQWN0aXZlXCIsIFwib25BcHBlYXJFbmRcIiwgXCJvbkVudGVyU3RhcnRcIiwgXCJvbkVudGVyQWN0aXZlXCIsIFwib25FbnRlckVuZFwiLCBcIm9uTGVhdmVTdGFydFwiLCBcIm9uTGVhdmVBY3RpdmVcIiwgXCJvbkxlYXZlRW5kXCJdO1xuZnVuY3Rpb24gZ2VuQ1NTTW90aW9uTGlzdCh0cmFuc2l0aW9uU3VwcG9ydCkge1xuICB2YXIgQ1NTTW90aW9uJDEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IENTU01vdGlvbjtcbiAgdmFyIENTU01vdGlvbkxpc3QyID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoQ1NTTW90aW9uTGlzdDMsIF9SZWFjdCRDb21wb25lbnQpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQ1NTTW90aW9uTGlzdDMpO1xuICAgIGZ1bmN0aW9uIENTU01vdGlvbkxpc3QzKCkge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU01vdGlvbkxpc3QzKTtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgIGtleUVudGl0aWVzOiBbXVxuICAgICAgfTtcbiAgICAgIF90aGlzLnJlbW92ZUtleSA9IGZ1bmN0aW9uKHJlbW92ZUtleSkge1xuICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgICAgdmFyIGtleUVudGl0aWVzID0gX3JlZi5rZXlFbnRpdGllcztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5RW50aXRpZXM6IGtleUVudGl0aWVzLm1hcChmdW5jdGlvbihlbnRpdHkpIHtcbiAgICAgICAgICAgICAgaWYgKGVudGl0eS5rZXkgIT09IHJlbW92ZUtleSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBlbnRpdHkpLCB7fSwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogU1RBVFVTX1JFTU9WRURcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKENTU01vdGlvbkxpc3QzLCBbe1xuICAgICAga2V5OiBcInJlbmRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICAgIHZhciBrZXlFbnRpdGllcyA9IHRoaXMuc3RhdGUua2V5RW50aXRpZXM7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsIGNvbXBvbmVudCA9IF90aGlzJHByb3BzLmNvbXBvbmVudCwgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbiwgX29uVmlzaWJsZUNoYW5nZWQgPSBfdGhpcyRwcm9wcy5vblZpc2libGVDaGFuZ2VkLCByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHMsIF9leGNsdWRlZCQ2KTtcbiAgICAgICAgdmFyIENvbXBvbmVudDIgPSBjb21wb25lbnQgfHwgUmVhY3QuRnJhZ21lbnQ7XG4gICAgICAgIHZhciBtb3Rpb25Qcm9wcyA9IHt9O1xuICAgICAgICBNT1RJT05fUFJPUF9OQU1FUy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICBtb3Rpb25Qcm9wc1twcm9wXSA9IHJlc3RQcm9wc1twcm9wXTtcbiAgICAgICAgICBkZWxldGUgcmVzdFByb3BzW3Byb3BdO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIHJlc3RQcm9wcy5rZXlzO1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50MiwgcmVzdFByb3BzLCBrZXlFbnRpdGllcy5tYXAoZnVuY3Rpb24oX3JlZjIpIHtcbiAgICAgICAgICB2YXIgc3RhdHVzID0gX3JlZjIuc3RhdHVzLCBldmVudFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBfZXhjbHVkZWQyKTtcbiAgICAgICAgICB2YXIgdmlzaWJsZSA9IHN0YXR1cyA9PT0gU1RBVFVTX0FERCB8fCBzdGF0dXMgPT09IFNUQVRVU19LRUVQO1xuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDU1NNb3Rpb24kMSwgX2V4dGVuZHMkMSh7fSwgbW90aW9uUHJvcHMsIHtcbiAgICAgICAgICAgIGtleTogZXZlbnRQcm9wcy5rZXksXG4gICAgICAgICAgICB2aXNpYmxlLFxuICAgICAgICAgICAgZXZlbnRQcm9wcyxcbiAgICAgICAgICAgIG9uVmlzaWJsZUNoYW5nZWQ6IGZ1bmN0aW9uIG9uVmlzaWJsZUNoYW5nZWQoY2hhbmdlZFZpc2libGUpIHtcbiAgICAgICAgICAgICAgX29uVmlzaWJsZUNoYW5nZWQgPT09IG51bGwgfHwgX29uVmlzaWJsZUNoYW5nZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vblZpc2libGVDaGFuZ2VkKGNoYW5nZWRWaXNpYmxlLCB7XG4gICAgICAgICAgICAgICAga2V5OiBldmVudFByb3BzLmtleVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIF90aGlzMi5yZW1vdmVLZXkoZXZlbnRQcm9wcy5rZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNoaWxkcmVuKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhfcmVmMywgX3JlZjQpIHtcbiAgICAgICAgdmFyIGtleXMyID0gX3JlZjMua2V5cztcbiAgICAgICAgdmFyIGtleUVudGl0aWVzID0gX3JlZjQua2V5RW50aXRpZXM7XG4gICAgICAgIHZhciBwYXJzZWRLZXlPYmplY3RzID0gcGFyc2VLZXlzKGtleXMyKTtcbiAgICAgICAgdmFyIG1peGVkS2V5RW50aXRpZXMgPSBkaWZmS2V5cyhrZXlFbnRpdGllcywgcGFyc2VkS2V5T2JqZWN0cyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2V5RW50aXRpZXM6IG1peGVkS2V5RW50aXRpZXMuZmlsdGVyKGZ1bmN0aW9uKGVudGl0eSkge1xuICAgICAgICAgICAgdmFyIHByZXZFbnRpdHkgPSBrZXlFbnRpdGllcy5maW5kKGZ1bmN0aW9uKF9yZWY1KSB7XG4gICAgICAgICAgICAgIHZhciBrZXkyID0gX3JlZjUua2V5O1xuICAgICAgICAgICAgICByZXR1cm4gZW50aXR5LmtleSA9PT0ga2V5MjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHByZXZFbnRpdHkgJiYgcHJldkVudGl0eS5zdGF0dXMgPT09IFNUQVRVU19SRU1PVkVEICYmIGVudGl0eS5zdGF0dXMgPT09IFNUQVRVU19SRU1PVkUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIENTU01vdGlvbkxpc3QzO1xuICB9KFJlYWN0LkNvbXBvbmVudCk7XG4gIENTU01vdGlvbkxpc3QyLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21wb25lbnQ6IFwiZGl2XCJcbiAgfTtcbiAgcmV0dXJuIENTU01vdGlvbkxpc3QyO1xufVxudmFyIENTU01vdGlvbkxpc3QgPSBnZW5DU1NNb3Rpb25MaXN0KHN1cHBvcnRUcmFuc2l0aW9uKTtcbnZhciBOb3RpY2UgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTm90aWNlMiwgX0NvbXBvbmVudCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTm90aWNlMik7XG4gIGZ1bmN0aW9uIE5vdGljZTIoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb3RpY2UyKTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwuYXBwbHkoX3N1cGVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICBfdGhpcy5jbG9zZVRpbWVyID0gbnVsbDtcbiAgICBfdGhpcy5jbG9zZSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICBpZiAoZTIpIHtcbiAgICAgICAgZTIuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBfdGhpcy5jbGVhckNsb3NlVGltZXIoKTtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLCBvbkNsb3NlMiA9IF90aGlzJHByb3BzLm9uQ2xvc2UsIG5vdGljZUtleSA9IF90aGlzJHByb3BzLm5vdGljZUtleTtcbiAgICAgIGlmIChvbkNsb3NlMikge1xuICAgICAgICBvbkNsb3NlMihub3RpY2VLZXkpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3RoaXMuc3RhcnRDbG9zZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuZHVyYXRpb24pIHtcbiAgICAgICAgX3RoaXMuY2xvc2VUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgIH0sIF90aGlzLnByb3BzLmR1cmF0aW9uICogMWUzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF90aGlzLmNsZWFyQ2xvc2VUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKF90aGlzLmNsb3NlVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmNsb3NlVGltZXIpO1xuICAgICAgICBfdGhpcy5jbG9zZVRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoTm90aWNlMiwgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLnN0YXJ0Q2xvc2VUaW1lcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgaWYgKHRoaXMucHJvcHMuZHVyYXRpb24gIT09IHByZXZQcm9wcy5kdXJhdGlvbiB8fCB0aGlzLnByb3BzLnVwZGF0ZU1hcmsgIT09IHByZXZQcm9wcy51cGRhdGVNYXJrIHx8IHRoaXMucHJvcHMudmlzaWJsZSAhPT0gcHJldlByb3BzLnZpc2libGUgJiYgdGhpcy5wcm9wcy52aXNpYmxlKSB7XG4gICAgICAgIHRoaXMucmVzdGFydENsb3NlVGltZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB0aGlzLmNsZWFyQ2xvc2VUaW1lcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXN0YXJ0Q2xvc2VUaW1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0YXJ0Q2xvc2VUaW1lcigpIHtcbiAgICAgIHRoaXMuY2xlYXJDbG9zZVRpbWVyKCk7XG4gICAgICB0aGlzLnN0YXJ0Q2xvc2VUaW1lcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcywgcHJlZml4Q2xzID0gX3RoaXMkcHJvcHMyLnByZWZpeENscywgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMyLmNsYXNzTmFtZSwgY2xvc2FibGUgPSBfdGhpcyRwcm9wczIuY2xvc2FibGUsIGNsb3NlSWNvbiA9IF90aGlzJHByb3BzMi5jbG9zZUljb24sIHN0eWxlMiA9IF90aGlzJHByb3BzMi5zdHlsZSwgb25DbGljayA9IF90aGlzJHByb3BzMi5vbkNsaWNrLCBjaGlsZHJlbiA9IF90aGlzJHByb3BzMi5jaGlsZHJlbiwgaG9sZGVyID0gX3RoaXMkcHJvcHMyLmhvbGRlcjtcbiAgICAgIHZhciBjb21wb25lbnRDbGFzcyA9IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItbm90aWNlXCIpO1xuICAgICAgdmFyIGRhdGFPckFyaWFBdHRyaWJ1dGVQcm9wcyA9IE9iamVjdC5rZXlzKHRoaXMucHJvcHMpLnJlZHVjZShmdW5jdGlvbihhY2MsIGtleTIpIHtcbiAgICAgICAgaWYgKGtleTIuc3Vic3RyKDAsIDUpID09PSBcImRhdGEtXCIgfHwga2V5Mi5zdWJzdHIoMCwgNSkgPT09IFwiYXJpYS1cIiB8fCBrZXkyID09PSBcInJvbGVcIikge1xuICAgICAgICAgIGFjY1trZXkyXSA9IF90aGlzMi5wcm9wc1trZXkyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgICAgdmFyIG5vZGUgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyQxKHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGNvbXBvbmVudENsYXNzLCBjbGFzc05hbWUsIF9kZWZpbmVQcm9wZXJ0eSQxKHt9LCBcIlwiLmNvbmNhdChjb21wb25lbnRDbGFzcywgXCItY2xvc2FibGVcIiksIGNsb3NhYmxlKSksXG4gICAgICAgIHN0eWxlOiBzdHlsZTIsXG4gICAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5jbGVhckNsb3NlVGltZXIsXG4gICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5zdGFydENsb3NlVGltZXIsXG4gICAgICAgIG9uQ2xpY2tcbiAgICAgIH0sIGRhdGFPckFyaWFBdHRyaWJ1dGVQcm9wcyksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChjb21wb25lbnRDbGFzcywgXCItY29udGVudFwiKVxuICAgICAgfSwgY2hpbGRyZW4pLCBjbG9zYWJsZSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7XG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICBvbkNsaWNrOiB0aGlzLmNsb3NlLFxuICAgICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KGNvbXBvbmVudENsYXNzLCBcIi1jbG9zZVwiKVxuICAgICAgfSwgY2xvc2VJY29uIHx8IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQoY29tcG9uZW50Q2xhc3MsIFwiLWNsb3NlLXhcIilcbiAgICAgIH0pKSA6IG51bGwpO1xuICAgICAgaWYgKGhvbGRlcikge1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChub2RlLCBob2xkZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOb3RpY2UyO1xufShDb21wb25lbnQpO1xuTm90aWNlLmRlZmF1bHRQcm9wcyA9IHtcbiAgb25DbG9zZTogZnVuY3Rpb24gb25DbG9zZSgpIHtcbiAgfSxcbiAgZHVyYXRpb246IDEuNVxufTtcbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSlcbiAgICByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKVxuICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIHVzZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb25JbnN0YW5jZTIpIHtcbiAgdmFyIGNyZWF0ZWRSZWYgPSBSZWFjdC51c2VSZWYoe30pO1xuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoW10pLCBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSwgZWxlbWVudHMgPSBfUmVhY3QkdXNlU3RhdGUyWzBdLCBzZXRFbGVtZW50cyA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG4gIGZ1bmN0aW9uIG5vdGlmeShub3RpY2VQcm9wcykge1xuICAgIHZhciBmaXJzdE1vdW50ID0gdHJ1ZTtcbiAgICBub3RpZmljYXRpb25JbnN0YW5jZTIuYWRkKG5vdGljZVByb3BzLCBmdW5jdGlvbihkaXYsIHByb3BzKSB7XG4gICAgICB2YXIga2V5MiA9IHByb3BzLmtleTtcbiAgICAgIGlmIChkaXYgJiYgKCFjcmVhdGVkUmVmLmN1cnJlbnRba2V5Ml0gfHwgZmlyc3RNb3VudCkpIHtcbiAgICAgICAgdmFyIG5vdGljZUVsZSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KE5vdGljZSwgX2V4dGVuZHMkMSh7fSwgcHJvcHMsIHtcbiAgICAgICAgICBob2xkZXI6IGRpdlxuICAgICAgICB9KSk7XG4gICAgICAgIGNyZWF0ZWRSZWYuY3VycmVudFtrZXkyXSA9IG5vdGljZUVsZTtcbiAgICAgICAgc2V0RWxlbWVudHMoZnVuY3Rpb24ob3JpZ2luRWxlbWVudHMpIHtcbiAgICAgICAgICB2YXIgaW5kZXgyID0gb3JpZ2luRWxlbWVudHMuZmluZEluZGV4KGZ1bmN0aW9uKGVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZS5rZXkgPT09IHByb3BzLmtleTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaW5kZXgyID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkob3JpZ2luRWxlbWVudHMpLCBbbm90aWNlRWxlXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjbG9uZUxpc3QgPSBfdG9Db25zdW1hYmxlQXJyYXkob3JpZ2luRWxlbWVudHMpO1xuICAgICAgICAgIGNsb25lTGlzdFtpbmRleDJdID0gbm90aWNlRWxlO1xuICAgICAgICAgIHJldHVybiBjbG9uZUxpc3Q7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZmlyc3RNb3VudCA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBbbm90aWZ5LCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgZWxlbWVudHMpXTtcbn1cbnZhciBzZWVkID0gMDtcbnZhciBub3cgPSBEYXRlLm5vdygpO1xuZnVuY3Rpb24gZ2V0VXVpZCgpIHtcbiAgdmFyIGlkMiA9IHNlZWQ7XG4gIHNlZWQgKz0gMTtcbiAgcmV0dXJuIFwicmNOb3RpZmljYXRpb25fXCIuY29uY2F0KG5vdywgXCJfXCIpLmNvbmNhdChpZDIpO1xufVxudmFyIE5vdGlmaWNhdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhOb3RpZmljYXRpb24yLCBfQ29tcG9uZW50KTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihOb3RpZmljYXRpb24yKTtcbiAgZnVuY3Rpb24gTm90aWZpY2F0aW9uMigpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vdGlmaWNhdGlvbjIpO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgbm90aWNlczogW11cbiAgICB9O1xuICAgIF90aGlzLmhvb2tSZWZzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBfdGhpcy5hZGQgPSBmdW5jdGlvbihvcmlnaW5Ob3RpY2UsIGhvbGRlckNhbGxiYWNrKSB7XG4gICAgICB2YXIga2V5MiA9IG9yaWdpbk5vdGljZS5rZXkgfHwgZ2V0VXVpZCgpO1xuICAgICAgdmFyIG5vdGljZTIgPSBfb2JqZWN0U3ByZWFkMiQxKF9vYmplY3RTcHJlYWQyJDEoe30sIG9yaWdpbk5vdGljZSksIHt9LCB7XG4gICAgICAgIGtleToga2V5MlxuICAgICAgfSk7XG4gICAgICB2YXIgbWF4Q291bnQyID0gX3RoaXMucHJvcHMubWF4Q291bnQ7XG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbihwcmV2aW91c1N0YXRlKSB7XG4gICAgICAgIHZhciBub3RpY2VzID0gcHJldmlvdXNTdGF0ZS5ub3RpY2VzO1xuICAgICAgICB2YXIgbm90aWNlSW5kZXggPSBub3RpY2VzLm1hcChmdW5jdGlvbih2Mikge1xuICAgICAgICAgIHJldHVybiB2Mi5ub3RpY2Uua2V5O1xuICAgICAgICB9KS5pbmRleE9mKGtleTIpO1xuICAgICAgICB2YXIgdXBkYXRlZE5vdGljZXMgPSBub3RpY2VzLmNvbmNhdCgpO1xuICAgICAgICBpZiAobm90aWNlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgdXBkYXRlZE5vdGljZXMuc3BsaWNlKG5vdGljZUluZGV4LCAxLCB7XG4gICAgICAgICAgICBub3RpY2U6IG5vdGljZTIsXG4gICAgICAgICAgICBob2xkZXJDYWxsYmFja1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChtYXhDb3VudDIgJiYgbm90aWNlcy5sZW5ndGggPj0gbWF4Q291bnQyKSB7XG4gICAgICAgICAgICBub3RpY2UyLmtleSA9IHVwZGF0ZWROb3RpY2VzWzBdLm5vdGljZS5rZXk7XG4gICAgICAgICAgICBub3RpY2UyLnVwZGF0ZU1hcmsgPSBnZXRVdWlkKCk7XG4gICAgICAgICAgICBub3RpY2UyLnVzZXJQYXNzS2V5ID0ga2V5MjtcbiAgICAgICAgICAgIHVwZGF0ZWROb3RpY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZWROb3RpY2VzLnB1c2goe1xuICAgICAgICAgICAgbm90aWNlOiBub3RpY2UyLFxuICAgICAgICAgICAgaG9sZGVyQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vdGljZXM6IHVwZGF0ZWROb3RpY2VzXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF90aGlzLnJlbW92ZSA9IGZ1bmN0aW9uKHJlbW92ZUtleSkge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24oX3JlZikge1xuICAgICAgICB2YXIgbm90aWNlcyA9IF9yZWYubm90aWNlcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub3RpY2VzOiBub3RpY2VzLmZpbHRlcihmdW5jdGlvbihfcmVmMikge1xuICAgICAgICAgICAgdmFyIF9yZWYyJG5vdGljZSA9IF9yZWYyLm5vdGljZSwga2V5MiA9IF9yZWYyJG5vdGljZS5rZXksIHVzZXJQYXNzS2V5ID0gX3JlZjIkbm90aWNlLnVzZXJQYXNzS2V5O1xuICAgICAgICAgICAgdmFyIG1lcmdlZEtleSA9IHVzZXJQYXNzS2V5IHx8IGtleTI7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkS2V5ICE9PSByZW1vdmVLZXk7XG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3RoaXMubm90aWNlUHJvcHNNYXAgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKE5vdGlmaWNhdGlvbjIsIFt7XG4gICAga2V5OiBcImdldFRyYW5zaXRpb25OYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyYW5zaXRpb25OYW1lMygpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsIHByZWZpeENscyA9IF90aGlzJHByb3BzLnByZWZpeENscywgYW5pbWF0aW9uID0gX3RoaXMkcHJvcHMuYW5pbWF0aW9uO1xuICAgICAgdmFyIHRyYW5zaXRpb25OYW1lMiA9IHRoaXMucHJvcHMudHJhbnNpdGlvbk5hbWU7XG4gICAgICBpZiAoIXRyYW5zaXRpb25OYW1lMiAmJiBhbmltYXRpb24pIHtcbiAgICAgICAgdHJhbnNpdGlvbk5hbWUyID0gXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1cIikuY29uY2F0KGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNpdGlvbk5hbWUyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgbm90aWNlcyA9IHRoaXMuc3RhdGUubm90aWNlcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLCBwcmVmaXhDbHMgPSBfdGhpcyRwcm9wczIucHJlZml4Q2xzLCBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczIuY2xhc3NOYW1lLCBjbG9zZUljb24gPSBfdGhpcyRwcm9wczIuY2xvc2VJY29uLCBzdHlsZTIgPSBfdGhpcyRwcm9wczIuc3R5bGU7XG4gICAgICB2YXIgbm90aWNlS2V5cyA9IFtdO1xuICAgICAgbm90aWNlcy5mb3JFYWNoKGZ1bmN0aW9uKF9yZWYzLCBpbmRleDIpIHtcbiAgICAgICAgdmFyIG5vdGljZTIgPSBfcmVmMy5ub3RpY2UsIGhvbGRlckNhbGxiYWNrID0gX3JlZjMuaG9sZGVyQ2FsbGJhY2s7XG4gICAgICAgIHZhciB1cGRhdGVNYXJrID0gaW5kZXgyID09PSBub3RpY2VzLmxlbmd0aCAtIDEgPyBub3RpY2UyLnVwZGF0ZU1hcmsgOiB2b2lkIDA7XG4gICAgICAgIHZhciBrZXkyID0gbm90aWNlMi5rZXksIHVzZXJQYXNzS2V5ID0gbm90aWNlMi51c2VyUGFzc0tleTtcbiAgICAgICAgdmFyIG5vdGljZVByb3BzID0gX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKF9vYmplY3RTcHJlYWQyJDEoe1xuICAgICAgICAgIHByZWZpeENscyxcbiAgICAgICAgICBjbG9zZUljb25cbiAgICAgICAgfSwgbm90aWNlMiksIG5vdGljZTIucHJvcHMpLCB7fSwge1xuICAgICAgICAgIGtleToga2V5MixcbiAgICAgICAgICBub3RpY2VLZXk6IHVzZXJQYXNzS2V5IHx8IGtleTIsXG4gICAgICAgICAgdXBkYXRlTWFyayxcbiAgICAgICAgICBvbkNsb3NlOiBmdW5jdGlvbiBvbkNsb3NlMihub3RpY2VLZXkpIHtcbiAgICAgICAgICAgIHZhciBfbm90aWNlJG9uQ2xvc2U7XG4gICAgICAgICAgICBfdGhpczIucmVtb3ZlKG5vdGljZUtleSk7XG4gICAgICAgICAgICAoX25vdGljZSRvbkNsb3NlID0gbm90aWNlMi5vbkNsb3NlKSA9PT0gbnVsbCB8fCBfbm90aWNlJG9uQ2xvc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub3RpY2Ukb25DbG9zZS5jYWxsKG5vdGljZTIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25DbGljazogbm90aWNlMi5vbkNsaWNrLFxuICAgICAgICAgIGNoaWxkcmVuOiBub3RpY2UyLmNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIG5vdGljZUtleXMucHVzaChrZXkyKTtcbiAgICAgICAgX3RoaXMyLm5vdGljZVByb3BzTWFwW2tleTJdID0ge1xuICAgICAgICAgIHByb3BzOiBub3RpY2VQcm9wcyxcbiAgICAgICAgICBob2xkZXJDYWxsYmFja1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMocHJlZml4Q2xzLCBjbGFzc05hbWUpLFxuICAgICAgICBzdHlsZTogc3R5bGUyXG4gICAgICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDU1NNb3Rpb25MaXN0LCB7XG4gICAgICAgIGtleXM6IG5vdGljZUtleXMsXG4gICAgICAgIG1vdGlvbk5hbWU6IHRoaXMuZ2V0VHJhbnNpdGlvbk5hbWUoKSxcbiAgICAgICAgb25WaXNpYmxlQ2hhbmdlZDogZnVuY3Rpb24gb25WaXNpYmxlQ2hhbmdlZChjaGFuZ2VkVmlzaWJsZSwgX3JlZjQpIHtcbiAgICAgICAgICB2YXIga2V5MiA9IF9yZWY0LmtleTtcbiAgICAgICAgICBpZiAoIWNoYW5nZWRWaXNpYmxlKSB7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMyLm5vdGljZVByb3BzTWFwW2tleTJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24oX3JlZjUpIHtcbiAgICAgICAgdmFyIGtleTIgPSBfcmVmNS5rZXksIG1vdGlvbkNsYXNzTmFtZSA9IF9yZWY1LmNsYXNzTmFtZSwgbW90aW9uU3R5bGUgPSBfcmVmNS5zdHlsZSwgdmlzaWJsZSA9IF9yZWY1LnZpc2libGU7XG4gICAgICAgIHZhciBfdGhpczIkbm90aWNlUHJvcHNNYXAgPSBfdGhpczIubm90aWNlUHJvcHNNYXBba2V5Ml0sIG5vdGljZVByb3BzID0gX3RoaXMyJG5vdGljZVByb3BzTWFwLnByb3BzLCBob2xkZXJDYWxsYmFjayA9IF90aGlzMiRub3RpY2VQcm9wc01hcC5ob2xkZXJDYWxsYmFjaztcbiAgICAgICAgaWYgKGhvbGRlckNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGtleToga2V5MixcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhtb3Rpb25DbGFzc05hbWUsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItaG9vay1ob2xkZXJcIikpLFxuICAgICAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQyJDEoe30sIG1vdGlvblN0eWxlKSxcbiAgICAgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKGRpdikge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleTIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRpdikge1xuICAgICAgICAgICAgICAgIF90aGlzMi5ob29rUmVmcy5zZXQoa2V5MiwgZGl2KTtcbiAgICAgICAgICAgICAgICBob2xkZXJDYWxsYmFjayhkaXYsIG5vdGljZVByb3BzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpczIuaG9va1JlZnMuZGVsZXRlKGtleTIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KE5vdGljZSwgX2V4dGVuZHMkMSh7fSwgbm90aWNlUHJvcHMsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMobW90aW9uQ2xhc3NOYW1lLCBub3RpY2VQcm9wcyA9PT0gbnVsbCB8fCBub3RpY2VQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm90aWNlUHJvcHMuY2xhc3NOYW1lKSxcbiAgICAgICAgICBzdHlsZTogX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBtb3Rpb25TdHlsZSksIG5vdGljZVByb3BzID09PSBudWxsIHx8IG5vdGljZVByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub3RpY2VQcm9wcy5zdHlsZSksXG4gICAgICAgICAgdmlzaWJsZVxuICAgICAgICB9KSk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOb3RpZmljYXRpb24yO1xufShDb21wb25lbnQpO1xuTm90aWZpY2F0aW9uLm5ld0luc3RhbmNlID0gdm9pZCAwO1xuTm90aWZpY2F0aW9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgcHJlZml4Q2xzOiBcInJjLW5vdGlmaWNhdGlvblwiLFxuICBhbmltYXRpb246IFwiZmFkZVwiLFxuICBzdHlsZToge1xuICAgIHRvcDogNjUsXG4gICAgbGVmdDogXCI1MCVcIlxuICB9XG59O1xuTm90aWZpY2F0aW9uLm5ld0luc3RhbmNlID0gZnVuY3Rpb24gbmV3Tm90aWZpY2F0aW9uSW5zdGFuY2UocHJvcGVydGllcywgY2FsbGJhY2spIHtcbiAgdmFyIF9yZWY2ID0gcHJvcGVydGllcyB8fCB7fSwgZ2V0Q29udGFpbmVyMiA9IF9yZWY2LmdldENvbnRhaW5lciwgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjYsIFtcImdldENvbnRhaW5lclwiXSk7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBpZiAoZ2V0Q29udGFpbmVyMikge1xuICAgIHZhciByb290MiA9IGdldENvbnRhaW5lcjIoKTtcbiAgICByb290Mi5hcHBlbmRDaGlsZChkaXYpO1xuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgfVxuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHJlZihub3RpZmljYXRpb24yKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrKHtcbiAgICAgIG5vdGljZTogZnVuY3Rpb24gbm90aWNlMihub3RpY2VQcm9wcykge1xuICAgICAgICBub3RpZmljYXRpb24yLmFkZChub3RpY2VQcm9wcyk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlTm90aWNlOiBmdW5jdGlvbiByZW1vdmVOb3RpY2Uoa2V5Mikge1xuICAgICAgICBub3RpZmljYXRpb24yLnJlbW92ZShrZXkyKTtcbiAgICAgIH0sXG4gICAgICBjb21wb25lbnQ6IG5vdGlmaWNhdGlvbjIsXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95MygpIHtcbiAgICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZShkaXYpO1xuICAgICAgICBpZiAoZGl2LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlTm90aWZpY2F0aW9uOiBmdW5jdGlvbiB1c2VOb3RpZmljYXRpb24kMSgpIHtcbiAgICAgICAgcmV0dXJuIHVzZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb24yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBSZWFjdERPTS5yZW5kZXIoLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTm90aWZpY2F0aW9uLCBfZXh0ZW5kcyQxKHt9LCBwcm9wcywge1xuICAgIHJlZlxuICB9KSksIGRpdik7XG59O1xudmFyIExvYWRpbmdPdXRsaW5lZCQyID0geyBcImljb25cIjogeyBcInRhZ1wiOiBcInN2Z1wiLCBcImF0dHJzXCI6IHsgXCJ2aWV3Qm94XCI6IFwiMCAwIDEwMjQgMTAyNFwiLCBcImZvY3VzYWJsZVwiOiBcImZhbHNlXCIgfSwgXCJjaGlsZHJlblwiOiBbeyBcInRhZ1wiOiBcInBhdGhcIiwgXCJhdHRyc1wiOiB7IFwiZFwiOiBcIk05ODggNTQ4Yy0xOS45IDAtMzYtMTYuMS0zNi0zNiAwLTU5LjQtMTEuNi0xMTctMzQuNi0xNzEuM2E0NDAuNDUgNDQwLjQ1IDAgMDAtOTQuMy0xMzkuOSA0MzcuNzEgNDM3LjcxIDAgMDAtMTM5LjktOTQuM0M2MjkgODMuNiA1NzEuNCA3MiA1MTIgNzJjLTE5LjkgMC0zNi0xNi4xLTM2LTM2czE2LjEtMzYgMzYtMzZjNjkuMSAwIDEzNi4yIDEzLjUgMTk5LjMgNDAuM0M3NzIuMyA2NiA4MjcgMTAzIDg3NCAxNTBjNDcgNDcgODMuOSAxMDEuOCAxMDkuNyAxNjIuNyAyNi43IDYzLjEgNDAuMiAxMzAuMiA0MC4yIDE5OS4zLjEgMTkuOS0xNiAzNi0zNS45IDM2elwiIH0gfV0gfSwgXCJuYW1lXCI6IFwibG9hZGluZ1wiLCBcInRoZW1lXCI6IFwib3V0bGluZWRcIiB9O1xudmFyIExvYWRpbmdPdXRsaW5lZFN2ZyA9IExvYWRpbmdPdXRsaW5lZCQyO1xudmFyIEljb25Db250ZXh0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNvbnRleHQoe30pO1xudmFyIEljb25Db250ZXh0JDEgPSBJY29uQ29udGV4dDtcbmZ1bmN0aW9uIGJvdW5kMDEobjIsIG1heCkge1xuICBpZiAoaXNPbmVQb2ludFplcm8objIpKSB7XG4gICAgbjIgPSBcIjEwMCVcIjtcbiAgfVxuICB2YXIgaXNQZXJjZW50ID0gaXNQZXJjZW50YWdlKG4yKTtcbiAgbjIgPSBtYXggPT09IDM2MCA/IG4yIDogTWF0aC5taW4obWF4LCBNYXRoLm1heCgwLCBwYXJzZUZsb2F0KG4yKSkpO1xuICBpZiAoaXNQZXJjZW50KSB7XG4gICAgbjIgPSBwYXJzZUludChTdHJpbmcobjIgKiBtYXgpLCAxMCkgLyAxMDA7XG4gIH1cbiAgaWYgKE1hdGguYWJzKG4yIC0gbWF4KSA8IDFlLTYpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZiAobWF4ID09PSAzNjApIHtcbiAgICBuMiA9IChuMiA8IDAgPyBuMiAlIG1heCArIG1heCA6IG4yICUgbWF4KSAvIHBhcnNlRmxvYXQoU3RyaW5nKG1heCkpO1xuICB9IGVsc2Uge1xuICAgIG4yID0gbjIgJSBtYXggLyBwYXJzZUZsb2F0KFN0cmluZyhtYXgpKTtcbiAgfVxuICByZXR1cm4gbjI7XG59XG5mdW5jdGlvbiBjbGFtcDAxKHZhbCkge1xuICByZXR1cm4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgdmFsKSk7XG59XG5mdW5jdGlvbiBpc09uZVBvaW50WmVybyhuMikge1xuICByZXR1cm4gdHlwZW9mIG4yID09PSBcInN0cmluZ1wiICYmIG4yLmluZGV4T2YoXCIuXCIpICE9PSAtMSAmJiBwYXJzZUZsb2F0KG4yKSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGlzUGVyY2VudGFnZShuMikge1xuICByZXR1cm4gdHlwZW9mIG4yID09PSBcInN0cmluZ1wiICYmIG4yLmluZGV4T2YoXCIlXCIpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIGJvdW5kQWxwaGEoYSkge1xuICBhID0gcGFyc2VGbG9hdChhKTtcbiAgaWYgKGlzTmFOKGEpIHx8IGEgPCAwIHx8IGEgPiAxKSB7XG4gICAgYSA9IDE7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9QZXJjZW50YWdlKG4yKSB7XG4gIGlmIChuMiA8PSAxKSB7XG4gICAgcmV0dXJuIE51bWJlcihuMikgKiAxMDAgKyBcIiVcIjtcbiAgfVxuICByZXR1cm4gbjI7XG59XG5mdW5jdGlvbiBwYWQyKGMyKSB7XG4gIHJldHVybiBjMi5sZW5ndGggPT09IDEgPyBcIjBcIiArIGMyIDogU3RyaW5nKGMyKTtcbn1cbmZ1bmN0aW9uIHJnYlRvUmdiKHIyLCBnMiwgYjIpIHtcbiAgcmV0dXJuIHtcbiAgICByOiBib3VuZDAxKHIyLCAyNTUpICogMjU1LFxuICAgIGc6IGJvdW5kMDEoZzIsIDI1NSkgKiAyNTUsXG4gICAgYjogYm91bmQwMShiMiwgMjU1KSAqIDI1NVxuICB9O1xufVxuZnVuY3Rpb24gcmdiVG9Ic2wocjIsIGcyLCBiMikge1xuICByMiA9IGJvdW5kMDEocjIsIDI1NSk7XG4gIGcyID0gYm91bmQwMShnMiwgMjU1KTtcbiAgYjIgPSBib3VuZDAxKGIyLCAyNTUpO1xuICB2YXIgbWF4ID0gTWF0aC5tYXgocjIsIGcyLCBiMik7XG4gIHZhciBtaW4gPSBNYXRoLm1pbihyMiwgZzIsIGIyKTtcbiAgdmFyIGggPSAwO1xuICB2YXIgcyA9IDA7XG4gIHZhciBsMiA9IChtYXggKyBtaW4pIC8gMjtcbiAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgcyA9IDA7XG4gICAgaCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGQyID0gbWF4IC0gbWluO1xuICAgIHMgPSBsMiA+IDAuNSA/IGQyIC8gKDIgLSBtYXggLSBtaW4pIDogZDIgLyAobWF4ICsgbWluKTtcbiAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgY2FzZSByMjpcbiAgICAgICAgaCA9IChnMiAtIGIyKSAvIGQyICsgKGcyIDwgYjIgPyA2IDogMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnMjpcbiAgICAgICAgaCA9IChiMiAtIHIyKSAvIGQyICsgMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGIyOlxuICAgICAgICBoID0gKHIyIC0gZzIpIC8gZDIgKyA0O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaCAvPSA2O1xuICB9XG4gIHJldHVybiB7IGgsIHMsIGw6IGwyIH07XG59XG5mdW5jdGlvbiBodWUycmdiKHAyLCBxMiwgdDIpIHtcbiAgaWYgKHQyIDwgMCkge1xuICAgIHQyICs9IDE7XG4gIH1cbiAgaWYgKHQyID4gMSkge1xuICAgIHQyIC09IDE7XG4gIH1cbiAgaWYgKHQyIDwgMSAvIDYpIHtcbiAgICByZXR1cm4gcDIgKyAocTIgLSBwMikgKiAoNiAqIHQyKTtcbiAgfVxuICBpZiAodDIgPCAxIC8gMikge1xuICAgIHJldHVybiBxMjtcbiAgfVxuICBpZiAodDIgPCAyIC8gMykge1xuICAgIHJldHVybiBwMiArIChxMiAtIHAyKSAqICgyIC8gMyAtIHQyKSAqIDY7XG4gIH1cbiAgcmV0dXJuIHAyO1xufVxuZnVuY3Rpb24gaHNsVG9SZ2IoaCwgcywgbDIpIHtcbiAgdmFyIHIyO1xuICB2YXIgZzI7XG4gIHZhciBiMjtcbiAgaCA9IGJvdW5kMDEoaCwgMzYwKTtcbiAgcyA9IGJvdW5kMDEocywgMTAwKTtcbiAgbDIgPSBib3VuZDAxKGwyLCAxMDApO1xuICBpZiAocyA9PT0gMCkge1xuICAgIGcyID0gbDI7XG4gICAgYjIgPSBsMjtcbiAgICByMiA9IGwyO1xuICB9IGVsc2Uge1xuICAgIHZhciBxMiA9IGwyIDwgMC41ID8gbDIgKiAoMSArIHMpIDogbDIgKyBzIC0gbDIgKiBzO1xuICAgIHZhciBwMiA9IDIgKiBsMiAtIHEyO1xuICAgIHIyID0gaHVlMnJnYihwMiwgcTIsIGggKyAxIC8gMyk7XG4gICAgZzIgPSBodWUycmdiKHAyLCBxMiwgaCk7XG4gICAgYjIgPSBodWUycmdiKHAyLCBxMiwgaCAtIDEgLyAzKTtcbiAgfVxuICByZXR1cm4geyByOiByMiAqIDI1NSwgZzogZzIgKiAyNTUsIGI6IGIyICogMjU1IH07XG59XG5mdW5jdGlvbiByZ2JUb0hzdihyMiwgZzIsIGIyKSB7XG4gIHIyID0gYm91bmQwMShyMiwgMjU1KTtcbiAgZzIgPSBib3VuZDAxKGcyLCAyNTUpO1xuICBiMiA9IGJvdW5kMDEoYjIsIDI1NSk7XG4gIHZhciBtYXggPSBNYXRoLm1heChyMiwgZzIsIGIyKTtcbiAgdmFyIG1pbiA9IE1hdGgubWluKHIyLCBnMiwgYjIpO1xuICB2YXIgaCA9IDA7XG4gIHZhciB2MiA9IG1heDtcbiAgdmFyIGQyID0gbWF4IC0gbWluO1xuICB2YXIgcyA9IG1heCA9PT0gMCA/IDAgOiBkMiAvIG1heDtcbiAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgaCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoIChtYXgpIHtcbiAgICAgIGNhc2UgcjI6XG4gICAgICAgIGggPSAoZzIgLSBiMikgLyBkMiArIChnMiA8IGIyID8gNiA6IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZzI6XG4gICAgICAgIGggPSAoYjIgLSByMikgLyBkMiArIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiMjpcbiAgICAgICAgaCA9IChyMiAtIGcyKSAvIGQyICsgNDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGggLz0gNjtcbiAgfVxuICByZXR1cm4geyBoLCBzLCB2OiB2MiB9O1xufVxuZnVuY3Rpb24gaHN2VG9SZ2IoaCwgcywgdjIpIHtcbiAgaCA9IGJvdW5kMDEoaCwgMzYwKSAqIDY7XG4gIHMgPSBib3VuZDAxKHMsIDEwMCk7XG4gIHYyID0gYm91bmQwMSh2MiwgMTAwKTtcbiAgdmFyIGkgPSBNYXRoLmZsb29yKGgpO1xuICB2YXIgZjIgPSBoIC0gaTtcbiAgdmFyIHAyID0gdjIgKiAoMSAtIHMpO1xuICB2YXIgcTIgPSB2MiAqICgxIC0gZjIgKiBzKTtcbiAgdmFyIHQyID0gdjIgKiAoMSAtICgxIC0gZjIpICogcyk7XG4gIHZhciBtb2QgPSBpICUgNjtcbiAgdmFyIHIyID0gW3YyLCBxMiwgcDIsIHAyLCB0MiwgdjJdW21vZF07XG4gIHZhciBnMiA9IFt0MiwgdjIsIHYyLCBxMiwgcDIsIHAyXVttb2RdO1xuICB2YXIgYjIgPSBbcDIsIHAyLCB0MiwgdjIsIHYyLCBxMl1bbW9kXTtcbiAgcmV0dXJuIHsgcjogcjIgKiAyNTUsIGc6IGcyICogMjU1LCBiOiBiMiAqIDI1NSB9O1xufVxuZnVuY3Rpb24gcmdiVG9IZXgocjIsIGcyLCBiMiwgYWxsb3czQ2hhcikge1xuICB2YXIgaGV4MiA9IFtcbiAgICBwYWQyKE1hdGgucm91bmQocjIpLnRvU3RyaW5nKDE2KSksXG4gICAgcGFkMihNYXRoLnJvdW5kKGcyKS50b1N0cmluZygxNikpLFxuICAgIHBhZDIoTWF0aC5yb3VuZChiMikudG9TdHJpbmcoMTYpKVxuICBdO1xuICBpZiAoYWxsb3czQ2hhciAmJiBoZXgyWzBdLnN0YXJ0c1dpdGgoaGV4MlswXS5jaGFyQXQoMSkpICYmIGhleDJbMV0uc3RhcnRzV2l0aChoZXgyWzFdLmNoYXJBdCgxKSkgJiYgaGV4MlsyXS5zdGFydHNXaXRoKGhleDJbMl0uY2hhckF0KDEpKSkge1xuICAgIHJldHVybiBoZXgyWzBdLmNoYXJBdCgwKSArIGhleDJbMV0uY2hhckF0KDApICsgaGV4MlsyXS5jaGFyQXQoMCk7XG4gIH1cbiAgcmV0dXJuIGhleDIuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHJnYmFUb0hleChyMiwgZzIsIGIyLCBhLCBhbGxvdzRDaGFyKSB7XG4gIHZhciBoZXgyID0gW1xuICAgIHBhZDIoTWF0aC5yb3VuZChyMikudG9TdHJpbmcoMTYpKSxcbiAgICBwYWQyKE1hdGgucm91bmQoZzIpLnRvU3RyaW5nKDE2KSksXG4gICAgcGFkMihNYXRoLnJvdW5kKGIyKS50b1N0cmluZygxNikpLFxuICAgIHBhZDIoY29udmVydERlY2ltYWxUb0hleChhKSlcbiAgXTtcbiAgaWYgKGFsbG93NENoYXIgJiYgaGV4MlswXS5zdGFydHNXaXRoKGhleDJbMF0uY2hhckF0KDEpKSAmJiBoZXgyWzFdLnN0YXJ0c1dpdGgoaGV4MlsxXS5jaGFyQXQoMSkpICYmIGhleDJbMl0uc3RhcnRzV2l0aChoZXgyWzJdLmNoYXJBdCgxKSkgJiYgaGV4MlszXS5zdGFydHNXaXRoKGhleDJbM10uY2hhckF0KDEpKSkge1xuICAgIHJldHVybiBoZXgyWzBdLmNoYXJBdCgwKSArIGhleDJbMV0uY2hhckF0KDApICsgaGV4MlsyXS5jaGFyQXQoMCkgKyBoZXgyWzNdLmNoYXJBdCgwKTtcbiAgfVxuICByZXR1cm4gaGV4Mi5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gY29udmVydERlY2ltYWxUb0hleChkMikge1xuICByZXR1cm4gTWF0aC5yb3VuZChwYXJzZUZsb2F0KGQyKSAqIDI1NSkudG9TdHJpbmcoMTYpO1xufVxuZnVuY3Rpb24gY29udmVydEhleFRvRGVjaW1hbChoKSB7XG4gIHJldHVybiBwYXJzZUludEZyb21IZXgoaCkgLyAyNTU7XG59XG5mdW5jdGlvbiBwYXJzZUludEZyb21IZXgodmFsKSB7XG4gIHJldHVybiBwYXJzZUludCh2YWwsIDE2KTtcbn1cbmZ1bmN0aW9uIG51bWJlcklucHV0VG9PYmplY3QoY29sb3IpIHtcbiAgcmV0dXJuIHtcbiAgICByOiBjb2xvciA+PiAxNixcbiAgICBnOiAoY29sb3IgJiA2NTI4MCkgPj4gOCxcbiAgICBiOiBjb2xvciAmIDI1NVxuICB9O1xufVxudmFyIG5hbWVzID0ge1xuICBhbGljZWJsdWU6IFwiI2YwZjhmZlwiLFxuICBhbnRpcXVld2hpdGU6IFwiI2ZhZWJkN1wiLFxuICBhcXVhOiBcIiMwMGZmZmZcIixcbiAgYXF1YW1hcmluZTogXCIjN2ZmZmQ0XCIsXG4gIGF6dXJlOiBcIiNmMGZmZmZcIixcbiAgYmVpZ2U6IFwiI2Y1ZjVkY1wiLFxuICBiaXNxdWU6IFwiI2ZmZTRjNFwiLFxuICBibGFjazogXCIjMDAwMDAwXCIsXG4gIGJsYW5jaGVkYWxtb25kOiBcIiNmZmViY2RcIixcbiAgYmx1ZTogXCIjMDAwMGZmXCIsXG4gIGJsdWV2aW9sZXQ6IFwiIzhhMmJlMlwiLFxuICBicm93bjogXCIjYTUyYTJhXCIsXG4gIGJ1cmx5d29vZDogXCIjZGViODg3XCIsXG4gIGNhZGV0Ymx1ZTogXCIjNWY5ZWEwXCIsXG4gIGNoYXJ0cmV1c2U6IFwiIzdmZmYwMFwiLFxuICBjaG9jb2xhdGU6IFwiI2QyNjkxZVwiLFxuICBjb3JhbDogXCIjZmY3ZjUwXCIsXG4gIGNvcm5mbG93ZXJibHVlOiBcIiM2NDk1ZWRcIixcbiAgY29ybnNpbGs6IFwiI2ZmZjhkY1wiLFxuICBjcmltc29uOiBcIiNkYzE0M2NcIixcbiAgY3lhbjogXCIjMDBmZmZmXCIsXG4gIGRhcmtibHVlOiBcIiMwMDAwOGJcIixcbiAgZGFya2N5YW46IFwiIzAwOGI4YlwiLFxuICBkYXJrZ29sZGVucm9kOiBcIiNiODg2MGJcIixcbiAgZGFya2dyYXk6IFwiI2E5YTlhOVwiLFxuICBkYXJrZ3JlZW46IFwiIzAwNjQwMFwiLFxuICBkYXJrZ3JleTogXCIjYTlhOWE5XCIsXG4gIGRhcmtraGFraTogXCIjYmRiNzZiXCIsXG4gIGRhcmttYWdlbnRhOiBcIiM4YjAwOGJcIixcbiAgZGFya29saXZlZ3JlZW46IFwiIzU1NmIyZlwiLFxuICBkYXJrb3JhbmdlOiBcIiNmZjhjMDBcIixcbiAgZGFya29yY2hpZDogXCIjOTkzMmNjXCIsXG4gIGRhcmtyZWQ6IFwiIzhiMDAwMFwiLFxuICBkYXJrc2FsbW9uOiBcIiNlOTk2N2FcIixcbiAgZGFya3NlYWdyZWVuOiBcIiM4ZmJjOGZcIixcbiAgZGFya3NsYXRlYmx1ZTogXCIjNDgzZDhiXCIsXG4gIGRhcmtzbGF0ZWdyYXk6IFwiIzJmNGY0ZlwiLFxuICBkYXJrc2xhdGVncmV5OiBcIiMyZjRmNGZcIixcbiAgZGFya3R1cnF1b2lzZTogXCIjMDBjZWQxXCIsXG4gIGRhcmt2aW9sZXQ6IFwiIzk0MDBkM1wiLFxuICBkZWVwcGluazogXCIjZmYxNDkzXCIsXG4gIGRlZXBza3libHVlOiBcIiMwMGJmZmZcIixcbiAgZGltZ3JheTogXCIjNjk2OTY5XCIsXG4gIGRpbWdyZXk6IFwiIzY5Njk2OVwiLFxuICBkb2RnZXJibHVlOiBcIiMxZTkwZmZcIixcbiAgZmlyZWJyaWNrOiBcIiNiMjIyMjJcIixcbiAgZmxvcmFsd2hpdGU6IFwiI2ZmZmFmMFwiLFxuICBmb3Jlc3RncmVlbjogXCIjMjI4YjIyXCIsXG4gIGZ1Y2hzaWE6IFwiI2ZmMDBmZlwiLFxuICBnYWluc2Jvcm86IFwiI2RjZGNkY1wiLFxuICBnaG9zdHdoaXRlOiBcIiNmOGY4ZmZcIixcbiAgZ29sZGVucm9kOiBcIiNkYWE1MjBcIixcbiAgZ29sZDogXCIjZmZkNzAwXCIsXG4gIGdyYXk6IFwiIzgwODA4MFwiLFxuICBncmVlbjogXCIjMDA4MDAwXCIsXG4gIGdyZWVueWVsbG93OiBcIiNhZGZmMmZcIixcbiAgZ3JleTogXCIjODA4MDgwXCIsXG4gIGhvbmV5ZGV3OiBcIiNmMGZmZjBcIixcbiAgaG90cGluazogXCIjZmY2OWI0XCIsXG4gIGluZGlhbnJlZDogXCIjY2Q1YzVjXCIsXG4gIGluZGlnbzogXCIjNGIwMDgyXCIsXG4gIGl2b3J5OiBcIiNmZmZmZjBcIixcbiAga2hha2k6IFwiI2YwZTY4Y1wiLFxuICBsYXZlbmRlcmJsdXNoOiBcIiNmZmYwZjVcIixcbiAgbGF2ZW5kZXI6IFwiI2U2ZTZmYVwiLFxuICBsYXduZ3JlZW46IFwiIzdjZmMwMFwiLFxuICBsZW1vbmNoaWZmb246IFwiI2ZmZmFjZFwiLFxuICBsaWdodGJsdWU6IFwiI2FkZDhlNlwiLFxuICBsaWdodGNvcmFsOiBcIiNmMDgwODBcIixcbiAgbGlnaHRjeWFuOiBcIiNlMGZmZmZcIixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFwiI2ZhZmFkMlwiLFxuICBsaWdodGdyYXk6IFwiI2QzZDNkM1wiLFxuICBsaWdodGdyZWVuOiBcIiM5MGVlOTBcIixcbiAgbGlnaHRncmV5OiBcIiNkM2QzZDNcIixcbiAgbGlnaHRwaW5rOiBcIiNmZmI2YzFcIixcbiAgbGlnaHRzYWxtb246IFwiI2ZmYTA3YVwiLFxuICBsaWdodHNlYWdyZWVuOiBcIiMyMGIyYWFcIixcbiAgbGlnaHRza3libHVlOiBcIiM4N2NlZmFcIixcbiAgbGlnaHRzbGF0ZWdyYXk6IFwiIzc3ODg5OVwiLFxuICBsaWdodHNsYXRlZ3JleTogXCIjNzc4ODk5XCIsXG4gIGxpZ2h0c3RlZWxibHVlOiBcIiNiMGM0ZGVcIixcbiAgbGlnaHR5ZWxsb3c6IFwiI2ZmZmZlMFwiLFxuICBsaW1lOiBcIiMwMGZmMDBcIixcbiAgbGltZWdyZWVuOiBcIiMzMmNkMzJcIixcbiAgbGluZW46IFwiI2ZhZjBlNlwiLFxuICBtYWdlbnRhOiBcIiNmZjAwZmZcIixcbiAgbWFyb29uOiBcIiM4MDAwMDBcIixcbiAgbWVkaXVtYXF1YW1hcmluZTogXCIjNjZjZGFhXCIsXG4gIG1lZGl1bWJsdWU6IFwiIzAwMDBjZFwiLFxuICBtZWRpdW1vcmNoaWQ6IFwiI2JhNTVkM1wiLFxuICBtZWRpdW1wdXJwbGU6IFwiIzkzNzBkYlwiLFxuICBtZWRpdW1zZWFncmVlbjogXCIjM2NiMzcxXCIsXG4gIG1lZGl1bXNsYXRlYmx1ZTogXCIjN2I2OGVlXCIsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiBcIiMwMGZhOWFcIixcbiAgbWVkaXVtdHVycXVvaXNlOiBcIiM0OGQxY2NcIixcbiAgbWVkaXVtdmlvbGV0cmVkOiBcIiNjNzE1ODVcIixcbiAgbWlkbmlnaHRibHVlOiBcIiMxOTE5NzBcIixcbiAgbWludGNyZWFtOiBcIiNmNWZmZmFcIixcbiAgbWlzdHlyb3NlOiBcIiNmZmU0ZTFcIixcbiAgbW9jY2FzaW46IFwiI2ZmZTRiNVwiLFxuICBuYXZham93aGl0ZTogXCIjZmZkZWFkXCIsXG4gIG5hdnk6IFwiIzAwMDA4MFwiLFxuICBvbGRsYWNlOiBcIiNmZGY1ZTZcIixcbiAgb2xpdmU6IFwiIzgwODAwMFwiLFxuICBvbGl2ZWRyYWI6IFwiIzZiOGUyM1wiLFxuICBvcmFuZ2U6IFwiI2ZmYTUwMFwiLFxuICBvcmFuZ2VyZWQ6IFwiI2ZmNDUwMFwiLFxuICBvcmNoaWQ6IFwiI2RhNzBkNlwiLFxuICBwYWxlZ29sZGVucm9kOiBcIiNlZWU4YWFcIixcbiAgcGFsZWdyZWVuOiBcIiM5OGZiOThcIixcbiAgcGFsZXR1cnF1b2lzZTogXCIjYWZlZWVlXCIsXG4gIHBhbGV2aW9sZXRyZWQ6IFwiI2RiNzA5M1wiLFxuICBwYXBheWF3aGlwOiBcIiNmZmVmZDVcIixcbiAgcGVhY2hwdWZmOiBcIiNmZmRhYjlcIixcbiAgcGVydTogXCIjY2Q4NTNmXCIsXG4gIHBpbms6IFwiI2ZmYzBjYlwiLFxuICBwbHVtOiBcIiNkZGEwZGRcIixcbiAgcG93ZGVyYmx1ZTogXCIjYjBlMGU2XCIsXG4gIHB1cnBsZTogXCIjODAwMDgwXCIsXG4gIHJlYmVjY2FwdXJwbGU6IFwiIzY2MzM5OVwiLFxuICByZWQ6IFwiI2ZmMDAwMFwiLFxuICByb3N5YnJvd246IFwiI2JjOGY4ZlwiLFxuICByb3lhbGJsdWU6IFwiIzQxNjllMVwiLFxuICBzYWRkbGVicm93bjogXCIjOGI0NTEzXCIsXG4gIHNhbG1vbjogXCIjZmE4MDcyXCIsXG4gIHNhbmR5YnJvd246IFwiI2Y0YTQ2MFwiLFxuICBzZWFncmVlbjogXCIjMmU4YjU3XCIsXG4gIHNlYXNoZWxsOiBcIiNmZmY1ZWVcIixcbiAgc2llbm5hOiBcIiNhMDUyMmRcIixcbiAgc2lsdmVyOiBcIiNjMGMwYzBcIixcbiAgc2t5Ymx1ZTogXCIjODdjZWViXCIsXG4gIHNsYXRlYmx1ZTogXCIjNmE1YWNkXCIsXG4gIHNsYXRlZ3JheTogXCIjNzA4MDkwXCIsXG4gIHNsYXRlZ3JleTogXCIjNzA4MDkwXCIsXG4gIHNub3c6IFwiI2ZmZmFmYVwiLFxuICBzcHJpbmdncmVlbjogXCIjMDBmZjdmXCIsXG4gIHN0ZWVsYmx1ZTogXCIjNDY4MmI0XCIsXG4gIHRhbjogXCIjZDJiNDhjXCIsXG4gIHRlYWw6IFwiIzAwODA4MFwiLFxuICB0aGlzdGxlOiBcIiNkOGJmZDhcIixcbiAgdG9tYXRvOiBcIiNmZjYzNDdcIixcbiAgdHVycXVvaXNlOiBcIiM0MGUwZDBcIixcbiAgdmlvbGV0OiBcIiNlZTgyZWVcIixcbiAgd2hlYXQ6IFwiI2Y1ZGViM1wiLFxuICB3aGl0ZTogXCIjZmZmZmZmXCIsXG4gIHdoaXRlc21va2U6IFwiI2Y1ZjVmNVwiLFxuICB5ZWxsb3c6IFwiI2ZmZmYwMFwiLFxuICB5ZWxsb3dncmVlbjogXCIjOWFjZDMyXCJcbn07XG5mdW5jdGlvbiBpbnB1dFRvUkdCKGNvbG9yKSB7XG4gIHZhciByZ2IgPSB7IHI6IDAsIGc6IDAsIGI6IDAgfTtcbiAgdmFyIGEgPSAxO1xuICB2YXIgcyA9IG51bGw7XG4gIHZhciB2MiA9IG51bGw7XG4gIHZhciBsMiA9IG51bGw7XG4gIHZhciBvayA9IGZhbHNlO1xuICB2YXIgZm9ybWF0MiA9IGZhbHNlO1xuICBpZiAodHlwZW9mIGNvbG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29sb3IgPSBzdHJpbmdJbnB1dFRvT2JqZWN0KGNvbG9yKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbG9yID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKGlzVmFsaWRDU1NVbml0KGNvbG9yLnIpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLmcpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLmIpKSB7XG4gICAgICByZ2IgPSByZ2JUb1JnYihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgICAgIG9rID0gdHJ1ZTtcbiAgICAgIGZvcm1hdDIgPSBTdHJpbmcoY29sb3Iucikuc3Vic3RyKC0xKSA9PT0gXCIlXCIgPyBcInByZ2JcIiA6IFwicmdiXCI7XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkQ1NTVW5pdChjb2xvci5oKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5zKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci52KSkge1xuICAgICAgcyA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iucyk7XG4gICAgICB2MiA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iudik7XG4gICAgICByZ2IgPSBoc3ZUb1JnYihjb2xvci5oLCBzLCB2Mik7XG4gICAgICBvayA9IHRydWU7XG4gICAgICBmb3JtYXQyID0gXCJoc3ZcIjtcbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRDU1NVbml0KGNvbG9yLmgpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLnMpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLmwpKSB7XG4gICAgICBzID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci5zKTtcbiAgICAgIGwyID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci5sKTtcbiAgICAgIHJnYiA9IGhzbFRvUmdiKGNvbG9yLmgsIHMsIGwyKTtcbiAgICAgIG9rID0gdHJ1ZTtcbiAgICAgIGZvcm1hdDIgPSBcImhzbFwiO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbG9yLCBcImFcIikpIHtcbiAgICAgIGEgPSBjb2xvci5hO1xuICAgIH1cbiAgfVxuICBhID0gYm91bmRBbHBoYShhKTtcbiAgcmV0dXJuIHtcbiAgICBvayxcbiAgICBmb3JtYXQ6IGNvbG9yLmZvcm1hdCB8fCBmb3JtYXQyLFxuICAgIHI6IE1hdGgubWluKDI1NSwgTWF0aC5tYXgocmdiLnIsIDApKSxcbiAgICBnOiBNYXRoLm1pbigyNTUsIE1hdGgubWF4KHJnYi5nLCAwKSksXG4gICAgYjogTWF0aC5taW4oMjU1LCBNYXRoLm1heChyZ2IuYiwgMCkpLFxuICAgIGFcbiAgfTtcbn1cbnZhciBDU1NfSU5URUdFUiA9IFwiWy1cXFxcK10/XFxcXGQrJT9cIjtcbnZhciBDU1NfTlVNQkVSID0gXCJbLVxcXFwrXT9cXFxcZCpcXFxcLlxcXFxkKyU/XCI7XG52YXIgQ1NTX1VOSVQgPSBcIig/OlwiICsgQ1NTX05VTUJFUiArIFwiKXwoPzpcIiArIENTU19JTlRFR0VSICsgXCIpXCI7XG52YXIgUEVSTUlTU0lWRV9NQVRDSDMgPSBcIltcXFxcc3xcXFxcKF0rKFwiICsgQ1NTX1VOSVQgKyBcIilbLHxcXFxcc10rKFwiICsgQ1NTX1VOSVQgKyBcIilbLHxcXFxcc10rKFwiICsgQ1NTX1VOSVQgKyBcIilcXFxccypcXFxcKT9cIjtcbnZhciBQRVJNSVNTSVZFX01BVENINCA9IFwiW1xcXFxzfFxcXFwoXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVxcXFxzKlxcXFwpP1wiO1xudmFyIG1hdGNoZXJzID0ge1xuICBDU1NfVU5JVDogbmV3IFJlZ0V4cChDU1NfVU5JVCksXG4gIHJnYjogbmV3IFJlZ0V4cChcInJnYlwiICsgUEVSTUlTU0lWRV9NQVRDSDMpLFxuICByZ2JhOiBuZXcgUmVnRXhwKFwicmdiYVwiICsgUEVSTUlTU0lWRV9NQVRDSDQpLFxuICBoc2w6IG5ldyBSZWdFeHAoXCJoc2xcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcbiAgaHNsYTogbmV3IFJlZ0V4cChcImhzbGFcIiArIFBFUk1JU1NJVkVfTUFUQ0g0KSxcbiAgaHN2OiBuZXcgUmVnRXhwKFwiaHN2XCIgKyBQRVJNSVNTSVZFX01BVENIMyksXG4gIGhzdmE6IG5ldyBSZWdFeHAoXCJoc3ZhXCIgKyBQRVJNSVNTSVZFX01BVENINCksXG4gIGhleDM6IC9eIz8oWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLyxcbiAgaGV4NjogL14jPyhbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvLFxuICBoZXg0OiAvXiM/KFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvLFxuICBoZXg4OiAvXiM/KFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvXG59O1xuZnVuY3Rpb24gc3RyaW5nSW5wdXRUb09iamVjdChjb2xvcikge1xuICBjb2xvciA9IGNvbG9yLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoY29sb3IubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBuYW1lZCA9IGZhbHNlO1xuICBpZiAobmFtZXNbY29sb3JdKSB7XG4gICAgY29sb3IgPSBuYW1lc1tjb2xvcl07XG4gICAgbmFtZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGNvbG9yID09PSBcInRyYW5zcGFyZW50XCIpIHtcbiAgICByZXR1cm4geyByOiAwLCBnOiAwLCBiOiAwLCBhOiAwLCBmb3JtYXQ6IFwibmFtZVwiIH07XG4gIH1cbiAgdmFyIG1hdGNoID0gbWF0Y2hlcnMucmdiLmV4ZWMoY29sb3IpO1xuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4geyByOiBtYXRjaFsxXSwgZzogbWF0Y2hbMl0sIGI6IG1hdGNoWzNdIH07XG4gIH1cbiAgbWF0Y2ggPSBtYXRjaGVycy5yZ2JhLmV4ZWMoY29sb3IpO1xuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4geyByOiBtYXRjaFsxXSwgZzogbWF0Y2hbMl0sIGI6IG1hdGNoWzNdLCBhOiBtYXRjaFs0XSB9O1xuICB9XG4gIG1hdGNoID0gbWF0Y2hlcnMuaHNsLmV4ZWMoY29sb3IpO1xuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4geyBoOiBtYXRjaFsxXSwgczogbWF0Y2hbMl0sIGw6IG1hdGNoWzNdIH07XG4gIH1cbiAgbWF0Y2ggPSBtYXRjaGVycy5oc2xhLmV4ZWMoY29sb3IpO1xuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4geyBoOiBtYXRjaFsxXSwgczogbWF0Y2hbMl0sIGw6IG1hdGNoWzNdLCBhOiBtYXRjaFs0XSB9O1xuICB9XG4gIG1hdGNoID0gbWF0Y2hlcnMuaHN2LmV4ZWMoY29sb3IpO1xuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4geyBoOiBtYXRjaFsxXSwgczogbWF0Y2hbMl0sIHY6IG1hdGNoWzNdIH07XG4gIH1cbiAgbWF0Y2ggPSBtYXRjaGVycy5oc3ZhLmV4ZWMoY29sb3IpO1xuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4geyBoOiBtYXRjaFsxXSwgczogbWF0Y2hbMl0sIHY6IG1hdGNoWzNdLCBhOiBtYXRjaFs0XSB9O1xuICB9XG4gIG1hdGNoID0gbWF0Y2hlcnMuaGV4OC5leGVjKGNvbG9yKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSksXG4gICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMl0pLFxuICAgICAgYjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzNdKSxcbiAgICAgIGE6IGNvbnZlcnRIZXhUb0RlY2ltYWwobWF0Y2hbNF0pLFxuICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXg4XCJcbiAgICB9O1xuICB9XG4gIG1hdGNoID0gbWF0Y2hlcnMuaGV4Ni5leGVjKGNvbG9yKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSksXG4gICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMl0pLFxuICAgICAgYjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzNdKSxcbiAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4XCJcbiAgICB9O1xuICB9XG4gIG1hdGNoID0gbWF0Y2hlcnMuaGV4NC5leGVjKGNvbG9yKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSArIG1hdGNoWzFdKSxcbiAgICAgIGc6IHBhcnNlSW50RnJvbUhleChtYXRjaFsyXSArIG1hdGNoWzJdKSxcbiAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSArIG1hdGNoWzNdKSxcbiAgICAgIGE6IGNvbnZlcnRIZXhUb0RlY2ltYWwobWF0Y2hbNF0gKyBtYXRjaFs0XSksXG4gICAgICBmb3JtYXQ6IG5hbWVkID8gXCJuYW1lXCIgOiBcImhleDhcIlxuICAgIH07XG4gIH1cbiAgbWF0Y2ggPSBtYXRjaGVycy5oZXgzLmV4ZWMoY29sb3IpO1xuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdICsgbWF0Y2hbMV0pLFxuICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdICsgbWF0Y2hbMl0pLFxuICAgICAgYjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzNdICsgbWF0Y2hbM10pLFxuICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXhcIlxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZENTU1VuaXQoY29sb3IpIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF0Y2hlcnMuQ1NTX1VOSVQuZXhlYyhTdHJpbmcoY29sb3IpKSk7XG59XG52YXIgVGlueUNvbG9yID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRpbnlDb2xvcjIoY29sb3IsIG9wdHMpIHtcbiAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkge1xuICAgICAgY29sb3IgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIHZhciBfYTtcbiAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiBUaW55Q29sb3IyKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29sb3IgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbG9yID0gbnVtYmVySW5wdXRUb09iamVjdChjb2xvcik7XG4gICAgfVxuICAgIHRoaXMub3JpZ2luYWxJbnB1dCA9IGNvbG9yO1xuICAgIHZhciByZ2IgPSBpbnB1dFRvUkdCKGNvbG9yKTtcbiAgICB0aGlzLm9yaWdpbmFsSW5wdXQgPSBjb2xvcjtcbiAgICB0aGlzLnIgPSByZ2IucjtcbiAgICB0aGlzLmcgPSByZ2IuZztcbiAgICB0aGlzLmIgPSByZ2IuYjtcbiAgICB0aGlzLmEgPSByZ2IuYTtcbiAgICB0aGlzLnJvdW5kQSA9IE1hdGgucm91bmQoMTAwICogdGhpcy5hKSAvIDEwMDtcbiAgICB0aGlzLmZvcm1hdCA9IChfYSA9IG9wdHMuZm9ybWF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiByZ2IuZm9ybWF0O1xuICAgIHRoaXMuZ3JhZGllbnRUeXBlID0gb3B0cy5ncmFkaWVudFR5cGU7XG4gICAgaWYgKHRoaXMuciA8IDEpIHtcbiAgICAgIHRoaXMuciA9IE1hdGgucm91bmQodGhpcy5yKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZyA8IDEpIHtcbiAgICAgIHRoaXMuZyA9IE1hdGgucm91bmQodGhpcy5nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYiA8IDEpIHtcbiAgICAgIHRoaXMuYiA9IE1hdGgucm91bmQodGhpcy5iKTtcbiAgICB9XG4gICAgdGhpcy5pc1ZhbGlkID0gcmdiLm9rO1xuICB9XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLmlzRGFyayA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldEJyaWdodG5lc3MoKSA8IDEyODtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUuaXNMaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5pc0RhcmsoKTtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUuZ2V0QnJpZ2h0bmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZ2IgPSB0aGlzLnRvUmdiKCk7XG4gICAgcmV0dXJuIChyZ2IuciAqIDI5OSArIHJnYi5nICogNTg3ICsgcmdiLmIgKiAxMTQpIC8gMWUzO1xuICB9O1xuICBUaW55Q29sb3IyLnByb3RvdHlwZS5nZXRMdW1pbmFuY2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmdiID0gdGhpcy50b1JnYigpO1xuICAgIHZhciBSO1xuICAgIHZhciBHO1xuICAgIHZhciBCO1xuICAgIHZhciBSc1JHQiA9IHJnYi5yIC8gMjU1O1xuICAgIHZhciBHc1JHQiA9IHJnYi5nIC8gMjU1O1xuICAgIHZhciBCc1JHQiA9IHJnYi5iIC8gMjU1O1xuICAgIGlmIChSc1JHQiA8PSAwLjAzOTI4KSB7XG4gICAgICBSID0gUnNSR0IgLyAxMi45MjtcbiAgICB9IGVsc2Uge1xuICAgICAgUiA9IE1hdGgucG93KChSc1JHQiArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICAgIH1cbiAgICBpZiAoR3NSR0IgPD0gMC4wMzkyOCkge1xuICAgICAgRyA9IEdzUkdCIC8gMTIuOTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIEcgPSBNYXRoLnBvdygoR3NSR0IgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgICB9XG4gICAgaWYgKEJzUkdCIDw9IDAuMDM5MjgpIHtcbiAgICAgIEIgPSBCc1JHQiAvIDEyLjkyO1xuICAgIH0gZWxzZSB7XG4gICAgICBCID0gTWF0aC5wb3coKEJzUkdCICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gICAgfVxuICAgIHJldHVybiAwLjIxMjYgKiBSICsgMC43MTUyICogRyArIDAuMDcyMiAqIEI7XG4gIH07XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLmdldEFscGhhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYTtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUuc2V0QWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHRoaXMuYSA9IGJvdW5kQWxwaGEoYWxwaGEpO1xuICAgIHRoaXMucm91bmRBID0gTWF0aC5yb3VuZCgxMDAgKiB0aGlzLmEpIC8gMTAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBUaW55Q29sb3IyLnByb3RvdHlwZS50b0hzdiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoc3YgPSByZ2JUb0hzdih0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgICByZXR1cm4geyBoOiBoc3YuaCAqIDM2MCwgczogaHN2LnMsIHY6IGhzdi52LCBhOiB0aGlzLmEgfTtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUudG9Ic3ZTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaHN2ID0gcmdiVG9Ic3YodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gICAgdmFyIGggPSBNYXRoLnJvdW5kKGhzdi5oICogMzYwKTtcbiAgICB2YXIgcyA9IE1hdGgucm91bmQoaHN2LnMgKiAxMDApO1xuICAgIHZhciB2MiA9IE1hdGgucm91bmQoaHN2LnYgKiAxMDApO1xuICAgIHJldHVybiB0aGlzLmEgPT09IDEgPyBcImhzdihcIiArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIHYyICsgXCIlKVwiIDogXCJoc3ZhKFwiICsgaCArIFwiLCBcIiArIHMgKyBcIiUsIFwiICsgdjIgKyBcIiUsIFwiICsgdGhpcy5yb3VuZEEgKyBcIilcIjtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUudG9Ic2wgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaHNsID0gcmdiVG9Ic2wodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gICAgcmV0dXJuIHsgaDogaHNsLmggKiAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCwgYTogdGhpcy5hIH07XG4gIH07XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLnRvSHNsU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhzbCA9IHJnYlRvSHNsKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICAgIHZhciBoID0gTWF0aC5yb3VuZChoc2wuaCAqIDM2MCk7XG4gICAgdmFyIHMgPSBNYXRoLnJvdW5kKGhzbC5zICogMTAwKTtcbiAgICB2YXIgbDIgPSBNYXRoLnJvdW5kKGhzbC5sICogMTAwKTtcbiAgICByZXR1cm4gdGhpcy5hID09PSAxID8gXCJoc2woXCIgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyBsMiArIFwiJSlcIiA6IFwiaHNsYShcIiArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIGwyICsgXCIlLCBcIiArIHRoaXMucm91bmRBICsgXCIpXCI7XG4gIH07XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oYWxsb3czQ2hhcikge1xuICAgIGlmIChhbGxvdzNDaGFyID09PSB2b2lkIDApIHtcbiAgICAgIGFsbG93M0NoYXIgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHJnYlRvSGV4KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIGFsbG93M0NoYXIpO1xuICB9O1xuICBUaW55Q29sb3IyLnByb3RvdHlwZS50b0hleFN0cmluZyA9IGZ1bmN0aW9uKGFsbG93M0NoYXIpIHtcbiAgICBpZiAoYWxsb3czQ2hhciA9PT0gdm9pZCAwKSB7XG4gICAgICBhbGxvdzNDaGFyID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBcIiNcIiArIHRoaXMudG9IZXgoYWxsb3czQ2hhcik7XG4gIH07XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLnRvSGV4OCA9IGZ1bmN0aW9uKGFsbG93NENoYXIpIHtcbiAgICBpZiAoYWxsb3c0Q2hhciA9PT0gdm9pZCAwKSB7XG4gICAgICBhbGxvdzRDaGFyID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByZ2JhVG9IZXgodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hLCBhbGxvdzRDaGFyKTtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUudG9IZXg4U3RyaW5nID0gZnVuY3Rpb24oYWxsb3c0Q2hhcikge1xuICAgIGlmIChhbGxvdzRDaGFyID09PSB2b2lkIDApIHtcbiAgICAgIGFsbG93NENoYXIgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIFwiI1wiICsgdGhpcy50b0hleDgoYWxsb3c0Q2hhcik7XG4gIH07XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLnRvUmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IE1hdGgucm91bmQodGhpcy5yKSxcbiAgICAgIGc6IE1hdGgucm91bmQodGhpcy5nKSxcbiAgICAgIGI6IE1hdGgucm91bmQodGhpcy5iKSxcbiAgICAgIGE6IHRoaXMuYVxuICAgIH07XG4gIH07XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLnRvUmdiU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIyID0gTWF0aC5yb3VuZCh0aGlzLnIpO1xuICAgIHZhciBnMiA9IE1hdGgucm91bmQodGhpcy5nKTtcbiAgICB2YXIgYjIgPSBNYXRoLnJvdW5kKHRoaXMuYik7XG4gICAgcmV0dXJuIHRoaXMuYSA9PT0gMSA/IFwicmdiKFwiICsgcjIgKyBcIiwgXCIgKyBnMiArIFwiLCBcIiArIGIyICsgXCIpXCIgOiBcInJnYmEoXCIgKyByMiArIFwiLCBcIiArIGcyICsgXCIsIFwiICsgYjIgKyBcIiwgXCIgKyB0aGlzLnJvdW5kQSArIFwiKVwiO1xuICB9O1xuICBUaW55Q29sb3IyLnByb3RvdHlwZS50b1BlcmNlbnRhZ2VSZ2IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZm10ID0gZnVuY3Rpb24oeDIpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKGJvdW5kMDEoeDIsIDI1NSkgKiAxMDApICsgXCIlXCI7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcjogZm10KHRoaXMuciksXG4gICAgICBnOiBmbXQodGhpcy5nKSxcbiAgICAgIGI6IGZtdCh0aGlzLmIpLFxuICAgICAgYTogdGhpcy5hXG4gICAgfTtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUudG9QZXJjZW50YWdlUmdiU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJuZCA9IGZ1bmN0aW9uKHgyKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChib3VuZDAxKHgyLCAyNTUpICogMTAwKTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmEgPT09IDEgPyBcInJnYihcIiArIHJuZCh0aGlzLnIpICsgXCIlLCBcIiArIHJuZCh0aGlzLmcpICsgXCIlLCBcIiArIHJuZCh0aGlzLmIpICsgXCIlKVwiIDogXCJyZ2JhKFwiICsgcm5kKHRoaXMucikgKyBcIiUsIFwiICsgcm5kKHRoaXMuZykgKyBcIiUsIFwiICsgcm5kKHRoaXMuYikgKyBcIiUsIFwiICsgdGhpcy5yb3VuZEEgKyBcIilcIjtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUudG9OYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuYSA8IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGhleDIgPSBcIiNcIiArIHJnYlRvSGV4KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIGZhbHNlKTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXMobmFtZXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkyID0gX2JbMF0sIHZhbHVlID0gX2JbMV07XG4gICAgICBpZiAoaGV4MiA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGtleTI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihmb3JtYXQyKSB7XG4gICAgdmFyIGZvcm1hdFNldCA9IEJvb2xlYW4oZm9ybWF0Mik7XG4gICAgZm9ybWF0MiA9IGZvcm1hdDIgIT09IG51bGwgJiYgZm9ybWF0MiAhPT0gdm9pZCAwID8gZm9ybWF0MiA6IHRoaXMuZm9ybWF0O1xuICAgIHZhciBmb3JtYXR0ZWRTdHJpbmcgPSBmYWxzZTtcbiAgICB2YXIgaGFzQWxwaGEgPSB0aGlzLmEgPCAxICYmIHRoaXMuYSA+PSAwO1xuICAgIHZhciBuZWVkc0FscGhhRm9ybWF0ID0gIWZvcm1hdFNldCAmJiBoYXNBbHBoYSAmJiAoZm9ybWF0Mi5zdGFydHNXaXRoKFwiaGV4XCIpIHx8IGZvcm1hdDIgPT09IFwibmFtZVwiKTtcbiAgICBpZiAobmVlZHNBbHBoYUZvcm1hdCkge1xuICAgICAgaWYgKGZvcm1hdDIgPT09IFwibmFtZVwiICYmIHRoaXMuYSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b05hbWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRvUmdiU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChmb3JtYXQyID09PSBcInJnYlwiKSB7XG4gICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvUmdiU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChmb3JtYXQyID09PSBcInByZ2JcIikge1xuICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b1BlcmNlbnRhZ2VSZ2JTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdDIgPT09IFwiaGV4XCIgfHwgZm9ybWF0MiA9PT0gXCJoZXg2XCIpIHtcbiAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdDIgPT09IFwiaGV4M1wiKSB7XG4gICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSGV4U3RyaW5nKHRydWUpO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0MiA9PT0gXCJoZXg0XCIpIHtcbiAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXg4U3RyaW5nKHRydWUpO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0MiA9PT0gXCJoZXg4XCIpIHtcbiAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXg4U3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChmb3JtYXQyID09PSBcIm5hbWVcIikge1xuICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b05hbWUoKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdDIgPT09IFwiaHNsXCIpIHtcbiAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9Ic2xTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdDIgPT09IFwiaHN2XCIpIHtcbiAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9Ic3ZTdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZFN0cmluZyB8fCB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gIH07XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIChNYXRoLnJvdW5kKHRoaXMucikgPDwgMTYpICsgKE1hdGgucm91bmQodGhpcy5nKSA8PCA4KSArIE1hdGgucm91bmQodGhpcy5iKTtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFRpbnlDb2xvcjIodGhpcy50b1N0cmluZygpKTtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUubGlnaHRlbiA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIGlmIChhbW91bnQgPT09IHZvaWQgMCkge1xuICAgICAgYW1vdW50ID0gMTA7XG4gICAgfVxuICAgIHZhciBoc2wgPSB0aGlzLnRvSHNsKCk7XG4gICAgaHNsLmwgKz0gYW1vdW50IC8gMTAwO1xuICAgIGhzbC5sID0gY2xhbXAwMShoc2wubCk7XG4gICAgcmV0dXJuIG5ldyBUaW55Q29sb3IyKGhzbCk7XG4gIH07XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLmJyaWdodGVuID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgaWYgKGFtb3VudCA9PT0gdm9pZCAwKSB7XG4gICAgICBhbW91bnQgPSAxMDtcbiAgICB9XG4gICAgdmFyIHJnYiA9IHRoaXMudG9SZ2IoKTtcbiAgICByZ2IuciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiLnIgLSBNYXRoLnJvdW5kKDI1NSAqIC0oYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZ2IuZyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiLmcgLSBNYXRoLnJvdW5kKDI1NSAqIC0oYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZ2IuYiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiLmIgLSBNYXRoLnJvdW5kKDI1NSAqIC0oYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZXR1cm4gbmV3IFRpbnlDb2xvcjIocmdiKTtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUuZGFya2VuID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgaWYgKGFtb3VudCA9PT0gdm9pZCAwKSB7XG4gICAgICBhbW91bnQgPSAxMDtcbiAgICB9XG4gICAgdmFyIGhzbCA9IHRoaXMudG9Ic2woKTtcbiAgICBoc2wubCAtPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLmwgPSBjbGFtcDAxKGhzbC5sKTtcbiAgICByZXR1cm4gbmV3IFRpbnlDb2xvcjIoaHNsKTtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUudGludCA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIGlmIChhbW91bnQgPT09IHZvaWQgMCkge1xuICAgICAgYW1vdW50ID0gMTA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1peChcIndoaXRlXCIsIGFtb3VudCk7XG4gIH07XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLnNoYWRlID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgaWYgKGFtb3VudCA9PT0gdm9pZCAwKSB7XG4gICAgICBhbW91bnQgPSAxMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWl4KFwiYmxhY2tcIiwgYW1vdW50KTtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUuZGVzYXR1cmF0ZSA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIGlmIChhbW91bnQgPT09IHZvaWQgMCkge1xuICAgICAgYW1vdW50ID0gMTA7XG4gICAgfVxuICAgIHZhciBoc2wgPSB0aGlzLnRvSHNsKCk7XG4gICAgaHNsLnMgLT0gYW1vdW50IC8gMTAwO1xuICAgIGhzbC5zID0gY2xhbXAwMShoc2wucyk7XG4gICAgcmV0dXJuIG5ldyBUaW55Q29sb3IyKGhzbCk7XG4gIH07XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLnNhdHVyYXRlID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgaWYgKGFtb3VudCA9PT0gdm9pZCAwKSB7XG4gICAgICBhbW91bnQgPSAxMDtcbiAgICB9XG4gICAgdmFyIGhzbCA9IHRoaXMudG9Ic2woKTtcbiAgICBoc2wucyArPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLnMgPSBjbGFtcDAxKGhzbC5zKTtcbiAgICByZXR1cm4gbmV3IFRpbnlDb2xvcjIoaHNsKTtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUuZ3JleXNjYWxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVzYXR1cmF0ZSgxMDApO1xuICB9O1xuICBUaW55Q29sb3IyLnByb3RvdHlwZS5zcGluID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgdmFyIGhzbCA9IHRoaXMudG9Ic2woKTtcbiAgICB2YXIgaHVlID0gKGhzbC5oICsgYW1vdW50KSAlIDM2MDtcbiAgICBoc2wuaCA9IGh1ZSA8IDAgPyAzNjAgKyBodWUgOiBodWU7XG4gICAgcmV0dXJuIG5ldyBUaW55Q29sb3IyKGhzbCk7XG4gIH07XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLm1peCA9IGZ1bmN0aW9uKGNvbG9yLCBhbW91bnQpIHtcbiAgICBpZiAoYW1vdW50ID09PSB2b2lkIDApIHtcbiAgICAgIGFtb3VudCA9IDUwO1xuICAgIH1cbiAgICB2YXIgcmdiMSA9IHRoaXMudG9SZ2IoKTtcbiAgICB2YXIgcmdiMiA9IG5ldyBUaW55Q29sb3IyKGNvbG9yKS50b1JnYigpO1xuICAgIHZhciBwMiA9IGFtb3VudCAvIDEwMDtcbiAgICB2YXIgcmdiYSA9IHtcbiAgICAgIHI6IChyZ2IyLnIgLSByZ2IxLnIpICogcDIgKyByZ2IxLnIsXG4gICAgICBnOiAocmdiMi5nIC0gcmdiMS5nKSAqIHAyICsgcmdiMS5nLFxuICAgICAgYjogKHJnYjIuYiAtIHJnYjEuYikgKiBwMiArIHJnYjEuYixcbiAgICAgIGE6IChyZ2IyLmEgLSByZ2IxLmEpICogcDIgKyByZ2IxLmFcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVGlueUNvbG9yMihyZ2JhKTtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUuYW5hbG9nb3VzID0gZnVuY3Rpb24ocmVzdWx0cywgc2xpY2VzKSB7XG4gICAgaWYgKHJlc3VsdHMgPT09IHZvaWQgMCkge1xuICAgICAgcmVzdWx0cyA9IDY7XG4gICAgfVxuICAgIGlmIChzbGljZXMgPT09IHZvaWQgMCkge1xuICAgICAgc2xpY2VzID0gMzA7XG4gICAgfVxuICAgIHZhciBoc2wgPSB0aGlzLnRvSHNsKCk7XG4gICAgdmFyIHBhcnQgPSAzNjAgLyBzbGljZXM7XG4gICAgdmFyIHJldCA9IFt0aGlzXTtcbiAgICBmb3IgKGhzbC5oID0gKGhzbC5oIC0gKHBhcnQgKiByZXN1bHRzID4+IDEpICsgNzIwKSAlIDM2MDsgLS1yZXN1bHRzOyApIHtcbiAgICAgIGhzbC5oID0gKGhzbC5oICsgcGFydCkgJSAzNjA7XG4gICAgICByZXQucHVzaChuZXcgVGlueUNvbG9yMihoc2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUuY29tcGxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoc2wgPSB0aGlzLnRvSHNsKCk7XG4gICAgaHNsLmggPSAoaHNsLmggKyAxODApICUgMzYwO1xuICAgIHJldHVybiBuZXcgVGlueUNvbG9yMihoc2wpO1xuICB9O1xuICBUaW55Q29sb3IyLnByb3RvdHlwZS5tb25vY2hyb21hdGljID0gZnVuY3Rpb24ocmVzdWx0cykge1xuICAgIGlmIChyZXN1bHRzID09PSB2b2lkIDApIHtcbiAgICAgIHJlc3VsdHMgPSA2O1xuICAgIH1cbiAgICB2YXIgaHN2ID0gdGhpcy50b0hzdigpO1xuICAgIHZhciBoID0gaHN2Lmg7XG4gICAgdmFyIHMgPSBoc3YucztcbiAgICB2YXIgdjIgPSBoc3YudjtcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIG1vZGlmaWNhdGlvbiA9IDEgLyByZXN1bHRzO1xuICAgIHdoaWxlIChyZXN1bHRzLS0pIHtcbiAgICAgIHJlcy5wdXNoKG5ldyBUaW55Q29sb3IyKHsgaCwgcywgdjogdjIgfSkpO1xuICAgICAgdjIgPSAodjIgKyBtb2RpZmljYXRpb24pICUgMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgVGlueUNvbG9yMi5wcm90b3R5cGUuc3BsaXRjb21wbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhzbCA9IHRoaXMudG9Ic2woKTtcbiAgICB2YXIgaCA9IGhzbC5oO1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLFxuICAgICAgbmV3IFRpbnlDb2xvcjIoeyBoOiAoaCArIDcyKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pLFxuICAgICAgbmV3IFRpbnlDb2xvcjIoeyBoOiAoaCArIDIxNikgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KVxuICAgIF07XG4gIH07XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLm9uQmFja2dyb3VuZCA9IGZ1bmN0aW9uKGJhY2tncm91bmQpIHtcbiAgICB2YXIgZmcgPSB0aGlzLnRvUmdiKCk7XG4gICAgdmFyIGJnID0gbmV3IFRpbnlDb2xvcjIoYmFja2dyb3VuZCkudG9SZ2IoKTtcbiAgICByZXR1cm4gbmV3IFRpbnlDb2xvcjIoe1xuICAgICAgcjogYmcuciArIChmZy5yIC0gYmcucikgKiBmZy5hLFxuICAgICAgZzogYmcuZyArIChmZy5nIC0gYmcuZykgKiBmZy5hLFxuICAgICAgYjogYmcuYiArIChmZy5iIC0gYmcuYikgKiBmZy5hXG4gICAgfSk7XG4gIH07XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLnRyaWFkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucG9seWFkKDMpO1xuICB9O1xuICBUaW55Q29sb3IyLnByb3RvdHlwZS50ZXRyYWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wb2x5YWQoNCk7XG4gIH07XG4gIFRpbnlDb2xvcjIucHJvdG90eXBlLnBvbHlhZCA9IGZ1bmN0aW9uKG4yKSB7XG4gICAgdmFyIGhzbCA9IHRoaXMudG9Ic2woKTtcbiAgICB2YXIgaCA9IGhzbC5oO1xuICAgIHZhciByZXN1bHQgPSBbdGhpc107XG4gICAgdmFyIGluY3JlbWVudCA9IDM2MCAvIG4yO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjI7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2gobmV3IFRpbnlDb2xvcjIoeyBoOiAoaCArIGkgKiBpbmNyZW1lbnQpICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBUaW55Q29sb3IyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiB0aGlzLnRvUmdiU3RyaW5nKCkgPT09IG5ldyBUaW55Q29sb3IyKGNvbG9yKS50b1JnYlN0cmluZygpO1xuICB9O1xuICByZXR1cm4gVGlueUNvbG9yMjtcbn0oKTtcbnZhciBodWVTdGVwID0gMjtcbnZhciBzYXR1cmF0aW9uU3RlcCA9IDAuMTY7XG52YXIgc2F0dXJhdGlvblN0ZXAyID0gMC4wNTtcbnZhciBicmlnaHRuZXNzU3RlcDEgPSAwLjA1O1xudmFyIGJyaWdodG5lc3NTdGVwMiA9IDAuMTU7XG52YXIgbGlnaHRDb2xvckNvdW50ID0gNTtcbnZhciBkYXJrQ29sb3JDb3VudCA9IDQ7XG52YXIgZGFya0NvbG9yTWFwID0gW3tcbiAgaW5kZXg6IDcsXG4gIG9wYWNpdHk6IDAuMTVcbn0sIHtcbiAgaW5kZXg6IDYsXG4gIG9wYWNpdHk6IDAuMjVcbn0sIHtcbiAgaW5kZXg6IDUsXG4gIG9wYWNpdHk6IDAuM1xufSwge1xuICBpbmRleDogNSxcbiAgb3BhY2l0eTogMC40NVxufSwge1xuICBpbmRleDogNSxcbiAgb3BhY2l0eTogMC42NVxufSwge1xuICBpbmRleDogNSxcbiAgb3BhY2l0eTogMC44NVxufSwge1xuICBpbmRleDogNCxcbiAgb3BhY2l0eTogMC45XG59LCB7XG4gIGluZGV4OiAzLFxuICBvcGFjaXR5OiAwLjk1XG59LCB7XG4gIGluZGV4OiAyLFxuICBvcGFjaXR5OiAwLjk3XG59LCB7XG4gIGluZGV4OiAxLFxuICBvcGFjaXR5OiAwLjk4XG59XTtcbmZ1bmN0aW9uIHRvSHN2KF9yZWYpIHtcbiAgdmFyIHIyID0gX3JlZi5yLCBnMiA9IF9yZWYuZywgYjIgPSBfcmVmLmI7XG4gIHZhciBoc3YgPSByZ2JUb0hzdihyMiwgZzIsIGIyKTtcbiAgcmV0dXJuIHtcbiAgICBoOiBoc3YuaCAqIDM2MCxcbiAgICBzOiBoc3YucyxcbiAgICB2OiBoc3YudlxuICB9O1xufVxuZnVuY3Rpb24gdG9IZXgoX3JlZjIpIHtcbiAgdmFyIHIyID0gX3JlZjIuciwgZzIgPSBfcmVmMi5nLCBiMiA9IF9yZWYyLmI7XG4gIHJldHVybiBcIiNcIi5jb25jYXQocmdiVG9IZXgocjIsIGcyLCBiMiwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIG1peCQxKHJnYjEsIHJnYjIsIGFtb3VudCkge1xuICB2YXIgcDIgPSBhbW91bnQgLyAxMDA7XG4gIHZhciByZ2IgPSB7XG4gICAgcjogKHJnYjIuciAtIHJnYjEucikgKiBwMiArIHJnYjEucixcbiAgICBnOiAocmdiMi5nIC0gcmdiMS5nKSAqIHAyICsgcmdiMS5nLFxuICAgIGI6IChyZ2IyLmIgLSByZ2IxLmIpICogcDIgKyByZ2IxLmJcbiAgfTtcbiAgcmV0dXJuIHJnYjtcbn1cbmZ1bmN0aW9uIGdldEh1ZShoc3YsIGksIGxpZ2h0KSB7XG4gIHZhciBodWU7XG4gIGlmIChNYXRoLnJvdW5kKGhzdi5oKSA+PSA2MCAmJiBNYXRoLnJvdW5kKGhzdi5oKSA8PSAyNDApIHtcbiAgICBodWUgPSBsaWdodCA/IE1hdGgucm91bmQoaHN2LmgpIC0gaHVlU3RlcCAqIGkgOiBNYXRoLnJvdW5kKGhzdi5oKSArIGh1ZVN0ZXAgKiBpO1xuICB9IGVsc2Uge1xuICAgIGh1ZSA9IGxpZ2h0ID8gTWF0aC5yb3VuZChoc3YuaCkgKyBodWVTdGVwICogaSA6IE1hdGgucm91bmQoaHN2LmgpIC0gaHVlU3RlcCAqIGk7XG4gIH1cbiAgaWYgKGh1ZSA8IDApIHtcbiAgICBodWUgKz0gMzYwO1xuICB9IGVsc2UgaWYgKGh1ZSA+PSAzNjApIHtcbiAgICBodWUgLT0gMzYwO1xuICB9XG4gIHJldHVybiBodWU7XG59XG5mdW5jdGlvbiBnZXRTYXR1cmF0aW9uKGhzdiwgaSwgbGlnaHQpIHtcbiAgaWYgKGhzdi5oID09PSAwICYmIGhzdi5zID09PSAwKSB7XG4gICAgcmV0dXJuIGhzdi5zO1xuICB9XG4gIHZhciBzYXR1cmF0aW9uO1xuICBpZiAobGlnaHQpIHtcbiAgICBzYXR1cmF0aW9uID0gaHN2LnMgLSBzYXR1cmF0aW9uU3RlcCAqIGk7XG4gIH0gZWxzZSBpZiAoaSA9PT0gZGFya0NvbG9yQ291bnQpIHtcbiAgICBzYXR1cmF0aW9uID0gaHN2LnMgKyBzYXR1cmF0aW9uU3RlcDtcbiAgfSBlbHNlIHtcbiAgICBzYXR1cmF0aW9uID0gaHN2LnMgKyBzYXR1cmF0aW9uU3RlcDIgKiBpO1xuICB9XG4gIGlmIChzYXR1cmF0aW9uID4gMSkge1xuICAgIHNhdHVyYXRpb24gPSAxO1xuICB9XG4gIGlmIChsaWdodCAmJiBpID09PSBsaWdodENvbG9yQ291bnQgJiYgc2F0dXJhdGlvbiA+IDAuMSkge1xuICAgIHNhdHVyYXRpb24gPSAwLjE7XG4gIH1cbiAgaWYgKHNhdHVyYXRpb24gPCAwLjA2KSB7XG4gICAgc2F0dXJhdGlvbiA9IDAuMDY7XG4gIH1cbiAgcmV0dXJuIE51bWJlcihzYXR1cmF0aW9uLnRvRml4ZWQoMikpO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWUkNChoc3YsIGksIGxpZ2h0KSB7XG4gIHZhciB2YWx1ZTtcbiAgaWYgKGxpZ2h0KSB7XG4gICAgdmFsdWUgPSBoc3YudiArIGJyaWdodG5lc3NTdGVwMSAqIGk7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBoc3YudiAtIGJyaWdodG5lc3NTdGVwMiAqIGk7XG4gIH1cbiAgaWYgKHZhbHVlID4gMSkge1xuICAgIHZhbHVlID0gMTtcbiAgfVxuICByZXR1cm4gTnVtYmVyKHZhbHVlLnRvRml4ZWQoMikpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGUkMShjb2xvcikge1xuICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBwYXR0ZXJucyA9IFtdO1xuICB2YXIgcENvbG9yID0gaW5wdXRUb1JHQihjb2xvcik7XG4gIGZvciAodmFyIGkgPSBsaWdodENvbG9yQ291bnQ7IGkgPiAwOyBpIC09IDEpIHtcbiAgICB2YXIgaHN2ID0gdG9Ic3YocENvbG9yKTtcbiAgICB2YXIgY29sb3JTdHJpbmcgPSB0b0hleChpbnB1dFRvUkdCKHtcbiAgICAgIGg6IGdldEh1ZShoc3YsIGksIHRydWUpLFxuICAgICAgczogZ2V0U2F0dXJhdGlvbihoc3YsIGksIHRydWUpLFxuICAgICAgdjogZ2V0VmFsdWUkNChoc3YsIGksIHRydWUpXG4gICAgfSkpO1xuICAgIHBhdHRlcm5zLnB1c2goY29sb3JTdHJpbmcpO1xuICB9XG4gIHBhdHRlcm5zLnB1c2godG9IZXgocENvbG9yKSk7XG4gIGZvciAodmFyIF9pID0gMTsgX2kgPD0gZGFya0NvbG9yQ291bnQ7IF9pICs9IDEpIHtcbiAgICB2YXIgX2hzdiA9IHRvSHN2KHBDb2xvcik7XG4gICAgdmFyIF9jb2xvclN0cmluZyA9IHRvSGV4KGlucHV0VG9SR0Ioe1xuICAgICAgaDogZ2V0SHVlKF9oc3YsIF9pKSxcbiAgICAgIHM6IGdldFNhdHVyYXRpb24oX2hzdiwgX2kpLFxuICAgICAgdjogZ2V0VmFsdWUkNChfaHN2LCBfaSlcbiAgICB9KSk7XG4gICAgcGF0dGVybnMucHVzaChfY29sb3JTdHJpbmcpO1xuICB9XG4gIGlmIChvcHRzLnRoZW1lID09PSBcImRhcmtcIikge1xuICAgIHJldHVybiBkYXJrQ29sb3JNYXAubWFwKGZ1bmN0aW9uKF9yZWYzKSB7XG4gICAgICB2YXIgaW5kZXgyID0gX3JlZjMuaW5kZXgsIG9wYWNpdHkgPSBfcmVmMy5vcGFjaXR5O1xuICAgICAgdmFyIGRhcmtDb2xvclN0cmluZyA9IHRvSGV4KG1peCQxKGlucHV0VG9SR0Iob3B0cy5iYWNrZ3JvdW5kQ29sb3IgfHwgXCIjMTQxNDE0XCIpLCBpbnB1dFRvUkdCKHBhdHRlcm5zW2luZGV4Ml0pLCBvcGFjaXR5ICogMTAwKSk7XG4gICAgICByZXR1cm4gZGFya0NvbG9yU3RyaW5nO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXR0ZXJucztcbn1cbnZhciBwcmVzZXRQcmltYXJ5Q29sb3JzID0ge1xuICByZWQ6IFwiI0Y1MjIyRFwiLFxuICB2b2xjYW5vOiBcIiNGQTU0MUNcIixcbiAgb3JhbmdlOiBcIiNGQThDMTZcIixcbiAgZ29sZDogXCIjRkFBRDE0XCIsXG4gIHllbGxvdzogXCIjRkFEQjE0XCIsXG4gIGxpbWU6IFwiI0EwRDkxMVwiLFxuICBncmVlbjogXCIjNTJDNDFBXCIsXG4gIGN5YW46IFwiIzEzQzJDMlwiLFxuICBibHVlOiBcIiMxODkwRkZcIixcbiAgZ2Vla2JsdWU6IFwiIzJGNTRFQlwiLFxuICBwdXJwbGU6IFwiIzcyMkVEMVwiLFxuICBtYWdlbnRhOiBcIiNFQjJGOTZcIixcbiAgZ3JleTogXCIjNjY2NjY2XCJcbn07XG52YXIgcHJlc2V0UGFsZXR0ZXMgPSB7fTtcbnZhciBwcmVzZXREYXJrUGFsZXR0ZXMgPSB7fTtcbk9iamVjdC5rZXlzKHByZXNldFByaW1hcnlDb2xvcnMpLmZvckVhY2goZnVuY3Rpb24oa2V5Mikge1xuICBwcmVzZXRQYWxldHRlc1trZXkyXSA9IGdlbmVyYXRlJDEocHJlc2V0UHJpbWFyeUNvbG9yc1trZXkyXSk7XG4gIHByZXNldFBhbGV0dGVzW2tleTJdLnByaW1hcnkgPSBwcmVzZXRQYWxldHRlc1trZXkyXVs1XTtcbiAgcHJlc2V0RGFya1BhbGV0dGVzW2tleTJdID0gZ2VuZXJhdGUkMShwcmVzZXRQcmltYXJ5Q29sb3JzW2tleTJdLCB7XG4gICAgdGhlbWU6IFwiZGFya1wiLFxuICAgIGJhY2tncm91bmRDb2xvcjogXCIjMTQxNDE0XCJcbiAgfSk7XG4gIHByZXNldERhcmtQYWxldHRlc1trZXkyXS5wcmltYXJ5ID0gcHJlc2V0RGFya1BhbGV0dGVzW2tleTJdWzVdO1xufSk7XG5wcmVzZXRQYWxldHRlcy5yZWQ7XG5wcmVzZXRQYWxldHRlcy52b2xjYW5vO1xucHJlc2V0UGFsZXR0ZXMuZ29sZDtcbnByZXNldFBhbGV0dGVzLm9yYW5nZTtcbnByZXNldFBhbGV0dGVzLnllbGxvdztcbnByZXNldFBhbGV0dGVzLmxpbWU7XG5wcmVzZXRQYWxldHRlcy5ncmVlbjtcbnByZXNldFBhbGV0dGVzLmN5YW47XG5wcmVzZXRQYWxldHRlcy5ibHVlO1xucHJlc2V0UGFsZXR0ZXMuZ2Vla2JsdWU7XG5wcmVzZXRQYWxldHRlcy5wdXJwbGU7XG5wcmVzZXRQYWxldHRlcy5tYWdlbnRhO1xucHJlc2V0UGFsZXR0ZXMuZ3JleTtcbnZhciB3YXJuZWQgPSB7fTtcbmZ1bmN0aW9uIHdhcm5pbmckMih2YWxpZCwgbWVzc2FnZTIpIHtcbn1cbmZ1bmN0aW9uIGNhbGwobWV0aG9kNCwgdmFsaWQsIG1lc3NhZ2UyKSB7XG4gIGlmICghdmFsaWQgJiYgIXdhcm5lZFttZXNzYWdlMl0pIHtcbiAgICBtZXRob2Q0KGZhbHNlLCBtZXNzYWdlMik7XG4gICAgd2FybmVkW21lc3NhZ2UyXSA9IHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5pbmdPbmNlKHZhbGlkLCBtZXNzYWdlMikge1xuICBjYWxsKHdhcm5pbmckMiwgdmFsaWQsIG1lc3NhZ2UyKTtcbn1cbnZhciBNQVJLX0tFWSA9IFwicmMtdXRpbC1rZXlcIjtcbmZ1bmN0aW9uIGdldE1hcmsoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fSwgbWFyayA9IF9yZWYubWFyaztcbiAgaWYgKG1hcmspIHtcbiAgICByZXR1cm4gbWFyay5zdGFydHNXaXRoKFwiZGF0YS1cIikgPyBtYXJrIDogXCJkYXRhLVwiLmNvbmNhdChtYXJrKTtcbiAgfVxuICByZXR1cm4gTUFSS19LRVk7XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXIkMShvcHRpb24pIHtcbiAgaWYgKG9wdGlvbi5hdHRhY2hUbykge1xuICAgIHJldHVybiBvcHRpb24uYXR0YWNoVG87XG4gIH1cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaGVhZFwiKTtcbiAgcmV0dXJuIGhlYWQgfHwgZG9jdW1lbnQuYm9keTtcbn1cbmZ1bmN0aW9uIGluamVjdENTUyhjc3MyKSB7XG4gIHZhciBfb3B0aW9uJGNzcDtcbiAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gIGlmICghY2FuVXNlRG9tKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBpZiAoKF9vcHRpb24kY3NwID0gb3B0aW9uLmNzcCkgPT09IG51bGwgfHwgX29wdGlvbiRjc3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb24kY3NwLm5vbmNlKSB7XG4gICAgdmFyIF9vcHRpb24kY3NwMjtcbiAgICBzdHlsZU5vZGUubm9uY2UgPSAoX29wdGlvbiRjc3AyID0gb3B0aW9uLmNzcCkgPT09IG51bGwgfHwgX29wdGlvbiRjc3AyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9uJGNzcDIubm9uY2U7XG4gIH1cbiAgc3R5bGVOb2RlLmlubmVySFRNTCA9IGNzczI7XG4gIHZhciBjb250YWluZXIgPSBnZXRDb250YWluZXIkMShvcHRpb24pO1xuICB2YXIgZmlyc3RDaGlsZCA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICBpZiAob3B0aW9uLnByZXBlbmQgJiYgY29udGFpbmVyLnByZXBlbmQpIHtcbiAgICBjb250YWluZXIucHJlcGVuZChzdHlsZU5vZGUpO1xuICB9IGVsc2UgaWYgKG9wdGlvbi5wcmVwZW5kICYmIGZpcnN0Q2hpbGQpIHtcbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHN0eWxlTm9kZSwgZmlyc3RDaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHN0eWxlTm9kZSk7XG4gIH1cbiAgcmV0dXJuIHN0eWxlTm9kZTtcbn1cbnZhciBjb250YWluZXJDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBmaW5kRXhpc3ROb2RlKGtleTIpIHtcbiAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBjb250YWluZXIgPSBnZXRDb250YWluZXIkMShvcHRpb24pO1xuICByZXR1cm4gQXJyYXkuZnJvbShjb250YWluZXJDYWNoZS5nZXQoY29udGFpbmVyKS5jaGlsZHJlbikuZmluZChmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gXCJTVFlMRVwiICYmIG5vZGUuZ2V0QXR0cmlidXRlKGdldE1hcmsob3B0aW9uKSkgPT09IGtleTI7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlQ1NTKGNzczIsIGtleTIpIHtcbiAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBjb250YWluZXIgPSBnZXRDb250YWluZXIkMShvcHRpb24pO1xuICBpZiAoIWNvbnRhaW5lckNhY2hlLmhhcyhjb250YWluZXIpKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyU3R5bGUgPSBpbmplY3RDU1MoXCJcIiwgb3B0aW9uKTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHBsYWNlaG9sZGVyU3R5bGUucGFyZW50Tm9kZTtcbiAgICBjb250YWluZXJDYWNoZS5zZXQoY29udGFpbmVyLCBwYXJlbnROb2RlKTtcbiAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBsYWNlaG9sZGVyU3R5bGUpO1xuICB9XG4gIHZhciBleGlzdE5vZGUgPSBmaW5kRXhpc3ROb2RlKGtleTIsIG9wdGlvbik7XG4gIGlmIChleGlzdE5vZGUpIHtcbiAgICB2YXIgX29wdGlvbiRjc3AzLCBfb3B0aW9uJGNzcDQ7XG4gICAgaWYgKCgoX29wdGlvbiRjc3AzID0gb3B0aW9uLmNzcCkgPT09IG51bGwgfHwgX29wdGlvbiRjc3AzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9uJGNzcDMubm9uY2UpICYmIGV4aXN0Tm9kZS5ub25jZSAhPT0gKChfb3B0aW9uJGNzcDQgPSBvcHRpb24uY3NwKSA9PT0gbnVsbCB8fCBfb3B0aW9uJGNzcDQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb24kY3NwNC5ub25jZSkpIHtcbiAgICAgIHZhciBfb3B0aW9uJGNzcDU7XG4gICAgICBleGlzdE5vZGUubm9uY2UgPSAoX29wdGlvbiRjc3A1ID0gb3B0aW9uLmNzcCkgPT09IG51bGwgfHwgX29wdGlvbiRjc3A1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9uJGNzcDUubm9uY2U7XG4gICAgfVxuICAgIGlmIChleGlzdE5vZGUuaW5uZXJIVE1MICE9PSBjc3MyKSB7XG4gICAgICBleGlzdE5vZGUuaW5uZXJIVE1MID0gY3NzMjtcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0Tm9kZTtcbiAgfVxuICB2YXIgbmV3Tm9kZSA9IGluamVjdENTUyhjc3MyLCBvcHRpb24pO1xuICBuZXdOb2RlLnNldEF0dHJpYnV0ZShnZXRNYXJrKG9wdGlvbiksIGtleTIpO1xuICByZXR1cm4gbmV3Tm9kZTtcbn1cbmZ1bmN0aW9uIHdhcm5pbmckMSh2YWxpZCwgbWVzc2FnZTIpIHtcbiAgd2FybmluZ09uY2UodmFsaWQsIFwiW0BhbnQtZGVzaWduL2ljb25zXSBcIi5jb25jYXQobWVzc2FnZTIpKTtcbn1cbmZ1bmN0aW9uIGlzSWNvbkRlZmluaXRpb24odGFyZ2V0KSB7XG4gIHJldHVybiBfdHlwZW9mJDEodGFyZ2V0KSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdGFyZ2V0Lm5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHRhcmdldC50aGVtZSA9PT0gXCJzdHJpbmdcIiAmJiAoX3R5cGVvZiQxKHRhcmdldC5pY29uKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdGFyZ2V0Lmljb24gPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBub3JtYWxpemVBdHRycygpIHtcbiAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJzKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBrZXkyKSB7XG4gICAgdmFyIHZhbCA9IGF0dHJzW2tleTJdO1xuICAgIHN3aXRjaCAoa2V5Mikge1xuICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgIGFjYy5jbGFzc05hbWUgPSB2YWw7XG4gICAgICAgIGRlbGV0ZSBhY2MuY2xhc3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYWNjW2tleTJdID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZShub2RlLCBrZXkyLCByb290UHJvcHMpIHtcbiAgaWYgKCFyb290UHJvcHMpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQobm9kZS50YWcsIF9vYmplY3RTcHJlYWQyJDEoe1xuICAgICAga2V5OiBrZXkyXG4gICAgfSwgbm9ybWFsaXplQXR0cnMobm9kZS5hdHRycykpLCAobm9kZS5jaGlsZHJlbiB8fCBbXSkubWFwKGZ1bmN0aW9uKGNoaWxkLCBpbmRleDIpIHtcbiAgICAgIHJldHVybiBnZW5lcmF0ZShjaGlsZCwgXCJcIi5jb25jYXQoa2V5MiwgXCItXCIpLmNvbmNhdChub2RlLnRhZywgXCItXCIpLmNvbmNhdChpbmRleDIpKTtcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KG5vZGUudGFnLCBfb2JqZWN0U3ByZWFkMiQxKF9vYmplY3RTcHJlYWQyJDEoe1xuICAgIGtleToga2V5MlxuICB9LCBub3JtYWxpemVBdHRycyhub2RlLmF0dHJzKSksIHJvb3RQcm9wcyksIChub2RlLmNoaWxkcmVuIHx8IFtdKS5tYXAoZnVuY3Rpb24oY2hpbGQsIGluZGV4Mikge1xuICAgIHJldHVybiBnZW5lcmF0ZShjaGlsZCwgXCJcIi5jb25jYXQoa2V5MiwgXCItXCIpLmNvbmNhdChub2RlLnRhZywgXCItXCIpLmNvbmNhdChpbmRleDIpKTtcbiAgfSkpO1xufVxuZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5Q29sb3IocHJpbWFyeUNvbG9yKSB7XG4gIHJldHVybiBnZW5lcmF0ZSQxKHByaW1hcnlDb2xvcilbMF07XG59XG5mdW5jdGlvbiBub3JtYWxpemVUd29Ub25lQ29sb3JzKHR3b1RvbmVDb2xvcikge1xuICBpZiAoIXR3b1RvbmVDb2xvcikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0d29Ub25lQ29sb3IpID8gdHdvVG9uZUNvbG9yIDogW3R3b1RvbmVDb2xvcl07XG59XG52YXIgaWNvblN0eWxlcyA9IFwiXFxuLmFudGljb24ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBsaW5lLWhlaWdodDogMDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbiAgdmVydGljYWwtYWxpZ246IC0wLjEyNWVtO1xcbiAgdGV4dC1yZW5kZXJpbmc6IG9wdGltaXplTGVnaWJpbGl0eTtcXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcXG59XFxuXFxuLmFudGljb24gPiAqIHtcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcbn1cXG5cXG4uYW50aWNvbiBzdmcge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG5cXG4uYW50aWNvbjo6YmVmb3JlIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi5hbnRpY29uIC5hbnRpY29uLWljb24ge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbi5hbnRpY29uW3RhYmluZGV4XSB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5hbnRpY29uLXNwaW46OmJlZm9yZSxcXG4uYW50aWNvbi1zcGluIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBsb2FkaW5nQ2lyY2xlIDFzIGluZmluaXRlIGxpbmVhcjtcXG4gIGFuaW1hdGlvbjogbG9hZGluZ0NpcmNsZSAxcyBpbmZpbml0ZSBsaW5lYXI7XFxufVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBsb2FkaW5nQ2lyY2xlIHtcXG4gIDEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgbG9hZGluZ0NpcmNsZSB7XFxuICAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgfVxcbn1cXG5cIjtcbnZhciB1c2VJbnNlcnRTdHlsZXMgPSBmdW5jdGlvbiB1c2VJbnNlcnRTdHlsZXMyKCkge1xuICB2YXIgc3R5bGVTdHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IGljb25TdHlsZXM7XG4gIHZhciBfdXNlQ29udGV4dCA9IHVzZUNvbnRleHQoSWNvbkNvbnRleHQkMSksIGNzcCA9IF91c2VDb250ZXh0LmNzcDtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZUNTUyhzdHlsZVN0ciwgXCJAYW50LWRlc2lnbi1pY29uc1wiLCB7XG4gICAgICBwcmVwZW5kOiB0cnVlLFxuICAgICAgY3NwXG4gICAgfSk7XG4gIH0sIFtdKTtcbn07XG52YXIgX2V4Y2x1ZGVkJDUgPSBbXCJpY29uXCIsIFwiY2xhc3NOYW1lXCIsIFwib25DbGlja1wiLCBcInN0eWxlXCIsIFwicHJpbWFyeUNvbG9yXCIsIFwic2Vjb25kYXJ5Q29sb3JcIl07XG52YXIgdHdvVG9uZUNvbG9yUGFsZXR0ZSA9IHtcbiAgcHJpbWFyeUNvbG9yOiBcIiMzMzNcIixcbiAgc2Vjb25kYXJ5Q29sb3I6IFwiI0U2RTZFNlwiLFxuICBjYWxjdWxhdGVkOiBmYWxzZVxufTtcbmZ1bmN0aW9uIHNldFR3b1RvbmVDb2xvcnMoX3JlZikge1xuICB2YXIgcHJpbWFyeUNvbG9yID0gX3JlZi5wcmltYXJ5Q29sb3IsIHNlY29uZGFyeUNvbG9yID0gX3JlZi5zZWNvbmRhcnlDb2xvcjtcbiAgdHdvVG9uZUNvbG9yUGFsZXR0ZS5wcmltYXJ5Q29sb3IgPSBwcmltYXJ5Q29sb3I7XG4gIHR3b1RvbmVDb2xvclBhbGV0dGUuc2Vjb25kYXJ5Q29sb3IgPSBzZWNvbmRhcnlDb2xvciB8fCBnZXRTZWNvbmRhcnlDb2xvcihwcmltYXJ5Q29sb3IpO1xuICB0d29Ub25lQ29sb3JQYWxldHRlLmNhbGN1bGF0ZWQgPSAhIXNlY29uZGFyeUNvbG9yO1xufVxuZnVuY3Rpb24gZ2V0VHdvVG9uZUNvbG9ycygpIHtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyJDEoe30sIHR3b1RvbmVDb2xvclBhbGV0dGUpO1xufVxudmFyIEljb25CYXNlID0gZnVuY3Rpb24gSWNvbkJhc2UyKHByb3BzKSB7XG4gIHZhciBpY29uID0gcHJvcHMuaWNvbiwgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLCBvbkNsaWNrID0gcHJvcHMub25DbGljaywgc3R5bGUyID0gcHJvcHMuc3R5bGUsIHByaW1hcnlDb2xvciA9IHByb3BzLnByaW1hcnlDb2xvciwgc2Vjb25kYXJ5Q29sb3IgPSBwcm9wcy5zZWNvbmRhcnlDb2xvciwgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQkNSk7XG4gIHZhciBjb2xvcnMgPSB0d29Ub25lQ29sb3JQYWxldHRlO1xuICBpZiAocHJpbWFyeUNvbG9yKSB7XG4gICAgY29sb3JzID0ge1xuICAgICAgcHJpbWFyeUNvbG9yLFxuICAgICAgc2Vjb25kYXJ5Q29sb3I6IHNlY29uZGFyeUNvbG9yIHx8IGdldFNlY29uZGFyeUNvbG9yKHByaW1hcnlDb2xvcilcbiAgICB9O1xuICB9XG4gIHVzZUluc2VydFN0eWxlcygpO1xuICB3YXJuaW5nJDEoaXNJY29uRGVmaW5pdGlvbihpY29uKSwgXCJpY29uIHNob3VsZCBiZSBpY29uIGRlZmluaXRvbiwgYnV0IGdvdCBcIi5jb25jYXQoaWNvbikpO1xuICBpZiAoIWlzSWNvbkRlZmluaXRpb24oaWNvbikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgdGFyZ2V0ID0gaWNvbjtcbiAgaWYgKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0Lmljb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRhcmdldCA9IF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwgdGFyZ2V0KSwge30sIHtcbiAgICAgIGljb246IHRhcmdldC5pY29uKGNvbG9ycy5wcmltYXJ5Q29sb3IsIGNvbG9ycy5zZWNvbmRhcnlDb2xvcilcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZ2VuZXJhdGUodGFyZ2V0Lmljb24sIFwic3ZnLVwiLmNvbmNhdCh0YXJnZXQubmFtZSksIF9vYmplY3RTcHJlYWQyJDEoe1xuICAgIGNsYXNzTmFtZSxcbiAgICBvbkNsaWNrLFxuICAgIHN0eWxlOiBzdHlsZTIsXG4gICAgXCJkYXRhLWljb25cIjogdGFyZ2V0Lm5hbWUsXG4gICAgd2lkdGg6IFwiMWVtXCIsXG4gICAgaGVpZ2h0OiBcIjFlbVwiLFxuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICB9LCByZXN0UHJvcHMpKTtcbn07XG5JY29uQmFzZS5kaXNwbGF5TmFtZSA9IFwiSWNvblJlYWN0XCI7XG5JY29uQmFzZS5nZXRUd29Ub25lQ29sb3JzID0gZ2V0VHdvVG9uZUNvbG9ycztcbkljb25CYXNlLnNldFR3b1RvbmVDb2xvcnMgPSBzZXRUd29Ub25lQ29sb3JzO1xudmFyIFJlYWN0SWNvbiA9IEljb25CYXNlO1xuZnVuY3Rpb24gc2V0VHdvVG9uZUNvbG9yKHR3b1RvbmVDb2xvcikge1xuICB2YXIgX25vcm1hbGl6ZVR3b1RvbmVDb2xvID0gbm9ybWFsaXplVHdvVG9uZUNvbG9ycyh0d29Ub25lQ29sb3IpLCBfbm9ybWFsaXplVHdvVG9uZUNvbG8yID0gX3NsaWNlZFRvQXJyYXkoX25vcm1hbGl6ZVR3b1RvbmVDb2xvLCAyKSwgcHJpbWFyeUNvbG9yID0gX25vcm1hbGl6ZVR3b1RvbmVDb2xvMlswXSwgc2Vjb25kYXJ5Q29sb3IgPSBfbm9ybWFsaXplVHdvVG9uZUNvbG8yWzFdO1xuICByZXR1cm4gUmVhY3RJY29uLnNldFR3b1RvbmVDb2xvcnMoe1xuICAgIHByaW1hcnlDb2xvcixcbiAgICBzZWNvbmRhcnlDb2xvclxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFR3b1RvbmVDb2xvcigpIHtcbiAgdmFyIGNvbG9ycyA9IFJlYWN0SWNvbi5nZXRUd29Ub25lQ29sb3JzKCk7XG4gIGlmICghY29sb3JzLmNhbGN1bGF0ZWQpIHtcbiAgICByZXR1cm4gY29sb3JzLnByaW1hcnlDb2xvcjtcbiAgfVxuICByZXR1cm4gW2NvbG9ycy5wcmltYXJ5Q29sb3IsIGNvbG9ycy5zZWNvbmRhcnlDb2xvcl07XG59XG52YXIgX2V4Y2x1ZGVkJDQgPSBbXCJjbGFzc05hbWVcIiwgXCJpY29uXCIsIFwic3BpblwiLCBcInJvdGF0ZVwiLCBcInRhYkluZGV4XCIsIFwib25DbGlja1wiLCBcInR3b1RvbmVDb2xvclwiXTtcbnNldFR3b1RvbmVDb2xvcihcIiMxODkwZmZcIik7XG52YXIgSWNvbiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uKHByb3BzLCByZWYpIHtcbiAgdmFyIF9jbGFzc05hbWVzO1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLCBpY29uID0gcHJvcHMuaWNvbiwgc3BpbiA9IHByb3BzLnNwaW4sIHJvdGF0ZSA9IHByb3BzLnJvdGF0ZSwgdGFiSW5kZXggPSBwcm9wcy50YWJJbmRleCwgb25DbGljayA9IHByb3BzLm9uQ2xpY2ssIHR3b1RvbmVDb2xvciA9IHByb3BzLnR3b1RvbmVDb2xvciwgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQkNCk7XG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoSWNvbkNvbnRleHQkMSksIF9SZWFjdCR1c2VDb250ZXh0JHByZSA9IF9SZWFjdCR1c2VDb250ZXh0LnByZWZpeENscywgcHJlZml4Q2xzID0gX1JlYWN0JHVzZUNvbnRleHQkcHJlID09PSB2b2lkIDAgPyBcImFudGljb25cIiA6IF9SZWFjdCR1c2VDb250ZXh0JHByZTtcbiAgdmFyIGNsYXNzU3RyaW5nID0gY2xhc3NOYW1lcyhwcmVmaXhDbHMsIChfY2xhc3NOYW1lcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lcywgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1cIikuY29uY2F0KGljb24ubmFtZSksICEhaWNvbi5uYW1lKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItc3BpblwiKSwgISFzcGluIHx8IGljb24ubmFtZSA9PT0gXCJsb2FkaW5nXCIpLCBfY2xhc3NOYW1lcyksIGNsYXNzTmFtZSk7XG4gIHZhciBpY29uVGFiSW5kZXggPSB0YWJJbmRleDtcbiAgaWYgKGljb25UYWJJbmRleCA9PT0gdm9pZCAwICYmIG9uQ2xpY2spIHtcbiAgICBpY29uVGFiSW5kZXggPSAtMTtcbiAgfVxuICB2YXIgc3ZnU3R5bGUgPSByb3RhdGUgPyB7XG4gICAgbXNUcmFuc2Zvcm06IFwicm90YXRlKFwiLmNvbmNhdChyb3RhdGUsIFwiZGVnKVwiKSxcbiAgICB0cmFuc2Zvcm06IFwicm90YXRlKFwiLmNvbmNhdChyb3RhdGUsIFwiZGVnKVwiKVxuICB9IDogdm9pZCAwO1xuICB2YXIgX25vcm1hbGl6ZVR3b1RvbmVDb2xvID0gbm9ybWFsaXplVHdvVG9uZUNvbG9ycyh0d29Ub25lQ29sb3IpLCBfbm9ybWFsaXplVHdvVG9uZUNvbG8yID0gX3NsaWNlZFRvQXJyYXkoX25vcm1hbGl6ZVR3b1RvbmVDb2xvLCAyKSwgcHJpbWFyeUNvbG9yID0gX25vcm1hbGl6ZVR3b1RvbmVDb2xvMlswXSwgc2Vjb25kYXJ5Q29sb3IgPSBfbm9ybWFsaXplVHdvVG9uZUNvbG8yWzFdO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7XG4gICAgcm9sZTogXCJpbWdcIixcbiAgICBcImFyaWEtbGFiZWxcIjogaWNvbi5uYW1lXG4gIH0sIHJlc3RQcm9wcyksIHt9LCB7XG4gICAgcmVmLFxuICAgIHRhYkluZGV4OiBpY29uVGFiSW5kZXgsXG4gICAgb25DbGljayxcbiAgICBjbGFzc05hbWU6IGNsYXNzU3RyaW5nXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdEljb24sIHtcbiAgICBpY29uLFxuICAgIHByaW1hcnlDb2xvcixcbiAgICBzZWNvbmRhcnlDb2xvcixcbiAgICBzdHlsZTogc3ZnU3R5bGVcbiAgfSkpO1xufSk7XG5JY29uLmRpc3BsYXlOYW1lID0gXCJBbnRkSWNvblwiO1xuSWNvbi5nZXRUd29Ub25lQ29sb3IgPSBnZXRUd29Ub25lQ29sb3I7XG5JY29uLnNldFR3b1RvbmVDb2xvciA9IHNldFR3b1RvbmVDb2xvcjtcbnZhciBBbnRkSWNvbiA9IEljb247XG52YXIgTG9hZGluZ091dGxpbmVkID0gZnVuY3Rpb24gTG9hZGluZ091dGxpbmVkMihwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChBbnRkSWNvbiwgX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgcmVmLFxuICAgIGljb246IExvYWRpbmdPdXRsaW5lZFN2Z1xuICB9KSk7XG59O1xuTG9hZGluZ091dGxpbmVkLmRpc3BsYXlOYW1lID0gXCJMb2FkaW5nT3V0bGluZWRcIjtcbnZhciBMb2FkaW5nT3V0bGluZWQkMSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5mb3J3YXJkUmVmKExvYWRpbmdPdXRsaW5lZCk7XG52YXIgRXhjbGFtYXRpb25DaXJjbGVGaWxsZWQkMiA9IHsgXCJpY29uXCI6IHsgXCJ0YWdcIjogXCJzdmdcIiwgXCJhdHRyc1wiOiB7IFwidmlld0JveFwiOiBcIjY0IDY0IDg5NiA4OTZcIiwgXCJmb2N1c2FibGVcIjogXCJmYWxzZVwiIH0sIFwiY2hpbGRyZW5cIjogW3sgXCJ0YWdcIjogXCJwYXRoXCIsIFwiYXR0cnNcIjogeyBcImRcIjogXCJNNTEyIDY0QzI2NC42IDY0IDY0IDI2NC42IDY0IDUxMnMyMDAuNiA0NDggNDQ4IDQ0OCA0NDgtMjAwLjYgNDQ4LTQ0OFM3NTkuNCA2NCA1MTIgNjR6bS0zMiAyMzJjMC00LjQgMy42LTggOC04aDQ4YzQuNCAwIDggMy42IDggOHYyNzJjMCA0LjQtMy42IDgtOCA4aC00OGMtNC40IDAtOC0zLjYtOC04VjI5NnptMzIgNDQwYTQ4LjAxIDQ4LjAxIDAgMDEwLTk2IDQ4LjAxIDQ4LjAxIDAgMDEwIDk2elwiIH0gfV0gfSwgXCJuYW1lXCI6IFwiZXhjbGFtYXRpb24tY2lyY2xlXCIsIFwidGhlbWVcIjogXCJmaWxsZWRcIiB9O1xudmFyIEV4Y2xhbWF0aW9uQ2lyY2xlRmlsbGVkU3ZnID0gRXhjbGFtYXRpb25DaXJjbGVGaWxsZWQkMjtcbnZhciBFeGNsYW1hdGlvbkNpcmNsZUZpbGxlZCA9IGZ1bmN0aW9uIEV4Y2xhbWF0aW9uQ2lyY2xlRmlsbGVkMihwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChBbnRkSWNvbiwgX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgcmVmLFxuICAgIGljb246IEV4Y2xhbWF0aW9uQ2lyY2xlRmlsbGVkU3ZnXG4gIH0pKTtcbn07XG5FeGNsYW1hdGlvbkNpcmNsZUZpbGxlZC5kaXNwbGF5TmFtZSA9IFwiRXhjbGFtYXRpb25DaXJjbGVGaWxsZWRcIjtcbnZhciBFeGNsYW1hdGlvbkNpcmNsZUZpbGxlZCQxID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmZvcndhcmRSZWYoRXhjbGFtYXRpb25DaXJjbGVGaWxsZWQpO1xudmFyIENsb3NlQ2lyY2xlRmlsbGVkJDIgPSB7IFwiaWNvblwiOiB7IFwidGFnXCI6IFwic3ZnXCIsIFwiYXR0cnNcIjogeyBcInZpZXdCb3hcIjogXCI2NCA2NCA4OTYgODk2XCIsIFwiZm9jdXNhYmxlXCI6IFwiZmFsc2VcIiB9LCBcImNoaWxkcmVuXCI6IFt7IFwidGFnXCI6IFwicGF0aFwiLCBcImF0dHJzXCI6IHsgXCJkXCI6IFwiTTUxMiA2NEMyNjQuNiA2NCA2NCAyNjQuNiA2NCA1MTJzMjAwLjYgNDQ4IDQ0OCA0NDggNDQ4LTIwMC42IDQ0OC00NDhTNzU5LjQgNjQgNTEyIDY0em0xNjUuNCA2MTguMmwtNjYtLjNMNTEyIDU2My40bC05OS4zIDExOC40LTY2LjEuM2MtNC40IDAtOC0zLjUtOC04IDAtMS45LjctMy43IDEuOS01LjJsMTMwLjEtMTU1TDM0MC41IDM1OWE4LjMyIDguMzIgMCAwMS0xLjktNS4yYzAtNC40IDMuNi04IDgtOGw2Ni4xLjNMNTEyIDQ2NC42bDk5LjMtMTE4LjQgNjYtLjNjNC40IDAgOCAzLjUgOCA4IDAgMS45LS43IDMuNy0xLjkgNS4yTDU1My41IDUxNGwxMzAgMTU1YzEuMiAxLjUgMS45IDMuMyAxLjkgNS4yIDAgNC40LTMuNiA4LTggOHpcIiB9IH1dIH0sIFwibmFtZVwiOiBcImNsb3NlLWNpcmNsZVwiLCBcInRoZW1lXCI6IFwiZmlsbGVkXCIgfTtcbnZhciBDbG9zZUNpcmNsZUZpbGxlZFN2ZyA9IENsb3NlQ2lyY2xlRmlsbGVkJDI7XG52YXIgQ2xvc2VDaXJjbGVGaWxsZWQgPSBmdW5jdGlvbiBDbG9zZUNpcmNsZUZpbGxlZDIocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW50ZEljb24sIF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwgcHJvcHMpLCB7fSwge1xuICAgIHJlZixcbiAgICBpY29uOiBDbG9zZUNpcmNsZUZpbGxlZFN2Z1xuICB9KSk7XG59O1xuQ2xvc2VDaXJjbGVGaWxsZWQuZGlzcGxheU5hbWUgPSBcIkNsb3NlQ2lyY2xlRmlsbGVkXCI7XG52YXIgQ2xvc2VDaXJjbGVGaWxsZWQkMSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5mb3J3YXJkUmVmKENsb3NlQ2lyY2xlRmlsbGVkKTtcbnZhciBDaGVja0NpcmNsZUZpbGxlZCQyID0geyBcImljb25cIjogeyBcInRhZ1wiOiBcInN2Z1wiLCBcImF0dHJzXCI6IHsgXCJ2aWV3Qm94XCI6IFwiNjQgNjQgODk2IDg5NlwiLCBcImZvY3VzYWJsZVwiOiBcImZhbHNlXCIgfSwgXCJjaGlsZHJlblwiOiBbeyBcInRhZ1wiOiBcInBhdGhcIiwgXCJhdHRyc1wiOiB7IFwiZFwiOiBcIk01MTIgNjRDMjY0LjYgNjQgNjQgMjY0LjYgNjQgNTEyczIwMC42IDQ0OCA0NDggNDQ4IDQ0OC0yMDAuNiA0NDgtNDQ4Uzc1OS40IDY0IDUxMiA2NHptMTkzLjUgMzAxLjdsLTIxMC42IDI5MmEzMS44IDMxLjggMCAwMS01MS43IDBMMzE4LjUgNDg0LjljLTMuOC01LjMgMC0xMi43IDYuNS0xMi43aDQ2LjljMTAuMiAwIDE5LjkgNC45IDI1LjkgMTMuM2w3MS4yIDk4LjggMTU3LjItMjE4YzYtOC4zIDE1LjYtMTMuMyAyNS45LTEzLjNINjk5YzYuNSAwIDEwLjMgNy40IDYuNSAxMi43elwiIH0gfV0gfSwgXCJuYW1lXCI6IFwiY2hlY2stY2lyY2xlXCIsIFwidGhlbWVcIjogXCJmaWxsZWRcIiB9O1xudmFyIENoZWNrQ2lyY2xlRmlsbGVkU3ZnID0gQ2hlY2tDaXJjbGVGaWxsZWQkMjtcbnZhciBDaGVja0NpcmNsZUZpbGxlZCA9IGZ1bmN0aW9uIENoZWNrQ2lyY2xlRmlsbGVkMihwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChBbnRkSWNvbiwgX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgcmVmLFxuICAgIGljb246IENoZWNrQ2lyY2xlRmlsbGVkU3ZnXG4gIH0pKTtcbn07XG5DaGVja0NpcmNsZUZpbGxlZC5kaXNwbGF5TmFtZSA9IFwiQ2hlY2tDaXJjbGVGaWxsZWRcIjtcbnZhciBDaGVja0NpcmNsZUZpbGxlZCQxID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmZvcndhcmRSZWYoQ2hlY2tDaXJjbGVGaWxsZWQpO1xudmFyIEluZm9DaXJjbGVGaWxsZWQkMiA9IHsgXCJpY29uXCI6IHsgXCJ0YWdcIjogXCJzdmdcIiwgXCJhdHRyc1wiOiB7IFwidmlld0JveFwiOiBcIjY0IDY0IDg5NiA4OTZcIiwgXCJmb2N1c2FibGVcIjogXCJmYWxzZVwiIH0sIFwiY2hpbGRyZW5cIjogW3sgXCJ0YWdcIjogXCJwYXRoXCIsIFwiYXR0cnNcIjogeyBcImRcIjogXCJNNTEyIDY0QzI2NC42IDY0IDY0IDI2NC42IDY0IDUxMnMyMDAuNiA0NDggNDQ4IDQ0OCA0NDgtMjAwLjYgNDQ4LTQ0OFM3NTkuNCA2NCA1MTIgNjR6bTMyIDY2NGMwIDQuNC0zLjYgOC04IDhoLTQ4Yy00LjQgMC04LTMuNi04LThWNDU2YzAtNC40IDMuNi04IDgtOGg0OGM0LjQgMCA4IDMuNiA4IDh2Mjcyem0tMzItMzQ0YTQ4LjAxIDQ4LjAxIDAgMDEwLTk2IDQ4LjAxIDQ4LjAxIDAgMDEwIDk2elwiIH0gfV0gfSwgXCJuYW1lXCI6IFwiaW5mby1jaXJjbGVcIiwgXCJ0aGVtZVwiOiBcImZpbGxlZFwiIH07XG52YXIgSW5mb0NpcmNsZUZpbGxlZFN2ZyA9IEluZm9DaXJjbGVGaWxsZWQkMjtcbnZhciBJbmZvQ2lyY2xlRmlsbGVkID0gZnVuY3Rpb24gSW5mb0NpcmNsZUZpbGxlZDIocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW50ZEljb24sIF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwgcHJvcHMpLCB7fSwge1xuICAgIHJlZixcbiAgICBpY29uOiBJbmZvQ2lyY2xlRmlsbGVkU3ZnXG4gIH0pKTtcbn07XG5JbmZvQ2lyY2xlRmlsbGVkLmRpc3BsYXlOYW1lID0gXCJJbmZvQ2lyY2xlRmlsbGVkXCI7XG52YXIgSW5mb0NpcmNsZUZpbGxlZCQxID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmZvcndhcmRSZWYoSW5mb0NpcmNsZUZpbGxlZCk7XG5mdW5jdGlvbiB0b0FycmF5JDEoY2hpbGRyZW4pIHtcbiAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciByZXQgPSBbXTtcbiAgUmVhY3RfX2RlZmF1bHQuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICBpZiAoKGNoaWxkID09PSB2b2lkIDAgfHwgY2hpbGQgPT09IG51bGwpICYmICFvcHRpb24ua2VlcEVtcHR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgcmV0ID0gcmV0LmNvbmNhdCh0b0FycmF5JDEoY2hpbGQpKTtcbiAgICB9IGVsc2UgaWYgKHJlYWN0SXMuZXhwb3J0cy5pc0ZyYWdtZW50KGNoaWxkKSAmJiBjaGlsZC5wcm9wcykge1xuICAgICAgcmV0ID0gcmV0LmNvbmNhdCh0b0FycmF5JDEoY2hpbGQucHJvcHMuY2hpbGRyZW4sIG9wdGlvbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQucHVzaChjaGlsZCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cbnZhciBIT09LX01BUksgPSBcIlJDX0ZPUk1fSU5URVJOQUxfSE9PS1NcIjtcbnZhciB3YXJuaW5nRnVuYyA9IGZ1bmN0aW9uIHdhcm5pbmdGdW5jMigpIHtcbiAgd2FybmluZ09uY2UoZmFsc2UsIFwiQ2FuIG5vdCBmaW5kIEZvcm1Db250ZXh0LiBQbGVhc2UgbWFrZSBzdXJlIHlvdSB3cmFwIEZpZWxkIHVuZGVyIEZvcm0uXCIpO1xufTtcbnZhciBDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBnZXRGaWVsZFZhbHVlOiB3YXJuaW5nRnVuYyxcbiAgZ2V0RmllbGRzVmFsdWU6IHdhcm5pbmdGdW5jLFxuICBnZXRGaWVsZEVycm9yOiB3YXJuaW5nRnVuYyxcbiAgZ2V0RmllbGRXYXJuaW5nOiB3YXJuaW5nRnVuYyxcbiAgZ2V0RmllbGRzRXJyb3I6IHdhcm5pbmdGdW5jLFxuICBpc0ZpZWxkc1RvdWNoZWQ6IHdhcm5pbmdGdW5jLFxuICBpc0ZpZWxkVG91Y2hlZDogd2FybmluZ0Z1bmMsXG4gIGlzRmllbGRWYWxpZGF0aW5nOiB3YXJuaW5nRnVuYyxcbiAgaXNGaWVsZHNWYWxpZGF0aW5nOiB3YXJuaW5nRnVuYyxcbiAgcmVzZXRGaWVsZHM6IHdhcm5pbmdGdW5jLFxuICBzZXRGaWVsZHM6IHdhcm5pbmdGdW5jLFxuICBzZXRGaWVsZHNWYWx1ZTogd2FybmluZ0Z1bmMsXG4gIHZhbGlkYXRlRmllbGRzOiB3YXJuaW5nRnVuYyxcbiAgc3VibWl0OiB3YXJuaW5nRnVuYyxcbiAgZ2V0SW50ZXJuYWxIb29rczogZnVuY3Rpb24gZ2V0SW50ZXJuYWxIb29rcygpIHtcbiAgICB3YXJuaW5nRnVuYygpO1xuICAgIHJldHVybiB7XG4gICAgICBkaXNwYXRjaDogd2FybmluZ0Z1bmMsXG4gICAgICBpbml0RW50aXR5VmFsdWU6IHdhcm5pbmdGdW5jLFxuICAgICAgcmVnaXN0ZXJGaWVsZDogd2FybmluZ0Z1bmMsXG4gICAgICB1c2VTdWJzY3JpYmU6IHdhcm5pbmdGdW5jLFxuICAgICAgc2V0SW5pdGlhbFZhbHVlczogd2FybmluZ0Z1bmMsXG4gICAgICBzZXRDYWxsYmFja3M6IHdhcm5pbmdGdW5jLFxuICAgICAgZ2V0RmllbGRzOiB3YXJuaW5nRnVuYyxcbiAgICAgIHNldFZhbGlkYXRlTWVzc2FnZXM6IHdhcm5pbmdGdW5jLFxuICAgICAgc2V0UHJlc2VydmU6IHdhcm5pbmdGdW5jLFxuICAgICAgZ2V0SW5pdGlhbFZhbHVlOiB3YXJuaW5nRnVuY1xuICAgIH07XG4gIH1cbn0pO1xuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59XG52YXIgcnVudGltZSA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbihtb2R1bGUpIHtcbiAgdmFyIHJ1bnRpbWUyID0gZnVuY3Rpb24oZXhwb3J0cykge1xuICAgIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gICAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICAgIHZhciB1bmRlZmluZWQkMTtcbiAgICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICAgIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gICAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuICAgIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleTIsIHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXkyLCB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmpba2V5Ml07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkZWZpbmUoe30sIFwiXCIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXkyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gb2JqW2tleTJdID0gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYyLCB0cnlMb2NzTGlzdCkge1xuICAgICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dDIodHJ5TG9jc0xpc3QgfHwgW10pO1xuICAgICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYyLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBnZW5lcmF0b3I7XG4gICAgfVxuICAgIGV4cG9ydHMud3JhcCA9IHdyYXA7XG4gICAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICAgIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG4gICAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcbiAgICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge1xuICAgIH1cbiAgICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHtcbiAgICB9XG4gICAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gICAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gICAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICAgIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgICB9XG4gICAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgIGRlZmluZShHcCwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKTtcbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kNCkge1xuICAgICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2Q0LCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZDQsIGFyZyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuIGN0b3IgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgOiBmYWxzZTtcbiAgICB9O1xuICAgIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgICAgcmV0dXJuIGdlbkZ1bjtcbiAgICB9O1xuICAgIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICAgIH07XG4gICAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kNCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2Q0XSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlMikge1xuICAgICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlMiwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcbiAgICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kNCwgYXJnKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpbnZva2UobWV0aG9kNCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gICAgfVxuICAgIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICAgIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG4gICAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYyLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKVxuICAgICAgICBQcm9taXNlSW1wbCA9IFByb21pc2U7XG4gICAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZjIsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpO1xuICAgICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmMiwgY29udGV4dCkge1xuICAgICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kNCwgYXJnKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgICBpZiAobWV0aG9kNCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q0O1xuICAgICAgICBjb250ZXh0LmFyZyA9IGFyZztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZjIsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBHZW5TdGF0ZUNvbXBsZXRlZCA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG4gICAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbWV0aG9kNCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICAgIGlmIChtZXRob2Q0ID09PSB1bmRlZmluZWQkMSkge1xuICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZDQsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG4gICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG4gICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgfVxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gICAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcbiAgICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcbiAgICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICAgIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuICAgICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgICB9XG4gICAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgICB9XG4gICAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDb250ZXh0Mih0cnlMb2NzTGlzdCkge1xuICAgICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gICAgfVxuICAgIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdDQpIHtcbiAgICAgIHZhciBrZXlzMiA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5MiBpbiBvYmplY3Q0KSB7XG4gICAgICAgIGtleXMyLnB1c2goa2V5Mik7XG4gICAgICB9XG4gICAgICBrZXlzMi5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgd2hpbGUgKGtleXMyLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkzID0ga2V5czIucG9wKCk7XG4gICAgICAgICAgaWYgKGtleTMgaW4gb2JqZWN0NCkge1xuICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTM7XG4gICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH07XG4gICAgfTtcbiAgICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dDIoKSB7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgICBuZXh0Mi52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgIG5leHQyLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQyLnZhbHVlID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICBuZXh0Mi5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0MjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gICAgfVxuICAgIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuICAgIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkJDEsIGRvbmU6IHRydWUgfTtcbiAgICB9XG4gICAgQ29udGV4dDIucHJvdG90eXBlID0ge1xuICAgICAgY29uc3RydWN0b3I6IENvbnRleHQyLFxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCQxO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuICAgICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgICB9LFxuICAgICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG4gICAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG4gICAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWJydXB0OiBmdW5jdGlvbih0eXBlNCwgYXJnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJiAodHlwZTQgPT09IFwiYnJlYWtcIiB8fCB0eXBlNCA9PT0gXCJjb250aW51ZVwiKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgICByZWNvcmQudHlwZSA9IHR5cGU0O1xuICAgICAgICByZWNvcmQuYXJnID0gYXJnO1xuICAgICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fCByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfSxcbiAgICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgICAgfSxcbiAgICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgICAgcmVzdWx0TmFtZSxcbiAgICAgICAgICBuZXh0TG9jXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH0obW9kdWxlLmV4cG9ydHMpO1xuICB0cnkge1xuICAgIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWUyO1xuICB9IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lMjtcbiAgICB9IGVsc2Uge1xuICAgICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lMik7XG4gICAgfVxuICB9XG59KShydW50aW1lKTtcbnZhciByZWdlbmVyYXRvciA9IHJ1bnRpbWUuZXhwb3J0cztcbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5MiwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5Ml0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZjIgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmMiwgYXJncyk7XG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuICAgICAgX25leHQodm9pZCAwKTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkyIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5MikpIHtcbiAgICAgICAgICB0YXJnZXRba2V5Ml0gPSBzb3VyY2Vba2V5Ml07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YyKG8yKSB7XG4gICAgcmV0dXJuIG8yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YobzIpO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHAyKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YyKG8yLCBwMykge1xuICAgIG8yLl9fcHJvdG9fXyA9IHAzO1xuICAgIHJldHVybiBvMjtcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwMik7XG59XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIHRydWU7XG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHtcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgfSBlbHNlIHtcbiAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdDIoUGFyZW50MiwgYXJnczIsIENsYXNzMikge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJnczIpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQyLCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzMilcbiAgICAgICAgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzczIucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSA6IHZvaWQgMDtcbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIyKENsYXNzMikge1xuICAgIGlmIChDbGFzczIgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzMikpXG4gICAgICByZXR1cm4gQ2xhc3MyO1xuICAgIGlmICh0eXBlb2YgQ2xhc3MyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzMikpXG4gICAgICAgIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzMik7XG4gICAgICBfY2FjaGUuc2V0KENsYXNzMiwgV3JhcHBlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzczIsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzMi5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MyKTtcbiAgfTtcbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG52YXIgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcyKCkge1xufTtcbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiBmYWxzZSkge1xuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZzModHlwZTQsIGVycm9ycykge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4gJiYgdHlwZW9mIEFTWU5DX1ZBTElEQVRPUl9OT19XQVJOSU5HID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoZXJyb3JzLmV2ZXJ5KGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZTIgPT09IFwic3RyaW5nXCI7XG4gICAgICB9KSkge1xuICAgICAgICBjb25zb2xlLndhcm4odHlwZTQsIGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydEZpZWxkc0Vycm9yKGVycm9ycykge1xuICBpZiAoIWVycm9ycyB8fCAhZXJyb3JzLmxlbmd0aClcbiAgICByZXR1cm4gbnVsbDtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuICBlcnJvcnMuZm9yRWFjaChmdW5jdGlvbihlcnJvcikge1xuICAgIHZhciBmaWVsZCA9IGVycm9yLmZpZWxkO1xuICAgIGZpZWxkc1tmaWVsZF0gPSBmaWVsZHNbZmllbGRdIHx8IFtdO1xuICAgIGZpZWxkc1tmaWVsZF0ucHVzaChlcnJvcik7XG4gIH0pO1xuICByZXR1cm4gZmllbGRzO1xufVxuZnVuY3Rpb24gZm9ybWF0KHRlbXBsYXRlKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICB2YXIgaSA9IDA7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9XG4gIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICB2YXIgc3RyID0gdGVtcGxhdGUucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgyKSB7XG4gICAgICBpZiAoeDIgPT09IFwiJSVcIikge1xuICAgICAgICByZXR1cm4gXCIlXCI7XG4gICAgICB9XG4gICAgICBpZiAoaSA+PSBsZW4pIHtcbiAgICAgICAgcmV0dXJuIHgyO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh4Mikge1xuICAgICAgICBjYXNlIFwiJXNcIjpcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICAgIGNhc2UgXCIlZFwiOlxuICAgICAgICAgIHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgICAgY2FzZSBcIiVqXCI6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBcIltDaXJjdWxhcl1cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHgyO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgcmV0dXJuIHRlbXBsYXRlO1xufVxuZnVuY3Rpb24gaXNOYXRpdmVTdHJpbmdUeXBlKHR5cGU0KSB7XG4gIHJldHVybiB0eXBlNCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlNCA9PT0gXCJ1cmxcIiB8fCB0eXBlNCA9PT0gXCJoZXhcIiB8fCB0eXBlNCA9PT0gXCJlbWFpbFwiIHx8IHR5cGU0ID09PSBcImRhdGVcIiB8fCB0eXBlNCA9PT0gXCJwYXR0ZXJuXCI7XG59XG5mdW5jdGlvbiBpc0VtcHR5VmFsdWUodmFsdWUsIHR5cGU0KSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGU0ID09PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIXZhbHVlLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc05hdGl2ZVN0cmluZ1R5cGUodHlwZTQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhdmFsdWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhc3luY1BhcmFsbGVsQXJyYXkoYXJyLCBmdW5jLCBjYWxsYmFjaykge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgdG90YWwgPSAwO1xuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgZnVuY3Rpb24gY291bnQoZXJyb3JzKSB7XG4gICAgcmVzdWx0cy5wdXNoLmFwcGx5KHJlc3VsdHMsIGVycm9ycyB8fCBbXSk7XG4gICAgdG90YWwrKztcbiAgICBpZiAodG90YWwgPT09IGFyckxlbmd0aCkge1xuICAgICAgY2FsbGJhY2socmVzdWx0cyk7XG4gICAgfVxuICB9XG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICBmdW5jKGEsIGNvdW50KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhc3luY1NlcmlhbEFycmF5KGFyciwgZnVuYywgY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4MiA9IDA7XG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoO1xuICBmdW5jdGlvbiBuZXh0KGVycm9ycykge1xuICAgIGlmIChlcnJvcnMgJiYgZXJyb3JzLmxlbmd0aCkge1xuICAgICAgY2FsbGJhY2soZXJyb3JzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9yaWdpbmFsID0gaW5kZXgyO1xuICAgIGluZGV4MiA9IGluZGV4MiArIDE7XG4gICAgaWYgKG9yaWdpbmFsIDwgYXJyTGVuZ3RoKSB7XG4gICAgICBmdW5jKGFycltvcmlnaW5hbF0sIG5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhbXSk7XG4gICAgfVxuICB9XG4gIG5leHQoW10pO1xufVxuZnVuY3Rpb24gZmxhdHRlbk9iakFycihvYmpBcnIpIHtcbiAgdmFyIHJldCA9IFtdO1xuICBPYmplY3Qua2V5cyhvYmpBcnIpLmZvckVhY2goZnVuY3Rpb24oazIpIHtcbiAgICByZXQucHVzaC5hcHBseShyZXQsIG9iakFycltrMl0gfHwgW10pO1xuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cbnZhciBBc3luY1ZhbGlkYXRpb25FcnJvciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihfRXJyb3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoQXN5bmNWYWxpZGF0aW9uRXJyb3IyLCBfRXJyb3IpO1xuICBmdW5jdGlvbiBBc3luY1ZhbGlkYXRpb25FcnJvcjIoZXJyb3JzLCBmaWVsZHMpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX3RoaXMgPSBfRXJyb3IuY2FsbCh0aGlzLCBcIkFzeW5jIFZhbGlkYXRpb24gRXJyb3JcIikgfHwgdGhpcztcbiAgICBfdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgX3RoaXMuZmllbGRzID0gZmllbGRzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICByZXR1cm4gQXN5bmNWYWxpZGF0aW9uRXJyb3IyO1xufSgvKiBAX19QVVJFX18gKi8gX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuZnVuY3Rpb24gYXN5bmNNYXAob2JqQXJyLCBvcHRpb24sIGZ1bmMsIGNhbGxiYWNrLCBzb3VyY2UpIHtcbiAgaWYgKG9wdGlvbi5maXJzdCkge1xuICAgIHZhciBfcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiBuZXh0MihlcnJvcnMpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3JzKTtcbiAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPyByZWplY3QobmV3IEFzeW5jVmFsaWRhdGlvbkVycm9yKGVycm9ycywgY29udmVydEZpZWxkc0Vycm9yKGVycm9ycykpKSA6IHJlc29sdmUoc291cmNlKTtcbiAgICAgIH07XG4gICAgICB2YXIgZmxhdHRlbkFyciA9IGZsYXR0ZW5PYmpBcnIob2JqQXJyKTtcbiAgICAgIGFzeW5jU2VyaWFsQXJyYXkoZmxhdHRlbkFyciwgZnVuYywgbmV4dCk7XG4gICAgfSk7XG4gICAgX3BlbmRpbmdbXCJjYXRjaFwiXShmdW5jdGlvbihlMikge1xuICAgICAgcmV0dXJuIGUyO1xuICAgIH0pO1xuICAgIHJldHVybiBfcGVuZGluZztcbiAgfVxuICB2YXIgZmlyc3RGaWVsZHMgPSBvcHRpb24uZmlyc3RGaWVsZHMgPT09IHRydWUgPyBPYmplY3Qua2V5cyhvYmpBcnIpIDogb3B0aW9uLmZpcnN0RmllbGRzIHx8IFtdO1xuICB2YXIgb2JqQXJyS2V5cyA9IE9iamVjdC5rZXlzKG9iakFycik7XG4gIHZhciBvYmpBcnJMZW5ndGggPSBvYmpBcnJLZXlzLmxlbmd0aDtcbiAgdmFyIHRvdGFsID0gMDtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQyKGVycm9ycykge1xuICAgICAgcmVzdWx0cy5wdXNoLmFwcGx5KHJlc3VsdHMsIGVycm9ycyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgaWYgKHRvdGFsID09PSBvYmpBcnJMZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2socmVzdWx0cyk7XG4gICAgICAgIHJldHVybiByZXN1bHRzLmxlbmd0aCA/IHJlamVjdChuZXcgQXN5bmNWYWxpZGF0aW9uRXJyb3IocmVzdWx0cywgY29udmVydEZpZWxkc0Vycm9yKHJlc3VsdHMpKSkgOiByZXNvbHZlKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIW9iakFycktleXMubGVuZ3RoKSB7XG4gICAgICBjYWxsYmFjayhyZXN1bHRzKTtcbiAgICAgIHJlc29sdmUoc291cmNlKTtcbiAgICB9XG4gICAgb2JqQXJyS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleTIpIHtcbiAgICAgIHZhciBhcnIgPSBvYmpBcnJba2V5Ml07XG4gICAgICBpZiAoZmlyc3RGaWVsZHMuaW5kZXhPZihrZXkyKSAhPT0gLTEpIHtcbiAgICAgICAgYXN5bmNTZXJpYWxBcnJheShhcnIsIGZ1bmMsIG5leHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXN5bmNQYXJhbGxlbEFycmF5KGFyciwgZnVuYywgbmV4dCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBwZW5kaW5nW1wiY2F0Y2hcIl0oZnVuY3Rpb24oZTIpIHtcbiAgICByZXR1cm4gZTI7XG4gIH0pO1xuICByZXR1cm4gcGVuZGluZztcbn1cbmZ1bmN0aW9uIGlzRXJyb3JPYmoob2JqKSB7XG4gIHJldHVybiAhIShvYmogJiYgb2JqLm1lc3NhZ2UgIT09IHZvaWQgMCk7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZSQzKHZhbHVlLCBwYXRoKSB7XG4gIHZhciB2MiA9IHZhbHVlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodjIgPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdjI7XG4gICAgfVxuICAgIHYyID0gdjJbcGF0aFtpXV07XG4gIH1cbiAgcmV0dXJuIHYyO1xufVxuZnVuY3Rpb24gY29tcGxlbWVudEVycm9yKHJ1bGUsIHNvdXJjZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2UpIHtcbiAgICB2YXIgZmllbGRWYWx1ZTtcbiAgICBpZiAocnVsZS5mdWxsRmllbGRzKSB7XG4gICAgICBmaWVsZFZhbHVlID0gZ2V0VmFsdWUkMyhzb3VyY2UsIHJ1bGUuZnVsbEZpZWxkcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpZWxkVmFsdWUgPSBzb3VyY2Vbb2UuZmllbGQgfHwgcnVsZS5mdWxsRmllbGRdO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvck9iaihvZSkpIHtcbiAgICAgIG9lLmZpZWxkID0gb2UuZmllbGQgfHwgcnVsZS5mdWxsRmllbGQ7XG4gICAgICBvZS5maWVsZFZhbHVlID0gZmllbGRWYWx1ZTtcbiAgICAgIHJldHVybiBvZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6IHR5cGVvZiBvZSA9PT0gXCJmdW5jdGlvblwiID8gb2UoKSA6IG9lLFxuICAgICAgZmllbGRWYWx1ZSxcbiAgICAgIGZpZWxkOiBvZS5maWVsZCB8fCBydWxlLmZ1bGxGaWVsZFxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBkZWVwTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSkge1xuICAgIGZvciAodmFyIHMgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHMpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtzXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdGFyZ2V0W3NdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGFyZ2V0W3NdID0gX2V4dGVuZHMoe30sIHRhcmdldFtzXSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtzXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG52YXIgcmVxdWlyZWQkMSA9IGZ1bmN0aW9uIHJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucywgdHlwZTQpIHtcbiAgaWYgKHJ1bGUucmVxdWlyZWQgJiYgKCFzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCkgfHwgaXNFbXB0eVZhbHVlKHZhbHVlLCB0eXBlNCB8fCBydWxlLnR5cGUpKSkge1xuICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzLnJlcXVpcmVkLCBydWxlLmZ1bGxGaWVsZCkpO1xuICB9XG59O1xudmFyIHdoaXRlc3BhY2UgPSBmdW5jdGlvbiB3aGl0ZXNwYWNlMihydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpIHtcbiAgaWYgKC9eXFxzKyQvLnRlc3QodmFsdWUpIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXMud2hpdGVzcGFjZSwgcnVsZS5mdWxsRmllbGQpKTtcbiAgfVxufTtcbnZhciBwYXR0ZXJuJDIgPSB7XG4gIGVtYWlsOiAvXigoW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKyhcXC5bXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKFxcW1swLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31dKXwoKFthLXpBLVpcXC0wLTlcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK1xcLikrW2EtekEtWlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl17Mix9KSkkLyxcbiAgdXJsOiBuZXcgUmVnRXhwKFwiXig/IW1haWx0bzopKD86KD86aHR0cHxodHRwc3xmdHApOi8vfC8vKSg/OlxcXFxTKyg/OjpcXFxcUyopP0ApPyg/Oig/Oig/OlsxLTldXFxcXGQ/fDFcXFxcZFxcXFxkfDJbMDFdXFxcXGR8MjJbMC0zXSkoPzpcXFxcLig/OjE/XFxcXGR7MSwyfXwyWzAtNF1cXFxcZHwyNVswLTVdKSl7Mn0oPzpcXFxcLig/OlswLTldXFxcXGQ/fDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0rLSopKlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSspKD86XFxcXC4oPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0rLSopKlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSspKig/OlxcXFwuKD86W2EtelxcXFx1MDBhMS1cXFxcdWZmZmZdezIsfSkpKXxsb2NhbGhvc3QpKD86OlxcXFxkezIsNX0pPyg/OigvfFxcXFw/fCMpW15cXFxcc10qKT8kXCIsIFwiaVwiKSxcbiAgaGV4OiAvXiM/KFthLWYwLTldezZ9fFthLWYwLTldezN9KSQvaVxufTtcbnZhciB0eXBlcyA9IHtcbiAgaW50ZWdlcjogZnVuY3Rpb24gaW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlcy5udW1iZXIodmFsdWUpICYmIHBhcnNlSW50KHZhbHVlLCAxMCkgPT09IHZhbHVlO1xuICB9LFxuICBcImZsb2F0XCI6IGZ1bmN0aW9uIGZsb2F0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVzLm51bWJlcih2YWx1ZSkgJiYgIXR5cGVzLmludGVnZXIodmFsdWUpO1xuICB9LFxuICBhcnJheTogZnVuY3Rpb24gYXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0sXG4gIHJlZ2V4cDogZnVuY3Rpb24gcmVnZXhwKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAhIW5ldyBSZWdFeHAodmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuICBkYXRlOiBmdW5jdGlvbiBkYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5nZXRUaW1lID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHZhbHVlLmdldE1vbnRoID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHZhbHVlLmdldFllYXIgPT09IFwiZnVuY3Rpb25cIiAmJiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKTtcbiAgfSxcbiAgbnVtYmVyOiBmdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG4gIH0sXG4gIG9iamVjdDogZnVuY3Rpb24gb2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhdHlwZXMuYXJyYXkodmFsdWUpO1xuICB9LFxuICBtZXRob2Q6IGZ1bmN0aW9uIG1ldGhvZCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbiAgfSxcbiAgZW1haWw6IGZ1bmN0aW9uIGVtYWlsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5sZW5ndGggPD0gMzIwICYmICEhdmFsdWUubWF0Y2gocGF0dGVybiQyLmVtYWlsKTtcbiAgfSxcbiAgdXJsOiBmdW5jdGlvbiB1cmwodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLmxlbmd0aCA8PSAyMDQ4ICYmICEhdmFsdWUubWF0Y2gocGF0dGVybiQyLnVybCk7XG4gIH0sXG4gIGhleDogZnVuY3Rpb24gaGV4KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhIXZhbHVlLm1hdGNoKHBhdHRlcm4kMi5oZXgpO1xuICB9XG59O1xudmFyIHR5cGUkMSA9IGZ1bmN0aW9uIHR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKSB7XG4gIGlmIChydWxlLnJlcXVpcmVkICYmIHZhbHVlID09PSB2b2lkIDApIHtcbiAgICByZXF1aXJlZCQxKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjdXN0b20gPSBbXCJpbnRlZ2VyXCIsIFwiZmxvYXRcIiwgXCJhcnJheVwiLCBcInJlZ2V4cFwiLCBcIm9iamVjdFwiLCBcIm1ldGhvZFwiLCBcImVtYWlsXCIsIFwibnVtYmVyXCIsIFwiZGF0ZVwiLCBcInVybFwiLCBcImhleFwiXTtcbiAgdmFyIHJ1bGVUeXBlID0gcnVsZS50eXBlO1xuICBpZiAoY3VzdG9tLmluZGV4T2YocnVsZVR5cGUpID4gLTEpIHtcbiAgICBpZiAoIXR5cGVzW3J1bGVUeXBlXSh2YWx1ZSkpIHtcbiAgICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzLnR5cGVzW3J1bGVUeXBlXSwgcnVsZS5mdWxsRmllbGQsIHJ1bGUudHlwZSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChydWxlVHlwZSAmJiB0eXBlb2YgdmFsdWUgIT09IHJ1bGUudHlwZSkge1xuICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzLnR5cGVzW3J1bGVUeXBlXSwgcnVsZS5mdWxsRmllbGQsIHJ1bGUudHlwZSkpO1xuICB9XG59O1xudmFyIHJhbmdlID0gZnVuY3Rpb24gcmFuZ2UyKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucykge1xuICB2YXIgbGVuID0gdHlwZW9mIHJ1bGUubGVuID09PSBcIm51bWJlclwiO1xuICB2YXIgbWluID0gdHlwZW9mIHJ1bGUubWluID09PSBcIm51bWJlclwiO1xuICB2YXIgbWF4ID0gdHlwZW9mIHJ1bGUubWF4ID09PSBcIm51bWJlclwiO1xuICB2YXIgc3BSZWdleHAgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nO1xuICB2YXIgdmFsID0gdmFsdWU7XG4gIHZhciBrZXkyID0gbnVsbDtcbiAgdmFyIG51bSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbiAgdmFyIHN0ciA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbiAgdmFyIGFyciA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICBpZiAobnVtKSB7XG4gICAga2V5MiA9IFwibnVtYmVyXCI7XG4gIH0gZWxzZSBpZiAoc3RyKSB7XG4gICAga2V5MiA9IFwic3RyaW5nXCI7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAga2V5MiA9IFwiYXJyYXlcIjtcbiAgfVxuICBpZiAoIWtleTIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycikge1xuICAgIHZhbCA9IHZhbHVlLmxlbmd0aDtcbiAgfVxuICBpZiAoc3RyKSB7XG4gICAgdmFsID0gdmFsdWUucmVwbGFjZShzcFJlZ2V4cCwgXCJfXCIpLmxlbmd0aDtcbiAgfVxuICBpZiAobGVuKSB7XG4gICAgaWYgKHZhbCAhPT0gcnVsZS5sZW4pIHtcbiAgICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzW2tleTJdLmxlbiwgcnVsZS5mdWxsRmllbGQsIHJ1bGUubGVuKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG1pbiAmJiAhbWF4ICYmIHZhbCA8IHJ1bGUubWluKSB7XG4gICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXNba2V5Ml0ubWluLCBydWxlLmZ1bGxGaWVsZCwgcnVsZS5taW4pKTtcbiAgfSBlbHNlIGlmIChtYXggJiYgIW1pbiAmJiB2YWwgPiBydWxlLm1heCkge1xuICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzW2tleTJdLm1heCwgcnVsZS5mdWxsRmllbGQsIHJ1bGUubWF4KSk7XG4gIH0gZWxzZSBpZiAobWluICYmIG1heCAmJiAodmFsIDwgcnVsZS5taW4gfHwgdmFsID4gcnVsZS5tYXgpKSB7XG4gICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXNba2V5Ml0ucmFuZ2UsIHJ1bGUuZnVsbEZpZWxkLCBydWxlLm1pbiwgcnVsZS5tYXgpKTtcbiAgfVxufTtcbnZhciBFTlVNJDEgPSBcImVudW1cIjtcbnZhciBlbnVtZXJhYmxlJDEgPSBmdW5jdGlvbiBlbnVtZXJhYmxlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucykge1xuICBydWxlW0VOVU0kMV0gPSBBcnJheS5pc0FycmF5KHJ1bGVbRU5VTSQxXSkgPyBydWxlW0VOVU0kMV0gOiBbXTtcbiAgaWYgKHJ1bGVbRU5VTSQxXS5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICBlcnJvcnMucHVzaChmb3JtYXQob3B0aW9ucy5tZXNzYWdlc1tFTlVNJDFdLCBydWxlLmZ1bGxGaWVsZCwgcnVsZVtFTlVNJDFdLmpvaW4oXCIsIFwiKSkpO1xuICB9XG59O1xudmFyIHBhdHRlcm4kMSA9IGZ1bmN0aW9uIHBhdHRlcm4ocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKSB7XG4gIGlmIChydWxlLnBhdHRlcm4pIHtcbiAgICBpZiAocnVsZS5wYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBydWxlLnBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICAgIGlmICghcnVsZS5wYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzLnBhdHRlcm4ubWlzbWF0Y2gsIHJ1bGUuZnVsbEZpZWxkLCB2YWx1ZSwgcnVsZS5wYXR0ZXJuKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcnVsZS5wYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YXIgX3BhdHRlcm4gPSBuZXcgUmVnRXhwKHJ1bGUucGF0dGVybik7XG4gICAgICBpZiAoIV9wYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzLnBhdHRlcm4ubWlzbWF0Y2gsIHJ1bGUuZnVsbEZpZWxkLCB2YWx1ZSwgcnVsZS5wYXR0ZXJuKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIHJ1bGVzID0ge1xuICByZXF1aXJlZDogcmVxdWlyZWQkMSxcbiAgd2hpdGVzcGFjZSxcbiAgdHlwZTogdHlwZSQxLFxuICByYW5nZSxcbiAgXCJlbnVtXCI6IGVudW1lcmFibGUkMSxcbiAgcGF0dGVybjogcGF0dGVybiQxXG59O1xudmFyIHN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZzIocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSwgXCJzdHJpbmdcIikgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMsIFwic3RyaW5nXCIpO1xuICAgIGlmICghaXNFbXB0eVZhbHVlKHZhbHVlLCBcInN0cmluZ1wiKSkge1xuICAgICAgcnVsZXMudHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgcnVsZXMucmFuZ2UocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIHJ1bGVzLnBhdHRlcm4ocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIGlmIChydWxlLndoaXRlc3BhY2UgPT09IHRydWUpIHtcbiAgICAgICAgcnVsZXMud2hpdGVzcGFjZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcbnZhciBtZXRob2QyID0gZnVuY3Rpb24gbWV0aG9kMyhydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoaXNFbXB0eVZhbHVlKHZhbHVlKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG52YXIgbnVtYmVyMiA9IGZ1bmN0aW9uIG51bWJlcjMocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICB2YWx1ZSA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSkgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICBydWxlcy50eXBlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgICBydWxlcy5yYW5nZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcbnZhciBfYm9vbGVhbiA9IGZ1bmN0aW9uIF9ib29sZWFuMihydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoaXNFbXB0eVZhbHVlKHZhbHVlKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG52YXIgcmVnZXhwMiA9IGZ1bmN0aW9uIHJlZ2V4cDMocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSkgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIGlmICghaXNFbXB0eVZhbHVlKHZhbHVlKSkge1xuICAgICAgcnVsZXMudHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcbnZhciBpbnRlZ2VyMiA9IGZ1bmN0aW9uIGludGVnZXIzKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcnVsZXMudHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgcnVsZXMucmFuZ2UocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG52YXIgZmxvYXRGbiA9IGZ1bmN0aW9uIGZsb2F0Rm4yKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcnVsZXMudHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgcnVsZXMucmFuZ2UocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG52YXIgYXJyYXkyID0gZnVuY3Rpb24gYXJyYXkzKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmICgodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCkgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMsIFwiYXJyYXlcIik7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIHJ1bGVzLnJhbmdlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGNhbGxiYWNrKGVycm9ycyk7XG59O1xudmFyIG9iamVjdDIgPSBmdW5jdGlvbiBvYmplY3QzKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcnVsZXMudHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcbnZhciBFTlVNID0gXCJlbnVtXCI7XG52YXIgZW51bWVyYWJsZTIgPSBmdW5jdGlvbiBlbnVtZXJhYmxlMyhydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoaXNFbXB0eVZhbHVlKHZhbHVlKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHJ1bGVzW0VOVU1dKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGNhbGxiYWNrKGVycm9ycyk7XG59O1xudmFyIHBhdHRlcm4yID0gZnVuY3Rpb24gcGF0dGVybjMocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSwgXCJzdHJpbmdcIikgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIGlmICghaXNFbXB0eVZhbHVlKHZhbHVlLCBcInN0cmluZ1wiKSkge1xuICAgICAgcnVsZXMucGF0dGVybihydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcbnZhciBkYXRlMiA9IGZ1bmN0aW9uIGRhdGUzKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUsIFwiZGF0ZVwiKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgaWYgKCFpc0VtcHR5VmFsdWUodmFsdWUsIFwiZGF0ZVwiKSkge1xuICAgICAgdmFyIGRhdGVPYmplY3Q7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGRhdGVPYmplY3QgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGVPYmplY3QgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBydWxlcy50eXBlKHJ1bGUsIGRhdGVPYmplY3QsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIGlmIChkYXRlT2JqZWN0KSB7XG4gICAgICAgIHJ1bGVzLnJhbmdlKHJ1bGUsIGRhdGVPYmplY3QuZ2V0VGltZSgpLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxiYWNrKGVycm9ycyk7XG59O1xudmFyIHJlcXVpcmVkMiA9IGZ1bmN0aW9uIHJlcXVpcmVkMyhydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB0eXBlNCA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gXCJhcnJheVwiIDogdHlwZW9mIHZhbHVlO1xuICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMsIHR5cGU0KTtcbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG52YXIgdHlwZTIgPSBmdW5jdGlvbiB0eXBlMyhydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgcnVsZVR5cGUgPSBydWxlLnR5cGU7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUsIHJ1bGVUeXBlKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucywgcnVsZVR5cGUpO1xuICAgIGlmICghaXNFbXB0eVZhbHVlKHZhbHVlLCBydWxlVHlwZSkpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG52YXIgYW55ID0gZnVuY3Rpb24gYW55MihydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoaXNFbXB0eVZhbHVlKHZhbHVlKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gIH1cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG52YXIgdmFsaWRhdG9ycyA9IHtcbiAgc3RyaW5nLFxuICBtZXRob2Q6IG1ldGhvZDIsXG4gIG51bWJlcjogbnVtYmVyMixcbiAgXCJib29sZWFuXCI6IF9ib29sZWFuLFxuICByZWdleHA6IHJlZ2V4cDIsXG4gIGludGVnZXI6IGludGVnZXIyLFxuICBcImZsb2F0XCI6IGZsb2F0Rm4sXG4gIGFycmF5OiBhcnJheTIsXG4gIG9iamVjdDogb2JqZWN0MixcbiAgXCJlbnVtXCI6IGVudW1lcmFibGUyLFxuICBwYXR0ZXJuOiBwYXR0ZXJuMixcbiAgZGF0ZTogZGF0ZTIsXG4gIHVybDogdHlwZTIsXG4gIGhleDogdHlwZTIsXG4gIGVtYWlsOiB0eXBlMixcbiAgcmVxdWlyZWQ6IHJlcXVpcmVkMixcbiAgYW55XG59O1xuZnVuY3Rpb24gbmV3TWVzc2FnZXMoKSB7XG4gIHJldHVybiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiVmFsaWRhdGlvbiBlcnJvciBvbiBmaWVsZCAlc1wiLFxuICAgIHJlcXVpcmVkOiBcIiVzIGlzIHJlcXVpcmVkXCIsXG4gICAgXCJlbnVtXCI6IFwiJXMgbXVzdCBiZSBvbmUgb2YgJXNcIixcbiAgICB3aGl0ZXNwYWNlOiBcIiVzIGNhbm5vdCBiZSBlbXB0eVwiLFxuICAgIGRhdGU6IHtcbiAgICAgIGZvcm1hdDogXCIlcyBkYXRlICVzIGlzIGludmFsaWQgZm9yIGZvcm1hdCAlc1wiLFxuICAgICAgcGFyc2U6IFwiJXMgZGF0ZSBjb3VsZCBub3QgYmUgcGFyc2VkLCAlcyBpcyBpbnZhbGlkIFwiLFxuICAgICAgaW52YWxpZDogXCIlcyBkYXRlICVzIGlzIGludmFsaWRcIlxuICAgIH0sXG4gICAgdHlwZXM6IHtcbiAgICAgIHN0cmluZzogXCIlcyBpcyBub3QgYSAlc1wiLFxuICAgICAgbWV0aG9kOiBcIiVzIGlzIG5vdCBhICVzIChmdW5jdGlvbilcIixcbiAgICAgIGFycmF5OiBcIiVzIGlzIG5vdCBhbiAlc1wiLFxuICAgICAgb2JqZWN0OiBcIiVzIGlzIG5vdCBhbiAlc1wiLFxuICAgICAgbnVtYmVyOiBcIiVzIGlzIG5vdCBhICVzXCIsXG4gICAgICBkYXRlOiBcIiVzIGlzIG5vdCBhICVzXCIsXG4gICAgICBcImJvb2xlYW5cIjogXCIlcyBpcyBub3QgYSAlc1wiLFxuICAgICAgaW50ZWdlcjogXCIlcyBpcyBub3QgYW4gJXNcIixcbiAgICAgIFwiZmxvYXRcIjogXCIlcyBpcyBub3QgYSAlc1wiLFxuICAgICAgcmVnZXhwOiBcIiVzIGlzIG5vdCBhIHZhbGlkICVzXCIsXG4gICAgICBlbWFpbDogXCIlcyBpcyBub3QgYSB2YWxpZCAlc1wiLFxuICAgICAgdXJsOiBcIiVzIGlzIG5vdCBhIHZhbGlkICVzXCIsXG4gICAgICBoZXg6IFwiJXMgaXMgbm90IGEgdmFsaWQgJXNcIlxuICAgIH0sXG4gICAgc3RyaW5nOiB7XG4gICAgICBsZW46IFwiJXMgbXVzdCBiZSBleGFjdGx5ICVzIGNoYXJhY3RlcnNcIixcbiAgICAgIG1pbjogXCIlcyBtdXN0IGJlIGF0IGxlYXN0ICVzIGNoYXJhY3RlcnNcIixcbiAgICAgIG1heDogXCIlcyBjYW5ub3QgYmUgbG9uZ2VyIHRoYW4gJXMgY2hhcmFjdGVyc1wiLFxuICAgICAgcmFuZ2U6IFwiJXMgbXVzdCBiZSBiZXR3ZWVuICVzIGFuZCAlcyBjaGFyYWN0ZXJzXCJcbiAgICB9LFxuICAgIG51bWJlcjoge1xuICAgICAgbGVuOiBcIiVzIG11c3QgZXF1YWwgJXNcIixcbiAgICAgIG1pbjogXCIlcyBjYW5ub3QgYmUgbGVzcyB0aGFuICVzXCIsXG4gICAgICBtYXg6IFwiJXMgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAlc1wiLFxuICAgICAgcmFuZ2U6IFwiJXMgbXVzdCBiZSBiZXR3ZWVuICVzIGFuZCAlc1wiXG4gICAgfSxcbiAgICBhcnJheToge1xuICAgICAgbGVuOiBcIiVzIG11c3QgYmUgZXhhY3RseSAlcyBpbiBsZW5ndGhcIixcbiAgICAgIG1pbjogXCIlcyBjYW5ub3QgYmUgbGVzcyB0aGFuICVzIGluIGxlbmd0aFwiLFxuICAgICAgbWF4OiBcIiVzIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gJXMgaW4gbGVuZ3RoXCIsXG4gICAgICByYW5nZTogXCIlcyBtdXN0IGJlIGJldHdlZW4gJXMgYW5kICVzIGluIGxlbmd0aFwiXG4gICAgfSxcbiAgICBwYXR0ZXJuOiB7XG4gICAgICBtaXNtYXRjaDogXCIlcyB2YWx1ZSAlcyBkb2VzIG5vdCBtYXRjaCBwYXR0ZXJuICVzXCJcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZTIoKSB7XG4gICAgICB2YXIgY2xvbmVkID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzKSk7XG4gICAgICBjbG9uZWQuY2xvbmUgPSB0aGlzLmNsb25lO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gIH07XG59XG52YXIgbWVzc2FnZXMgPSBuZXdNZXNzYWdlcygpO1xudmFyIFNjaGVtYSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gU2NoZW1hMihkZXNjcmlwdG9yKSB7XG4gICAgdGhpcy5ydWxlcyA9IG51bGw7XG4gICAgdGhpcy5fbWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICB0aGlzLmRlZmluZShkZXNjcmlwdG9yKTtcbiAgfVxuICB2YXIgX3Byb3RvID0gU2NoZW1hMi5wcm90b3R5cGU7XG4gIF9wcm90by5kZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUocnVsZXMyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoIXJ1bGVzMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbmZpZ3VyZSBhIHNjaGVtYSB3aXRoIG5vIHJ1bGVzXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJ1bGVzMiAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KHJ1bGVzMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJ1bGVzIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgIH1cbiAgICB0aGlzLnJ1bGVzID0ge307XG4gICAgT2JqZWN0LmtleXMocnVsZXMyKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBpdGVtID0gcnVsZXMyW25hbWVdO1xuICAgICAgX3RoaXMucnVsZXNbbmFtZV0gPSBBcnJheS5pc0FycmF5KGl0ZW0pID8gaXRlbSA6IFtpdGVtXTtcbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLm1lc3NhZ2VzID0gZnVuY3Rpb24gbWVzc2FnZXMyKF9tZXNzYWdlcykge1xuICAgIGlmIChfbWVzc2FnZXMpIHtcbiAgICAgIHRoaXMuX21lc3NhZ2VzID0gZGVlcE1lcmdlKG5ld01lc3NhZ2VzKCksIF9tZXNzYWdlcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tZXNzYWdlcztcbiAgfTtcbiAgX3Byb3RvLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoc291cmNlXywgbywgb2MpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICBpZiAobyA9PT0gdm9pZCAwKSB7XG4gICAgICBvID0ge307XG4gICAgfVxuICAgIGlmIChvYyA9PT0gdm9pZCAwKSB7XG4gICAgICBvYyA9IGZ1bmN0aW9uIG9jMigpIHtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VfO1xuICAgIHZhciBvcHRpb25zID0gbztcbiAgICB2YXIgY2FsbGJhY2sgPSBvYztcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMucnVsZXMgfHwgT2JqZWN0LmtleXModGhpcy5ydWxlcykubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc291cmNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGxldGUocmVzdWx0cykge1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIGZpZWxkcyA9IHt9O1xuICAgICAgZnVuY3Rpb24gYWRkKGUyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUyKSkge1xuICAgICAgICAgIHZhciBfZXJyb3JzO1xuICAgICAgICAgIGVycm9ycyA9IChfZXJyb3JzID0gZXJyb3JzKS5jb25jYXQuYXBwbHkoX2Vycm9ycywgZTIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGUyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFkZChyZXN1bHRzW2ldKTtcbiAgICAgIH1cbiAgICAgIGlmICghZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBzb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmllbGRzID0gY29udmVydEZpZWxkc0Vycm9yKGVycm9ycyk7XG4gICAgICAgIGNhbGxiYWNrKGVycm9ycywgZmllbGRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubWVzc2FnZXMpIHtcbiAgICAgIHZhciBtZXNzYWdlcyQxID0gdGhpcy5tZXNzYWdlcygpO1xuICAgICAgaWYgKG1lc3NhZ2VzJDEgPT09IG1lc3NhZ2VzKSB7XG4gICAgICAgIG1lc3NhZ2VzJDEgPSBuZXdNZXNzYWdlcygpO1xuICAgICAgfVxuICAgICAgZGVlcE1lcmdlKG1lc3NhZ2VzJDEsIG9wdGlvbnMubWVzc2FnZXMpO1xuICAgICAgb3B0aW9ucy5tZXNzYWdlcyA9IG1lc3NhZ2VzJDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMubWVzc2FnZXMgPSB0aGlzLm1lc3NhZ2VzKCk7XG4gICAgfVxuICAgIHZhciBzZXJpZXMgPSB7fTtcbiAgICB2YXIga2V5czIgPSBvcHRpb25zLmtleXMgfHwgT2JqZWN0LmtleXModGhpcy5ydWxlcyk7XG4gICAga2V5czIuZm9yRWFjaChmdW5jdGlvbih6Mikge1xuICAgICAgdmFyIGFyciA9IF90aGlzMi5ydWxlc1t6Ml07XG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbejJdO1xuICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24ocjIpIHtcbiAgICAgICAgdmFyIHJ1bGUgPSByMjtcbiAgICAgICAgaWYgKHR5cGVvZiBydWxlLnRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaWYgKHNvdXJjZSA9PT0gc291cmNlXykge1xuICAgICAgICAgICAgc291cmNlID0gX2V4dGVuZHMoe30sIHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gc291cmNlW3oyXSA9IHJ1bGUudHJhbnNmb3JtKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJ1bGUgPSB7XG4gICAgICAgICAgICB2YWxpZGF0b3I6IHJ1bGVcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ1bGUgPSBfZXh0ZW5kcyh7fSwgcnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcnVsZS52YWxpZGF0b3IgPSBfdGhpczIuZ2V0VmFsaWRhdGlvbk1ldGhvZChydWxlKTtcbiAgICAgICAgaWYgKCFydWxlLnZhbGlkYXRvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBydWxlLmZpZWxkID0gejI7XG4gICAgICAgIHJ1bGUuZnVsbEZpZWxkID0gcnVsZS5mdWxsRmllbGQgfHwgejI7XG4gICAgICAgIHJ1bGUudHlwZSA9IF90aGlzMi5nZXRUeXBlKHJ1bGUpO1xuICAgICAgICBzZXJpZXNbejJdID0gc2VyaWVzW3oyXSB8fCBbXTtcbiAgICAgICAgc2VyaWVzW3oyXS5wdXNoKHtcbiAgICAgICAgICBydWxlLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBmaWVsZDogejJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgZXJyb3JGaWVsZHMgPSB7fTtcbiAgICByZXR1cm4gYXN5bmNNYXAoc2VyaWVzLCBvcHRpb25zLCBmdW5jdGlvbihkYXRhLCBkb0l0KSB7XG4gICAgICB2YXIgcnVsZSA9IGRhdGEucnVsZTtcbiAgICAgIHZhciBkZWVwID0gKHJ1bGUudHlwZSA9PT0gXCJvYmplY3RcIiB8fCBydWxlLnR5cGUgPT09IFwiYXJyYXlcIikgJiYgKHR5cGVvZiBydWxlLmZpZWxkcyA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcnVsZS5kZWZhdWx0RmllbGQgPT09IFwib2JqZWN0XCIpO1xuICAgICAgZGVlcCA9IGRlZXAgJiYgKHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgZGF0YS52YWx1ZSk7XG4gICAgICBydWxlLmZpZWxkID0gZGF0YS5maWVsZDtcbiAgICAgIGZ1bmN0aW9uIGFkZEZ1bGxGaWVsZChrZXkyLCBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzY2hlbWEsIHtcbiAgICAgICAgICBmdWxsRmllbGQ6IHJ1bGUuZnVsbEZpZWxkICsgXCIuXCIgKyBrZXkyLFxuICAgICAgICAgIGZ1bGxGaWVsZHM6IHJ1bGUuZnVsbEZpZWxkcyA/IFtdLmNvbmNhdChydWxlLmZ1bGxGaWVsZHMsIFtrZXkyXSkgOiBba2V5Ml1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjYihlMikge1xuICAgICAgICBpZiAoZTIgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGUyID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yTGlzdCA9IEFycmF5LmlzQXJyYXkoZTIpID8gZTIgOiBbZTJdO1xuICAgICAgICBpZiAoIW9wdGlvbnMuc3VwcHJlc3NXYXJuaW5nICYmIGVycm9yTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICBTY2hlbWEyLndhcm5pbmcoXCJhc3luYy12YWxpZGF0b3I6XCIsIGVycm9yTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yTGlzdC5sZW5ndGggJiYgcnVsZS5tZXNzYWdlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBlcnJvckxpc3QgPSBbXS5jb25jYXQocnVsZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsbGVkRXJyb3JzID0gZXJyb3JMaXN0Lm1hcChjb21wbGVtZW50RXJyb3IocnVsZSwgc291cmNlKSk7XG4gICAgICAgIGlmIChvcHRpb25zLmZpcnN0ICYmIGZpbGxlZEVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBlcnJvckZpZWxkc1tydWxlLmZpZWxkXSA9IDE7XG4gICAgICAgICAgcmV0dXJuIGRvSXQoZmlsbGVkRXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXApIHtcbiAgICAgICAgICBkb0l0KGZpbGxlZEVycm9ycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJ1bGUucmVxdWlyZWQgJiYgIWRhdGEudmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChydWxlLm1lc3NhZ2UgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBmaWxsZWRFcnJvcnMgPSBbXS5jb25jYXQocnVsZS5tZXNzYWdlKS5tYXAoY29tcGxlbWVudEVycm9yKHJ1bGUsIHNvdXJjZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmVycm9yKSB7XG4gICAgICAgICAgICAgIGZpbGxlZEVycm9ycyA9IFtvcHRpb25zLmVycm9yKHJ1bGUsIGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzLnJlcXVpcmVkLCBydWxlLmZpZWxkKSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvSXQoZmlsbGVkRXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZpZWxkc1NjaGVtYSA9IHt9O1xuICAgICAgICAgIGlmIChydWxlLmRlZmF1bHRGaWVsZCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YS52YWx1ZSkubWFwKGZ1bmN0aW9uKGtleTIpIHtcbiAgICAgICAgICAgICAgZmllbGRzU2NoZW1hW2tleTJdID0gcnVsZS5kZWZhdWx0RmllbGQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmllbGRzU2NoZW1hID0gX2V4dGVuZHMoe30sIGZpZWxkc1NjaGVtYSwgZGF0YS5ydWxlLmZpZWxkcyk7XG4gICAgICAgICAgdmFyIHBhcmVkRmllbGRzU2NoZW1hID0ge307XG4gICAgICAgICAgT2JqZWN0LmtleXMoZmllbGRzU2NoZW1hKS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgZmllbGRTY2hlbWEgPSBmaWVsZHNTY2hlbWFbZmllbGRdO1xuICAgICAgICAgICAgdmFyIGZpZWxkU2NoZW1hTGlzdCA9IEFycmF5LmlzQXJyYXkoZmllbGRTY2hlbWEpID8gZmllbGRTY2hlbWEgOiBbZmllbGRTY2hlbWFdO1xuICAgICAgICAgICAgcGFyZWRGaWVsZHNTY2hlbWFbZmllbGRdID0gZmllbGRTY2hlbWFMaXN0Lm1hcChhZGRGdWxsRmllbGQuYmluZChudWxsLCBmaWVsZCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzY2hlbWEgPSBuZXcgU2NoZW1hMihwYXJlZEZpZWxkc1NjaGVtYSk7XG4gICAgICAgICAgc2NoZW1hLm1lc3NhZ2VzKG9wdGlvbnMubWVzc2FnZXMpO1xuICAgICAgICAgIGlmIChkYXRhLnJ1bGUub3B0aW9ucykge1xuICAgICAgICAgICAgZGF0YS5ydWxlLm9wdGlvbnMubWVzc2FnZXMgPSBvcHRpb25zLm1lc3NhZ2VzO1xuICAgICAgICAgICAgZGF0YS5ydWxlLm9wdGlvbnMuZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY2hlbWEudmFsaWRhdGUoZGF0YS52YWx1ZSwgZGF0YS5ydWxlLm9wdGlvbnMgfHwgb3B0aW9ucywgZnVuY3Rpb24oZXJycykge1xuICAgICAgICAgICAgdmFyIGZpbmFsRXJyb3JzID0gW107XG4gICAgICAgICAgICBpZiAoZmlsbGVkRXJyb3JzICYmIGZpbGxlZEVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZmluYWxFcnJvcnMucHVzaC5hcHBseShmaW5hbEVycm9ycywgZmlsbGVkRXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJzICYmIGVycnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGZpbmFsRXJyb3JzLnB1c2guYXBwbHkoZmluYWxFcnJvcnMsIGVycnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9JdChmaW5hbEVycm9ycy5sZW5ndGggPyBmaW5hbEVycm9ycyA6IG51bGwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcmVzO1xuICAgICAgaWYgKHJ1bGUuYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgcmVzID0gcnVsZS5hc3luY1ZhbGlkYXRvcihydWxlLCBkYXRhLnZhbHVlLCBjYiwgZGF0YS5zb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChydWxlLnZhbGlkYXRvcikge1xuICAgICAgICByZXMgPSBydWxlLnZhbGlkYXRvcihydWxlLCBkYXRhLnZhbHVlLCBjYiwgZGF0YS5zb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVzID09PSB0cnVlKSB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgY2IodHlwZW9mIHJ1bGUubWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiID8gcnVsZS5tZXNzYWdlKHJ1bGUuZnVsbEZpZWxkIHx8IHJ1bGUuZmllbGQpIDogcnVsZS5tZXNzYWdlIHx8IChydWxlLmZ1bGxGaWVsZCB8fCBydWxlLmZpZWxkKSArIFwiIGZhaWxzXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgY2IocmVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXMgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGNiKHJlcy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlcyAmJiByZXMudGhlbikge1xuICAgICAgICByZXMudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICByZXR1cm4gY2IoZTIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICBjb21wbGV0ZShyZXN1bHRzKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuICBfcHJvdG8uZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUocnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgPT09IHZvaWQgMCAmJiBydWxlLnBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJ1bGUudHlwZSA9IFwicGF0dGVyblwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJ1bGUudmFsaWRhdG9yICE9PSBcImZ1bmN0aW9uXCIgJiYgcnVsZS50eXBlICYmICF2YWxpZGF0b3JzLmhhc093blByb3BlcnR5KHJ1bGUudHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoXCJVbmtub3duIHJ1bGUgdHlwZSAlc1wiLCBydWxlLnR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bGUudHlwZSB8fCBcInN0cmluZ1wiO1xuICB9O1xuICBfcHJvdG8uZ2V0VmFsaWRhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIGdldFZhbGlkYXRpb25NZXRob2QocnVsZSkge1xuICAgIGlmICh0eXBlb2YgcnVsZS52YWxpZGF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHJ1bGUudmFsaWRhdG9yO1xuICAgIH1cbiAgICB2YXIga2V5czIgPSBPYmplY3Qua2V5cyhydWxlKTtcbiAgICB2YXIgbWVzc2FnZUluZGV4ID0ga2V5czIuaW5kZXhPZihcIm1lc3NhZ2VcIik7XG4gICAgaWYgKG1lc3NhZ2VJbmRleCAhPT0gLTEpIHtcbiAgICAgIGtleXMyLnNwbGljZShtZXNzYWdlSW5kZXgsIDEpO1xuICAgIH1cbiAgICBpZiAoa2V5czIubGVuZ3RoID09PSAxICYmIGtleXMyWzBdID09PSBcInJlcXVpcmVkXCIpIHtcbiAgICAgIHJldHVybiB2YWxpZGF0b3JzLnJlcXVpcmVkO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdG9yc1t0aGlzLmdldFR5cGUocnVsZSldIHx8IHZvaWQgMDtcbiAgfTtcbiAgcmV0dXJuIFNjaGVtYTI7XG59KCk7XG5TY2hlbWEucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcih0eXBlNCwgdmFsaWRhdG9yKSB7XG4gIGlmICh0eXBlb2YgdmFsaWRhdG9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVnaXN0ZXIgYSB2YWxpZGF0b3IgYnkgdHlwZSwgdmFsaWRhdG9yIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIHZhbGlkYXRvcnNbdHlwZTRdID0gdmFsaWRhdG9yO1xufTtcblNjaGVtYS53YXJuaW5nID0gd2FybmluZztcblNjaGVtYS5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuU2NoZW1hLnZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzO1xudmFyIHR5cGVUZW1wbGF0ZSQxID0gXCInJHtuYW1lfScgaXMgbm90IGEgdmFsaWQgJHt0eXBlfVwiO1xudmFyIGRlZmF1bHRWYWxpZGF0ZU1lc3NhZ2VzID0ge1xuICBkZWZhdWx0OiBcIlZhbGlkYXRpb24gZXJyb3Igb24gZmllbGQgJyR7bmFtZX0nXCIsXG4gIHJlcXVpcmVkOiBcIicke25hbWV9JyBpcyByZXF1aXJlZFwiLFxuICBlbnVtOiBcIicke25hbWV9JyBtdXN0IGJlIG9uZSBvZiBbJHtlbnVtfV1cIixcbiAgd2hpdGVzcGFjZTogXCInJHtuYW1lfScgY2Fubm90IGJlIGVtcHR5XCIsXG4gIGRhdGU6IHtcbiAgICBmb3JtYXQ6IFwiJyR7bmFtZX0nIGlzIGludmFsaWQgZm9yIGZvcm1hdCBkYXRlXCIsXG4gICAgcGFyc2U6IFwiJyR7bmFtZX0nIGNvdWxkIG5vdCBiZSBwYXJzZWQgYXMgZGF0ZVwiLFxuICAgIGludmFsaWQ6IFwiJyR7bmFtZX0nIGlzIGludmFsaWQgZGF0ZVwiXG4gIH0sXG4gIHR5cGVzOiB7XG4gICAgc3RyaW5nOiB0eXBlVGVtcGxhdGUkMSxcbiAgICBtZXRob2Q6IHR5cGVUZW1wbGF0ZSQxLFxuICAgIGFycmF5OiB0eXBlVGVtcGxhdGUkMSxcbiAgICBvYmplY3Q6IHR5cGVUZW1wbGF0ZSQxLFxuICAgIG51bWJlcjogdHlwZVRlbXBsYXRlJDEsXG4gICAgZGF0ZTogdHlwZVRlbXBsYXRlJDEsXG4gICAgYm9vbGVhbjogdHlwZVRlbXBsYXRlJDEsXG4gICAgaW50ZWdlcjogdHlwZVRlbXBsYXRlJDEsXG4gICAgZmxvYXQ6IHR5cGVUZW1wbGF0ZSQxLFxuICAgIHJlZ2V4cDogdHlwZVRlbXBsYXRlJDEsXG4gICAgZW1haWw6IHR5cGVUZW1wbGF0ZSQxLFxuICAgIHVybDogdHlwZVRlbXBsYXRlJDEsXG4gICAgaGV4OiB0eXBlVGVtcGxhdGUkMVxuICB9LFxuICBzdHJpbmc6IHtcbiAgICBsZW46IFwiJyR7bmFtZX0nIG11c3QgYmUgZXhhY3RseSAke2xlbn0gY2hhcmFjdGVyc1wiLFxuICAgIG1pbjogXCInJHtuYW1lfScgbXVzdCBiZSBhdCBsZWFzdCAke21pbn0gY2hhcmFjdGVyc1wiLFxuICAgIG1heDogXCInJHtuYW1lfScgY2Fubm90IGJlIGxvbmdlciB0aGFuICR7bWF4fSBjaGFyYWN0ZXJzXCIsXG4gICAgcmFuZ2U6IFwiJyR7bmFtZX0nIG11c3QgYmUgYmV0d2VlbiAke21pbn0gYW5kICR7bWF4fSBjaGFyYWN0ZXJzXCJcbiAgfSxcbiAgbnVtYmVyOiB7XG4gICAgbGVuOiBcIicke25hbWV9JyBtdXN0IGVxdWFsICR7bGVufVwiLFxuICAgIG1pbjogXCInJHtuYW1lfScgY2Fubm90IGJlIGxlc3MgdGhhbiAke21pbn1cIixcbiAgICBtYXg6IFwiJyR7bmFtZX0nIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gJHttYXh9XCIsXG4gICAgcmFuZ2U6IFwiJyR7bmFtZX0nIG11c3QgYmUgYmV0d2VlbiAke21pbn0gYW5kICR7bWF4fVwiXG4gIH0sXG4gIGFycmF5OiB7XG4gICAgbGVuOiBcIicke25hbWV9JyBtdXN0IGJlIGV4YWN0bHkgJHtsZW59IGluIGxlbmd0aFwiLFxuICAgIG1pbjogXCInJHtuYW1lfScgY2Fubm90IGJlIGxlc3MgdGhhbiAke21pbn0gaW4gbGVuZ3RoXCIsXG4gICAgbWF4OiBcIicke25hbWV9JyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuICR7bWF4fSBpbiBsZW5ndGhcIixcbiAgICByYW5nZTogXCInJHtuYW1lfScgbXVzdCBiZSBiZXR3ZWVuICR7bWlufSBhbmQgJHttYXh9IGluIGxlbmd0aFwiXG4gIH0sXG4gIHBhdHRlcm46IHtcbiAgICBtaXNtYXRjaDogXCInJHtuYW1lfScgZG9lcyBub3QgbWF0Y2ggcGF0dGVybiAke3BhdHRlcm59XCJcbiAgfVxufTtcbmZ1bmN0aW9uIGdldChlbnRpdHksIHBhdGgpIHtcbiAgdmFyIGN1cnJlbnQgPSBlbnRpdHk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY3VycmVudCA9IGN1cnJlbnRbcGF0aFtpXV07XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBfdG9BcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5mdW5jdGlvbiBpbnRlcm5hbFNldChlbnRpdHksIHBhdGhzLCB2YWx1ZSwgcmVtb3ZlSWZVbmRlZmluZWQpIHtcbiAgaWYgKCFwYXRocy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIF9wYXRocyA9IF90b0FycmF5KHBhdGhzKSwgcGF0aCA9IF9wYXRoc1swXSwgcmVzdFBhdGggPSBfcGF0aHMuc2xpY2UoMSk7XG4gIHZhciBjbG9uZTI7XG4gIGlmICghZW50aXR5ICYmIHR5cGVvZiBwYXRoID09PSBcIm51bWJlclwiKSB7XG4gICAgY2xvbmUyID0gW107XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbnRpdHkpKSB7XG4gICAgY2xvbmUyID0gX3RvQ29uc3VtYWJsZUFycmF5KGVudGl0eSk7XG4gIH0gZWxzZSB7XG4gICAgY2xvbmUyID0gX29iamVjdFNwcmVhZDIkMSh7fSwgZW50aXR5KTtcbiAgfVxuICBpZiAocmVtb3ZlSWZVbmRlZmluZWQgJiYgdmFsdWUgPT09IHZvaWQgMCAmJiByZXN0UGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBkZWxldGUgY2xvbmUyW3BhdGhdW3Jlc3RQYXRoWzBdXTtcbiAgfSBlbHNlIHtcbiAgICBjbG9uZTJbcGF0aF0gPSBpbnRlcm5hbFNldChjbG9uZTJbcGF0aF0sIHJlc3RQYXRoLCB2YWx1ZSwgcmVtb3ZlSWZVbmRlZmluZWQpO1xuICB9XG4gIHJldHVybiBjbG9uZTI7XG59XG5mdW5jdGlvbiBzZXQoZW50aXR5LCBwYXRocywgdmFsdWUpIHtcbiAgdmFyIHJlbW92ZUlmVW5kZWZpbmVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgaWYgKHBhdGhzLmxlbmd0aCAmJiByZW1vdmVJZlVuZGVmaW5lZCAmJiB2YWx1ZSA9PT0gdm9pZCAwICYmICFnZXQoZW50aXR5LCBwYXRocy5zbGljZSgwLCAtMSkpKSB7XG4gICAgcmV0dXJuIGVudGl0eTtcbiAgfVxuICByZXR1cm4gaW50ZXJuYWxTZXQoZW50aXR5LCBwYXRocywgdmFsdWUsIHJlbW92ZUlmVW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGdldE5hbWVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHRvQXJyYXkocGF0aCk7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZSQyKHN0b3JlLCBuYW1lUGF0aCkge1xuICB2YXIgdmFsdWUgPSBnZXQoc3RvcmUsIG5hbWVQYXRoKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0VmFsdWUoc3RvcmUsIG5hbWVQYXRoLCB2YWx1ZSkge1xuICB2YXIgcmVtb3ZlSWZVbmRlZmluZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICB2YXIgbmV3U3RvcmUgPSBzZXQoc3RvcmUsIG5hbWVQYXRoLCB2YWx1ZSwgcmVtb3ZlSWZVbmRlZmluZWQpO1xuICByZXR1cm4gbmV3U3RvcmU7XG59XG5mdW5jdGlvbiBjbG9uZUJ5TmFtZVBhdGhMaXN0KHN0b3JlLCBuYW1lUGF0aExpc3QpIHtcbiAgdmFyIG5ld1N0b3JlID0ge307XG4gIG5hbWVQYXRoTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKG5hbWVQYXRoKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUkMihzdG9yZSwgbmFtZVBhdGgpO1xuICAgIG5ld1N0b3JlID0gc2V0VmFsdWUobmV3U3RvcmUsIG5hbWVQYXRoLCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gbmV3U3RvcmU7XG59XG5mdW5jdGlvbiBjb250YWluc05hbWVQYXRoKG5hbWVQYXRoTGlzdCwgbmFtZVBhdGgpIHtcbiAgcmV0dXJuIG5hbWVQYXRoTGlzdCAmJiBuYW1lUGF0aExpc3Quc29tZShmdW5jdGlvbihwYXRoKSB7XG4gICAgcmV0dXJuIG1hdGNoTmFtZVBhdGgocGF0aCwgbmFtZVBhdGgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0JDMob2JqKSB7XG4gIHJldHVybiBfdHlwZW9mJDEob2JqKSA9PT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5mdW5jdGlvbiBpbnRlcm5hbFNldFZhbHVlcyhzdG9yZSwgdmFsdWVzKSB7XG4gIHZhciBuZXdTdG9yZSA9IEFycmF5LmlzQXJyYXkoc3RvcmUpID8gX3RvQ29uc3VtYWJsZUFycmF5KHN0b3JlKSA6IF9vYmplY3RTcHJlYWQyJDEoe30sIHN0b3JlKTtcbiAgaWYgKCF2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3U3RvcmU7XG4gIH1cbiAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleTIpIHtcbiAgICB2YXIgcHJldlZhbHVlID0gbmV3U3RvcmVba2V5Ml07XG4gICAgdmFyIHZhbHVlID0gdmFsdWVzW2tleTJdO1xuICAgIHZhciByZWN1cnNpdmUgPSBpc09iamVjdCQzKHByZXZWYWx1ZSkgJiYgaXNPYmplY3QkMyh2YWx1ZSk7XG4gICAgbmV3U3RvcmVba2V5Ml0gPSByZWN1cnNpdmUgPyBpbnRlcm5hbFNldFZhbHVlcyhwcmV2VmFsdWUsIHZhbHVlIHx8IHt9KSA6IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIG5ld1N0b3JlO1xufVxuZnVuY3Rpb24gc2V0VmFsdWVzKHN0b3JlKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0VmFsdWVzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICByZXN0VmFsdWVzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gcmVzdFZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24oY3VycmVudCwgbmV3U3RvcmUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxTZXRWYWx1ZXMoY3VycmVudCwgbmV3U3RvcmUpO1xuICB9LCBzdG9yZSk7XG59XG5mdW5jdGlvbiBtYXRjaE5hbWVQYXRoKG5hbWVQYXRoLCBjaGFuZ2VkTmFtZVBhdGgpIHtcbiAgaWYgKCFuYW1lUGF0aCB8fCAhY2hhbmdlZE5hbWVQYXRoIHx8IG5hbWVQYXRoLmxlbmd0aCAhPT0gY2hhbmdlZE5hbWVQYXRoLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbmFtZVBhdGguZXZlcnkoZnVuY3Rpb24obmFtZVVuaXQsIGkpIHtcbiAgICByZXR1cm4gY2hhbmdlZE5hbWVQYXRoW2ldID09PSBuYW1lVW5pdDtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc1NpbWlsYXIoc291cmNlLCB0YXJnZXQpIHtcbiAgaWYgKHNvdXJjZSA9PT0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFzb3VyY2UgJiYgdGFyZ2V0IHx8IHNvdXJjZSAmJiAhdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghc291cmNlIHx8ICF0YXJnZXQgfHwgX3R5cGVvZiQxKHNvdXJjZSkgIT09IFwib2JqZWN0XCIgfHwgX3R5cGVvZiQxKHRhcmdldCkgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIgdGFyZ2V0S2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XG4gIHZhciBrZXlzMiA9IG5ldyBTZXQoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShzb3VyY2VLZXlzKSwgX3RvQ29uc3VtYWJsZUFycmF5KHRhcmdldEtleXMpKSk7XG4gIHJldHVybiBfdG9Db25zdW1hYmxlQXJyYXkoa2V5czIpLmV2ZXJ5KGZ1bmN0aW9uKGtleTIpIHtcbiAgICB2YXIgc291cmNlVmFsdWUgPSBzb3VyY2Vba2V5Ml07XG4gICAgdmFyIHRhcmdldFZhbHVlID0gdGFyZ2V0W2tleTJdO1xuICAgIGlmICh0eXBlb2Ygc291cmNlVmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdGFyZ2V0VmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VWYWx1ZSA9PT0gdGFyZ2V0VmFsdWU7XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVmYXVsdEdldFZhbHVlRnJvbUV2ZW50KHZhbHVlUHJvcE5hbWUpIHtcbiAgdmFyIGV2ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdm9pZCAwIDogYXJndW1lbnRzWzFdO1xuICBpZiAoZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIF90eXBlb2YkMShldmVudC50YXJnZXQpID09PSBcIm9iamVjdFwiICYmIHZhbHVlUHJvcE5hbWUgaW4gZXZlbnQudGFyZ2V0KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRhcmdldFt2YWx1ZVByb3BOYW1lXTtcbiAgfVxuICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiBtb3ZlKGFycmF5NCwgbW92ZUluZGV4LCB0b0luZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheTQubGVuZ3RoO1xuICBpZiAobW92ZUluZGV4IDwgMCB8fCBtb3ZlSW5kZXggPj0gbGVuZ3RoIHx8IHRvSW5kZXggPCAwIHx8IHRvSW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFycmF5NDtcbiAgfVxuICB2YXIgaXRlbSA9IGFycmF5NFttb3ZlSW5kZXhdO1xuICB2YXIgZGlmZiA9IG1vdmVJbmRleCAtIHRvSW5kZXg7XG4gIGlmIChkaWZmID4gMCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFycmF5NC5zbGljZSgwLCB0b0luZGV4KSksIFtpdGVtXSwgX3RvQ29uc3VtYWJsZUFycmF5KGFycmF5NC5zbGljZSh0b0luZGV4LCBtb3ZlSW5kZXgpKSwgX3RvQ29uc3VtYWJsZUFycmF5KGFycmF5NC5zbGljZShtb3ZlSW5kZXggKyAxLCBsZW5ndGgpKSk7XG4gIH1cbiAgaWYgKGRpZmYgPCAwKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYXJyYXk0LnNsaWNlKDAsIG1vdmVJbmRleCkpLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJyYXk0LnNsaWNlKG1vdmVJbmRleCArIDEsIHRvSW5kZXggKyAxKSksIFtpdGVtXSwgX3RvQ29uc3VtYWJsZUFycmF5KGFycmF5NC5zbGljZSh0b0luZGV4ICsgMSwgbGVuZ3RoKSkpO1xuICB9XG4gIHJldHVybiBhcnJheTQ7XG59XG52YXIgQXN5bmNWYWxpZGF0b3IgPSBTY2hlbWE7XG5mdW5jdGlvbiByZXBsYWNlTWVzc2FnZSh0ZW1wbGF0ZSwga3YpIHtcbiAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL1xcJFxce1xcdytcXH0vZywgZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIGtleTIgPSBzdHIuc2xpY2UoMiwgLTEpO1xuICAgIHJldHVybiBrdltrZXkyXTtcbiAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVJ1bGUoX3gsIF94MiwgX3gzLCBfeDQsIF94NSkge1xuICByZXR1cm4gX3ZhbGlkYXRlUnVsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX3ZhbGlkYXRlUnVsZSgpIHtcbiAgX3ZhbGlkYXRlUnVsZSA9IF9hc3luY1RvR2VuZXJhdG9yKC8qIEBfX1BVUkVfXyAqLyByZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKG5hbWUsIHZhbHVlLCBydWxlLCBvcHRpb25zLCBtZXNzYWdlVmFyaWFibGVzKSB7XG4gICAgdmFyIGNsb25lUnVsZSwgc3ViUnVsZUZpZWxkLCB2YWxpZGF0b3IsIG1lc3NhZ2VzMiwgcmVzdWx0LCBzdWJSZXN1bHRzLCBrdiwgZmlsbFZhcmlhYmxlUmVzdWx0O1xuICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNsb25lUnVsZSA9IF9vYmplY3RTcHJlYWQyJDEoe30sIHJ1bGUpO1xuICAgICAgICAgICAgZGVsZXRlIGNsb25lUnVsZS5ydWxlSW5kZXg7XG4gICAgICAgICAgICBzdWJSdWxlRmllbGQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNsb25lUnVsZSAmJiBjbG9uZVJ1bGUudHlwZSA9PT0gXCJhcnJheVwiICYmIGNsb25lUnVsZS5kZWZhdWx0RmllbGQpIHtcbiAgICAgICAgICAgICAgc3ViUnVsZUZpZWxkID0gY2xvbmVSdWxlLmRlZmF1bHRGaWVsZDtcbiAgICAgICAgICAgICAgZGVsZXRlIGNsb25lUnVsZS5kZWZhdWx0RmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxpZGF0b3IgPSBuZXcgQXN5bmNWYWxpZGF0b3IoX2RlZmluZVByb3BlcnR5JDEoe30sIG5hbWUsIFtjbG9uZVJ1bGVdKSk7XG4gICAgICAgICAgICBtZXNzYWdlczIgPSBzZXRWYWx1ZXMoe30sIGRlZmF1bHRWYWxpZGF0ZU1lc3NhZ2VzLCBvcHRpb25zLnZhbGlkYXRlTWVzc2FnZXMpO1xuICAgICAgICAgICAgdmFsaWRhdG9yLm1lc3NhZ2VzKG1lc3NhZ2VzMik7XG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbGlkYXRvci52YWxpZGF0ZShfZGVmaW5lUHJvcGVydHkkMSh7fSwgbmFtZSwgdmFsdWUpLCBfb2JqZWN0U3ByZWFkMiQxKHt9LCBvcHRpb25zKSkpO1xuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTM7XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSg4KTtcbiAgICAgICAgICAgIGlmIChfY29udGV4dDIudDAuZXJyb3JzKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0Mi50MC5lcnJvcnMubWFwKGZ1bmN0aW9uKF9yZWY0LCBpbmRleDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZTIgPSBfcmVmNC5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuaXNWYWxpZEVsZW1lbnQobWVzc2FnZTIpID8gLyogQF9fUFVSRV9fICovIFJlYWN0LmNsb25lRWxlbWVudChtZXNzYWdlMiwge1xuICAgICAgICAgICAgICAgICAga2V5OiBcImVycm9yX1wiLmNvbmNhdChpbmRleDIpXG4gICAgICAgICAgICAgICAgfSkgOiBtZXNzYWdlMjtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKF9jb250ZXh0Mi50MCk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IFttZXNzYWdlczIuZGVmYXVsdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIGlmICghKCFyZXN1bHQubGVuZ3RoICYmIHN1YlJ1bGVGaWVsZCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE5O1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHZhbHVlLm1hcChmdW5jdGlvbihzdWJWYWx1ZSwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVSdWxlKFwiXCIuY29uY2F0KG5hbWUsIFwiLlwiKS5jb25jYXQoaSksIHN1YlZhbHVlLCBzdWJSdWxlRmllbGQsIG9wdGlvbnMsIG1lc3NhZ2VWYXJpYWJsZXMpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICBzdWJSZXN1bHRzID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBzdWJSZXN1bHRzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBlcnJvcnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocHJldiksIF90b0NvbnN1bWFibGVBcnJheShlcnJvcnMpKTtcbiAgICAgICAgICAgIH0sIFtdKSk7XG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgIGt2ID0gX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBydWxlKSwge30sIHtcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgZW51bTogKHJ1bGUuZW51bSB8fCBbXSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgICB9LCBtZXNzYWdlVmFyaWFibGVzKTtcbiAgICAgICAgICAgIGZpbGxWYXJpYWJsZVJlc3VsdCA9IHJlc3VsdC5tYXAoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlTWVzc2FnZShlcnJvciwga3YpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgZmlsbFZhcmlhYmxlUmVzdWx0KTtcbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbOCwgMTNdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF92YWxpZGF0ZVJ1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUnVsZXMobmFtZVBhdGgsIHZhbHVlLCBydWxlczIsIG9wdGlvbnMsIHZhbGlkYXRlRmlyc3QsIG1lc3NhZ2VWYXJpYWJsZXMpIHtcbiAgdmFyIG5hbWUgPSBuYW1lUGF0aC5qb2luKFwiLlwiKTtcbiAgdmFyIGZpbGxlZFJ1bGVzID0gcnVsZXMyLm1hcChmdW5jdGlvbihjdXJyZW50UnVsZSwgcnVsZUluZGV4KSB7XG4gICAgdmFyIG9yaWdpblZhbGlkYXRvckZ1bmMgPSBjdXJyZW50UnVsZS52YWxpZGF0b3I7XG4gICAgdmFyIGNsb25lUnVsZSA9IF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwgY3VycmVudFJ1bGUpLCB7fSwge1xuICAgICAgcnVsZUluZGV4XG4gICAgfSk7XG4gICAgaWYgKG9yaWdpblZhbGlkYXRvckZ1bmMpIHtcbiAgICAgIGNsb25lUnVsZS52YWxpZGF0b3IgPSBmdW5jdGlvbihydWxlLCB2YWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBoYXNQcm9taXNlID0gZmFsc2U7XG4gICAgICAgIHZhciB3cmFwcGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiB3cmFwcGVkQ2FsbGJhY2syKCkge1xuICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHdhcm5pbmdPbmNlKCFoYXNQcm9taXNlLCBcIllvdXIgdmFsaWRhdG9yIGZ1bmN0aW9uIGhhcyBhbHJlYWR5IHJldHVybiBhIHByb21pc2UuIGBjYWxsYmFja2Agd2lsbCBiZSBpZ25vcmVkLlwiKTtcbiAgICAgICAgICAgIGlmICghaGFzUHJvbWlzZSkge1xuICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG9yaWdpblZhbGlkYXRvckZ1bmMocnVsZSwgdmFsLCB3cmFwcGVkQ2FsbGJhY2spO1xuICAgICAgICBoYXNQcm9taXNlID0gcHJvbWlzZSAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHByb21pc2UuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgd2FybmluZ09uY2UoaGFzUHJvbWlzZSwgXCJgY2FsbGJhY2tgIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSByZXR1cm4gYSBwcm9taXNlIGluc3RlYWQuXCIpO1xuICAgICAgICBpZiAoaGFzUHJvbWlzZSkge1xuICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIgfHwgXCIgXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVSdWxlO1xuICB9KS5zb3J0KGZ1bmN0aW9uKF9yZWYsIF9yZWYyKSB7XG4gICAgdmFyIHcxID0gX3JlZi53YXJuaW5nT25seSwgaTEgPSBfcmVmLnJ1bGVJbmRleDtcbiAgICB2YXIgdzIgPSBfcmVmMi53YXJuaW5nT25seSwgaTIgPSBfcmVmMi5ydWxlSW5kZXg7XG4gICAgaWYgKCEhdzEgPT09ICEhdzIpIHtcbiAgICAgIHJldHVybiBpMSAtIGkyO1xuICAgIH1cbiAgICBpZiAodzEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH0pO1xuICB2YXIgc3VtbWFyeVByb21pc2U7XG4gIGlmICh2YWxpZGF0ZUZpcnN0ID09PSB0cnVlKSB7XG4gICAgc3VtbWFyeVByb21pc2UgPSBuZXcgUHJvbWlzZSgvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjMgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiBAX19QVVJFX18gKi8gcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgaSwgcnVsZSwgZXJyb3JzO1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmICghKGkgPCBmaWxsZWRSdWxlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVsZSA9IGZpbGxlZFJ1bGVzW2ldO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVJ1bGUobmFtZSwgdmFsdWUsIHJ1bGUsIG9wdGlvbnMsIG1lc3NhZ2VWYXJpYWJsZXMpO1xuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlamVjdChbe1xuICAgICAgICAgICAgICAgICAgZXJyb3JzLFxuICAgICAgICAgICAgICAgICAgcnVsZVxuICAgICAgICAgICAgICAgIH1dKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKF94NiwgX3g3KSB7XG4gICAgICAgIHJldHVybiBfcmVmMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9KCkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBydWxlUHJvbWlzZXMgPSBmaWxsZWRSdWxlcy5tYXAoZnVuY3Rpb24ocnVsZSkge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlUnVsZShuYW1lLCB2YWx1ZSwgcnVsZSwgb3B0aW9ucywgbWVzc2FnZVZhcmlhYmxlcykudGhlbihmdW5jdGlvbihlcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcnJvcnMsXG4gICAgICAgICAgcnVsZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgc3VtbWFyeVByb21pc2UgPSAodmFsaWRhdGVGaXJzdCA/IGZpbmlzaE9uRmlyc3RGYWlsZWQocnVsZVByb21pc2VzKSA6IGZpbmlzaE9uQWxsRmFpbGVkKHJ1bGVQcm9taXNlcykpLnRoZW4oZnVuY3Rpb24oZXJyb3JzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JzKTtcbiAgICB9KTtcbiAgfVxuICBzdW1tYXJ5UHJvbWlzZS5jYXRjaChmdW5jdGlvbihlMikge1xuICAgIHJldHVybiBlMjtcbiAgfSk7XG4gIHJldHVybiBzdW1tYXJ5UHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGZpbmlzaE9uQWxsRmFpbGVkKF94OCkge1xuICByZXR1cm4gX2ZpbmlzaE9uQWxsRmFpbGVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfZmluaXNoT25BbGxGYWlsZWQoKSB7XG4gIF9maW5pc2hPbkFsbEZhaWxlZCA9IF9hc3luY1RvR2VuZXJhdG9yKC8qIEBfX1BVUkVfXyAqLyByZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHJ1bGVQcm9taXNlcykge1xuICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIFByb21pc2UuYWxsKHJ1bGVQcm9taXNlcykudGhlbihmdW5jdGlvbihlcnJvcnNMaXN0KSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmNTtcbiAgICAgICAgICAgICAgdmFyIGVycm9ycyA9IChfcmVmNSA9IFtdKS5jb25jYXQuYXBwbHkoX3JlZjUsIF90b0NvbnN1bWFibGVBcnJheShlcnJvcnNMaXN0KSk7XG4gICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMpO1xuICB9KSk7XG4gIHJldHVybiBfZmluaXNoT25BbGxGYWlsZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGZpbmlzaE9uRmlyc3RGYWlsZWQoX3g5KSB7XG4gIHJldHVybiBfZmluaXNoT25GaXJzdEZhaWxlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2ZpbmlzaE9uRmlyc3RGYWlsZWQoKSB7XG4gIF9maW5pc2hPbkZpcnN0RmFpbGVkID0gX2FzeW5jVG9HZW5lcmF0b3IoLyogQF9fUFVSRV9fICovIHJlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQocnVsZVByb21pc2VzKSB7XG4gICAgdmFyIGNvdW50O1xuICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgcnVsZVByb21pc2VzLmZvckVhY2goZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbihydWxlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChydWxlRXJyb3IuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtydWxlRXJyb3JdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IHJ1bGVQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0KTtcbiAgfSkpO1xuICByZXR1cm4gX2ZpbmlzaE9uRmlyc3RGYWlsZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbnZhciBfZXhjbHVkZWQkMyA9IFtcIm5hbWVcIl07XG52YXIgRU1QVFlfRVJST1JTID0gW107XG5mdW5jdGlvbiByZXF1aXJlVXBkYXRlKHNob3VsZFVwZGF0ZSwgcHJldiwgbmV4dCwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGluZm8pIHtcbiAgaWYgKHR5cGVvZiBzaG91bGRVcGRhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBzaG91bGRVcGRhdGUocHJldiwgbmV4dCwgXCJzb3VyY2VcIiBpbiBpbmZvID8ge1xuICAgICAgc291cmNlOiBpbmZvLnNvdXJjZVxuICAgIH0gOiB7fSk7XG4gIH1cbiAgcmV0dXJuIHByZXZWYWx1ZSAhPT0gbmV4dFZhbHVlO1xufVxudmFyIEZpZWxkID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEZpZWxkMiwgX1JlYWN0JENvbXBvbmVudCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRmllbGQyKTtcbiAgZnVuY3Rpb24gRmllbGQyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWVsZDIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgcmVzZXRDb3VudDogMFxuICAgIH07XG4gICAgX3RoaXMuY2FuY2VsUmVnaXN0ZXJGdW5jID0gbnVsbDtcbiAgICBfdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgX3RoaXMudG91Y2hlZCA9IGZhbHNlO1xuICAgIF90aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgX3RoaXMudmFsaWRhdGVQcm9taXNlID0gbnVsbDtcbiAgICBfdGhpcy5wcmV2VmFsaWRhdGluZyA9IHZvaWQgMDtcbiAgICBfdGhpcy5lcnJvcnMgPSBFTVBUWV9FUlJPUlM7XG4gICAgX3RoaXMud2FybmluZ3MgPSBFTVBUWV9FUlJPUlM7XG4gICAgX3RoaXMuY2FuY2VsUmVnaXN0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLCBwcmVzZXJ2ZSA9IF90aGlzJHByb3BzLnByZXNlcnZlLCBpc0xpc3RGaWVsZCA9IF90aGlzJHByb3BzLmlzTGlzdEZpZWxkLCBuYW1lID0gX3RoaXMkcHJvcHMubmFtZTtcbiAgICAgIGlmIChfdGhpcy5jYW5jZWxSZWdpc3RlckZ1bmMpIHtcbiAgICAgICAgX3RoaXMuY2FuY2VsUmVnaXN0ZXJGdW5jKGlzTGlzdEZpZWxkLCBwcmVzZXJ2ZSwgZ2V0TmFtZVBhdGgobmFtZSkpO1xuICAgICAgfVxuICAgICAgX3RoaXMuY2FuY2VsUmVnaXN0ZXJGdW5jID0gbnVsbDtcbiAgICB9O1xuICAgIF90aGlzLmdldE5hbWVQYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gX3RoaXMucHJvcHMsIG5hbWUgPSBfdGhpcyRwcm9wczIubmFtZSwgZmllbGRDb250ZXh0ID0gX3RoaXMkcHJvcHMyLmZpZWxkQ29udGV4dDtcbiAgICAgIHZhciBfZmllbGRDb250ZXh0JHByZWZpeE4gPSBmaWVsZENvbnRleHQucHJlZml4TmFtZSwgcHJlZml4TmFtZSA9IF9maWVsZENvbnRleHQkcHJlZml4TiA9PT0gdm9pZCAwID8gW10gOiBfZmllbGRDb250ZXh0JHByZWZpeE47XG4gICAgICByZXR1cm4gbmFtZSAhPT0gdm9pZCAwID8gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwcmVmaXhOYW1lKSwgX3RvQ29uc3VtYWJsZUFycmF5KG5hbWUpKSA6IFtdO1xuICAgIH07XG4gICAgX3RoaXMuZ2V0UnVsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSBfdGhpcy5wcm9wcywgX3RoaXMkcHJvcHMzJHJ1bGVzID0gX3RoaXMkcHJvcHMzLnJ1bGVzLCBydWxlczIgPSBfdGhpcyRwcm9wczMkcnVsZXMgPT09IHZvaWQgMCA/IFtdIDogX3RoaXMkcHJvcHMzJHJ1bGVzLCBmaWVsZENvbnRleHQgPSBfdGhpcyRwcm9wczMuZmllbGRDb250ZXh0O1xuICAgICAgcmV0dXJuIHJ1bGVzMi5tYXAoZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBydWxlKGZpZWxkQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF90aGlzLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghX3RoaXMubW91bnRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24oX3JlZikge1xuICAgICAgICB2YXIgcmVzZXRDb3VudCA9IF9yZWYucmVzZXRDb3VudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldENvdW50OiByZXNldENvdW50ICsgMVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfdGhpcy50cmlnZ2VyTWV0YUV2ZW50ID0gZnVuY3Rpb24oZGVzdHJveTMpIHtcbiAgICAgIHZhciBvbk1ldGFDaGFuZ2UgPSBfdGhpcy5wcm9wcy5vbk1ldGFDaGFuZ2U7XG4gICAgICBvbk1ldGFDaGFuZ2UgPT09IG51bGwgfHwgb25NZXRhQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbk1ldGFDaGFuZ2UoX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBfdGhpcy5nZXRNZXRhKCkpLCB7fSwge1xuICAgICAgICBkZXN0cm95OiBkZXN0cm95M1xuICAgICAgfSkpO1xuICAgIH07XG4gICAgX3RoaXMub25TdG9yZUNoYW5nZSA9IGZ1bmN0aW9uKHByZXZTdG9yZSwgbmFtZVBhdGhMaXN0LCBpbmZvKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gX3RoaXMucHJvcHMsIHNob3VsZFVwZGF0ZSA9IF90aGlzJHByb3BzNC5zaG91bGRVcGRhdGUsIF90aGlzJHByb3BzNCRkZXBlbmRlbiA9IF90aGlzJHByb3BzNC5kZXBlbmRlbmNpZXMsIGRlcGVuZGVuY2llcyA9IF90aGlzJHByb3BzNCRkZXBlbmRlbiA9PT0gdm9pZCAwID8gW10gOiBfdGhpcyRwcm9wczQkZGVwZW5kZW4sIG9uUmVzZXQgPSBfdGhpcyRwcm9wczQub25SZXNldDtcbiAgICAgIHZhciBzdG9yZSA9IGluZm8uc3RvcmU7XG4gICAgICB2YXIgbmFtZVBhdGggPSBfdGhpcy5nZXROYW1lUGF0aCgpO1xuICAgICAgdmFyIHByZXZWYWx1ZSA9IF90aGlzLmdldFZhbHVlKHByZXZTdG9yZSk7XG4gICAgICB2YXIgY3VyVmFsdWUgPSBfdGhpcy5nZXRWYWx1ZShzdG9yZSk7XG4gICAgICB2YXIgbmFtZVBhdGhNYXRjaCA9IG5hbWVQYXRoTGlzdCAmJiBjb250YWluc05hbWVQYXRoKG5hbWVQYXRoTGlzdCwgbmFtZVBhdGgpO1xuICAgICAgaWYgKGluZm8udHlwZSA9PT0gXCJ2YWx1ZVVwZGF0ZVwiICYmIGluZm8uc291cmNlID09PSBcImV4dGVybmFsXCIgJiYgcHJldlZhbHVlICE9PSBjdXJWYWx1ZSkge1xuICAgICAgICBfdGhpcy50b3VjaGVkID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICBfdGhpcy52YWxpZGF0ZVByb21pc2UgPSBudWxsO1xuICAgICAgICBfdGhpcy5lcnJvcnMgPSBFTVBUWV9FUlJPUlM7XG4gICAgICAgIF90aGlzLndhcm5pbmdzID0gRU1QVFlfRVJST1JTO1xuICAgICAgICBfdGhpcy50cmlnZ2VyTWV0YUV2ZW50KCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGluZm8udHlwZSkge1xuICAgICAgICBjYXNlIFwicmVzZXRcIjpcbiAgICAgICAgICBpZiAoIW5hbWVQYXRoTGlzdCB8fCBuYW1lUGF0aE1hdGNoKSB7XG4gICAgICAgICAgICBfdGhpcy50b3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMudmFsaWRhdGVQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmVycm9ycyA9IEVNUFRZX0VSUk9SUztcbiAgICAgICAgICAgIF90aGlzLndhcm5pbmdzID0gRU1QVFlfRVJST1JTO1xuICAgICAgICAgICAgX3RoaXMudHJpZ2dlck1ldGFFdmVudCgpO1xuICAgICAgICAgICAgb25SZXNldCA9PT0gbnVsbCB8fCBvblJlc2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblJlc2V0KCk7XG4gICAgICAgICAgICBfdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICBfdGhpcy5yZVJlbmRlcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwic2V0RmllbGRcIjoge1xuICAgICAgICAgIGlmIChuYW1lUGF0aE1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGluZm8uZGF0YTtcbiAgICAgICAgICAgIGlmIChcInRvdWNoZWRcIiBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgIF90aGlzLnRvdWNoZWQgPSBkYXRhLnRvdWNoZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJ2YWxpZGF0aW5nXCIgaW4gZGF0YSAmJiAhKFwib3JpZ2luUkNGaWVsZFwiIGluIGRhdGEpKSB7XG4gICAgICAgICAgICAgIF90aGlzLnZhbGlkYXRlUHJvbWlzZSA9IGRhdGEudmFsaWRhdGluZyA/IFByb21pc2UucmVzb2x2ZShbXSkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwiZXJyb3JzXCIgaW4gZGF0YSkge1xuICAgICAgICAgICAgICBfdGhpcy5lcnJvcnMgPSBkYXRhLmVycm9ycyB8fCBFTVBUWV9FUlJPUlM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJ3YXJuaW5nc1wiIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgX3RoaXMud2FybmluZ3MgPSBkYXRhLndhcm5pbmdzIHx8IEVNUFRZX0VSUk9SUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLnRyaWdnZXJNZXRhRXZlbnQoKTtcbiAgICAgICAgICAgIF90aGlzLnJlUmVuZGVyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaG91bGRVcGRhdGUgJiYgIW5hbWVQYXRoLmxlbmd0aCAmJiByZXF1aXJlVXBkYXRlKHNob3VsZFVwZGF0ZSwgcHJldlN0b3JlLCBzdG9yZSwgcHJldlZhbHVlLCBjdXJWYWx1ZSwgaW5mbykpIHtcbiAgICAgICAgICAgIF90aGlzLnJlUmVuZGVyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJkZXBlbmRlbmNpZXNVcGRhdGVcIjoge1xuICAgICAgICAgIHZhciBkZXBlbmRlbmN5TGlzdCA9IGRlcGVuZGVuY2llcy5tYXAoZ2V0TmFtZVBhdGgpO1xuICAgICAgICAgIGlmIChkZXBlbmRlbmN5TGlzdC5zb21lKGZ1bmN0aW9uKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluc05hbWVQYXRoKGluZm8ucmVsYXRlZEZpZWxkcywgZGVwZW5kZW5jeSk7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIF90aGlzLnJlUmVuZGVyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKG5hbWVQYXRoTWF0Y2ggfHwgKCFkZXBlbmRlbmNpZXMubGVuZ3RoIHx8IG5hbWVQYXRoLmxlbmd0aCB8fCBzaG91bGRVcGRhdGUpICYmIHJlcXVpcmVVcGRhdGUoc2hvdWxkVXBkYXRlLCBwcmV2U3RvcmUsIHN0b3JlLCBwcmV2VmFsdWUsIGN1clZhbHVlLCBpbmZvKSkge1xuICAgICAgICAgICAgX3RoaXMucmVSZW5kZXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSB0cnVlKSB7XG4gICAgICAgIF90aGlzLnJlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfdGhpcy52YWxpZGF0ZVJ1bGVzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG5hbWVQYXRoID0gX3RoaXMuZ2V0TmFtZVBhdGgoKTtcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBfdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgdmFyIHJvb3RQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFfdGhpcy5tb3VudGVkKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhpcyRwcm9wczUgPSBfdGhpcy5wcm9wcywgX3RoaXMkcHJvcHM1JHZhbGlkYXRlID0gX3RoaXMkcHJvcHM1LnZhbGlkYXRlRmlyc3QsIHZhbGlkYXRlRmlyc3QgPSBfdGhpcyRwcm9wczUkdmFsaWRhdGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3RoaXMkcHJvcHM1JHZhbGlkYXRlLCBtZXNzYWdlVmFyaWFibGVzID0gX3RoaXMkcHJvcHM1Lm1lc3NhZ2VWYXJpYWJsZXM7XG4gICAgICAgIHZhciBfcmVmMiA9IG9wdGlvbnMgfHwge30sIHRyaWdnZXJOYW1lID0gX3JlZjIudHJpZ2dlck5hbWU7XG4gICAgICAgIHZhciBmaWx0ZXJlZFJ1bGVzID0gX3RoaXMuZ2V0UnVsZXMoKTtcbiAgICAgICAgaWYgKHRyaWdnZXJOYW1lKSB7XG4gICAgICAgICAgZmlsdGVyZWRSdWxlcyA9IGZpbHRlcmVkUnVsZXMuZmlsdGVyKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0ZVRyaWdnZXIgPSBydWxlLnZhbGlkYXRlVHJpZ2dlcjtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVUcmlnZ2VyKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRyaWdnZXJMaXN0ID0gdG9BcnJheSh2YWxpZGF0ZVRyaWdnZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXJMaXN0LmluY2x1ZGVzKHRyaWdnZXJOYW1lKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvbWlzZSA9IHZhbGlkYXRlUnVsZXMobmFtZVBhdGgsIGN1cnJlbnRWYWx1ZSwgZmlsdGVyZWRSdWxlcywgb3B0aW9ucywgdmFsaWRhdGVGaXJzdCwgbWVzc2FnZVZhcmlhYmxlcyk7XG4gICAgICAgIHByb21pc2UuY2F0Y2goZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHJ1bGVFcnJvcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IEVNUFRZX0VSUk9SUztcbiAgICAgICAgICBpZiAoX3RoaXMudmFsaWRhdGVQcm9taXNlID09PSByb290UHJvbWlzZSkge1xuICAgICAgICAgICAgX3RoaXMudmFsaWRhdGVQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBuZXh0RXJyb3JzID0gW107XG4gICAgICAgICAgICB2YXIgbmV4dFdhcm5pbmdzID0gW107XG4gICAgICAgICAgICBydWxlRXJyb3JzLmZvckVhY2goZnVuY3Rpb24oX3JlZjMpIHtcbiAgICAgICAgICAgICAgdmFyIHdhcm5pbmdPbmx5ID0gX3JlZjMucnVsZS53YXJuaW5nT25seSwgX3JlZjMkZXJyb3JzID0gX3JlZjMuZXJyb3JzLCBlcnJvcnMgPSBfcmVmMyRlcnJvcnMgPT09IHZvaWQgMCA/IEVNUFRZX0VSUk9SUyA6IF9yZWYzJGVycm9ycztcbiAgICAgICAgICAgICAgaWYgKHdhcm5pbmdPbmx5KSB7XG4gICAgICAgICAgICAgICAgbmV4dFdhcm5pbmdzLnB1c2guYXBwbHkobmV4dFdhcm5pbmdzLCBfdG9Db25zdW1hYmxlQXJyYXkoZXJyb3JzKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dEVycm9ycy5wdXNoLmFwcGx5KG5leHRFcnJvcnMsIF90b0NvbnN1bWFibGVBcnJheShlcnJvcnMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5lcnJvcnMgPSBuZXh0RXJyb3JzO1xuICAgICAgICAgICAgX3RoaXMud2FybmluZ3MgPSBuZXh0V2FybmluZ3M7XG4gICAgICAgICAgICBfdGhpcy50cmlnZ2VyTWV0YUV2ZW50KCk7XG4gICAgICAgICAgICBfdGhpcy5yZVJlbmRlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy52YWxpZGF0ZVByb21pc2UgPSByb290UHJvbWlzZTtcbiAgICAgIF90aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIF90aGlzLmVycm9ycyA9IEVNUFRZX0VSUk9SUztcbiAgICAgIF90aGlzLndhcm5pbmdzID0gRU1QVFlfRVJST1JTO1xuICAgICAgX3RoaXMudHJpZ2dlck1ldGFFdmVudCgpO1xuICAgICAgX3RoaXMucmVSZW5kZXIoKTtcbiAgICAgIHJldHVybiByb290UHJvbWlzZTtcbiAgICB9O1xuICAgIF90aGlzLmlzRmllbGRWYWxpZGF0aW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISFfdGhpcy52YWxpZGF0ZVByb21pc2U7XG4gICAgfTtcbiAgICBfdGhpcy5pc0ZpZWxkVG91Y2hlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnRvdWNoZWQ7XG4gICAgfTtcbiAgICBfdGhpcy5pc0ZpZWxkRGlydHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChfdGhpcy5kaXJ0eSB8fCBfdGhpcy5wcm9wcy5pbml0aWFsVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBmaWVsZENvbnRleHQgPSBfdGhpcy5wcm9wcy5maWVsZENvbnRleHQ7XG4gICAgICB2YXIgX2ZpZWxkQ29udGV4dCRnZXRJbnRlID0gZmllbGRDb250ZXh0LmdldEludGVybmFsSG9va3MoSE9PS19NQVJLKSwgZ2V0SW5pdGlhbFZhbHVlID0gX2ZpZWxkQ29udGV4dCRnZXRJbnRlLmdldEluaXRpYWxWYWx1ZTtcbiAgICAgIGlmIChnZXRJbml0aWFsVmFsdWUoX3RoaXMuZ2V0TmFtZVBhdGgoKSkgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF90aGlzLmdldEVycm9ycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmVycm9ycztcbiAgICB9O1xuICAgIF90aGlzLmdldFdhcm5pbmdzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX3RoaXMud2FybmluZ3M7XG4gICAgfTtcbiAgICBfdGhpcy5pc0xpc3RGaWVsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmlzTGlzdEZpZWxkO1xuICAgIH07XG4gICAgX3RoaXMuaXNMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMuaXNMaXN0O1xuICAgIH07XG4gICAgX3RoaXMuaXNQcmVzZXJ2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnByZXNlcnZlO1xuICAgIH07XG4gICAgX3RoaXMuZ2V0TWV0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMucHJldlZhbGlkYXRpbmcgPSBfdGhpcy5pc0ZpZWxkVmFsaWRhdGluZygpO1xuICAgICAgdmFyIG1ldGEgPSB7XG4gICAgICAgIHRvdWNoZWQ6IF90aGlzLmlzRmllbGRUb3VjaGVkKCksXG4gICAgICAgIHZhbGlkYXRpbmc6IF90aGlzLnByZXZWYWxpZGF0aW5nLFxuICAgICAgICBlcnJvcnM6IF90aGlzLmVycm9ycyxcbiAgICAgICAgd2FybmluZ3M6IF90aGlzLndhcm5pbmdzLFxuICAgICAgICBuYW1lOiBfdGhpcy5nZXROYW1lUGF0aCgpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG1ldGE7XG4gICAgfTtcbiAgICBfdGhpcy5nZXRPbmx5Q2hpbGQgPSBmdW5jdGlvbihjaGlsZHJlbikge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBtZXRhID0gX3RoaXMuZ2V0TWV0YSgpO1xuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBfdGhpcy5nZXRPbmx5Q2hpbGQoY2hpbGRyZW4oX3RoaXMuZ2V0Q29udHJvbGxlZCgpLCBtZXRhLCBfdGhpcy5wcm9wcy5maWVsZENvbnRleHQpKSksIHt9LCB7XG4gICAgICAgICAgaXNGdW5jdGlvbjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZExpc3QgPSB0b0FycmF5JDEoY2hpbGRyZW4pO1xuICAgICAgaWYgKGNoaWxkTGlzdC5sZW5ndGggIT09IDEgfHwgIS8qIEBfX1BVUkVfXyAqLyBSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZExpc3RbMF0pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hpbGQ6IGNoaWxkTGlzdCxcbiAgICAgICAgICBpc0Z1bmN0aW9uOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGQ6IGNoaWxkTGlzdFswXSxcbiAgICAgICAgaXNGdW5jdGlvbjogZmFsc2VcbiAgICAgIH07XG4gICAgfTtcbiAgICBfdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uKHN0b3JlKSB7XG4gICAgICB2YXIgZ2V0RmllbGRzVmFsdWUgPSBfdGhpcy5wcm9wcy5maWVsZENvbnRleHQuZ2V0RmllbGRzVmFsdWU7XG4gICAgICB2YXIgbmFtZVBhdGggPSBfdGhpcy5nZXROYW1lUGF0aCgpO1xuICAgICAgcmV0dXJuIGdldFZhbHVlJDIoc3RvcmUgfHwgZ2V0RmllbGRzVmFsdWUodHJ1ZSksIG5hbWVQYXRoKTtcbiAgICB9O1xuICAgIF90aGlzLmdldENvbnRyb2xsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGlsZFByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHZhciBfdGhpcyRwcm9wczYgPSBfdGhpcy5wcm9wcywgdHJpZ2dlciA9IF90aGlzJHByb3BzNi50cmlnZ2VyLCB2YWxpZGF0ZVRyaWdnZXIgPSBfdGhpcyRwcm9wczYudmFsaWRhdGVUcmlnZ2VyLCBnZXRWYWx1ZUZyb21FdmVudCA9IF90aGlzJHByb3BzNi5nZXRWYWx1ZUZyb21FdmVudCwgbm9ybWFsaXplMiA9IF90aGlzJHByb3BzNi5ub3JtYWxpemUsIHZhbHVlUHJvcE5hbWUgPSBfdGhpcyRwcm9wczYudmFsdWVQcm9wTmFtZSwgZ2V0VmFsdWVQcm9wcyA9IF90aGlzJHByb3BzNi5nZXRWYWx1ZVByb3BzLCBmaWVsZENvbnRleHQgPSBfdGhpcyRwcm9wczYuZmllbGRDb250ZXh0O1xuICAgICAgdmFyIG1lcmdlZFZhbGlkYXRlVHJpZ2dlciA9IHZhbGlkYXRlVHJpZ2dlciAhPT0gdm9pZCAwID8gdmFsaWRhdGVUcmlnZ2VyIDogZmllbGRDb250ZXh0LnZhbGlkYXRlVHJpZ2dlcjtcbiAgICAgIHZhciBuYW1lUGF0aCA9IF90aGlzLmdldE5hbWVQYXRoKCk7XG4gICAgICB2YXIgZ2V0SW50ZXJuYWxIb29rczMgPSBmaWVsZENvbnRleHQuZ2V0SW50ZXJuYWxIb29rcywgZ2V0RmllbGRzVmFsdWUgPSBmaWVsZENvbnRleHQuZ2V0RmllbGRzVmFsdWU7XG4gICAgICB2YXIgX2dldEludGVybmFsSG9va3MgPSBnZXRJbnRlcm5hbEhvb2tzMyhIT09LX01BUkspLCBkaXNwYXRjaCA9IF9nZXRJbnRlcm5hbEhvb2tzLmRpc3BhdGNoO1xuICAgICAgdmFyIHZhbHVlID0gX3RoaXMuZ2V0VmFsdWUoKTtcbiAgICAgIHZhciBtZXJnZWRHZXRWYWx1ZVByb3BzID0gZ2V0VmFsdWVQcm9wcyB8fCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSQxKHt9LCB2YWx1ZVByb3BOYW1lLCB2YWwpO1xuICAgICAgfTtcbiAgICAgIHZhciBvcmlnaW5UcmlnZ2VyRnVuYyA9IGNoaWxkUHJvcHNbdHJpZ2dlcl07XG4gICAgICB2YXIgY29udHJvbCA9IF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwgY2hpbGRQcm9wcyksIG1lcmdlZEdldFZhbHVlUHJvcHModmFsdWUpKTtcbiAgICAgIGNvbnRyb2xbdHJpZ2dlcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMudG91Y2hlZCA9IHRydWU7XG4gICAgICAgIF90aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMudHJpZ2dlck1ldGFFdmVudCgpO1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFZhbHVlRnJvbUV2ZW50KSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBnZXRWYWx1ZUZyb21FdmVudC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1ZhbHVlID0gZGVmYXVsdEdldFZhbHVlRnJvbUV2ZW50LmFwcGx5KHZvaWQgMCwgW3ZhbHVlUHJvcE5hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vcm1hbGl6ZTIpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG5vcm1hbGl6ZTIobmV3VmFsdWUsIHZhbHVlLCBnZXRGaWVsZHNWYWx1ZSh0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IFwidXBkYXRlVmFsdWVcIixcbiAgICAgICAgICBuYW1lUGF0aCxcbiAgICAgICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcmlnaW5UcmlnZ2VyRnVuYykge1xuICAgICAgICAgIG9yaWdpblRyaWdnZXJGdW5jLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgdmFsaWRhdGVUcmlnZ2VyTGlzdCA9IHRvQXJyYXkobWVyZ2VkVmFsaWRhdGVUcmlnZ2VyIHx8IFtdKTtcbiAgICAgIHZhbGlkYXRlVHJpZ2dlckxpc3QuZm9yRWFjaChmdW5jdGlvbih0cmlnZ2VyTmFtZSkge1xuICAgICAgICB2YXIgb3JpZ2luVHJpZ2dlciA9IGNvbnRyb2xbdHJpZ2dlck5hbWVdO1xuICAgICAgICBjb250cm9sW3RyaWdnZXJOYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChvcmlnaW5UcmlnZ2VyKSB7XG4gICAgICAgICAgICBvcmlnaW5UcmlnZ2VyLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJ1bGVzMiA9IF90aGlzLnByb3BzLnJ1bGVzO1xuICAgICAgICAgIGlmIChydWxlczIgJiYgcnVsZXMyLmxlbmd0aCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInZhbGlkYXRlRmllbGRcIixcbiAgICAgICAgICAgICAgbmFtZVBhdGgsXG4gICAgICAgICAgICAgIHRyaWdnZXJOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250cm9sO1xuICAgIH07XG4gICAgaWYgKHByb3BzLmZpZWxkQ29udGV4dCkge1xuICAgICAgdmFyIGdldEludGVybmFsSG9va3MyID0gcHJvcHMuZmllbGRDb250ZXh0LmdldEludGVybmFsSG9va3M7XG4gICAgICB2YXIgX2dldEludGVybmFsSG9va3MyID0gZ2V0SW50ZXJuYWxIb29rczIoSE9PS19NQVJLKSwgaW5pdEVudGl0eVZhbHVlID0gX2dldEludGVybmFsSG9va3MyLmluaXRFbnRpdHlWYWx1ZTtcbiAgICAgIGluaXRFbnRpdHlWYWx1ZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoRmllbGQyLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczcgPSB0aGlzLnByb3BzLCBzaG91bGRVcGRhdGUgPSBfdGhpcyRwcm9wczcuc2hvdWxkVXBkYXRlLCBmaWVsZENvbnRleHQgPSBfdGhpcyRwcm9wczcuZmllbGRDb250ZXh0O1xuICAgICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICAgIGlmIChmaWVsZENvbnRleHQpIHtcbiAgICAgICAgdmFyIGdldEludGVybmFsSG9va3MyID0gZmllbGRDb250ZXh0LmdldEludGVybmFsSG9va3M7XG4gICAgICAgIHZhciBfZ2V0SW50ZXJuYWxIb29rczMgPSBnZXRJbnRlcm5hbEhvb2tzMihIT09LX01BUkspLCByZWdpc3RlckZpZWxkID0gX2dldEludGVybmFsSG9va3MzLnJlZ2lzdGVyRmllbGQ7XG4gICAgICAgIHRoaXMuY2FuY2VsUmVnaXN0ZXJGdW5jID0gcmVnaXN0ZXJGaWVsZCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5yZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMuY2FuY2VsUmVnaXN0ZXIoKTtcbiAgICAgIHRoaXMudHJpZ2dlck1ldGFFdmVudCh0cnVlKTtcbiAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZVJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZVJlbmRlcigpIHtcbiAgICAgIGlmICghdGhpcy5tb3VudGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgcmVzZXRDb3VudCA9IHRoaXMuc3RhdGUucmVzZXRDb3VudDtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgX3RoaXMkZ2V0T25seUNoaWxkID0gdGhpcy5nZXRPbmx5Q2hpbGQoY2hpbGRyZW4pLCBjaGlsZCA9IF90aGlzJGdldE9ubHlDaGlsZC5jaGlsZCwgaXNGdW5jdGlvbjIgPSBfdGhpcyRnZXRPbmx5Q2hpbGQuaXNGdW5jdGlvbjtcbiAgICAgIHZhciByZXR1cm5DaGlsZE5vZGU7XG4gICAgICBpZiAoaXNGdW5jdGlvbjIpIHtcbiAgICAgICAgcmV0dXJuQ2hpbGROb2RlID0gY2hpbGQ7XG4gICAgICB9IGVsc2UgaWYgKC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuQ2hpbGROb2RlID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgdGhpcy5nZXRDb250cm9sbGVkKGNoaWxkLnByb3BzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nT25jZSghY2hpbGQsIFwiYGNoaWxkcmVuYCBvZiBGaWVsZCBpcyBub3QgdmFsaWRhdGUgUmVhY3RFbGVtZW50LlwiKTtcbiAgICAgICAgcmV0dXJuQ2hpbGROb2RlID0gY2hpbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIHtcbiAgICAgICAga2V5OiByZXNldENvdW50XG4gICAgICB9LCByZXR1cm5DaGlsZE5vZGUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRmllbGQyO1xufShSZWFjdC5Db21wb25lbnQpO1xuRmllbGQuY29udGV4dFR5cGUgPSBDb250ZXh0O1xuRmllbGQuZGVmYXVsdFByb3BzID0ge1xuICB0cmlnZ2VyOiBcIm9uQ2hhbmdlXCIsXG4gIHZhbHVlUHJvcE5hbWU6IFwidmFsdWVcIlxufTtcbmZ1bmN0aW9uIFdyYXBwZXJGaWVsZChfcmVmNSkge1xuICB2YXIgbmFtZSA9IF9yZWY1Lm5hbWUsIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNSwgX2V4Y2x1ZGVkJDMpO1xuICB2YXIgZmllbGRDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChDb250ZXh0KTtcbiAgdmFyIG5hbWVQYXRoID0gbmFtZSAhPT0gdm9pZCAwID8gZ2V0TmFtZVBhdGgobmFtZSkgOiB2b2lkIDA7XG4gIHZhciBrZXkyID0gXCJrZWVwXCI7XG4gIGlmICghcmVzdFByb3BzLmlzTGlzdEZpZWxkKSB7XG4gICAga2V5MiA9IFwiX1wiLmNvbmNhdCgobmFtZVBhdGggfHwgW10pLmpvaW4oXCJfXCIpKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmllbGQsIF9leHRlbmRzJDEoe1xuICAgIGtleToga2V5MixcbiAgICBuYW1lOiBuYW1lUGF0aFxuICB9LCByZXN0UHJvcHMsIHtcbiAgICBmaWVsZENvbnRleHRcbiAgfSkpO1xufVxudmFyIExpc3RDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG52YXIgTGlzdCA9IGZ1bmN0aW9uIExpc3QyKF9yZWYpIHtcbiAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsIGluaXRpYWxWYWx1ZSA9IF9yZWYuaW5pdGlhbFZhbHVlLCBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sIHJ1bGVzMiA9IF9yZWYucnVsZXMsIHZhbGlkYXRlVHJpZ2dlciA9IF9yZWYudmFsaWRhdGVUcmlnZ2VyO1xuICB2YXIgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dCk7XG4gIHZhciBrZXlSZWYgPSBSZWFjdC51c2VSZWYoe1xuICAgIGtleXM6IFtdLFxuICAgIGlkOiAwXG4gIH0pO1xuICB2YXIga2V5TWFuYWdlciA9IGtleVJlZi5jdXJyZW50O1xuICB2YXIgcHJlZml4TmFtZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhcmVudFByZWZpeE5hbWUgPSBnZXROYW1lUGF0aChjb250ZXh0LnByZWZpeE5hbWUpIHx8IFtdO1xuICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHBhcmVudFByZWZpeE5hbWUpLCBfdG9Db25zdW1hYmxlQXJyYXkoZ2V0TmFtZVBhdGgobmFtZSkpKTtcbiAgfSwgW2NvbnRleHQucHJlZml4TmFtZSwgbmFtZV0pO1xuICB2YXIgZmllbGRDb250ZXh0ID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBjb250ZXh0KSwge30sIHtcbiAgICAgIHByZWZpeE5hbWVcbiAgICB9KTtcbiAgfSwgW2NvbnRleHQsIHByZWZpeE5hbWVdKTtcbiAgdmFyIGxpc3RDb250ZXh0ID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0S2V5OiBmdW5jdGlvbiBnZXRLZXkobmFtZVBhdGgpIHtcbiAgICAgICAgdmFyIGxlbiA9IHByZWZpeE5hbWUubGVuZ3RoO1xuICAgICAgICB2YXIgcGF0aE5hbWUgPSBuYW1lUGF0aFtsZW5dO1xuICAgICAgICByZXR1cm4gW2tleU1hbmFnZXIua2V5c1twYXRoTmFtZV0sIG5hbWVQYXRoLnNsaWNlKGxlbiArIDEpXTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbcHJlZml4TmFtZV0pO1xuICBpZiAodHlwZW9mIGNoaWxkcmVuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB3YXJuaW5nT25jZShmYWxzZSwgXCJGb3JtLkxpc3Qgb25seSBhY2NlcHRzIGZ1bmN0aW9uIGFzIGNoaWxkcmVuLlwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc2hvdWxkVXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkVXBkYXRlMihwcmV2VmFsdWUsIG5leHRWYWx1ZSwgX3JlZjIpIHtcbiAgICB2YXIgc291cmNlID0gX3JlZjIuc291cmNlO1xuICAgIGlmIChzb3VyY2UgPT09IFwiaW50ZXJuYWxcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcHJldlZhbHVlICE9PSBuZXh0VmFsdWU7XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBsaXN0Q29udGV4dFxuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGZpZWxkQ29udGV4dFxuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVyRmllbGQsIHtcbiAgICBuYW1lOiBbXSxcbiAgICBzaG91bGRVcGRhdGUsXG4gICAgcnVsZXM6IHJ1bGVzMixcbiAgICB2YWxpZGF0ZVRyaWdnZXIsXG4gICAgaW5pdGlhbFZhbHVlLFxuICAgIGlzTGlzdDogdHJ1ZVxuICB9LCBmdW5jdGlvbihfcmVmMywgbWV0YSkge1xuICAgIHZhciBfcmVmMyR2YWx1ZSA9IF9yZWYzLnZhbHVlLCB2YWx1ZSA9IF9yZWYzJHZhbHVlID09PSB2b2lkIDAgPyBbXSA6IF9yZWYzJHZhbHVlLCBvbkNoYW5nZSA9IF9yZWYzLm9uQ2hhbmdlO1xuICAgIHZhciBnZXRGaWVsZFZhbHVlID0gY29udGV4dC5nZXRGaWVsZFZhbHVlO1xuICAgIHZhciBnZXROZXdWYWx1ZSA9IGZ1bmN0aW9uIGdldE5ld1ZhbHVlMigpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBnZXRGaWVsZFZhbHVlKHByZWZpeE5hbWUgfHwgW10pO1xuICAgICAgcmV0dXJuIHZhbHVlcyB8fCBbXTtcbiAgICB9O1xuICAgIHZhciBvcGVyYXRpb25zID0ge1xuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoZGVmYXVsdFZhbHVlLCBpbmRleDIpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gZ2V0TmV3VmFsdWUoKTtcbiAgICAgICAgaWYgKGluZGV4MiA+PSAwICYmIGluZGV4MiA8PSBuZXdWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICBrZXlNYW5hZ2VyLmtleXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGtleU1hbmFnZXIua2V5cy5zbGljZSgwLCBpbmRleDIpKSwgW2tleU1hbmFnZXIuaWRdLCBfdG9Db25zdW1hYmxlQXJyYXkoa2V5TWFuYWdlci5rZXlzLnNsaWNlKGluZGV4MikpKTtcbiAgICAgICAgICBvbkNoYW5nZShbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5ld1ZhbHVlLnNsaWNlKDAsIGluZGV4MikpLCBbZGVmYXVsdFZhbHVlXSwgX3RvQ29uc3VtYWJsZUFycmF5KG5ld1ZhbHVlLnNsaWNlKGluZGV4MikpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5TWFuYWdlci5rZXlzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShrZXlNYW5hZ2VyLmtleXMpLCBba2V5TWFuYWdlci5pZF0pO1xuICAgICAgICAgIG9uQ2hhbmdlKFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobmV3VmFsdWUpLCBbZGVmYXVsdFZhbHVlXSkpO1xuICAgICAgICB9XG4gICAgICAgIGtleU1hbmFnZXIuaWQgKz0gMTtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShpbmRleDIpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gZ2V0TmV3VmFsdWUoKTtcbiAgICAgICAgdmFyIGluZGV4U2V0ID0gbmV3IFNldChBcnJheS5pc0FycmF5KGluZGV4MikgPyBpbmRleDIgOiBbaW5kZXgyXSk7XG4gICAgICAgIGlmIChpbmRleFNldC5zaXplIDw9IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAga2V5TWFuYWdlci5rZXlzID0ga2V5TWFuYWdlci5rZXlzLmZpbHRlcihmdW5jdGlvbihfLCBrZXlzSW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gIWluZGV4U2V0LmhhcyhrZXlzSW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgb25DaGFuZ2UobmV3VmFsdWUuZmlsdGVyKGZ1bmN0aW9uKF8sIHZhbHVlSW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gIWluZGV4U2V0Lmhhcyh2YWx1ZUluZGV4KTtcbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUkMShmcm9tLCB0bykge1xuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gZ2V0TmV3VmFsdWUoKTtcbiAgICAgICAgaWYgKGZyb20gPCAwIHx8IGZyb20gPj0gbmV3VmFsdWUubGVuZ3RoIHx8IHRvIDwgMCB8fCB0byA+PSBuZXdWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAga2V5TWFuYWdlci5rZXlzID0gbW92ZShrZXlNYW5hZ2VyLmtleXMsIGZyb20sIHRvKTtcbiAgICAgICAgb25DaGFuZ2UobW92ZShuZXdWYWx1ZSwgZnJvbSwgdG8pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBsaXN0VmFsdWUgPSB2YWx1ZSB8fCBbXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdFZhbHVlKSkge1xuICAgICAgbGlzdFZhbHVlID0gW107XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbihsaXN0VmFsdWUubWFwKGZ1bmN0aW9uKF9fLCBpbmRleDIpIHtcbiAgICAgIHZhciBrZXkyID0ga2V5TWFuYWdlci5rZXlzW2luZGV4Ml07XG4gICAgICBpZiAoa2V5MiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGtleU1hbmFnZXIua2V5c1tpbmRleDJdID0ga2V5TWFuYWdlci5pZDtcbiAgICAgICAga2V5MiA9IGtleU1hbmFnZXIua2V5c1tpbmRleDJdO1xuICAgICAgICBrZXlNYW5hZ2VyLmlkICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBpbmRleDIsXG4gICAgICAgIGtleToga2V5MixcbiAgICAgICAgaXNMaXN0RmllbGQ6IHRydWVcbiAgICAgIH07XG4gICAgfSksIG9wZXJhdGlvbnMsIG1ldGEpO1xuICB9KSkpO1xufTtcbmZ1bmN0aW9uIGFsbFByb21pc2VGaW5pc2gocHJvbWlzZUxpc3QpIHtcbiAgdmFyIGhhc0Vycm9yID0gZmFsc2U7XG4gIHZhciBjb3VudCA9IHByb21pc2VMaXN0Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgaWYgKCFwcm9taXNlTGlzdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcHJvbWlzZUxpc3QuZm9yRWFjaChmdW5jdGlvbihwcm9taXNlLCBpbmRleDIpIHtcbiAgICAgIHByb21pc2UuY2F0Y2goZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZTI7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICByZXN1bHRzW2luZGV4Ml0gPSByZXN1bHQ7XG4gICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0Vycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG52YXIgU1BMSVQgPSBcIl9fQGZpZWxkX3NwbGl0X19cIjtcbmZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lUGF0aCkge1xuICByZXR1cm4gbmFtZVBhdGgubWFwKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoX3R5cGVvZiQxKGNlbGwpLCBcIjpcIikuY29uY2F0KGNlbGwpO1xuICB9KS5qb2luKFNQTElUKTtcbn1cbnZhciBOYW1lTWFwID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBOYW1lTWFwMigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmFtZU1hcDIpO1xuICAgIHRoaXMua3ZzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoTmFtZU1hcDIsIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQyKGtleTIsIHZhbHVlKSB7XG4gICAgICB0aGlzLmt2cy5zZXQobm9ybWFsaXplKGtleTIpLCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQyKGtleTIpIHtcbiAgICAgIHJldHVybiB0aGlzLmt2cy5nZXQobm9ybWFsaXplKGtleTIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShrZXkyLCB1cGRhdGVyKSB7XG4gICAgICB2YXIgb3JpZ2luID0gdGhpcy5nZXQoa2V5Mik7XG4gICAgICB2YXIgbmV4dCA9IHVwZGF0ZXIob3JpZ2luKTtcbiAgICAgIGlmICghbmV4dCkge1xuICAgICAgICB0aGlzLmRlbGV0ZShrZXkyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0KGtleTIsIG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkyKSB7XG4gICAgICB0aGlzLmt2cy5kZWxldGUobm9ybWFsaXplKGtleTIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmt2cy5lbnRyaWVzKCkpLm1hcChmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLCBrZXkyID0gX3JlZjJbMF0sIHZhbHVlID0gX3JlZjJbMV07XG4gICAgICAgIHZhciBjZWxscyA9IGtleTIuc3BsaXQoU1BMSVQpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soe1xuICAgICAgICAgIGtleTogY2VsbHMubWFwKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgIHZhciBfY2VsbCRtYXRjaCA9IGNlbGwubWF0Y2goL14oW146XSopOiguKikkLyksIF9jZWxsJG1hdGNoMiA9IF9zbGljZWRUb0FycmF5KF9jZWxsJG1hdGNoLCAzKSwgdHlwZTQgPSBfY2VsbCRtYXRjaDJbMV0sIHVuaXQgPSBfY2VsbCRtYXRjaDJbMl07XG4gICAgICAgICAgICByZXR1cm4gdHlwZTQgPT09IFwibnVtYmVyXCIgPyBOdW1iZXIodW5pdCkgOiB1bml0O1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgdGhpcy5tYXAoZnVuY3Rpb24oX3JlZjMpIHtcbiAgICAgICAgdmFyIGtleTIgPSBfcmVmMy5rZXksIHZhbHVlID0gX3JlZjMudmFsdWU7XG4gICAgICAgIGpzb25ba2V5Mi5qb2luKFwiLlwiKV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTmFtZU1hcDI7XG59KCk7XG52YXIgX2V4Y2x1ZGVkJDIgPSBbXCJuYW1lXCIsIFwiZXJyb3JzXCJdO1xudmFyIEZvcm1TdG9yZSA9IC8qIEBfX1BVUkVfXyAqLyBfY3JlYXRlQ2xhc3MoZnVuY3Rpb24gRm9ybVN0b3JlMihmb3JjZVJvb3RVcGRhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1TdG9yZTIpO1xuICB0aGlzLmZvcm1Ib29rZWQgPSBmYWxzZTtcbiAgdGhpcy5mb3JjZVJvb3RVcGRhdGUgPSB2b2lkIDA7XG4gIHRoaXMuc3Vic2NyaWJhYmxlID0gdHJ1ZTtcbiAgdGhpcy5zdG9yZSA9IHt9O1xuICB0aGlzLmZpZWxkRW50aXRpZXMgPSBbXTtcbiAgdGhpcy5pbml0aWFsVmFsdWVzID0ge307XG4gIHRoaXMuY2FsbGJhY2tzID0ge307XG4gIHRoaXMudmFsaWRhdGVNZXNzYWdlcyA9IG51bGw7XG4gIHRoaXMucHJlc2VydmUgPSBudWxsO1xuICB0aGlzLmxhc3RWYWxpZGF0ZVByb21pc2UgPSBudWxsO1xuICB0aGlzLmdldEZvcm0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0RmllbGRWYWx1ZTogX3RoaXMuZ2V0RmllbGRWYWx1ZSxcbiAgICAgIGdldEZpZWxkc1ZhbHVlOiBfdGhpcy5nZXRGaWVsZHNWYWx1ZSxcbiAgICAgIGdldEZpZWxkRXJyb3I6IF90aGlzLmdldEZpZWxkRXJyb3IsXG4gICAgICBnZXRGaWVsZFdhcm5pbmc6IF90aGlzLmdldEZpZWxkV2FybmluZyxcbiAgICAgIGdldEZpZWxkc0Vycm9yOiBfdGhpcy5nZXRGaWVsZHNFcnJvcixcbiAgICAgIGlzRmllbGRzVG91Y2hlZDogX3RoaXMuaXNGaWVsZHNUb3VjaGVkLFxuICAgICAgaXNGaWVsZFRvdWNoZWQ6IF90aGlzLmlzRmllbGRUb3VjaGVkLFxuICAgICAgaXNGaWVsZFZhbGlkYXRpbmc6IF90aGlzLmlzRmllbGRWYWxpZGF0aW5nLFxuICAgICAgaXNGaWVsZHNWYWxpZGF0aW5nOiBfdGhpcy5pc0ZpZWxkc1ZhbGlkYXRpbmcsXG4gICAgICByZXNldEZpZWxkczogX3RoaXMucmVzZXRGaWVsZHMsXG4gICAgICBzZXRGaWVsZHM6IF90aGlzLnNldEZpZWxkcyxcbiAgICAgIHNldEZpZWxkc1ZhbHVlOiBfdGhpcy5zZXRGaWVsZHNWYWx1ZSxcbiAgICAgIHZhbGlkYXRlRmllbGRzOiBfdGhpcy52YWxpZGF0ZUZpZWxkcyxcbiAgICAgIHN1Ym1pdDogX3RoaXMuc3VibWl0LFxuICAgICAgZ2V0SW50ZXJuYWxIb29rczogX3RoaXMuZ2V0SW50ZXJuYWxIb29rc1xuICAgIH07XG4gIH07XG4gIHRoaXMuZ2V0SW50ZXJuYWxIb29rcyA9IGZ1bmN0aW9uKGtleTIpIHtcbiAgICBpZiAoa2V5MiA9PT0gSE9PS19NQVJLKSB7XG4gICAgICBfdGhpcy5mb3JtSG9va2VkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BhdGNoOiBfdGhpcy5kaXNwYXRjaCxcbiAgICAgICAgaW5pdEVudGl0eVZhbHVlOiBfdGhpcy5pbml0RW50aXR5VmFsdWUsXG4gICAgICAgIHJlZ2lzdGVyRmllbGQ6IF90aGlzLnJlZ2lzdGVyRmllbGQsXG4gICAgICAgIHVzZVN1YnNjcmliZTogX3RoaXMudXNlU3Vic2NyaWJlLFxuICAgICAgICBzZXRJbml0aWFsVmFsdWVzOiBfdGhpcy5zZXRJbml0aWFsVmFsdWVzLFxuICAgICAgICBzZXRDYWxsYmFja3M6IF90aGlzLnNldENhbGxiYWNrcyxcbiAgICAgICAgc2V0VmFsaWRhdGVNZXNzYWdlczogX3RoaXMuc2V0VmFsaWRhdGVNZXNzYWdlcyxcbiAgICAgICAgZ2V0RmllbGRzOiBfdGhpcy5nZXRGaWVsZHMsXG4gICAgICAgIHNldFByZXNlcnZlOiBfdGhpcy5zZXRQcmVzZXJ2ZSxcbiAgICAgICAgZ2V0SW5pdGlhbFZhbHVlOiBfdGhpcy5nZXRJbml0aWFsVmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIHdhcm5pbmdPbmNlKGZhbHNlLCBcImBnZXRJbnRlcm5hbEhvb2tzYCBpcyBpbnRlcm5hbCB1c2FnZS4gU2hvdWxkIG5vdCBjYWxsIGRpcmVjdGx5LlwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgdGhpcy51c2VTdWJzY3JpYmUgPSBmdW5jdGlvbihzdWJzY3JpYmFibGUpIHtcbiAgICBfdGhpcy5zdWJzY3JpYmFibGUgPSBzdWJzY3JpYmFibGU7XG4gIH07XG4gIHRoaXMuc2V0SW5pdGlhbFZhbHVlcyA9IGZ1bmN0aW9uKGluaXRpYWxWYWx1ZXMsIGluaXQpIHtcbiAgICBfdGhpcy5pbml0aWFsVmFsdWVzID0gaW5pdGlhbFZhbHVlcyB8fCB7fTtcbiAgICBpZiAoaW5pdCkge1xuICAgICAgX3RoaXMuc3RvcmUgPSBzZXRWYWx1ZXMoe30sIGluaXRpYWxWYWx1ZXMsIF90aGlzLnN0b3JlKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuZ2V0SW5pdGlhbFZhbHVlID0gZnVuY3Rpb24obmFtZVBhdGgpIHtcbiAgICByZXR1cm4gZ2V0VmFsdWUkMihfdGhpcy5pbml0aWFsVmFsdWVzLCBuYW1lUGF0aCk7XG4gIH07XG4gIHRoaXMuc2V0Q2FsbGJhY2tzID0gZnVuY3Rpb24oY2FsbGJhY2tzKSB7XG4gICAgX3RoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICB9O1xuICB0aGlzLnNldFZhbGlkYXRlTWVzc2FnZXMgPSBmdW5jdGlvbih2YWxpZGF0ZU1lc3NhZ2VzKSB7XG4gICAgX3RoaXMudmFsaWRhdGVNZXNzYWdlcyA9IHZhbGlkYXRlTWVzc2FnZXM7XG4gIH07XG4gIHRoaXMuc2V0UHJlc2VydmUgPSBmdW5jdGlvbihwcmVzZXJ2ZSkge1xuICAgIF90aGlzLnByZXNlcnZlID0gcHJlc2VydmU7XG4gIH07XG4gIHRoaXMudGltZW91dElkID0gbnVsbDtcbiAgdGhpcy53YXJuaW5nVW5ob29rZWQgPSBmdW5jdGlvbigpIHtcbiAgfTtcbiAgdGhpcy5nZXRGaWVsZEVudGl0aWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHB1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIGlmICghcHVyZSkge1xuICAgICAgcmV0dXJuIF90aGlzLmZpZWxkRW50aXRpZXM7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcy5maWVsZEVudGl0aWVzLmZpbHRlcihmdW5jdGlvbihmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLmdldE5hbWVQYXRoKCkubGVuZ3RoO1xuICAgIH0pO1xuICB9O1xuICB0aGlzLmdldEZpZWxkc01hcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwdXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgY2FjaGUgPSBuZXcgTmFtZU1hcCgpO1xuICAgIF90aGlzLmdldEZpZWxkRW50aXRpZXMocHVyZSkuZm9yRWFjaChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgdmFyIG5hbWVQYXRoID0gZmllbGQuZ2V0TmFtZVBhdGgoKTtcbiAgICAgIGNhY2hlLnNldChuYW1lUGF0aCwgZmllbGQpO1xuICAgIH0pO1xuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcbiAgdGhpcy5nZXRGaWVsZEVudGl0aWVzRm9yTmFtZVBhdGhMaXN0ID0gZnVuY3Rpb24obmFtZUxpc3QpIHtcbiAgICBpZiAoIW5hbWVMaXN0KSB7XG4gICAgICByZXR1cm4gX3RoaXMuZ2V0RmllbGRFbnRpdGllcyh0cnVlKTtcbiAgICB9XG4gICAgdmFyIGNhY2hlID0gX3RoaXMuZ2V0RmllbGRzTWFwKHRydWUpO1xuICAgIHJldHVybiBuYW1lTGlzdC5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIG5hbWVQYXRoID0gZ2V0TmFtZVBhdGgobmFtZSk7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KG5hbWVQYXRoKSB8fCB7XG4gICAgICAgIElOVkFMSURBVEVfTkFNRV9QQVRIOiBnZXROYW1lUGF0aChuYW1lKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbiAgdGhpcy5nZXRGaWVsZHNWYWx1ZSA9IGZ1bmN0aW9uKG5hbWVMaXN0LCBmaWx0ZXJGdW5jKSB7XG4gICAgX3RoaXMud2FybmluZ1VuaG9va2VkKCk7XG4gICAgaWYgKG5hbWVMaXN0ID09PSB0cnVlICYmICFmaWx0ZXJGdW5jKSB7XG4gICAgICByZXR1cm4gX3RoaXMuc3RvcmU7XG4gICAgfVxuICAgIHZhciBmaWVsZEVudGl0aWVzID0gX3RoaXMuZ2V0RmllbGRFbnRpdGllc0Zvck5hbWVQYXRoTGlzdChBcnJheS5pc0FycmF5KG5hbWVMaXN0KSA/IG5hbWVMaXN0IDogbnVsbCk7XG4gICAgdmFyIGZpbHRlcmVkTmFtZUxpc3QgPSBbXTtcbiAgICBmaWVsZEVudGl0aWVzLmZvckVhY2goZnVuY3Rpb24oZW50aXR5KSB7XG4gICAgICB2YXIgX2VudGl0eSRpc0xpc3RGaWVsZDtcbiAgICAgIHZhciBuYW1lUGF0aCA9IFwiSU5WQUxJREFURV9OQU1FX1BBVEhcIiBpbiBlbnRpdHkgPyBlbnRpdHkuSU5WQUxJREFURV9OQU1FX1BBVEggOiBlbnRpdHkuZ2V0TmFtZVBhdGgoKTtcbiAgICAgIGlmICghbmFtZUxpc3QgJiYgKChfZW50aXR5JGlzTGlzdEZpZWxkID0gZW50aXR5LmlzTGlzdEZpZWxkKSA9PT0gbnVsbCB8fCBfZW50aXR5JGlzTGlzdEZpZWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZW50aXR5JGlzTGlzdEZpZWxkLmNhbGwoZW50aXR5KSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFmaWx0ZXJGdW5jKSB7XG4gICAgICAgIGZpbHRlcmVkTmFtZUxpc3QucHVzaChuYW1lUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWV0YSA9IFwiZ2V0TWV0YVwiIGluIGVudGl0eSA/IGVudGl0eS5nZXRNZXRhKCkgOiBudWxsO1xuICAgICAgICBpZiAoZmlsdGVyRnVuYyhtZXRhKSkge1xuICAgICAgICAgIGZpbHRlcmVkTmFtZUxpc3QucHVzaChuYW1lUGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmVCeU5hbWVQYXRoTGlzdChfdGhpcy5zdG9yZSwgZmlsdGVyZWROYW1lTGlzdC5tYXAoZ2V0TmFtZVBhdGgpKTtcbiAgfTtcbiAgdGhpcy5nZXRGaWVsZFZhbHVlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIF90aGlzLndhcm5pbmdVbmhvb2tlZCgpO1xuICAgIHZhciBuYW1lUGF0aCA9IGdldE5hbWVQYXRoKG5hbWUpO1xuICAgIHJldHVybiBnZXRWYWx1ZSQyKF90aGlzLnN0b3JlLCBuYW1lUGF0aCk7XG4gIH07XG4gIHRoaXMuZ2V0RmllbGRzRXJyb3IgPSBmdW5jdGlvbihuYW1lTGlzdCkge1xuICAgIF90aGlzLndhcm5pbmdVbmhvb2tlZCgpO1xuICAgIHZhciBmaWVsZEVudGl0aWVzID0gX3RoaXMuZ2V0RmllbGRFbnRpdGllc0Zvck5hbWVQYXRoTGlzdChuYW1lTGlzdCk7XG4gICAgcmV0dXJuIGZpZWxkRW50aXRpZXMubWFwKGZ1bmN0aW9uKGVudGl0eSwgaW5kZXgyKSB7XG4gICAgICBpZiAoZW50aXR5ICYmICEoXCJJTlZBTElEQVRFX05BTUVfUEFUSFwiIGluIGVudGl0eSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBlbnRpdHkuZ2V0TmFtZVBhdGgoKSxcbiAgICAgICAgICBlcnJvcnM6IGVudGl0eS5nZXRFcnJvcnMoKSxcbiAgICAgICAgICB3YXJuaW5nczogZW50aXR5LmdldFdhcm5pbmdzKClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGdldE5hbWVQYXRoKG5hbWVMaXN0W2luZGV4Ml0pLFxuICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICB3YXJuaW5nczogW11cbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG4gIHRoaXMuZ2V0RmllbGRFcnJvciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfdGhpcy53YXJuaW5nVW5ob29rZWQoKTtcbiAgICB2YXIgbmFtZVBhdGggPSBnZXROYW1lUGF0aChuYW1lKTtcbiAgICB2YXIgZmllbGRFcnJvciA9IF90aGlzLmdldEZpZWxkc0Vycm9yKFtuYW1lUGF0aF0pWzBdO1xuICAgIHJldHVybiBmaWVsZEVycm9yLmVycm9ycztcbiAgfTtcbiAgdGhpcy5nZXRGaWVsZFdhcm5pbmcgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgX3RoaXMud2FybmluZ1VuaG9va2VkKCk7XG4gICAgdmFyIG5hbWVQYXRoID0gZ2V0TmFtZVBhdGgobmFtZSk7XG4gICAgdmFyIGZpZWxkRXJyb3IgPSBfdGhpcy5nZXRGaWVsZHNFcnJvcihbbmFtZVBhdGhdKVswXTtcbiAgICByZXR1cm4gZmllbGRFcnJvci53YXJuaW5ncztcbiAgfTtcbiAgdGhpcy5pc0ZpZWxkc1RvdWNoZWQgPSBmdW5jdGlvbigpIHtcbiAgICBfdGhpcy53YXJuaW5nVW5ob29rZWQoKTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHZhciBhcmcwID0gYXJnc1swXSwgYXJnMSA9IGFyZ3NbMV07XG4gICAgdmFyIG5hbWVQYXRoTGlzdDtcbiAgICB2YXIgaXNBbGxGaWVsZHNUb3VjaGVkID0gZmFsc2U7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBuYW1lUGF0aExpc3QgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG4gICAgICAgIG5hbWVQYXRoTGlzdCA9IGFyZzAubWFwKGdldE5hbWVQYXRoKTtcbiAgICAgICAgaXNBbGxGaWVsZHNUb3VjaGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lUGF0aExpc3QgPSBudWxsO1xuICAgICAgICBpc0FsbEZpZWxkc1RvdWNoZWQgPSBhcmcwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lUGF0aExpc3QgPSBhcmcwLm1hcChnZXROYW1lUGF0aCk7XG4gICAgICBpc0FsbEZpZWxkc1RvdWNoZWQgPSBhcmcxO1xuICAgIH1cbiAgICB2YXIgZmllbGRFbnRpdGllcyA9IF90aGlzLmdldEZpZWxkRW50aXRpZXModHJ1ZSk7XG4gICAgdmFyIGlzRmllbGRUb3VjaGVkID0gZnVuY3Rpb24gaXNGaWVsZFRvdWNoZWQyKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuaXNGaWVsZFRvdWNoZWQoKTtcbiAgICB9O1xuICAgIGlmICghbmFtZVBhdGhMaXN0KSB7XG4gICAgICByZXR1cm4gaXNBbGxGaWVsZHNUb3VjaGVkID8gZmllbGRFbnRpdGllcy5ldmVyeShpc0ZpZWxkVG91Y2hlZCkgOiBmaWVsZEVudGl0aWVzLnNvbWUoaXNGaWVsZFRvdWNoZWQpO1xuICAgIH1cbiAgICB2YXIgbWFwID0gbmV3IE5hbWVNYXAoKTtcbiAgICBuYW1lUGF0aExpc3QuZm9yRWFjaChmdW5jdGlvbihzaG9ydE5hbWVQYXRoKSB7XG4gICAgICBtYXAuc2V0KHNob3J0TmFtZVBhdGgsIFtdKTtcbiAgICB9KTtcbiAgICBmaWVsZEVudGl0aWVzLmZvckVhY2goZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgIHZhciBmaWVsZE5hbWVQYXRoID0gZmllbGQuZ2V0TmFtZVBhdGgoKTtcbiAgICAgIG5hbWVQYXRoTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKHNob3J0TmFtZVBhdGgpIHtcbiAgICAgICAgaWYgKHNob3J0TmFtZVBhdGguZXZlcnkoZnVuY3Rpb24obmFtZVVuaXQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gZmllbGROYW1lUGF0aFtpXSA9PT0gbmFtZVVuaXQ7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgbWFwLnVwZGF0ZShzaG9ydE5hbWVQYXRoLCBmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsaXN0KSwgW2ZpZWxkXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBpc05hbWVQYXRoTGlzdFRvdWNoZWQgPSBmdW5jdGlvbiBpc05hbWVQYXRoTGlzdFRvdWNoZWQyKGVudGl0aWVzKSB7XG4gICAgICByZXR1cm4gZW50aXRpZXMuc29tZShpc0ZpZWxkVG91Y2hlZCk7XG4gICAgfTtcbiAgICB2YXIgbmFtZVBhdGhMaXN0RW50aXRpZXMgPSBtYXAubWFwKGZ1bmN0aW9uKF9yZWYpIHtcbiAgICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQWxsRmllbGRzVG91Y2hlZCA/IG5hbWVQYXRoTGlzdEVudGl0aWVzLmV2ZXJ5KGlzTmFtZVBhdGhMaXN0VG91Y2hlZCkgOiBuYW1lUGF0aExpc3RFbnRpdGllcy5zb21lKGlzTmFtZVBhdGhMaXN0VG91Y2hlZCk7XG4gIH07XG4gIHRoaXMuaXNGaWVsZFRvdWNoZWQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgX3RoaXMud2FybmluZ1VuaG9va2VkKCk7XG4gICAgcmV0dXJuIF90aGlzLmlzRmllbGRzVG91Y2hlZChbbmFtZV0pO1xuICB9O1xuICB0aGlzLmlzRmllbGRzVmFsaWRhdGluZyA9IGZ1bmN0aW9uKG5hbWVMaXN0KSB7XG4gICAgX3RoaXMud2FybmluZ1VuaG9va2VkKCk7XG4gICAgdmFyIGZpZWxkRW50aXRpZXMgPSBfdGhpcy5nZXRGaWVsZEVudGl0aWVzKCk7XG4gICAgaWYgKCFuYW1lTGlzdCkge1xuICAgICAgcmV0dXJuIGZpZWxkRW50aXRpZXMuc29tZShmdW5jdGlvbih0ZXN0RmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRlc3RGaWVsZC5pc0ZpZWxkVmFsaWRhdGluZygpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBuYW1lUGF0aExpc3QgPSBuYW1lTGlzdC5tYXAoZ2V0TmFtZVBhdGgpO1xuICAgIHJldHVybiBmaWVsZEVudGl0aWVzLnNvbWUoZnVuY3Rpb24odGVzdEZpZWxkKSB7XG4gICAgICB2YXIgZmllbGROYW1lUGF0aCA9IHRlc3RGaWVsZC5nZXROYW1lUGF0aCgpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5zTmFtZVBhdGgobmFtZVBhdGhMaXN0LCBmaWVsZE5hbWVQYXRoKSAmJiB0ZXN0RmllbGQuaXNGaWVsZFZhbGlkYXRpbmcoKTtcbiAgICB9KTtcbiAgfTtcbiAgdGhpcy5pc0ZpZWxkVmFsaWRhdGluZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfdGhpcy53YXJuaW5nVW5ob29rZWQoKTtcbiAgICByZXR1cm4gX3RoaXMuaXNGaWVsZHNWYWxpZGF0aW5nKFtuYW1lXSk7XG4gIH07XG4gIHRoaXMucmVzZXRXaXRoRmllbGRJbml0aWFsVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5mbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGNhY2hlID0gbmV3IE5hbWVNYXAoKTtcbiAgICB2YXIgZmllbGRFbnRpdGllcyA9IF90aGlzLmdldEZpZWxkRW50aXRpZXModHJ1ZSk7XG4gICAgZmllbGRFbnRpdGllcy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICB2YXIgaW5pdGlhbFZhbHVlID0gZmllbGQucHJvcHMuaW5pdGlhbFZhbHVlO1xuICAgICAgdmFyIG5hbWVQYXRoID0gZmllbGQuZ2V0TmFtZVBhdGgoKTtcbiAgICAgIGlmIChpbml0aWFsVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICB2YXIgcmVjb3JkcyA9IGNhY2hlLmdldChuYW1lUGF0aCkgfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgcmVjb3Jkcy5hZGQoe1xuICAgICAgICAgIGVudGl0eTogZmllbGQsXG4gICAgICAgICAgdmFsdWU6IGluaXRpYWxWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY2FjaGUuc2V0KG5hbWVQYXRoLCByZWNvcmRzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgcmVzZXRXaXRoRmllbGRzID0gZnVuY3Rpb24gcmVzZXRXaXRoRmllbGRzMihlbnRpdGllcykge1xuICAgICAgZW50aXRpZXMuZm9yRWFjaChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICB2YXIgaW5pdGlhbFZhbHVlID0gZmllbGQucHJvcHMuaW5pdGlhbFZhbHVlO1xuICAgICAgICBpZiAoaW5pdGlhbFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2YXIgbmFtZVBhdGggPSBmaWVsZC5nZXROYW1lUGF0aCgpO1xuICAgICAgICAgIHZhciBmb3JtSW5pdGlhbFZhbHVlID0gX3RoaXMuZ2V0SW5pdGlhbFZhbHVlKG5hbWVQYXRoKTtcbiAgICAgICAgICBpZiAoZm9ybUluaXRpYWxWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB3YXJuaW5nT25jZShmYWxzZSwgXCJGb3JtIGFscmVhZHkgc2V0ICdpbml0aWFsVmFsdWVzJyB3aXRoIHBhdGggJ1wiLmNvbmNhdChuYW1lUGF0aC5qb2luKFwiLlwiKSwgXCInLiBGaWVsZCBjYW4gbm90IG92ZXJ3cml0ZSBpdC5cIikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkcyA9IGNhY2hlLmdldChuYW1lUGF0aCk7XG4gICAgICAgICAgICBpZiAocmVjb3JkcyAmJiByZWNvcmRzLnNpemUgPiAxKSB7XG4gICAgICAgICAgICAgIHdhcm5pbmdPbmNlKGZhbHNlLCBcIk11bHRpcGxlIEZpZWxkIHdpdGggcGF0aCAnXCIuY29uY2F0KG5hbWVQYXRoLmpvaW4oXCIuXCIpLCBcIicgc2V0ICdpbml0aWFsVmFsdWUnLiBDYW4gbm90IGRlY2lkZSB3aGljaCBvbmUgdG8gcGljay5cIikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmRzKSB7XG4gICAgICAgICAgICAgIHZhciBvcmlnaW5WYWx1ZSA9IF90aGlzLmdldEZpZWxkVmFsdWUobmFtZVBhdGgpO1xuICAgICAgICAgICAgICBpZiAoIWluZm8uc2tpcEV4aXN0IHx8IG9yaWdpblZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdG9yZSA9IHNldFZhbHVlKF90aGlzLnN0b3JlLCBuYW1lUGF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHJlY29yZHMpWzBdLnZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgcmVxdWlyZWRGaWVsZEVudGl0aWVzO1xuICAgIGlmIChpbmZvLmVudGl0aWVzKSB7XG4gICAgICByZXF1aXJlZEZpZWxkRW50aXRpZXMgPSBpbmZvLmVudGl0aWVzO1xuICAgIH0gZWxzZSBpZiAoaW5mby5uYW1lUGF0aExpc3QpIHtcbiAgICAgIHJlcXVpcmVkRmllbGRFbnRpdGllcyA9IFtdO1xuICAgICAgaW5mby5uYW1lUGF0aExpc3QuZm9yRWFjaChmdW5jdGlvbihuYW1lUGF0aCkge1xuICAgICAgICB2YXIgcmVjb3JkcyA9IGNhY2hlLmdldChuYW1lUGF0aCk7XG4gICAgICAgIGlmIChyZWNvcmRzKSB7XG4gICAgICAgICAgdmFyIF9yZXF1aXJlZEZpZWxkRW50aXRpZTtcbiAgICAgICAgICAoX3JlcXVpcmVkRmllbGRFbnRpdGllID0gcmVxdWlyZWRGaWVsZEVudGl0aWVzKS5wdXNoLmFwcGx5KF9yZXF1aXJlZEZpZWxkRW50aXRpZSwgX3RvQ29uc3VtYWJsZUFycmF5KF90b0NvbnN1bWFibGVBcnJheShyZWNvcmRzKS5tYXAoZnVuY3Rpb24ocjIpIHtcbiAgICAgICAgICAgIHJldHVybiByMi5lbnRpdHk7XG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVpcmVkRmllbGRFbnRpdGllcyA9IGZpZWxkRW50aXRpZXM7XG4gICAgfVxuICAgIHJlc2V0V2l0aEZpZWxkcyhyZXF1aXJlZEZpZWxkRW50aXRpZXMpO1xuICB9O1xuICB0aGlzLnJlc2V0RmllbGRzID0gZnVuY3Rpb24obmFtZUxpc3QpIHtcbiAgICBfdGhpcy53YXJuaW5nVW5ob29rZWQoKTtcbiAgICB2YXIgcHJldlN0b3JlID0gX3RoaXMuc3RvcmU7XG4gICAgaWYgKCFuYW1lTGlzdCkge1xuICAgICAgX3RoaXMuc3RvcmUgPSBzZXRWYWx1ZXMoe30sIF90aGlzLmluaXRpYWxWYWx1ZXMpO1xuICAgICAgX3RoaXMucmVzZXRXaXRoRmllbGRJbml0aWFsVmFsdWUoKTtcbiAgICAgIF90aGlzLm5vdGlmeU9ic2VydmVycyhwcmV2U3RvcmUsIG51bGwsIHtcbiAgICAgICAgdHlwZTogXCJyZXNldFwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hbWVQYXRoTGlzdCA9IG5hbWVMaXN0Lm1hcChnZXROYW1lUGF0aCk7XG4gICAgbmFtZVBhdGhMaXN0LmZvckVhY2goZnVuY3Rpb24obmFtZVBhdGgpIHtcbiAgICAgIHZhciBpbml0aWFsVmFsdWUgPSBfdGhpcy5nZXRJbml0aWFsVmFsdWUobmFtZVBhdGgpO1xuICAgICAgX3RoaXMuc3RvcmUgPSBzZXRWYWx1ZShfdGhpcy5zdG9yZSwgbmFtZVBhdGgsIGluaXRpYWxWYWx1ZSk7XG4gICAgfSk7XG4gICAgX3RoaXMucmVzZXRXaXRoRmllbGRJbml0aWFsVmFsdWUoe1xuICAgICAgbmFtZVBhdGhMaXN0XG4gICAgfSk7XG4gICAgX3RoaXMubm90aWZ5T2JzZXJ2ZXJzKHByZXZTdG9yZSwgbmFtZVBhdGhMaXN0LCB7XG4gICAgICB0eXBlOiBcInJlc2V0XCJcbiAgICB9KTtcbiAgfTtcbiAgdGhpcy5zZXRGaWVsZHMgPSBmdW5jdGlvbihmaWVsZHMpIHtcbiAgICBfdGhpcy53YXJuaW5nVW5ob29rZWQoKTtcbiAgICB2YXIgcHJldlN0b3JlID0gX3RoaXMuc3RvcmU7XG4gICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24oZmllbGREYXRhKSB7XG4gICAgICB2YXIgbmFtZSA9IGZpZWxkRGF0YS5uYW1lO1xuICAgICAgZmllbGREYXRhLmVycm9ycztcbiAgICAgIHZhciBkYXRhID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGZpZWxkRGF0YSwgX2V4Y2x1ZGVkJDIpO1xuICAgICAgdmFyIG5hbWVQYXRoID0gZ2V0TmFtZVBhdGgobmFtZSk7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRhdGEpIHtcbiAgICAgICAgX3RoaXMuc3RvcmUgPSBzZXRWYWx1ZShfdGhpcy5zdG9yZSwgbmFtZVBhdGgsIGRhdGEudmFsdWUpO1xuICAgICAgfVxuICAgICAgX3RoaXMubm90aWZ5T2JzZXJ2ZXJzKHByZXZTdG9yZSwgW25hbWVQYXRoXSwge1xuICAgICAgICB0eXBlOiBcInNldEZpZWxkXCIsXG4gICAgICAgIGRhdGE6IGZpZWxkRGF0YVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIHRoaXMuZ2V0RmllbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVudGl0aWVzID0gX3RoaXMuZ2V0RmllbGRFbnRpdGllcyh0cnVlKTtcbiAgICB2YXIgZmllbGRzID0gZW50aXRpZXMubWFwKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICB2YXIgbmFtZVBhdGggPSBmaWVsZC5nZXROYW1lUGF0aCgpO1xuICAgICAgdmFyIG1ldGEgPSBmaWVsZC5nZXRNZXRhKCk7XG4gICAgICB2YXIgZmllbGREYXRhID0gX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBtZXRhKSwge30sIHtcbiAgICAgICAgbmFtZTogbmFtZVBhdGgsXG4gICAgICAgIHZhbHVlOiBfdGhpcy5nZXRGaWVsZFZhbHVlKG5hbWVQYXRoKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmllbGREYXRhLCBcIm9yaWdpblJDRmllbGRcIiwge1xuICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmllbGREYXRhO1xuICAgIH0pO1xuICAgIHJldHVybiBmaWVsZHM7XG4gIH07XG4gIHRoaXMuaW5pdEVudGl0eVZhbHVlID0gZnVuY3Rpb24oZW50aXR5KSB7XG4gICAgdmFyIGluaXRpYWxWYWx1ZSA9IGVudGl0eS5wcm9wcy5pbml0aWFsVmFsdWU7XG4gICAgaWYgKGluaXRpYWxWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB2YXIgbmFtZVBhdGggPSBlbnRpdHkuZ2V0TmFtZVBhdGgoKTtcbiAgICAgIHZhciBwcmV2VmFsdWUgPSBnZXRWYWx1ZSQyKF90aGlzLnN0b3JlLCBuYW1lUGF0aCk7XG4gICAgICBpZiAocHJldlZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgX3RoaXMuc3RvcmUgPSBzZXRWYWx1ZShfdGhpcy5zdG9yZSwgbmFtZVBhdGgsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB0aGlzLnJlZ2lzdGVyRmllbGQgPSBmdW5jdGlvbihlbnRpdHkpIHtcbiAgICBfdGhpcy5maWVsZEVudGl0aWVzLnB1c2goZW50aXR5KTtcbiAgICBpZiAoZW50aXR5LnByb3BzLmluaXRpYWxWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB2YXIgcHJldlN0b3JlID0gX3RoaXMuc3RvcmU7XG4gICAgICBfdGhpcy5yZXNldFdpdGhGaWVsZEluaXRpYWxWYWx1ZSh7XG4gICAgICAgIGVudGl0aWVzOiBbZW50aXR5XSxcbiAgICAgICAgc2tpcEV4aXN0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIF90aGlzLm5vdGlmeU9ic2VydmVycyhwcmV2U3RvcmUsIFtlbnRpdHkuZ2V0TmFtZVBhdGgoKV0sIHtcbiAgICAgICAgdHlwZTogXCJ2YWx1ZVVwZGF0ZVwiLFxuICAgICAgICBzb3VyY2U6IFwiaW50ZXJuYWxcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihpc0xpc3RGaWVsZCwgcHJlc2VydmUpIHtcbiAgICAgIHZhciBzdWJOYW1lUGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogW107XG4gICAgICBfdGhpcy5maWVsZEVudGl0aWVzID0gX3RoaXMuZmllbGRFbnRpdGllcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gZW50aXR5O1xuICAgICAgfSk7XG4gICAgICB2YXIgbWVyZ2VkUHJlc2VydmUgPSBwcmVzZXJ2ZSAhPT0gdm9pZCAwID8gcHJlc2VydmUgOiBfdGhpcy5wcmVzZXJ2ZTtcbiAgICAgIGlmIChtZXJnZWRQcmVzZXJ2ZSA9PT0gZmFsc2UgJiYgKCFpc0xpc3RGaWVsZCB8fCBzdWJOYW1lUGF0aC5sZW5ndGggPiAxKSkge1xuICAgICAgICB2YXIgbmFtZVBhdGggPSBlbnRpdHkuZ2V0TmFtZVBhdGgoKTtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGlzTGlzdEZpZWxkID8gdm9pZCAwIDogZ2V0VmFsdWUkMihfdGhpcy5pbml0aWFsVmFsdWVzLCBuYW1lUGF0aCk7XG4gICAgICAgIGlmIChuYW1lUGF0aC5sZW5ndGggJiYgX3RoaXMuZ2V0RmllbGRWYWx1ZShuYW1lUGF0aCkgIT09IGRlZmF1bHRWYWx1ZSAmJiBfdGhpcy5maWVsZEVudGl0aWVzLmV2ZXJ5KGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuICFtYXRjaE5hbWVQYXRoKGZpZWxkLmdldE5hbWVQYXRoKCksIG5hbWVQYXRoKTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB2YXIgX3ByZXZTdG9yZSA9IF90aGlzLnN0b3JlO1xuICAgICAgICAgIF90aGlzLnN0b3JlID0gc2V0VmFsdWUoX3ByZXZTdG9yZSwgbmFtZVBhdGgsIGRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgX3RoaXMubm90aWZ5T2JzZXJ2ZXJzKF9wcmV2U3RvcmUsIFtuYW1lUGF0aF0sIHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVtb3ZlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfdGhpcy50cmlnZ2VyRGVwZW5kZW5jaWVzVXBkYXRlKF9wcmV2U3RvcmUsIG5hbWVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbihhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICBjYXNlIFwidXBkYXRlVmFsdWVcIjoge1xuICAgICAgICB2YXIgbmFtZVBhdGggPSBhY3Rpb24ubmFtZVBhdGgsIHZhbHVlID0gYWN0aW9uLnZhbHVlO1xuICAgICAgICBfdGhpcy51cGRhdGVWYWx1ZShuYW1lUGF0aCwgdmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ2YWxpZGF0ZUZpZWxkXCI6IHtcbiAgICAgICAgdmFyIF9uYW1lUGF0aCA9IGFjdGlvbi5uYW1lUGF0aCwgdHJpZ2dlck5hbWUgPSBhY3Rpb24udHJpZ2dlck5hbWU7XG4gICAgICAgIF90aGlzLnZhbGlkYXRlRmllbGRzKFtfbmFtZVBhdGhdLCB7XG4gICAgICAgICAgdHJpZ2dlck5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdGhpcy5ub3RpZnlPYnNlcnZlcnMgPSBmdW5jdGlvbihwcmV2U3RvcmUsIG5hbWVQYXRoTGlzdCwgaW5mbykge1xuICAgIGlmIChfdGhpcy5zdWJzY3JpYmFibGUpIHtcbiAgICAgIHZhciBtZXJnZWRJbmZvID0gX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBpbmZvKSwge30sIHtcbiAgICAgICAgc3RvcmU6IF90aGlzLmdldEZpZWxkc1ZhbHVlKHRydWUpXG4gICAgICB9KTtcbiAgICAgIF90aGlzLmdldEZpZWxkRW50aXRpZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKF9yZWYyKSB7XG4gICAgICAgIHZhciBvblN0b3JlQ2hhbmdlID0gX3JlZjIub25TdG9yZUNoYW5nZTtcbiAgICAgICAgb25TdG9yZUNoYW5nZShwcmV2U3RvcmUsIG5hbWVQYXRoTGlzdCwgbWVyZ2VkSW5mbyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuZm9yY2VSb290VXBkYXRlKCk7XG4gICAgfVxuICB9O1xuICB0aGlzLnRyaWdnZXJEZXBlbmRlbmNpZXNVcGRhdGUgPSBmdW5jdGlvbihwcmV2U3RvcmUsIG5hbWVQYXRoKSB7XG4gICAgdmFyIGNoaWxkcmVuRmllbGRzID0gX3RoaXMuZ2V0RGVwZW5kZW5jeUNoaWxkcmVuRmllbGRzKG5hbWVQYXRoKTtcbiAgICBpZiAoY2hpbGRyZW5GaWVsZHMubGVuZ3RoKSB7XG4gICAgICBfdGhpcy52YWxpZGF0ZUZpZWxkcyhjaGlsZHJlbkZpZWxkcyk7XG4gICAgfVxuICAgIF90aGlzLm5vdGlmeU9ic2VydmVycyhwcmV2U3RvcmUsIGNoaWxkcmVuRmllbGRzLCB7XG4gICAgICB0eXBlOiBcImRlcGVuZGVuY2llc1VwZGF0ZVwiLFxuICAgICAgcmVsYXRlZEZpZWxkczogW25hbWVQYXRoXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGNoaWxkcmVuRmllbGRzKSlcbiAgICB9KTtcbiAgICByZXR1cm4gY2hpbGRyZW5GaWVsZHM7XG4gIH07XG4gIHRoaXMudXBkYXRlVmFsdWUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBuYW1lUGF0aCA9IGdldE5hbWVQYXRoKG5hbWUpO1xuICAgIHZhciBwcmV2U3RvcmUgPSBfdGhpcy5zdG9yZTtcbiAgICBfdGhpcy5zdG9yZSA9IHNldFZhbHVlKF90aGlzLnN0b3JlLCBuYW1lUGF0aCwgdmFsdWUpO1xuICAgIF90aGlzLm5vdGlmeU9ic2VydmVycyhwcmV2U3RvcmUsIFtuYW1lUGF0aF0sIHtcbiAgICAgIHR5cGU6IFwidmFsdWVVcGRhdGVcIixcbiAgICAgIHNvdXJjZTogXCJpbnRlcm5hbFwiXG4gICAgfSk7XG4gICAgdmFyIGNoaWxkcmVuRmllbGRzID0gX3RoaXMudHJpZ2dlckRlcGVuZGVuY2llc1VwZGF0ZShwcmV2U3RvcmUsIG5hbWVQYXRoKTtcbiAgICB2YXIgb25WYWx1ZXNDaGFuZ2UgPSBfdGhpcy5jYWxsYmFja3Mub25WYWx1ZXNDaGFuZ2U7XG4gICAgaWYgKG9uVmFsdWVzQ2hhbmdlKSB7XG4gICAgICB2YXIgY2hhbmdlZFZhbHVlcyA9IGNsb25lQnlOYW1lUGF0aExpc3QoX3RoaXMuc3RvcmUsIFtuYW1lUGF0aF0pO1xuICAgICAgb25WYWx1ZXNDaGFuZ2UoY2hhbmdlZFZhbHVlcywgX3RoaXMuZ2V0RmllbGRzVmFsdWUoKSk7XG4gICAgfVxuICAgIF90aGlzLnRyaWdnZXJPbkZpZWxkc0NoYW5nZShbbmFtZVBhdGhdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY2hpbGRyZW5GaWVsZHMpKSk7XG4gIH07XG4gIHRoaXMuc2V0RmllbGRzVmFsdWUgPSBmdW5jdGlvbihzdG9yZSkge1xuICAgIF90aGlzLndhcm5pbmdVbmhvb2tlZCgpO1xuICAgIHZhciBwcmV2U3RvcmUgPSBfdGhpcy5zdG9yZTtcbiAgICBpZiAoc3RvcmUpIHtcbiAgICAgIF90aGlzLnN0b3JlID0gc2V0VmFsdWVzKF90aGlzLnN0b3JlLCBzdG9yZSk7XG4gICAgfVxuICAgIF90aGlzLm5vdGlmeU9ic2VydmVycyhwcmV2U3RvcmUsIG51bGwsIHtcbiAgICAgIHR5cGU6IFwidmFsdWVVcGRhdGVcIixcbiAgICAgIHNvdXJjZTogXCJleHRlcm5hbFwiXG4gICAgfSk7XG4gIH07XG4gIHRoaXMuZ2V0RGVwZW5kZW5jeUNoaWxkcmVuRmllbGRzID0gZnVuY3Rpb24ocm9vdE5hbWVQYXRoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB2YXIgY2hpbGRyZW5GaWVsZHMgPSBbXTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzMmZpZWxkcyA9IG5ldyBOYW1lTWFwKCk7XG4gICAgX3RoaXMuZ2V0RmllbGRFbnRpdGllcygpLmZvckVhY2goZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSBmaWVsZC5wcm9wcy5kZXBlbmRlbmNpZXM7XG4gICAgICAoZGVwZW5kZW5jaWVzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgdmFyIGRlcGVuZGVuY3lOYW1lUGF0aCA9IGdldE5hbWVQYXRoKGRlcGVuZGVuY3kpO1xuICAgICAgICBkZXBlbmRlbmNpZXMyZmllbGRzLnVwZGF0ZShkZXBlbmRlbmN5TmFtZVBhdGgsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBmaWVsZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgZmllbGRzLmFkZChmaWVsZCk7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgZmlsbENoaWxkcmVuID0gZnVuY3Rpb24gZmlsbENoaWxkcmVuMihuYW1lUGF0aCkge1xuICAgICAgdmFyIGZpZWxkcyA9IGRlcGVuZGVuY2llczJmaWVsZHMuZ2V0KG5hbWVQYXRoKSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgaWYgKCFjaGlsZHJlbi5oYXMoZmllbGQpKSB7XG4gICAgICAgICAgY2hpbGRyZW4uYWRkKGZpZWxkKTtcbiAgICAgICAgICB2YXIgZmllbGROYW1lUGF0aCA9IGZpZWxkLmdldE5hbWVQYXRoKCk7XG4gICAgICAgICAgaWYgKGZpZWxkLmlzRmllbGREaXJ0eSgpICYmIGZpZWxkTmFtZVBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGlsZHJlbkZpZWxkcy5wdXNoKGZpZWxkTmFtZVBhdGgpO1xuICAgICAgICAgICAgZmlsbENoaWxkcmVuMihmaWVsZE5hbWVQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgZmlsbENoaWxkcmVuKHJvb3ROYW1lUGF0aCk7XG4gICAgcmV0dXJuIGNoaWxkcmVuRmllbGRzO1xuICB9O1xuICB0aGlzLnRyaWdnZXJPbkZpZWxkc0NoYW5nZSA9IGZ1bmN0aW9uKG5hbWVQYXRoTGlzdCwgZmlsZWRFcnJvcnMpIHtcbiAgICB2YXIgb25GaWVsZHNDaGFuZ2UgPSBfdGhpcy5jYWxsYmFja3Mub25GaWVsZHNDaGFuZ2U7XG4gICAgaWYgKG9uRmllbGRzQ2hhbmdlKSB7XG4gICAgICB2YXIgZmllbGRzID0gX3RoaXMuZ2V0RmllbGRzKCk7XG4gICAgICBpZiAoZmlsZWRFcnJvcnMpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gbmV3IE5hbWVNYXAoKTtcbiAgICAgICAgZmlsZWRFcnJvcnMuZm9yRWFjaChmdW5jdGlvbihfcmVmMykge1xuICAgICAgICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSwgZXJyb3JzID0gX3JlZjMuZXJyb3JzO1xuICAgICAgICAgIGNhY2hlLnNldChuYW1lLCBlcnJvcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgICBmaWVsZC5lcnJvcnMgPSBjYWNoZS5nZXQoZmllbGQubmFtZSkgfHwgZmllbGQuZXJyb3JzO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFuZ2VkRmllbGRzID0gZmllbGRzLmZpbHRlcihmdW5jdGlvbihfcmVmNCkge1xuICAgICAgICB2YXIgZmllbGROYW1lID0gX3JlZjQubmFtZTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zTmFtZVBhdGgobmFtZVBhdGhMaXN0LCBmaWVsZE5hbWUpO1xuICAgICAgfSk7XG4gICAgICBvbkZpZWxkc0NoYW5nZShjaGFuZ2VkRmllbGRzLCBmaWVsZHMpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy52YWxpZGF0ZUZpZWxkcyA9IGZ1bmN0aW9uKG5hbWVMaXN0LCBvcHRpb25zKSB7XG4gICAgX3RoaXMud2FybmluZ1VuaG9va2VkKCk7XG4gICAgdmFyIHByb3ZpZGVOYW1lTGlzdCA9ICEhbmFtZUxpc3Q7XG4gICAgdmFyIG5hbWVQYXRoTGlzdCA9IHByb3ZpZGVOYW1lTGlzdCA/IG5hbWVMaXN0Lm1hcChnZXROYW1lUGF0aCkgOiBbXTtcbiAgICB2YXIgcHJvbWlzZUxpc3QgPSBbXTtcbiAgICBfdGhpcy5nZXRGaWVsZEVudGl0aWVzKHRydWUpLmZvckVhY2goZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgIGlmICghcHJvdmlkZU5hbWVMaXN0KSB7XG4gICAgICAgIG5hbWVQYXRoTGlzdC5wdXNoKGZpZWxkLmdldE5hbWVQYXRoKCkpO1xuICAgICAgfVxuICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVjdXJzaXZlKSAmJiBwcm92aWRlTmFtZUxpc3QpIHtcbiAgICAgICAgdmFyIG5hbWVQYXRoID0gZmllbGQuZ2V0TmFtZVBhdGgoKTtcbiAgICAgICAgaWYgKG5hbWVQYXRoLmV2ZXJ5KGZ1bmN0aW9uKG5hbWVVbml0LCBpKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWVMaXN0W2ldID09PSBuYW1lVW5pdCB8fCBuYW1lTGlzdFtpXSA9PT0gdm9pZCAwO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIG5hbWVQYXRoTGlzdC5wdXNoKG5hbWVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFmaWVsZC5wcm9wcy5ydWxlcyB8fCAhZmllbGQucHJvcHMucnVsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBmaWVsZE5hbWVQYXRoID0gZmllbGQuZ2V0TmFtZVBhdGgoKTtcbiAgICAgIGlmICghcHJvdmlkZU5hbWVMaXN0IHx8IGNvbnRhaW5zTmFtZVBhdGgobmFtZVBhdGhMaXN0LCBmaWVsZE5hbWVQYXRoKSkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IGZpZWxkLnZhbGlkYXRlUnVsZXMoX29iamVjdFNwcmVhZDIkMSh7XG4gICAgICAgICAgdmFsaWRhdGVNZXNzYWdlczogX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBkZWZhdWx0VmFsaWRhdGVNZXNzYWdlcyksIF90aGlzLnZhbGlkYXRlTWVzc2FnZXMpXG4gICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgcHJvbWlzZUxpc3QucHVzaChwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGZpZWxkTmFtZVBhdGgsXG4gICAgICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICAgICAgd2FybmluZ3M6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24ocnVsZUVycm9ycykge1xuICAgICAgICAgIHZhciBtZXJnZWRFcnJvcnMgPSBbXTtcbiAgICAgICAgICB2YXIgbWVyZ2VkV2FybmluZ3MgPSBbXTtcbiAgICAgICAgICBydWxlRXJyb3JzLmZvckVhY2goZnVuY3Rpb24oX3JlZjUpIHtcbiAgICAgICAgICAgIHZhciB3YXJuaW5nT25seSA9IF9yZWY1LnJ1bGUud2FybmluZ09ubHksIGVycm9ycyA9IF9yZWY1LmVycm9ycztcbiAgICAgICAgICAgIGlmICh3YXJuaW5nT25seSkge1xuICAgICAgICAgICAgICBtZXJnZWRXYXJuaW5ncy5wdXNoLmFwcGx5KG1lcmdlZFdhcm5pbmdzLCBfdG9Db25zdW1hYmxlQXJyYXkoZXJyb3JzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtZXJnZWRFcnJvcnMucHVzaC5hcHBseShtZXJnZWRFcnJvcnMsIF90b0NvbnN1bWFibGVBcnJheShlcnJvcnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobWVyZ2VkRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHtcbiAgICAgICAgICAgICAgbmFtZTogZmllbGROYW1lUGF0aCxcbiAgICAgICAgICAgICAgZXJyb3JzOiBtZXJnZWRFcnJvcnMsXG4gICAgICAgICAgICAgIHdhcm5pbmdzOiBtZXJnZWRXYXJuaW5nc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBmaWVsZE5hbWVQYXRoLFxuICAgICAgICAgICAgZXJyb3JzOiBtZXJnZWRFcnJvcnMsXG4gICAgICAgICAgICB3YXJuaW5nczogbWVyZ2VkV2FybmluZ3NcbiAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHN1bW1hcnlQcm9taXNlID0gYWxsUHJvbWlzZUZpbmlzaChwcm9taXNlTGlzdCk7XG4gICAgX3RoaXMubGFzdFZhbGlkYXRlUHJvbWlzZSA9IHN1bW1hcnlQcm9taXNlO1xuICAgIHN1bW1hcnlQcm9taXNlLmNhdGNoKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgdmFyIHJlc3VsdE5hbWVQYXRoTGlzdCA9IHJlc3VsdHMubWFwKGZ1bmN0aW9uKF9yZWY2KSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZjYubmFtZTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9KTtcbiAgICAgIF90aGlzLm5vdGlmeU9ic2VydmVycyhfdGhpcy5zdG9yZSwgcmVzdWx0TmFtZVBhdGhMaXN0LCB7XG4gICAgICAgIHR5cGU6IFwidmFsaWRhdGVGaW5pc2hcIlxuICAgICAgfSk7XG4gICAgICBfdGhpcy50cmlnZ2VyT25GaWVsZHNDaGFuZ2UocmVzdWx0TmFtZVBhdGhMaXN0LCByZXN1bHRzKTtcbiAgICB9KTtcbiAgICB2YXIgcmV0dXJuUHJvbWlzZSA9IHN1bW1hcnlQcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoX3RoaXMubGFzdFZhbGlkYXRlUHJvbWlzZSA9PT0gc3VtbWFyeVByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGhpcy5nZXRGaWVsZHNWYWx1ZShuYW1lUGF0aExpc3QpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChbXSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgdmFyIGVycm9yTGlzdCA9IHJlc3VsdHMuZmlsdGVyKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdC5lcnJvcnMubGVuZ3RoO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xuICAgICAgICB2YWx1ZXM6IF90aGlzLmdldEZpZWxkc1ZhbHVlKG5hbWVQYXRoTGlzdCksXG4gICAgICAgIGVycm9yRmllbGRzOiBlcnJvckxpc3QsXG4gICAgICAgIG91dE9mRGF0ZTogX3RoaXMubGFzdFZhbGlkYXRlUHJvbWlzZSAhPT0gc3VtbWFyeVByb21pc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVyblByb21pc2UuY2F0Y2goZnVuY3Rpb24oZTIpIHtcbiAgICAgIHJldHVybiBlMjtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0dXJuUHJvbWlzZTtcbiAgfTtcbiAgdGhpcy5zdWJtaXQgPSBmdW5jdGlvbigpIHtcbiAgICBfdGhpcy53YXJuaW5nVW5ob29rZWQoKTtcbiAgICBfdGhpcy52YWxpZGF0ZUZpZWxkcygpLnRoZW4oZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICB2YXIgb25GaW5pc2ggPSBfdGhpcy5jYWxsYmFja3Mub25GaW5pc2g7XG4gICAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvbkZpbmlzaCh2YWx1ZXMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KS5jYXRjaChmdW5jdGlvbihlMikge1xuICAgICAgdmFyIG9uRmluaXNoRmFpbGVkID0gX3RoaXMuY2FsbGJhY2tzLm9uRmluaXNoRmFpbGVkO1xuICAgICAgaWYgKG9uRmluaXNoRmFpbGVkKSB7XG4gICAgICAgIG9uRmluaXNoRmFpbGVkKGUyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgdGhpcy5mb3JjZVJvb3RVcGRhdGUgPSBmb3JjZVJvb3RVcGRhdGU7XG59KTtcbmZ1bmN0aW9uIHVzZUZvcm0oZm9ybSkge1xuICB2YXIgZm9ybVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoe30pLCBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSwgZm9yY2VVcGRhdGUgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuICBpZiAoIWZvcm1SZWYuY3VycmVudCkge1xuICAgIGlmIChmb3JtKSB7XG4gICAgICBmb3JtUmVmLmN1cnJlbnQgPSBmb3JtO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZm9yY2VSZVJlbmRlciA9IGZ1bmN0aW9uIGZvcmNlUmVSZW5kZXIyKCkge1xuICAgICAgICBmb3JjZVVwZGF0ZSh7fSk7XG4gICAgICB9O1xuICAgICAgdmFyIGZvcm1TdG9yZSA9IG5ldyBGb3JtU3RvcmUoZm9yY2VSZVJlbmRlcik7XG4gICAgICBmb3JtUmVmLmN1cnJlbnQgPSBmb3JtU3RvcmUuZ2V0Rm9ybSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2Zvcm1SZWYuY3VycmVudF07XG59XG52YXIgRm9ybUNvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIHRyaWdnZXJGb3JtQ2hhbmdlOiBmdW5jdGlvbiB0cmlnZ2VyRm9ybUNoYW5nZSgpIHtcbiAgfSxcbiAgdHJpZ2dlckZvcm1GaW5pc2g6IGZ1bmN0aW9uIHRyaWdnZXJGb3JtRmluaXNoKCkge1xuICB9LFxuICByZWdpc3RlckZvcm06IGZ1bmN0aW9uIHJlZ2lzdGVyRm9ybSgpIHtcbiAgfSxcbiAgdW5yZWdpc3RlckZvcm06IGZ1bmN0aW9uIHVucmVnaXN0ZXJGb3JtKCkge1xuICB9XG59KTtcbnZhciBGb3JtUHJvdmlkZXIgPSBmdW5jdGlvbiBGb3JtUHJvdmlkZXIyKF9yZWYpIHtcbiAgdmFyIHZhbGlkYXRlTWVzc2FnZXMgPSBfcmVmLnZhbGlkYXRlTWVzc2FnZXMsIG9uRm9ybUNoYW5nZSA9IF9yZWYub25Gb3JtQ2hhbmdlLCBvbkZvcm1GaW5pc2ggPSBfcmVmLm9uRm9ybUZpbmlzaCwgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICB2YXIgZm9ybUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KEZvcm1Db250ZXh0KTtcbiAgdmFyIGZvcm1zUmVmID0gUmVhY3QudXNlUmVmKHt9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwgZm9ybUNvbnRleHQpLCB7fSwge1xuICAgICAgdmFsaWRhdGVNZXNzYWdlczogX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBmb3JtQ29udGV4dC52YWxpZGF0ZU1lc3NhZ2VzKSwgdmFsaWRhdGVNZXNzYWdlcyksXG4gICAgICB0cmlnZ2VyRm9ybUNoYW5nZTogZnVuY3Rpb24gdHJpZ2dlckZvcm1DaGFuZ2UyKG5hbWUsIGNoYW5nZWRGaWVsZHMpIHtcbiAgICAgICAgaWYgKG9uRm9ybUNoYW5nZSkge1xuICAgICAgICAgIG9uRm9ybUNoYW5nZShuYW1lLCB7XG4gICAgICAgICAgICBjaGFuZ2VkRmllbGRzLFxuICAgICAgICAgICAgZm9ybXM6IGZvcm1zUmVmLmN1cnJlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtQ29udGV4dC50cmlnZ2VyRm9ybUNoYW5nZShuYW1lLCBjaGFuZ2VkRmllbGRzKTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyRm9ybUZpbmlzaDogZnVuY3Rpb24gdHJpZ2dlckZvcm1GaW5pc2gyKG5hbWUsIHZhbHVlcykge1xuICAgICAgICBpZiAob25Gb3JtRmluaXNoKSB7XG4gICAgICAgICAgb25Gb3JtRmluaXNoKG5hbWUsIHtcbiAgICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICAgIGZvcm1zOiBmb3Jtc1JlZi5jdXJyZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybUNvbnRleHQudHJpZ2dlckZvcm1GaW5pc2gobmFtZSwgdmFsdWVzKTtcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckZvcm06IGZ1bmN0aW9uIHJlZ2lzdGVyRm9ybTIobmFtZSwgZm9ybSkge1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgIGZvcm1zUmVmLmN1cnJlbnQgPSBfb2JqZWN0U3ByZWFkMiQxKF9vYmplY3RTcHJlYWQyJDEoe30sIGZvcm1zUmVmLmN1cnJlbnQpLCB7fSwgX2RlZmluZVByb3BlcnR5JDEoe30sIG5hbWUsIGZvcm0pKTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtQ29udGV4dC5yZWdpc3RlckZvcm0obmFtZSwgZm9ybSk7XG4gICAgICB9LFxuICAgICAgdW5yZWdpc3RlckZvcm06IGZ1bmN0aW9uIHVucmVnaXN0ZXJGb3JtMihuYW1lKSB7XG4gICAgICAgIHZhciBuZXdGb3JtcyA9IF9vYmplY3RTcHJlYWQyJDEoe30sIGZvcm1zUmVmLmN1cnJlbnQpO1xuICAgICAgICBkZWxldGUgbmV3Rm9ybXNbbmFtZV07XG4gICAgICAgIGZvcm1zUmVmLmN1cnJlbnQgPSBuZXdGb3JtcztcbiAgICAgICAgZm9ybUNvbnRleHQudW5yZWdpc3RlckZvcm0obmFtZSk7XG4gICAgICB9XG4gICAgfSlcbiAgfSwgY2hpbGRyZW4pO1xufTtcbnZhciBfZXhjbHVkZWQkMSA9IFtcIm5hbWVcIiwgXCJpbml0aWFsVmFsdWVzXCIsIFwiZmllbGRzXCIsIFwiZm9ybVwiLCBcInByZXNlcnZlXCIsIFwiY2hpbGRyZW5cIiwgXCJjb21wb25lbnRcIiwgXCJ2YWxpZGF0ZU1lc3NhZ2VzXCIsIFwidmFsaWRhdGVUcmlnZ2VyXCIsIFwib25WYWx1ZXNDaGFuZ2VcIiwgXCJvbkZpZWxkc0NoYW5nZVwiLCBcIm9uRmluaXNoXCIsIFwib25GaW5pc2hGYWlsZWRcIl07XG52YXIgRm9ybSA9IGZ1bmN0aW9uIEZvcm0yKF9yZWYsIHJlZikge1xuICB2YXIgbmFtZSA9IF9yZWYubmFtZSwgaW5pdGlhbFZhbHVlcyA9IF9yZWYuaW5pdGlhbFZhbHVlcywgZmllbGRzID0gX3JlZi5maWVsZHMsIGZvcm0gPSBfcmVmLmZvcm0sIHByZXNlcnZlID0gX3JlZi5wcmVzZXJ2ZSwgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLCBfcmVmJGNvbXBvbmVudCA9IF9yZWYuY29tcG9uZW50LCBDb21wb25lbnQyID0gX3JlZiRjb21wb25lbnQgPT09IHZvaWQgMCA/IFwiZm9ybVwiIDogX3JlZiRjb21wb25lbnQsIHZhbGlkYXRlTWVzc2FnZXMgPSBfcmVmLnZhbGlkYXRlTWVzc2FnZXMsIF9yZWYkdmFsaWRhdGVUcmlnZ2VyID0gX3JlZi52YWxpZGF0ZVRyaWdnZXIsIHZhbGlkYXRlVHJpZ2dlciA9IF9yZWYkdmFsaWRhdGVUcmlnZ2VyID09PSB2b2lkIDAgPyBcIm9uQ2hhbmdlXCIgOiBfcmVmJHZhbGlkYXRlVHJpZ2dlciwgb25WYWx1ZXNDaGFuZ2UgPSBfcmVmLm9uVmFsdWVzQ2hhbmdlLCBfb25GaWVsZHNDaGFuZ2UgPSBfcmVmLm9uRmllbGRzQ2hhbmdlLCBfb25GaW5pc2ggPSBfcmVmLm9uRmluaXNoLCBvbkZpbmlzaEZhaWxlZCA9IF9yZWYub25GaW5pc2hGYWlsZWQsIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQkMSk7XG4gIHZhciBmb3JtQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRm9ybUNvbnRleHQpO1xuICB2YXIgX3VzZUZvcm0gPSB1c2VGb3JtKGZvcm0pLCBfdXNlRm9ybTIgPSBfc2xpY2VkVG9BcnJheShfdXNlRm9ybSwgMSksIGZvcm1JbnN0YW5jZSA9IF91c2VGb3JtMlswXTtcbiAgdmFyIF9mb3JtSW5zdGFuY2UkZ2V0SW50ZSA9IGZvcm1JbnN0YW5jZS5nZXRJbnRlcm5hbEhvb2tzKEhPT0tfTUFSSyksIHVzZVN1YnNjcmliZSA9IF9mb3JtSW5zdGFuY2UkZ2V0SW50ZS51c2VTdWJzY3JpYmUsIHNldEluaXRpYWxWYWx1ZXMgPSBfZm9ybUluc3RhbmNlJGdldEludGUuc2V0SW5pdGlhbFZhbHVlcywgc2V0Q2FsbGJhY2tzID0gX2Zvcm1JbnN0YW5jZSRnZXRJbnRlLnNldENhbGxiYWNrcywgc2V0VmFsaWRhdGVNZXNzYWdlcyA9IF9mb3JtSW5zdGFuY2UkZ2V0SW50ZS5zZXRWYWxpZGF0ZU1lc3NhZ2VzLCBzZXRQcmVzZXJ2ZSA9IF9mb3JtSW5zdGFuY2UkZ2V0SW50ZS5zZXRQcmVzZXJ2ZTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmb3JtSW5zdGFuY2U7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24oKSB7XG4gICAgZm9ybUNvbnRleHQucmVnaXN0ZXJGb3JtKG5hbWUsIGZvcm1JbnN0YW5jZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgZm9ybUNvbnRleHQudW5yZWdpc3RlckZvcm0obmFtZSk7XG4gICAgfTtcbiAgfSwgW2Zvcm1Db250ZXh0LCBmb3JtSW5zdGFuY2UsIG5hbWVdKTtcbiAgc2V0VmFsaWRhdGVNZXNzYWdlcyhfb2JqZWN0U3ByZWFkMiQxKF9vYmplY3RTcHJlYWQyJDEoe30sIGZvcm1Db250ZXh0LnZhbGlkYXRlTWVzc2FnZXMpLCB2YWxpZGF0ZU1lc3NhZ2VzKSk7XG4gIHNldENhbGxiYWNrcyh7XG4gICAgb25WYWx1ZXNDaGFuZ2UsXG4gICAgb25GaWVsZHNDaGFuZ2U6IGZ1bmN0aW9uIG9uRmllbGRzQ2hhbmdlKGNoYW5nZWRGaWVsZHMpIHtcbiAgICAgIGZvcm1Db250ZXh0LnRyaWdnZXJGb3JtQ2hhbmdlKG5hbWUsIGNoYW5nZWRGaWVsZHMpO1xuICAgICAgaWYgKF9vbkZpZWxkc0NoYW5nZSkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgX29uRmllbGRzQ2hhbmdlLmFwcGx5KHZvaWQgMCwgW2NoYW5nZWRGaWVsZHNdLmNvbmNhdChyZXN0KSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkZpbmlzaDogZnVuY3Rpb24gb25GaW5pc2godmFsdWVzMikge1xuICAgICAgZm9ybUNvbnRleHQudHJpZ2dlckZvcm1GaW5pc2gobmFtZSwgdmFsdWVzMik7XG4gICAgICBpZiAoX29uRmluaXNoKSB7XG4gICAgICAgIF9vbkZpbmlzaCh2YWx1ZXMyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uRmluaXNoRmFpbGVkXG4gIH0pO1xuICBzZXRQcmVzZXJ2ZShwcmVzZXJ2ZSk7XG4gIHZhciBtb3VudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgc2V0SW5pdGlhbFZhbHVlcyhpbml0aWFsVmFsdWVzLCAhbW91bnRSZWYuY3VycmVudCk7XG4gIGlmICghbW91bnRSZWYuY3VycmVudCkge1xuICAgIG1vdW50UmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9XG4gIHZhciBjaGlsZHJlbk5vZGUgPSBjaGlsZHJlbjtcbiAgdmFyIGNoaWxkcmVuUmVuZGVyUHJvcHMgPSB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIjtcbiAgaWYgKGNoaWxkcmVuUmVuZGVyUHJvcHMpIHtcbiAgICB2YXIgdmFsdWVzID0gZm9ybUluc3RhbmNlLmdldEZpZWxkc1ZhbHVlKHRydWUpO1xuICAgIGNoaWxkcmVuTm9kZSA9IGNoaWxkcmVuKHZhbHVlcywgZm9ybUluc3RhbmNlKTtcbiAgfVxuICB1c2VTdWJzY3JpYmUoIWNoaWxkcmVuUmVuZGVyUHJvcHMpO1xuICB2YXIgcHJldkZpZWxkc1JlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFpc1NpbWlsYXIocHJldkZpZWxkc1JlZi5jdXJyZW50IHx8IFtdLCBmaWVsZHMgfHwgW10pKSB7XG4gICAgICBmb3JtSW5zdGFuY2Uuc2V0RmllbGRzKGZpZWxkcyB8fCBbXSk7XG4gICAgfVxuICAgIHByZXZGaWVsZHNSZWYuY3VycmVudCA9IGZpZWxkcztcbiAgfSwgW2ZpZWxkcywgZm9ybUluc3RhbmNlXSk7XG4gIHZhciBmb3JtQ29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBmb3JtSW5zdGFuY2UpLCB7fSwge1xuICAgICAgdmFsaWRhdGVUcmlnZ2VyXG4gICAgfSk7XG4gIH0sIFtmb3JtSW5zdGFuY2UsIHZhbGlkYXRlVHJpZ2dlcl0pO1xuICB2YXIgd3JhcHBlck5vZGUgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGZvcm1Db250ZXh0VmFsdWVcbiAgfSwgY2hpbGRyZW5Ob2RlKTtcbiAgaWYgKENvbXBvbmVudDIgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHdyYXBwZXJOb2RlO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQyLCBfZXh0ZW5kcyQxKHt9LCByZXN0UHJvcHMsIHtcbiAgICBvblN1Ym1pdDogZnVuY3Rpb24gb25TdWJtaXQoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGZvcm1JbnN0YW5jZS5zdWJtaXQoKTtcbiAgICB9LFxuICAgIG9uUmVzZXQ6IGZ1bmN0aW9uIG9uUmVzZXQoZXZlbnQpIHtcbiAgICAgIHZhciBfcmVzdFByb3BzJG9uUmVzZXQ7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZm9ybUluc3RhbmNlLnJlc2V0RmllbGRzKCk7XG4gICAgICAoX3Jlc3RQcm9wcyRvblJlc2V0ID0gcmVzdFByb3BzLm9uUmVzZXQpID09PSBudWxsIHx8IF9yZXN0UHJvcHMkb25SZXNldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Jlc3RQcm9wcyRvblJlc2V0LmNhbGwocmVzdFByb3BzLCBldmVudCk7XG4gICAgfVxuICB9KSwgd3JhcHBlck5vZGUpO1xufTtcbnZhciBJbnRlcm5hbEZvcm0gPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuZm9yd2FyZFJlZihGb3JtKTtcbnZhciBSZWZGb3JtID0gSW50ZXJuYWxGb3JtO1xuUmVmRm9ybS5Gb3JtUHJvdmlkZXIgPSBGb3JtUHJvdmlkZXI7XG5SZWZGb3JtLkZpZWxkID0gV3JhcHBlckZpZWxkO1xuUmVmRm9ybS5MaXN0ID0gTGlzdDtcblJlZkZvcm0udXNlRm9ybSA9IHVzZUZvcm07XG52YXIgc2FmZUlzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIHBvbnlmaWxsKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgIT09IHZhbHVlO1xufTtcbmZ1bmN0aW9uIGlzRXF1YWwkMShmaXJzdCwgc2Vjb25kKSB7XG4gIGlmIChmaXJzdCA9PT0gc2Vjb25kKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHNhZmVJc05hTihmaXJzdCkgJiYgc2FmZUlzTmFOKHNlY29uZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhcmVJbnB1dHNFcXVhbChuZXdJbnB1dHMsIGxhc3RJbnB1dHMpIHtcbiAgaWYgKG5ld0lucHV0cy5sZW5ndGggIT09IGxhc3RJbnB1dHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3SW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFpc0VxdWFsJDEobmV3SW5wdXRzW2ldLCBsYXN0SW5wdXRzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVPbmUocmVzdWx0Rm4sIGlzRXF1YWwyKSB7XG4gIGlmIChpc0VxdWFsMiA9PT0gdm9pZCAwKSB7XG4gICAgaXNFcXVhbDIgPSBhcmVJbnB1dHNFcXVhbDtcbiAgfVxuICB2YXIgY2FjaGUgPSBudWxsO1xuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICB2YXIgbmV3QXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBuZXdBcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmIChjYWNoZSAmJiBjYWNoZS5sYXN0VGhpcyA9PT0gdGhpcyAmJiBpc0VxdWFsMihuZXdBcmdzLCBjYWNoZS5sYXN0QXJncykpIHtcbiAgICAgIHJldHVybiBjYWNoZS5sYXN0UmVzdWx0O1xuICAgIH1cbiAgICB2YXIgbGFzdFJlc3VsdCA9IHJlc3VsdEZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgIGNhY2hlID0ge1xuICAgICAgbGFzdFJlc3VsdCxcbiAgICAgIGxhc3RBcmdzOiBuZXdBcmdzLFxuICAgICAgbGFzdFRoaXM6IHRoaXNcbiAgICB9O1xuICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICB9XG4gIG1lbW9pemVkLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIyKCkge1xuICAgIGNhY2hlID0gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxudmFyIGRldldhcm5pbmcgPSBmdW5jdGlvbih2YWxpZCwgY29tcG9uZW50LCBtZXNzYWdlMikge1xuICB3YXJuaW5nT25jZSh2YWxpZCwgXCJbYW50ZDogXCIuY29uY2F0KGNvbXBvbmVudCwgXCJdIFwiKS5jb25jYXQobWVzc2FnZTIpKTtcbn07XG52YXIgUGFnaW5hdGlvbiA9IHtcbiAgaXRlbXNfcGVyX3BhZ2U6IFwiLyBwYWdlXCIsXG4gIGp1bXBfdG86IFwiR28gdG9cIixcbiAganVtcF90b19jb25maXJtOiBcImNvbmZpcm1cIixcbiAgcGFnZTogXCJQYWdlXCIsXG4gIHByZXZfcGFnZTogXCJQcmV2aW91cyBQYWdlXCIsXG4gIG5leHRfcGFnZTogXCJOZXh0IFBhZ2VcIixcbiAgcHJldl81OiBcIlByZXZpb3VzIDUgUGFnZXNcIixcbiAgbmV4dF81OiBcIk5leHQgNSBQYWdlc1wiLFxuICBwcmV2XzM6IFwiUHJldmlvdXMgMyBQYWdlc1wiLFxuICBuZXh0XzM6IFwiTmV4dCAzIFBhZ2VzXCIsXG4gIHBhZ2Vfc2l6ZTogXCJQYWdlIFNpemVcIlxufTtcbnZhciBsb2NhbGUkMiA9IHtcbiAgbG9jYWxlOiBcImVuX1VTXCIsXG4gIHRvZGF5OiBcIlRvZGF5XCIsXG4gIG5vdzogXCJOb3dcIixcbiAgYmFja1RvVG9kYXk6IFwiQmFjayB0byB0b2RheVwiLFxuICBvazogXCJPa1wiLFxuICBjbGVhcjogXCJDbGVhclwiLFxuICBtb250aDogXCJNb250aFwiLFxuICB5ZWFyOiBcIlllYXJcIixcbiAgdGltZVNlbGVjdDogXCJzZWxlY3QgdGltZVwiLFxuICBkYXRlU2VsZWN0OiBcInNlbGVjdCBkYXRlXCIsXG4gIHdlZWtTZWxlY3Q6IFwiQ2hvb3NlIGEgd2Vla1wiLFxuICBtb250aFNlbGVjdDogXCJDaG9vc2UgYSBtb250aFwiLFxuICB5ZWFyU2VsZWN0OiBcIkNob29zZSBhIHllYXJcIixcbiAgZGVjYWRlU2VsZWN0OiBcIkNob29zZSBhIGRlY2FkZVwiLFxuICB5ZWFyRm9ybWF0OiBcIllZWVlcIixcbiAgZGF0ZUZvcm1hdDogXCJNL0QvWVlZWVwiLFxuICBkYXlGb3JtYXQ6IFwiRFwiLFxuICBkYXRlVGltZUZvcm1hdDogXCJNL0QvWVlZWSBISDptbTpzc1wiLFxuICBtb250aEJlZm9yZVllYXI6IHRydWUsXG4gIHByZXZpb3VzTW9udGg6IFwiUHJldmlvdXMgbW9udGggKFBhZ2VVcClcIixcbiAgbmV4dE1vbnRoOiBcIk5leHQgbW9udGggKFBhZ2VEb3duKVwiLFxuICBwcmV2aW91c1llYXI6IFwiTGFzdCB5ZWFyIChDb250cm9sICsgbGVmdClcIixcbiAgbmV4dFllYXI6IFwiTmV4dCB5ZWFyIChDb250cm9sICsgcmlnaHQpXCIsXG4gIHByZXZpb3VzRGVjYWRlOiBcIkxhc3QgZGVjYWRlXCIsXG4gIG5leHREZWNhZGU6IFwiTmV4dCBkZWNhZGVcIixcbiAgcHJldmlvdXNDZW50dXJ5OiBcIkxhc3QgY2VudHVyeVwiLFxuICBuZXh0Q2VudHVyeTogXCJOZXh0IGNlbnR1cnlcIlxufTtcbnZhciBsb2NhbGUkMSA9IHtcbiAgcGxhY2Vob2xkZXI6IFwiU2VsZWN0IHRpbWVcIixcbiAgcmFuZ2VQbGFjZWhvbGRlcjogW1wiU3RhcnQgdGltZVwiLCBcIkVuZCB0aW1lXCJdXG59O1xudmFyIFRpbWVQaWNrZXIgPSBsb2NhbGUkMTtcbnZhciBsb2NhbGUgPSB7XG4gIGxhbmc6IF9leHRlbmRzJDEoe1xuICAgIHBsYWNlaG9sZGVyOiBcIlNlbGVjdCBkYXRlXCIsXG4gICAgeWVhclBsYWNlaG9sZGVyOiBcIlNlbGVjdCB5ZWFyXCIsXG4gICAgcXVhcnRlclBsYWNlaG9sZGVyOiBcIlNlbGVjdCBxdWFydGVyXCIsXG4gICAgbW9udGhQbGFjZWhvbGRlcjogXCJTZWxlY3QgbW9udGhcIixcbiAgICB3ZWVrUGxhY2Vob2xkZXI6IFwiU2VsZWN0IHdlZWtcIixcbiAgICByYW5nZVBsYWNlaG9sZGVyOiBbXCJTdGFydCBkYXRlXCIsIFwiRW5kIGRhdGVcIl0sXG4gICAgcmFuZ2VZZWFyUGxhY2Vob2xkZXI6IFtcIlN0YXJ0IHllYXJcIiwgXCJFbmQgeWVhclwiXSxcbiAgICByYW5nZU1vbnRoUGxhY2Vob2xkZXI6IFtcIlN0YXJ0IG1vbnRoXCIsIFwiRW5kIG1vbnRoXCJdLFxuICAgIHJhbmdlV2Vla1BsYWNlaG9sZGVyOiBbXCJTdGFydCB3ZWVrXCIsIFwiRW5kIHdlZWtcIl1cbiAgfSwgbG9jYWxlJDIpLFxuICB0aW1lUGlja2VyTG9jYWxlOiBfZXh0ZW5kcyQxKHt9LCBUaW1lUGlja2VyKVxufTtcbnZhciBEYXRlUGlja2VyID0gbG9jYWxlO1xudmFyIHR5cGVUZW1wbGF0ZSA9IFwiJHtsYWJlbH0gaXMgbm90IGEgdmFsaWQgJHt0eXBlfVwiO1xudmFyIGxvY2FsZVZhbHVlcyA9IHtcbiAgbG9jYWxlOiBcImVuXCIsXG4gIFBhZ2luYXRpb24sXG4gIERhdGVQaWNrZXIsXG4gIFRpbWVQaWNrZXIsXG4gIENhbGVuZGFyOiBEYXRlUGlja2VyLFxuICBnbG9iYWw6IHtcbiAgICBwbGFjZWhvbGRlcjogXCJQbGVhc2Ugc2VsZWN0XCJcbiAgfSxcbiAgVGFibGU6IHtcbiAgICBmaWx0ZXJUaXRsZTogXCJGaWx0ZXIgbWVudVwiLFxuICAgIGZpbHRlckNvbmZpcm06IFwiT0tcIixcbiAgICBmaWx0ZXJSZXNldDogXCJSZXNldFwiLFxuICAgIGZpbHRlckVtcHR5VGV4dDogXCJObyBmaWx0ZXJzXCIsXG4gICAgZmlsdGVyQ2hlY2thbGw6IFwiU2VsZWN0IGFsbCBpdGVtc1wiLFxuICAgIGZpbHRlclNlYXJjaFBsYWNlaG9sZGVyOiBcIlNlYXJjaCBpbiBmaWx0ZXJzXCIsXG4gICAgZW1wdHlUZXh0OiBcIk5vIGRhdGFcIixcbiAgICBzZWxlY3RBbGw6IFwiU2VsZWN0IGN1cnJlbnQgcGFnZVwiLFxuICAgIHNlbGVjdEludmVydDogXCJJbnZlcnQgY3VycmVudCBwYWdlXCIsXG4gICAgc2VsZWN0Tm9uZTogXCJDbGVhciBhbGwgZGF0YVwiLFxuICAgIHNlbGVjdGlvbkFsbDogXCJTZWxlY3QgYWxsIGRhdGFcIixcbiAgICBzb3J0VGl0bGU6IFwiU29ydFwiLFxuICAgIGV4cGFuZDogXCJFeHBhbmQgcm93XCIsXG4gICAgY29sbGFwc2U6IFwiQ29sbGFwc2Ugcm93XCIsXG4gICAgdHJpZ2dlckRlc2M6IFwiQ2xpY2sgdG8gc29ydCBkZXNjZW5kaW5nXCIsXG4gICAgdHJpZ2dlckFzYzogXCJDbGljayB0byBzb3J0IGFzY2VuZGluZ1wiLFxuICAgIGNhbmNlbFNvcnQ6IFwiQ2xpY2sgdG8gY2FuY2VsIHNvcnRpbmdcIlxuICB9LFxuICBNb2RhbDoge1xuICAgIG9rVGV4dDogXCJPS1wiLFxuICAgIGNhbmNlbFRleHQ6IFwiQ2FuY2VsXCIsXG4gICAganVzdE9rVGV4dDogXCJPS1wiXG4gIH0sXG4gIFBvcGNvbmZpcm06IHtcbiAgICBva1RleHQ6IFwiT0tcIixcbiAgICBjYW5jZWxUZXh0OiBcIkNhbmNlbFwiXG4gIH0sXG4gIFRyYW5zZmVyOiB7XG4gICAgdGl0bGVzOiBbXCJcIiwgXCJcIl0sXG4gICAgc2VhcmNoUGxhY2Vob2xkZXI6IFwiU2VhcmNoIGhlcmVcIixcbiAgICBpdGVtVW5pdDogXCJpdGVtXCIsXG4gICAgaXRlbXNVbml0OiBcIml0ZW1zXCIsXG4gICAgcmVtb3ZlOiBcIlJlbW92ZVwiLFxuICAgIHNlbGVjdEN1cnJlbnQ6IFwiU2VsZWN0IGN1cnJlbnQgcGFnZVwiLFxuICAgIHJlbW92ZUN1cnJlbnQ6IFwiUmVtb3ZlIGN1cnJlbnQgcGFnZVwiLFxuICAgIHNlbGVjdEFsbDogXCJTZWxlY3QgYWxsIGRhdGFcIixcbiAgICByZW1vdmVBbGw6IFwiUmVtb3ZlIGFsbCBkYXRhXCIsXG4gICAgc2VsZWN0SW52ZXJ0OiBcIkludmVydCBjdXJyZW50IHBhZ2VcIlxuICB9LFxuICBVcGxvYWQ6IHtcbiAgICB1cGxvYWRpbmc6IFwiVXBsb2FkaW5nLi4uXCIsXG4gICAgcmVtb3ZlRmlsZTogXCJSZW1vdmUgZmlsZVwiLFxuICAgIHVwbG9hZEVycm9yOiBcIlVwbG9hZCBlcnJvclwiLFxuICAgIHByZXZpZXdGaWxlOiBcIlByZXZpZXcgZmlsZVwiLFxuICAgIGRvd25sb2FkRmlsZTogXCJEb3dubG9hZCBmaWxlXCJcbiAgfSxcbiAgRW1wdHk6IHtcbiAgICBkZXNjcmlwdGlvbjogXCJObyBEYXRhXCJcbiAgfSxcbiAgSWNvbjoge1xuICAgIGljb246IFwiaWNvblwiXG4gIH0sXG4gIFRleHQ6IHtcbiAgICBlZGl0OiBcIkVkaXRcIixcbiAgICBjb3B5OiBcIkNvcHlcIixcbiAgICBjb3BpZWQ6IFwiQ29waWVkXCIsXG4gICAgZXhwYW5kOiBcIkV4cGFuZFwiXG4gIH0sXG4gIFBhZ2VIZWFkZXI6IHtcbiAgICBiYWNrOiBcIkJhY2tcIlxuICB9LFxuICBGb3JtOiB7XG4gICAgb3B0aW9uYWw6IFwiKG9wdGlvbmFsKVwiLFxuICAgIGRlZmF1bHRWYWxpZGF0ZU1lc3NhZ2VzOiB7XG4gICAgICBcImRlZmF1bHRcIjogXCJGaWVsZCB2YWxpZGF0aW9uIGVycm9yIGZvciAke2xhYmVsfVwiLFxuICAgICAgcmVxdWlyZWQ6IFwiUGxlYXNlIGVudGVyICR7bGFiZWx9XCIsXG4gICAgICBcImVudW1cIjogXCIke2xhYmVsfSBtdXN0IGJlIG9uZSBvZiBbJHtlbnVtfV1cIixcbiAgICAgIHdoaXRlc3BhY2U6IFwiJHtsYWJlbH0gY2Fubm90IGJlIGEgYmxhbmsgY2hhcmFjdGVyXCIsXG4gICAgICBkYXRlOiB7XG4gICAgICAgIGZvcm1hdDogXCIke2xhYmVsfSBkYXRlIGZvcm1hdCBpcyBpbnZhbGlkXCIsXG4gICAgICAgIHBhcnNlOiBcIiR7bGFiZWx9IGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBkYXRlXCIsXG4gICAgICAgIGludmFsaWQ6IFwiJHtsYWJlbH0gaXMgYW4gaW52YWxpZCBkYXRlXCJcbiAgICAgIH0sXG4gICAgICB0eXBlczoge1xuICAgICAgICBzdHJpbmc6IHR5cGVUZW1wbGF0ZSxcbiAgICAgICAgbWV0aG9kOiB0eXBlVGVtcGxhdGUsXG4gICAgICAgIGFycmF5OiB0eXBlVGVtcGxhdGUsXG4gICAgICAgIG9iamVjdDogdHlwZVRlbXBsYXRlLFxuICAgICAgICBudW1iZXI6IHR5cGVUZW1wbGF0ZSxcbiAgICAgICAgZGF0ZTogdHlwZVRlbXBsYXRlLFxuICAgICAgICBcImJvb2xlYW5cIjogdHlwZVRlbXBsYXRlLFxuICAgICAgICBpbnRlZ2VyOiB0eXBlVGVtcGxhdGUsXG4gICAgICAgIFwiZmxvYXRcIjogdHlwZVRlbXBsYXRlLFxuICAgICAgICByZWdleHA6IHR5cGVUZW1wbGF0ZSxcbiAgICAgICAgZW1haWw6IHR5cGVUZW1wbGF0ZSxcbiAgICAgICAgdXJsOiB0eXBlVGVtcGxhdGUsXG4gICAgICAgIGhleDogdHlwZVRlbXBsYXRlXG4gICAgICB9LFxuICAgICAgc3RyaW5nOiB7XG4gICAgICAgIGxlbjogXCIke2xhYmVsfSBtdXN0IGJlICR7bGVufSBjaGFyYWN0ZXJzXCIsXG4gICAgICAgIG1pbjogXCIke2xhYmVsfSBtdXN0IGJlIGF0IGxlYXN0ICR7bWlufSBjaGFyYWN0ZXJzXCIsXG4gICAgICAgIG1heDogXCIke2xhYmVsfSBtdXN0IGJlIHVwIHRvICR7bWF4fSBjaGFyYWN0ZXJzXCIsXG4gICAgICAgIHJhbmdlOiBcIiR7bGFiZWx9IG11c3QgYmUgYmV0d2VlbiAke21pbn0tJHttYXh9IGNoYXJhY3RlcnNcIlxuICAgICAgfSxcbiAgICAgIG51bWJlcjoge1xuICAgICAgICBsZW46IFwiJHtsYWJlbH0gbXVzdCBiZSBlcXVhbCB0byAke2xlbn1cIixcbiAgICAgICAgbWluOiBcIiR7bGFiZWx9IG11c3QgYmUgbWluaW11bSAke21pbn1cIixcbiAgICAgICAgbWF4OiBcIiR7bGFiZWx9IG11c3QgYmUgbWF4aW11bSAke21heH1cIixcbiAgICAgICAgcmFuZ2U6IFwiJHtsYWJlbH0gbXVzdCBiZSBiZXR3ZWVuICR7bWlufS0ke21heH1cIlxuICAgICAgfSxcbiAgICAgIGFycmF5OiB7XG4gICAgICAgIGxlbjogXCJNdXN0IGJlICR7bGVufSAke2xhYmVsfVwiLFxuICAgICAgICBtaW46IFwiQXQgbGVhc3QgJHttaW59ICR7bGFiZWx9XCIsXG4gICAgICAgIG1heDogXCJBdCBtb3N0ICR7bWF4fSAke2xhYmVsfVwiLFxuICAgICAgICByYW5nZTogXCJUaGUgYW1vdW50IG9mICR7bGFiZWx9IG11c3QgYmUgYmV0d2VlbiAke21pbn0tJHttYXh9XCJcbiAgICAgIH0sXG4gICAgICBwYXR0ZXJuOiB7XG4gICAgICAgIG1pc21hdGNoOiBcIiR7bGFiZWx9IGRvZXMgbm90IG1hdGNoIHRoZSBwYXR0ZXJuICR7cGF0dGVybn1cIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgSW1hZ2U6IHtcbiAgICBwcmV2aWV3OiBcIlByZXZpZXdcIlxuICB9XG59O1xudmFyIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGVWYWx1ZXM7XG52YXIgcnVudGltZUxvY2FsZSA9IF9leHRlbmRzJDEoe30sIGRlZmF1bHRMb2NhbGUuTW9kYWwpO1xuZnVuY3Rpb24gY2hhbmdlQ29uZmlybUxvY2FsZShuZXdMb2NhbGUpIHtcbiAgaWYgKG5ld0xvY2FsZSkge1xuICAgIHJ1bnRpbWVMb2NhbGUgPSBfZXh0ZW5kcyQxKF9leHRlbmRzJDEoe30sIHJ1bnRpbWVMb2NhbGUpLCBuZXdMb2NhbGUpO1xuICB9IGVsc2Uge1xuICAgIHJ1bnRpbWVMb2NhbGUgPSBfZXh0ZW5kcyQxKHt9LCBkZWZhdWx0TG9jYWxlLk1vZGFsKTtcbiAgfVxufVxudmFyIExvY2FsZUNvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ29udGV4dCh2b2lkIDApO1xudmFyIExvY2FsZUNvbnRleHQkMSA9IExvY2FsZUNvbnRleHQ7XG52YXIgQU5UX01BUksgPSBcImludGVybmFsTWFya1wiO1xudmFyIExvY2FsZVByb3ZpZGVyID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKExvY2FsZVByb3ZpZGVyMiwgX1JlYWN0JENvbXBvbmVudCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTG9jYWxlUHJvdmlkZXIyKTtcbiAgZnVuY3Rpb24gTG9jYWxlUHJvdmlkZXIyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2NhbGVQcm92aWRlcjIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpO1xuICAgIF90aGlzLmdldE1lbW9pemVkQ29udGV4dFZhbHVlID0gbWVtb2l6ZU9uZShmdW5jdGlvbihsb2NhbGVWYWx1ZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzJDEoX2V4dGVuZHMkMSh7fSwgbG9jYWxlVmFsdWUpLCB7XG4gICAgICAgIGV4aXN0OiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjaGFuZ2VDb25maXJtTG9jYWxlKHByb3BzLmxvY2FsZSAmJiBwcm9wcy5sb2NhbGUuTW9kYWwpO1xuICAgIGRldldhcm5pbmcocHJvcHMuX0FOVF9NQVJLX18gPT09IEFOVF9NQVJLLCBcIkxvY2FsZVByb3ZpZGVyXCIsIFwiYExvY2FsZVByb3ZpZGVyYCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGBsb2NhbGVgIHdpdGggYENvbmZpZ1Byb3ZpZGVyYCBpbnN0ZWFkOiBodHRwOi8vdS5hbnQuZGVzaWduL2xvY2FsZVwiKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKExvY2FsZVByb3ZpZGVyMiwgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBjaGFuZ2VDb25maXJtTG9jYWxlKHRoaXMucHJvcHMubG9jYWxlICYmIHRoaXMucHJvcHMubG9jYWxlLk1vZGFsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIHZhciBsb2NhbGUyID0gdGhpcy5wcm9wcy5sb2NhbGU7XG4gICAgICBpZiAocHJldlByb3BzLmxvY2FsZSAhPT0gbG9jYWxlMikge1xuICAgICAgICBjaGFuZ2VDb25maXJtTG9jYWxlKGxvY2FsZTIgJiYgbG9jYWxlMi5Nb2RhbCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgY2hhbmdlQ29uZmlybUxvY2FsZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcywgbG9jYWxlMiA9IF90aGlzJHByb3BzLmxvY2FsZSwgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBjb250ZXh0VmFsdWUgPSB0aGlzLmdldE1lbW9pemVkQ29udGV4dFZhbHVlKGxvY2FsZTIpO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KExvY2FsZUNvbnRleHQkMS5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMb2NhbGVQcm92aWRlcjI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5Mb2NhbGVQcm92aWRlci5kZWZhdWx0UHJvcHMgPSB7XG4gIGxvY2FsZToge31cbn07XG52YXIgTG9jYWxlUmVjZWl2ZXIgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTG9jYWxlUmVjZWl2ZXIyLCBfUmVhY3QkQ29tcG9uZW50KTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihMb2NhbGVSZWNlaXZlcjIpO1xuICBmdW5jdGlvbiBMb2NhbGVSZWNlaXZlcjIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvY2FsZVJlY2VpdmVyMik7XG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhMb2NhbGVSZWNlaXZlcjIsIFt7XG4gICAga2V5OiBcImdldExvY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2NhbGUoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLCBjb21wb25lbnROYW1lID0gX3RoaXMkcHJvcHMuY29tcG9uZW50TmFtZSwgZGVmYXVsdExvY2FsZSQxID0gX3RoaXMkcHJvcHMuZGVmYXVsdExvY2FsZTtcbiAgICAgIHZhciBsb2NhbGUyID0gZGVmYXVsdExvY2FsZSQxIHx8IGRlZmF1bHRMb2NhbGVbY29tcG9uZW50TmFtZSAhPT0gbnVsbCAmJiBjb21wb25lbnROYW1lICE9PSB2b2lkIDAgPyBjb21wb25lbnROYW1lIDogXCJnbG9iYWxcIl07XG4gICAgICB2YXIgYW50TG9jYWxlID0gdGhpcy5jb250ZXh0O1xuICAgICAgdmFyIGxvY2FsZUZyb21Db250ZXh0ID0gY29tcG9uZW50TmFtZSAmJiBhbnRMb2NhbGUgPyBhbnRMb2NhbGVbY29tcG9uZW50TmFtZV0gOiB7fTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyQxKF9leHRlbmRzJDEoe30sIGxvY2FsZTIgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGxvY2FsZTIoKSA6IGxvY2FsZTIpLCBsb2NhbGVGcm9tQ29udGV4dCB8fCB7fSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExvY2FsZUNvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG9jYWxlQ29kZSgpIHtcbiAgICAgIHZhciBhbnRMb2NhbGUgPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgbG9jYWxlQ29kZSA9IGFudExvY2FsZSAmJiBhbnRMb2NhbGUubG9jYWxlO1xuICAgICAgaWYgKGFudExvY2FsZSAmJiBhbnRMb2NhbGUuZXhpc3QgJiYgIWxvY2FsZUNvZGUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2NhbGUubG9jYWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvY2FsZUNvZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLmdldExvY2FsZSgpLCB0aGlzLmdldExvY2FsZUNvZGUoKSwgdGhpcy5jb250ZXh0KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExvY2FsZVJlY2VpdmVyMjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcbkxvY2FsZVJlY2VpdmVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgY29tcG9uZW50TmFtZTogXCJnbG9iYWxcIlxufTtcbkxvY2FsZVJlY2VpdmVyLmNvbnRleHRUeXBlID0gTG9jYWxlQ29udGV4dCQxO1xudmFyIEVtcHR5JDIgPSBmdW5jdGlvbiBFbXB0eSgpIHtcbiAgdmFyIF9SZWFjdCR1c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChDb25maWdDb250ZXh0KSwgZ2V0UHJlZml4Q2xzID0gX1JlYWN0JHVzZUNvbnRleHQuZ2V0UHJlZml4Q2xzO1xuICB2YXIgcHJlZml4Q2xzID0gZ2V0UHJlZml4Q2xzKFwiZW1wdHktaW1nLWRlZmF1bHRcIik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMsXG4gICAgd2lkdGg6IFwiMTg0XCIsXG4gICAgaGVpZ2h0OiBcIjE1MlwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDE4NCAxNTJcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgyNCAzMS42NylcIlxuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImVsbGlwc2VcIiwge1xuICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1lbGxpcHNlXCIpLFxuICAgIGN4OiBcIjY3Ljc5N1wiLFxuICAgIGN5OiBcIjEwNi44OVwiLFxuICAgIHJ4OiBcIjY3Ljc5N1wiLFxuICAgIHJ5OiBcIjEyLjY2OFwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1wYXRoLTFcIiksXG4gICAgZDogXCJNMTIyLjAzNCA2OS42NzRMOTguMTA5IDQwLjIyOWMtMS4xNDgtMS4zODYtMi44MjYtMi4yMjUtNC41OTMtMi4yMjVoLTUxLjQ0Yy0xLjc2NiAwLTMuNDQ0LjgzOS00LjU5MiAyLjIyNUwxMy41NiA2OS42NzR2MTUuMzgzaDEwOC40NzVWNjkuNjc0elwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1wYXRoLTJcIiksXG4gICAgZDogXCJNMTAxLjUzNyA4Ni4yMTRMODAuNjMgNjEuMTAyYy0xLjAwMS0xLjIwNy0yLjUwNy0xLjg2Ny00LjA0OC0xLjg2N0gzMS43MjRjLTEuNTQgMC0zLjA0Ny42Ni00LjA0OCAxLjg2N0w2Ljc2OSA4Ni4yMTR2MTMuNzkyaDk0Ljc2OFY4Ni4yMTR6XCIsXG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgxMy41NilcIlxuICB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItcGF0aC0zXCIpLFxuICAgIGQ6IFwiTTMzLjgzIDBoNjcuOTMzYTQgNCAwIDAgMSA0IDR2OTMuMzQ0YTQgNCAwIDAgMS00IDRIMzMuODNhNCA0IDAgMCAxLTQtNFY0YTQgNCAwIDAgMSA0LTR6XCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXBhdGgtNFwiKSxcbiAgICBkOiBcIk00Mi42NzggOS45NTNoNTAuMjM3YTIgMiAwIDAgMSAyIDJWMzYuOTFhMiAyIDAgMCAxLTIgMkg0Mi42NzhhMiAyIDAgMCAxLTItMlYxMS45NTNhMiAyIDAgMCAxIDItMnpNNDIuOTQgNDkuNzY3aDQ5LjcxM2EyLjI2MiAyLjI2MiAwIDEgMSAwIDQuNTI0SDQyLjk0YTIuMjYyIDIuMjYyIDAgMCAxIDAtNC41MjR6TTQyLjk0IDYxLjUzaDQ5LjcxM2EyLjI2MiAyLjI2MiAwIDEgMSAwIDQuNTI1SDQyLjk0YTIuMjYyIDIuMjYyIDAgMCAxIDAtNC41MjV6TTEyMS44MTMgMTA1LjAzMmMtLjc3NSAzLjA3MS0zLjQ5NyA1LjM2LTYuNzM1IDUuMzZIMjAuNTE1Yy0zLjIzOCAwLTUuOTYtMi4yOS02LjczNC01LjM2YTcuMzA5IDcuMzA5IDAgMCAxLS4yMjItMS43OVY2OS42NzVoMjYuMzE4YzIuOTA3IDAgNS4yNSAyLjQ0OCA1LjI1IDUuNDJ2LjA0YzAgMi45NzEgMi4zNyA1LjM3IDUuMjc3IDUuMzdoMzQuNzg1YzIuOTA3IDAgNS4yNzctMi40MjEgNS4yNzctNS4zOTNWNzUuMWMwLTIuOTcyIDIuMzQzLTUuNDI2IDUuMjUtNS40MjZoMjYuMzE4djMzLjU2OWMwIC42MTctLjA3NyAxLjIxNi0uMjIxIDEuNzg5elwiXG4gIH0pKSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItcGF0aC01XCIpLFxuICAgIGQ6IFwiTTE0OS4xMjEgMzMuMjkybC02LjgzIDIuNjVhMSAxIDAgMCAxLTEuMzE3LTEuMjNsMS45MzctNi4yMDdjLTIuNTg5LTIuOTQ0LTQuMTA5LTYuNTM0LTQuMTA5LTEwLjQwOEMxMzguODAyIDguMTAyIDE0OC45MiAwIDE2MS40MDIgMCAxNzMuODgxIDAgMTg0IDguMTAyIDE4NCAxOC4wOTdjMCA5Ljk5NS0xMC4xMTggMTguMDk3LTIyLjU5OSAxOC4wOTctNC41MjggMC04Ljc0NC0xLjA2Ni0xMi4yOC0yLjkwMnpcIlxuICB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItZ1wiKSxcbiAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKDE0OS42NSAxNS4zODMpXCJcbiAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJlbGxpcHNlXCIsIHtcbiAgICBjeDogXCIyMC42NTRcIixcbiAgICBjeTogXCIzLjE2N1wiLFxuICAgIHJ4OiBcIjIuODQ5XCIsXG4gICAgcnk6IFwiMi44MTVcIlxuICB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk01LjY5OCA1LjYzSDBMMi44OTguNzA0ek05LjI1OS43MDRoNC45ODVWNS42M0g5LjI1OXpcIlxuICB9KSkpKTtcbn07XG52YXIgRGVmYXVsdEVtcHR5SW1nID0gRW1wdHkkMjtcbnZhciBTaW1wbGUgPSBmdW5jdGlvbiBTaW1wbGUyKCkge1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KENvbmZpZ0NvbnRleHQpLCBnZXRQcmVmaXhDbHMgPSBfUmVhY3QkdXNlQ29udGV4dC5nZXRQcmVmaXhDbHM7XG4gIHZhciBwcmVmaXhDbHMgPSBnZXRQcmVmaXhDbHMoXCJlbXB0eS1pbWctc2ltcGxlXCIpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzLFxuICAgIHdpZHRoOiBcIjY0XCIsXG4gICAgaGVpZ2h0OiBcIjQxXCIsXG4gICAgdmlld0JveDogXCIwIDAgNjQgNDFcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgwIDEpXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZWxsaXBzZVwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWVsbGlwc2VcIiksXG4gICAgY3g6IFwiMzJcIixcbiAgICBjeTogXCIzM1wiLFxuICAgIHJ4OiBcIjMyXCIsXG4gICAgcnk6IFwiN1wiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1nXCIpLFxuICAgIGZpbGxSdWxlOiBcIm5vbnplcm9cIlxuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTU1IDEyLjc2TDQ0Ljg1NCAxLjI1OEM0NC4zNjcuNDc0IDQzLjY1NiAwIDQyLjkwNyAwSDIxLjA5M2MtLjc0OSAwLTEuNDYuNDc0LTEuOTQ3IDEuMjU3TDkgMTIuNzYxVjIyaDQ2di05LjI0elwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTQxLjYxMyAxNS45MzFjMC0xLjYwNS45OTQtMi45MyAyLjIyNy0yLjkzMUg1NXYxOC4xMzdDNTUgMzMuMjYgNTMuNjggMzUgNTIuMDUgMzVoLTQwLjFDMTAuMzIgMzUgOSAzMy4yNTkgOSAzMS4xMzdWMTNoMTEuMTZjMS4yMzMgMCAyLjIyNyAxLjMyMyAyLjIyNyAyLjkyOHYuMDIyYzAgMS42MDUgMS4wMDUgMi45MDEgMi4yMzcgMi45MDFoMTQuNzUyYzEuMjMyIDAgMi4yMzctMS4zMDggMi4yMzctMi45MTN2LS4wMDd6XCIsXG4gICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXBhdGhcIilcbiAgfSkpKSk7XG59O1xudmFyIFNpbXBsZUVtcHR5SW1nID0gU2ltcGxlO1xudmFyIF9fcmVzdCQ4ID0gZ2xvYmFsVGhpcyAmJiBnbG9iYWxUaGlzLl9fcmVzdCB8fCBmdW5jdGlvbihzLCBlMikge1xuICB2YXIgdDIgPSB7fTtcbiAgZm9yICh2YXIgcDIgaW4gcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcDIpICYmIGUyLmluZGV4T2YocDIpIDwgMClcbiAgICAgIHQyW3AyXSA9IHNbcDJdO1xuICB9XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICBmb3IgKHZhciBpID0gMCwgcDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChlMi5pbmRleE9mKHAyW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHAyW2ldKSlcbiAgICAgICAgdDJbcDJbaV1dID0gc1twMltpXV07XG4gICAgfVxuICByZXR1cm4gdDI7XG59O1xudmFyIGRlZmF1bHRFbXB0eUltZyA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRFbXB0eUltZywgbnVsbCk7XG52YXIgc2ltcGxlRW1wdHlJbWcgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChTaW1wbGVFbXB0eUltZywgbnVsbCk7XG52YXIgRW1wdHkyID0gZnVuY3Rpb24gRW1wdHkzKF9hKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIGN1c3RvbWl6ZVByZWZpeENscyA9IF9hLnByZWZpeENscywgX2EkaW1hZ2UgPSBfYS5pbWFnZSwgaW1hZ2UgPSBfYSRpbWFnZSA9PT0gdm9pZCAwID8gZGVmYXVsdEVtcHR5SW1nIDogX2EkaW1hZ2UsIGRlc2NyaXB0aW9uID0gX2EuZGVzY3JpcHRpb24sIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGltYWdlU3R5bGUgPSBfYS5pbWFnZVN0eWxlLCByZXN0UHJvcHMgPSBfX3Jlc3QkOChfYSwgW1wiY2xhc3NOYW1lXCIsIFwicHJlZml4Q2xzXCIsIFwiaW1hZ2VcIiwgXCJkZXNjcmlwdGlvblwiLCBcImNoaWxkcmVuXCIsIFwiaW1hZ2VTdHlsZVwiXSk7XG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQ29uZmlnQ29udGV4dCksIGdldFByZWZpeENscyA9IF9SZWFjdCR1c2VDb250ZXh0LmdldFByZWZpeENscywgZGlyZWN0aW9uID0gX1JlYWN0JHVzZUNvbnRleHQuZGlyZWN0aW9uO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTG9jYWxlUmVjZWl2ZXIsIHtcbiAgICBjb21wb25lbnROYW1lOiBcIkVtcHR5XCJcbiAgfSwgZnVuY3Rpb24obG9jYWxlMikge1xuICAgIHZhciBfY2xhc3NOYW1lcztcbiAgICB2YXIgcHJlZml4Q2xzID0gZ2V0UHJlZml4Q2xzKFwiZW1wdHlcIiwgY3VzdG9taXplUHJlZml4Q2xzKTtcbiAgICB2YXIgZGVzID0gdHlwZW9mIGRlc2NyaXB0aW9uICE9PSBcInVuZGVmaW5lZFwiID8gZGVzY3JpcHRpb24gOiBsb2NhbGUyLmRlc2NyaXB0aW9uO1xuICAgIHZhciBhbHQgPSB0eXBlb2YgZGVzID09PSBcInN0cmluZ1wiID8gZGVzIDogXCJlbXB0eVwiO1xuICAgIHZhciBpbWFnZU5vZGUgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgaW1hZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGltYWdlTm9kZSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHtcbiAgICAgICAgYWx0LFxuICAgICAgICBzcmM6IGltYWdlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW1hZ2VOb2RlID0gaW1hZ2U7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyQxKHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhwcmVmaXhDbHMsIChfY2xhc3NOYW1lcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lcywgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1ub3JtYWxcIiksIGltYWdlID09PSBzaW1wbGVFbXB0eUltZyksIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXJ0bFwiKSwgZGlyZWN0aW9uID09PSBcInJ0bFwiKSwgX2NsYXNzTmFtZXMpLCBjbGFzc05hbWUpXG4gICAgfSwgcmVzdFByb3BzKSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWltYWdlXCIpLFxuICAgICAgc3R5bGU6IGltYWdlU3R5bGVcbiAgICB9LCBpbWFnZU5vZGUpLCBkZXMgJiYgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWRlc2NyaXB0aW9uXCIpXG4gICAgfSwgZGVzKSwgY2hpbGRyZW4gJiYgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWZvb3RlclwiKVxuICAgIH0sIGNoaWxkcmVuKSk7XG4gIH0pO1xufTtcbkVtcHR5Mi5QUkVTRU5URURfSU1BR0VfREVGQVVMVCA9IGRlZmF1bHRFbXB0eUltZztcbkVtcHR5Mi5QUkVTRU5URURfSU1BR0VfU0lNUExFID0gc2ltcGxlRW1wdHlJbWc7XG52YXIgRW1wdHkkMSA9IEVtcHR5MjtcbnZhciByZW5kZXJFbXB0eSA9IGZ1bmN0aW9uIHJlbmRlckVtcHR5Mihjb21wb25lbnROYW1lKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb25maWdDb25zdW1lciwgbnVsbCwgZnVuY3Rpb24oX3JlZikge1xuICAgIHZhciBnZXRQcmVmaXhDbHMgPSBfcmVmLmdldFByZWZpeENscztcbiAgICB2YXIgcHJlZml4ID0gZ2V0UHJlZml4Q2xzKFwiZW1wdHlcIik7XG4gICAgc3dpdGNoIChjb21wb25lbnROYW1lKSB7XG4gICAgICBjYXNlIFwiVGFibGVcIjpcbiAgICAgIGNhc2UgXCJMaXN0XCI6XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChFbXB0eSQxLCB7XG4gICAgICAgICAgaW1hZ2U6IEVtcHR5JDEuUFJFU0VOVEVEX0lNQUdFX1NJTVBMRVxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJTZWxlY3RcIjpcbiAgICAgIGNhc2UgXCJUcmVlU2VsZWN0XCI6XG4gICAgICBjYXNlIFwiQ2FzY2FkZXJcIjpcbiAgICAgIGNhc2UgXCJUcmFuc2ZlclwiOlxuICAgICAgY2FzZSBcIk1lbnRpb25zXCI6XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChFbXB0eSQxLCB7XG4gICAgICAgICAgaW1hZ2U6IEVtcHR5JDEuUFJFU0VOVEVEX0lNQUdFX1NJTVBMRSxcbiAgICAgICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItc21hbGxcIilcbiAgICAgICAgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRW1wdHkkMSwgbnVsbCk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgZGVmYXVsdFJlbmRlckVtcHR5ID0gcmVuZGVyRW1wdHk7XG52YXIgZGVmYXVsdEdldFByZWZpeENscyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRQcmVmaXhDbHMyKHN1ZmZpeENscywgY3VzdG9taXplUHJlZml4Q2xzKSB7XG4gIGlmIChjdXN0b21pemVQcmVmaXhDbHMpXG4gICAgcmV0dXJuIGN1c3RvbWl6ZVByZWZpeENscztcbiAgcmV0dXJuIHN1ZmZpeENscyA/IFwiYW50LVwiLmNvbmNhdChzdWZmaXhDbHMpIDogXCJhbnRcIjtcbn07XG52YXIgQ29uZmlnQ29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgZ2V0UHJlZml4Q2xzOiBkZWZhdWx0R2V0UHJlZml4Q2xzLFxuICByZW5kZXJFbXB0eTogZGVmYXVsdFJlbmRlckVtcHR5XG59KTtcbnZhciBDb25maWdDb25zdW1lciA9IENvbmZpZ0NvbnRleHQuQ29uc3VtZXI7XG52YXIgU2l6ZUNvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xudmFyIFNpemVDb250ZXh0UHJvdmlkZXIgPSBmdW5jdGlvbiBTaXplQ29udGV4dFByb3ZpZGVyMihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sIHNpemUgPSBfcmVmLnNpemU7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChTaXplQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24ob3JpZ2luU2l6ZSkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChTaXplQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHNpemUgfHwgb3JpZ2luU2l6ZVxuICAgIH0sIGNoaWxkcmVuKTtcbiAgfSk7XG59O1xudmFyIFNpemVDb250ZXh0JDEgPSBTaXplQ29udGV4dDtcbnZhciBDbG9zZU91dGxpbmVkJDIgPSB7IFwiaWNvblwiOiB7IFwidGFnXCI6IFwic3ZnXCIsIFwiYXR0cnNcIjogeyBcInZpZXdCb3hcIjogXCI2NCA2NCA4OTYgODk2XCIsIFwiZm9jdXNhYmxlXCI6IFwiZmFsc2VcIiB9LCBcImNoaWxkcmVuXCI6IFt7IFwidGFnXCI6IFwicGF0aFwiLCBcImF0dHJzXCI6IHsgXCJkXCI6IFwiTTU2My44IDUxMmwyNjIuNS0zMTIuOWM0LjQtNS4yLjctMTMuMS02LjEtMTMuMWgtNzkuOGMtNC43IDAtOS4yIDIuMS0xMi4zIDUuN0w1MTEuNiA0NDkuOCAyOTUuMSAxOTEuN2MtMy0zLjYtNy41LTUuNy0xMi4zLTUuN0gyMDNjLTYuOCAwLTEwLjUgNy45LTYuMSAxMy4xTDQ1OS40IDUxMiAxOTYuOSA4MjQuOUE3Ljk1IDcuOTUgMCAwMDIwMyA4MzhoNzkuOGM0LjcgMCA5LjItMi4xIDEyLjMtNS43bDIxNi41LTI1OC4xIDIxNi41IDI1OC4xYzMgMy42IDcuNSA1LjcgMTIuMyA1LjdoNzkuOGM2LjggMCAxMC41LTcuOSA2LjEtMTMuMUw1NjMuOCA1MTJ6XCIgfSB9XSB9LCBcIm5hbWVcIjogXCJjbG9zZVwiLCBcInRoZW1lXCI6IFwib3V0bGluZWRcIiB9O1xudmFyIENsb3NlT3V0bGluZWRTdmcgPSBDbG9zZU91dGxpbmVkJDI7XG52YXIgQ2xvc2VPdXRsaW5lZCA9IGZ1bmN0aW9uIENsb3NlT3V0bGluZWQyKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEFudGRJY29uLCBfb2JqZWN0U3ByZWFkMiQxKF9vYmplY3RTcHJlYWQyJDEoe30sIHByb3BzKSwge30sIHtcbiAgICByZWYsXG4gICAgaWNvbjogQ2xvc2VPdXRsaW5lZFN2Z1xuICB9KSk7XG59O1xuQ2xvc2VPdXRsaW5lZC5kaXNwbGF5TmFtZSA9IFwiQ2xvc2VPdXRsaW5lZFwiO1xudmFyIENsb3NlT3V0bGluZWQkMSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5mb3J3YXJkUmVmKENsb3NlT3V0bGluZWQpO1xudmFyIENoZWNrQ2lyY2xlT3V0bGluZWQkMiA9IHsgXCJpY29uXCI6IHsgXCJ0YWdcIjogXCJzdmdcIiwgXCJhdHRyc1wiOiB7IFwidmlld0JveFwiOiBcIjY0IDY0IDg5NiA4OTZcIiwgXCJmb2N1c2FibGVcIjogXCJmYWxzZVwiIH0sIFwiY2hpbGRyZW5cIjogW3sgXCJ0YWdcIjogXCJwYXRoXCIsIFwiYXR0cnNcIjogeyBcImRcIjogXCJNNjk5IDM1M2gtNDYuOWMtMTAuMiAwLTE5LjkgNC45LTI1LjkgMTMuM0w0NjkgNTg0LjNsLTcxLjItOTguOGMtNi04LjMtMTUuNi0xMy4zLTI1LjktMTMuM0gzMjVjLTYuNSAwLTEwLjMgNy40LTYuNSAxMi43bDEyNC42IDE3Mi44YTMxLjggMzEuOCAwIDAwNTEuNyAwbDIxMC42LTI5MmMzLjktNS4zLjEtMTIuNy02LjQtMTIuN3pcIiB9IH0sIHsgXCJ0YWdcIjogXCJwYXRoXCIsIFwiYXR0cnNcIjogeyBcImRcIjogXCJNNTEyIDY0QzI2NC42IDY0IDY0IDI2NC42IDY0IDUxMnMyMDAuNiA0NDggNDQ4IDQ0OCA0NDgtMjAwLjYgNDQ4LTQ0OFM3NTkuNCA2NCA1MTIgNjR6bTAgODIwYy0yMDUuNCAwLTM3Mi0xNjYuNi0zNzItMzcyczE2Ni42LTM3MiAzNzItMzcyIDM3MiAxNjYuNiAzNzIgMzcyLTE2Ni42IDM3Mi0zNzIgMzcyelwiIH0gfV0gfSwgXCJuYW1lXCI6IFwiY2hlY2stY2lyY2xlXCIsIFwidGhlbWVcIjogXCJvdXRsaW5lZFwiIH07XG52YXIgQ2hlY2tDaXJjbGVPdXRsaW5lZFN2ZyA9IENoZWNrQ2lyY2xlT3V0bGluZWQkMjtcbnZhciBDaGVja0NpcmNsZU91dGxpbmVkID0gZnVuY3Rpb24gQ2hlY2tDaXJjbGVPdXRsaW5lZDIocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW50ZEljb24sIF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwgcHJvcHMpLCB7fSwge1xuICAgIHJlZixcbiAgICBpY29uOiBDaGVja0NpcmNsZU91dGxpbmVkU3ZnXG4gIH0pKTtcbn07XG5DaGVja0NpcmNsZU91dGxpbmVkLmRpc3BsYXlOYW1lID0gXCJDaGVja0NpcmNsZU91dGxpbmVkXCI7XG52YXIgQ2hlY2tDaXJjbGVPdXRsaW5lZCQxID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmZvcndhcmRSZWYoQ2hlY2tDaXJjbGVPdXRsaW5lZCk7XG52YXIgQ2xvc2VDaXJjbGVPdXRsaW5lZCQyID0geyBcImljb25cIjogeyBcInRhZ1wiOiBcInN2Z1wiLCBcImF0dHJzXCI6IHsgXCJ2aWV3Qm94XCI6IFwiNjQgNjQgODk2IDg5NlwiLCBcImZvY3VzYWJsZVwiOiBcImZhbHNlXCIgfSwgXCJjaGlsZHJlblwiOiBbeyBcInRhZ1wiOiBcInBhdGhcIiwgXCJhdHRyc1wiOiB7IFwiZFwiOiBcIk02ODUuNCAzNTQuOGMwLTQuNC0zLjYtOC04LThsLTY2IC4zTDUxMiA0NjUuNmwtOTkuMy0xMTguNC02Ni4xLS4zYy00LjQgMC04IDMuNS04IDggMCAxLjkuNyAzLjcgMS45IDUuMmwxMzAuMSAxNTVMMzQwLjUgNjcwYTguMzIgOC4zMiAwIDAwLTEuOSA1LjJjMCA0LjQgMy42IDggOCA4bDY2LjEtLjNMNTEyIDU2NC40bDk5LjMgMTE4LjQgNjYgLjNjNC40IDAgOC0zLjUgOC04IDAtMS45LS43LTMuNy0xLjktNS4yTDU1My41IDUxNWwxMzAuMS0xNTVjMS4yLTEuNCAxLjgtMy4zIDEuOC01LjJ6XCIgfSB9LCB7IFwidGFnXCI6IFwicGF0aFwiLCBcImF0dHJzXCI6IHsgXCJkXCI6IFwiTTUxMiA2NUMyNjQuNiA2NSA2NCAyNjUuNiA2NCA1MTNzMjAwLjYgNDQ4IDQ0OCA0NDggNDQ4LTIwMC42IDQ0OC00NDhTNzU5LjQgNjUgNTEyIDY1em0wIDgyMGMtMjA1LjQgMC0zNzItMTY2LjYtMzcyLTM3MnMxNjYuNi0zNzIgMzcyLTM3MiAzNzIgMTY2LjYgMzcyIDM3Mi0xNjYuNiAzNzItMzcyIDM3MnpcIiB9IH1dIH0sIFwibmFtZVwiOiBcImNsb3NlLWNpcmNsZVwiLCBcInRoZW1lXCI6IFwib3V0bGluZWRcIiB9O1xudmFyIENsb3NlQ2lyY2xlT3V0bGluZWRTdmcgPSBDbG9zZUNpcmNsZU91dGxpbmVkJDI7XG52YXIgQ2xvc2VDaXJjbGVPdXRsaW5lZCA9IGZ1bmN0aW9uIENsb3NlQ2lyY2xlT3V0bGluZWQyKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEFudGRJY29uLCBfb2JqZWN0U3ByZWFkMiQxKF9vYmplY3RTcHJlYWQyJDEoe30sIHByb3BzKSwge30sIHtcbiAgICByZWYsXG4gICAgaWNvbjogQ2xvc2VDaXJjbGVPdXRsaW5lZFN2Z1xuICB9KSk7XG59O1xuQ2xvc2VDaXJjbGVPdXRsaW5lZC5kaXNwbGF5TmFtZSA9IFwiQ2xvc2VDaXJjbGVPdXRsaW5lZFwiO1xudmFyIENsb3NlQ2lyY2xlT3V0bGluZWQkMSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5mb3J3YXJkUmVmKENsb3NlQ2lyY2xlT3V0bGluZWQpO1xudmFyIEV4Y2xhbWF0aW9uQ2lyY2xlT3V0bGluZWQkMiA9IHsgXCJpY29uXCI6IHsgXCJ0YWdcIjogXCJzdmdcIiwgXCJhdHRyc1wiOiB7IFwidmlld0JveFwiOiBcIjY0IDY0IDg5NiA4OTZcIiwgXCJmb2N1c2FibGVcIjogXCJmYWxzZVwiIH0sIFwiY2hpbGRyZW5cIjogW3sgXCJ0YWdcIjogXCJwYXRoXCIsIFwiYXR0cnNcIjogeyBcImRcIjogXCJNNTEyIDY0QzI2NC42IDY0IDY0IDI2NC42IDY0IDUxMnMyMDAuNiA0NDggNDQ4IDQ0OCA0NDgtMjAwLjYgNDQ4LTQ0OFM3NTkuNCA2NCA1MTIgNjR6bTAgODIwYy0yMDUuNCAwLTM3Mi0xNjYuNi0zNzItMzcyczE2Ni42LTM3MiAzNzItMzcyIDM3MiAxNjYuNiAzNzIgMzcyLTE2Ni42IDM3Mi0zNzIgMzcyelwiIH0gfSwgeyBcInRhZ1wiOiBcInBhdGhcIiwgXCJhdHRyc1wiOiB7IFwiZFwiOiBcIk00NjQgNjg4YTQ4IDQ4IDAgMTA5NiAwIDQ4IDQ4IDAgMTAtOTYgMHptMjQtMTEyaDQ4YzQuNCAwIDgtMy42IDgtOFYyOTZjMC00LjQtMy42LTgtOC04aC00OGMtNC40IDAtOCAzLjYtOCA4djI3MmMwIDQuNCAzLjYgOCA4IDh6XCIgfSB9XSB9LCBcIm5hbWVcIjogXCJleGNsYW1hdGlvbi1jaXJjbGVcIiwgXCJ0aGVtZVwiOiBcIm91dGxpbmVkXCIgfTtcbnZhciBFeGNsYW1hdGlvbkNpcmNsZU91dGxpbmVkU3ZnID0gRXhjbGFtYXRpb25DaXJjbGVPdXRsaW5lZCQyO1xudmFyIEV4Y2xhbWF0aW9uQ2lyY2xlT3V0bGluZWQgPSBmdW5jdGlvbiBFeGNsYW1hdGlvbkNpcmNsZU91dGxpbmVkMihwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChBbnRkSWNvbiwgX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgcmVmLFxuICAgIGljb246IEV4Y2xhbWF0aW9uQ2lyY2xlT3V0bGluZWRTdmdcbiAgfSkpO1xufTtcbkV4Y2xhbWF0aW9uQ2lyY2xlT3V0bGluZWQuZGlzcGxheU5hbWUgPSBcIkV4Y2xhbWF0aW9uQ2lyY2xlT3V0bGluZWRcIjtcbnZhciBFeGNsYW1hdGlvbkNpcmNsZU91dGxpbmVkJDEgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuZm9yd2FyZFJlZihFeGNsYW1hdGlvbkNpcmNsZU91dGxpbmVkKTtcbnZhciBJbmZvQ2lyY2xlT3V0bGluZWQkMiA9IHsgXCJpY29uXCI6IHsgXCJ0YWdcIjogXCJzdmdcIiwgXCJhdHRyc1wiOiB7IFwidmlld0JveFwiOiBcIjY0IDY0IDg5NiA4OTZcIiwgXCJmb2N1c2FibGVcIjogXCJmYWxzZVwiIH0sIFwiY2hpbGRyZW5cIjogW3sgXCJ0YWdcIjogXCJwYXRoXCIsIFwiYXR0cnNcIjogeyBcImRcIjogXCJNNTEyIDY0QzI2NC42IDY0IDY0IDI2NC42IDY0IDUxMnMyMDAuNiA0NDggNDQ4IDQ0OCA0NDgtMjAwLjYgNDQ4LTQ0OFM3NTkuNCA2NCA1MTIgNjR6bTAgODIwYy0yMDUuNCAwLTM3Mi0xNjYuNi0zNzItMzcyczE2Ni42LTM3MiAzNzItMzcyIDM3MiAxNjYuNiAzNzIgMzcyLTE2Ni42IDM3Mi0zNzIgMzcyelwiIH0gfSwgeyBcInRhZ1wiOiBcInBhdGhcIiwgXCJhdHRyc1wiOiB7IFwiZFwiOiBcIk00NjQgMzM2YTQ4IDQ4IDAgMTA5NiAwIDQ4IDQ4IDAgMTAtOTYgMHptNzIgMTEyaC00OGMtNC40IDAtOCAzLjYtOCA4djI3MmMwIDQuNCAzLjYgOCA4IDhoNDhjNC40IDAgOC0zLjYgOC04VjQ1NmMwLTQuNC0zLjYtOC04LTh6XCIgfSB9XSB9LCBcIm5hbWVcIjogXCJpbmZvLWNpcmNsZVwiLCBcInRoZW1lXCI6IFwib3V0bGluZWRcIiB9O1xudmFyIEluZm9DaXJjbGVPdXRsaW5lZFN2ZyA9IEluZm9DaXJjbGVPdXRsaW5lZCQyO1xudmFyIEluZm9DaXJjbGVPdXRsaW5lZCA9IGZ1bmN0aW9uIEluZm9DaXJjbGVPdXRsaW5lZDIocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW50ZEljb24sIF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwgcHJvcHMpLCB7fSwge1xuICAgIHJlZixcbiAgICBpY29uOiBJbmZvQ2lyY2xlT3V0bGluZWRTdmdcbiAgfSkpO1xufTtcbkluZm9DaXJjbGVPdXRsaW5lZC5kaXNwbGF5TmFtZSA9IFwiSW5mb0NpcmNsZU91dGxpbmVkXCI7XG52YXIgSW5mb0NpcmNsZU91dGxpbmVkJDEgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuZm9yd2FyZFJlZihJbmZvQ2lyY2xlT3V0bGluZWQpO1xuZnVuY3Rpb24gY3JlYXRlVXNlTm90aWZpY2F0aW9uKGdldE5vdGlmaWNhdGlvbkluc3RhbmNlMiwgZ2V0UkNOb3RpY2VQcm9wczIpIHtcbiAgdmFyIHVzZU5vdGlmaWNhdGlvbiQxID0gZnVuY3Rpb24gdXNlTm90aWZpY2F0aW9uJDEyKCkge1xuICAgIHZhciBnZXRQcmVmaXhDbHM7XG4gICAgdmFyIGlubmVySW5zdGFuY2UgPSBudWxsO1xuICAgIHZhciBwcm94eSA9IHtcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKG5vdGljZVByb3BzLCBob2xkZXJDYWxsYmFjaykge1xuICAgICAgICBpbm5lckluc3RhbmNlID09PSBudWxsIHx8IGlubmVySW5zdGFuY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlubmVySW5zdGFuY2UuY29tcG9uZW50LmFkZChub3RpY2VQcm9wcywgaG9sZGVyQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIF91c2VSQ05vdGlmaWNhdGlvbiA9IHVzZU5vdGlmaWNhdGlvbihwcm94eSksIF91c2VSQ05vdGlmaWNhdGlvbjIgPSBfc2xpY2VkVG9BcnJheShfdXNlUkNOb3RpZmljYXRpb24sIDIpLCBob29rTm90aWZ5ID0gX3VzZVJDTm90aWZpY2F0aW9uMlswXSwgaG9sZGVyID0gX3VzZVJDTm90aWZpY2F0aW9uMlsxXTtcbiAgICBmdW5jdGlvbiBub3RpZnkoYXJncykge1xuICAgICAgdmFyIGN1c3RvbWl6ZVByZWZpeENscyA9IGFyZ3MucHJlZml4Q2xzO1xuICAgICAgdmFyIG1lcmdlZFByZWZpeENscyA9IGdldFByZWZpeENscyhcIm5vdGlmaWNhdGlvblwiLCBjdXN0b21pemVQcmVmaXhDbHMpO1xuICAgICAgZ2V0Tm90aWZpY2F0aW9uSW5zdGFuY2UyKF9leHRlbmRzJDEoX2V4dGVuZHMkMSh7fSwgYXJncyksIHtcbiAgICAgICAgcHJlZml4Q2xzOiBtZXJnZWRQcmVmaXhDbHNcbiAgICAgIH0pLCBmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgIHZhciBwcmVmaXhDbHMgPSBfcmVmLnByZWZpeENscywgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlO1xuICAgICAgICBpbm5lckluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIGhvb2tOb3RpZnkoZ2V0UkNOb3RpY2VQcm9wczIoYXJncywgcHJlZml4Q2xzKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGhvb2tBcGlSZWYgPSBSZWFjdC51c2VSZWYoe30pO1xuICAgIGhvb2tBcGlSZWYuY3VycmVudC5vcGVuID0gbm90aWZ5O1xuICAgIFtcInN1Y2Nlc3NcIiwgXCJpbmZvXCIsIFwid2FybmluZ1wiLCBcImVycm9yXCJdLmZvckVhY2goZnVuY3Rpb24odHlwZTQpIHtcbiAgICAgIGhvb2tBcGlSZWYuY3VycmVudFt0eXBlNF0gPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBob29rQXBpUmVmLmN1cnJlbnQub3BlbihfZXh0ZW5kcyQxKF9leHRlbmRzJDEoe30sIGFyZ3MpLCB7XG4gICAgICAgICAgdHlwZTogdHlwZTRcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2hvb2tBcGlSZWYuY3VycmVudCwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29uZmlnQ29uc3VtZXIsIHtcbiAgICAgIGtleTogXCJob2xkZXJcIlxuICAgIH0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIGdldFByZWZpeENscyA9IGNvbnRleHQuZ2V0UHJlZml4Q2xzO1xuICAgICAgcmV0dXJuIGhvbGRlcjtcbiAgICB9KV07XG4gIH07XG4gIHJldHVybiB1c2VOb3RpZmljYXRpb24kMTtcbn1cbmdsb2JhbFRoaXMgJiYgZ2xvYmFsVGhpcy5fX2F3YWl0ZXIgfHwgZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHJlamVjdChlMik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICByZWplY3QoZTIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgfVxuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIG5vdGlmaWNhdGlvbkluc3RhbmNlID0ge307XG52YXIgZGVmYXVsdER1cmF0aW9uJDEgPSA0LjU7XG52YXIgZGVmYXVsdFRvcCQxID0gMjQ7XG52YXIgZGVmYXVsdEJvdHRvbSA9IDI0O1xudmFyIGRlZmF1bHRQcmVmaXhDbHMkMSA9IFwiXCI7XG52YXIgZGVmYXVsdFBsYWNlbWVudCA9IFwidG9wUmlnaHRcIjtcbnZhciBkZWZhdWx0R2V0Q29udGFpbmVyO1xudmFyIGRlZmF1bHRDbG9zZUljb247XG52YXIgcnRsJDEgPSBmYWxzZTtcbnZhciBtYXhDb3VudCQxO1xuZnVuY3Rpb24gc2V0Tm90aWZpY2F0aW9uQ29uZmlnKG9wdGlvbnMpIHtcbiAgdmFyIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiwgcGxhY2VtZW50ID0gb3B0aW9ucy5wbGFjZW1lbnQsIGJvdHRvbSA9IG9wdGlvbnMuYm90dG9tLCB0b3AgPSBvcHRpb25zLnRvcCwgZ2V0Q29udGFpbmVyMiA9IG9wdGlvbnMuZ2V0Q29udGFpbmVyLCBjbG9zZUljb24gPSBvcHRpb25zLmNsb3NlSWNvbiwgcHJlZml4Q2xzID0gb3B0aW9ucy5wcmVmaXhDbHM7XG4gIGlmIChwcmVmaXhDbHMgIT09IHZvaWQgMCkge1xuICAgIGRlZmF1bHRQcmVmaXhDbHMkMSA9IHByZWZpeENscztcbiAgfVxuICBpZiAoZHVyYXRpb24gIT09IHZvaWQgMCkge1xuICAgIGRlZmF1bHREdXJhdGlvbiQxID0gZHVyYXRpb247XG4gIH1cbiAgaWYgKHBsYWNlbWVudCAhPT0gdm9pZCAwKSB7XG4gICAgZGVmYXVsdFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnJ0bCkge1xuICAgIGRlZmF1bHRQbGFjZW1lbnQgPSBcInRvcExlZnRcIjtcbiAgfVxuICBpZiAoYm90dG9tICE9PSB2b2lkIDApIHtcbiAgICBkZWZhdWx0Qm90dG9tID0gYm90dG9tO1xuICB9XG4gIGlmICh0b3AgIT09IHZvaWQgMCkge1xuICAgIGRlZmF1bHRUb3AkMSA9IHRvcDtcbiAgfVxuICBpZiAoZ2V0Q29udGFpbmVyMiAhPT0gdm9pZCAwKSB7XG4gICAgZGVmYXVsdEdldENvbnRhaW5lciA9IGdldENvbnRhaW5lcjI7XG4gIH1cbiAgaWYgKGNsb3NlSWNvbiAhPT0gdm9pZCAwKSB7XG4gICAgZGVmYXVsdENsb3NlSWNvbiA9IGNsb3NlSWNvbjtcbiAgfVxuICBpZiAob3B0aW9ucy5ydGwgIT09IHZvaWQgMCkge1xuICAgIHJ0bCQxID0gb3B0aW9ucy5ydGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMubWF4Q291bnQgIT09IHZvaWQgMCkge1xuICAgIG1heENvdW50JDEgPSBvcHRpb25zLm1heENvdW50O1xuICB9XG59XG5mdW5jdGlvbiBnZXRQbGFjZW1lbnRTdHlsZShwbGFjZW1lbnQpIHtcbiAgdmFyIHRvcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogZGVmYXVsdFRvcCQxO1xuICB2YXIgYm90dG9tID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiBkZWZhdWx0Qm90dG9tO1xuICB2YXIgc3R5bGUyO1xuICBzd2l0Y2ggKHBsYWNlbWVudCkge1xuICAgIGNhc2UgXCJ0b3BMZWZ0XCI6XG4gICAgICBzdHlsZTIgPSB7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcCxcbiAgICAgICAgYm90dG9tOiBcImF1dG9cIlxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0b3BSaWdodFwiOlxuICAgICAgc3R5bGUyID0ge1xuICAgICAgICByaWdodDogMCxcbiAgICAgICAgdG9wLFxuICAgICAgICBib3R0b206IFwiYXV0b1wiXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJvdHRvbUxlZnRcIjpcbiAgICAgIHN0eWxlMiA9IHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiBcImF1dG9cIixcbiAgICAgICAgYm90dG9tXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0eWxlMiA9IHtcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHRvcDogXCJhdXRvXCIsXG4gICAgICAgIGJvdHRvbVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBzdHlsZTI7XG59XG5mdW5jdGlvbiBnZXROb3RpZmljYXRpb25JbnN0YW5jZShhcmdzLCBjYWxsYmFjaykge1xuICB2YXIgX2FyZ3MkcGxhY2VtZW50ID0gYXJncy5wbGFjZW1lbnQsIHBsYWNlbWVudCA9IF9hcmdzJHBsYWNlbWVudCA9PT0gdm9pZCAwID8gZGVmYXVsdFBsYWNlbWVudCA6IF9hcmdzJHBsYWNlbWVudCwgdG9wID0gYXJncy50b3AsIGJvdHRvbSA9IGFyZ3MuYm90dG9tLCBfYXJncyRnZXRDb250YWluZXIgPSBhcmdzLmdldENvbnRhaW5lciwgZ2V0Q29udGFpbmVyMiA9IF9hcmdzJGdldENvbnRhaW5lciA9PT0gdm9pZCAwID8gZGVmYXVsdEdldENvbnRhaW5lciA6IF9hcmdzJGdldENvbnRhaW5lciwgY3VzdG9taXplUHJlZml4Q2xzID0gYXJncy5wcmVmaXhDbHM7XG4gIHZhciBfZ2xvYmFsQ29uZmlnID0gZ2xvYmFsQ29uZmlnKCksIGdldFByZWZpeENscyA9IF9nbG9iYWxDb25maWcuZ2V0UHJlZml4Q2xzLCBnZXRJY29uUHJlZml4Q2xzID0gX2dsb2JhbENvbmZpZy5nZXRJY29uUHJlZml4Q2xzO1xuICB2YXIgcHJlZml4Q2xzID0gZ2V0UHJlZml4Q2xzKFwibm90aWZpY2F0aW9uXCIsIGN1c3RvbWl6ZVByZWZpeENscyB8fCBkZWZhdWx0UHJlZml4Q2xzJDEpO1xuICB2YXIgaWNvblByZWZpeENscyA9IGdldEljb25QcmVmaXhDbHMoKTtcbiAgdmFyIGNhY2hlS2V5ID0gXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1cIikuY29uY2F0KHBsYWNlbWVudCk7XG4gIHZhciBjYWNoZUluc3RhbmNlID0gbm90aWZpY2F0aW9uSW5zdGFuY2VbY2FjaGVLZXldO1xuICBpZiAoY2FjaGVJbnN0YW5jZSkge1xuICAgIFByb21pc2UucmVzb2x2ZShjYWNoZUluc3RhbmNlKS50aGVuKGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIHByZWZpeENsczogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1ub3RpY2VcIiksXG4gICAgICAgIGljb25QcmVmaXhDbHMsXG4gICAgICAgIGluc3RhbmNlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5vdGlmaWNhdGlvbkNsYXNzID0gY2xhc3NOYW1lcyhcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLVwiKS5jb25jYXQocGxhY2VtZW50KSwgX2RlZmluZVByb3BlcnR5JDEoe30sIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItcnRsXCIpLCBydGwkMSA9PT0gdHJ1ZSkpO1xuICBub3RpZmljYXRpb25JbnN0YW5jZVtjYWNoZUtleV0gPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgTm90aWZpY2F0aW9uLm5ld0luc3RhbmNlKHtcbiAgICAgIHByZWZpeENscyxcbiAgICAgIGNsYXNzTmFtZTogbm90aWZpY2F0aW9uQ2xhc3MsXG4gICAgICBzdHlsZTogZ2V0UGxhY2VtZW50U3R5bGUocGxhY2VtZW50LCB0b3AsIGJvdHRvbSksXG4gICAgICBnZXRDb250YWluZXI6IGdldENvbnRhaW5lcjIsXG4gICAgICBtYXhDb3VudDogbWF4Q291bnQkMVxuICAgIH0sIGZ1bmN0aW9uKG5vdGlmaWNhdGlvbjIpIHtcbiAgICAgIHJlc29sdmUobm90aWZpY2F0aW9uMik7XG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIHByZWZpeENsczogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1ub3RpY2VcIiksXG4gICAgICAgIGljb25QcmVmaXhDbHMsXG4gICAgICAgIGluc3RhbmNlOiBub3RpZmljYXRpb24yXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG52YXIgdHlwZVRvSWNvbiQxID0ge1xuICBzdWNjZXNzOiBDaGVja0NpcmNsZU91dGxpbmVkJDEsXG4gIGluZm86IEluZm9DaXJjbGVPdXRsaW5lZCQxLFxuICBlcnJvcjogQ2xvc2VDaXJjbGVPdXRsaW5lZCQxLFxuICB3YXJuaW5nOiBFeGNsYW1hdGlvbkNpcmNsZU91dGxpbmVkJDFcbn07XG5mdW5jdGlvbiBnZXRSQ05vdGljZVByb3BzJDEoYXJncywgcHJlZml4Q2xzLCBpY29uUHJlZml4Q2xzKSB7XG4gIHZhciBkdXJhdGlvbkFyZyA9IGFyZ3MuZHVyYXRpb24sIGljb24gPSBhcmdzLmljb24sIHR5cGU0ID0gYXJncy50eXBlLCBkZXNjcmlwdGlvbiA9IGFyZ3MuZGVzY3JpcHRpb24sIG1lc3NhZ2UyID0gYXJncy5tZXNzYWdlLCBidG4gPSBhcmdzLmJ0biwgb25DbG9zZTIgPSBhcmdzLm9uQ2xvc2UsIG9uQ2xpY2sgPSBhcmdzLm9uQ2xpY2ssIGtleTIgPSBhcmdzLmtleSwgc3R5bGUyID0gYXJncy5zdHlsZSwgY2xhc3NOYW1lID0gYXJncy5jbGFzc05hbWUsIF9hcmdzJGNsb3NlSWNvbiA9IGFyZ3MuY2xvc2VJY29uLCBjbG9zZUljb24gPSBfYXJncyRjbG9zZUljb24gPT09IHZvaWQgMCA/IGRlZmF1bHRDbG9zZUljb24gOiBfYXJncyRjbG9zZUljb247XG4gIHZhciBkdXJhdGlvbiA9IGR1cmF0aW9uQXJnID09PSB2b2lkIDAgPyBkZWZhdWx0RHVyYXRpb24kMSA6IGR1cmF0aW9uQXJnO1xuICB2YXIgaWNvbk5vZGUgPSBudWxsO1xuICBpZiAoaWNvbikge1xuICAgIGljb25Ob2RlID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1pY29uXCIpXG4gICAgfSwgYXJncy5pY29uKTtcbiAgfSBlbHNlIGlmICh0eXBlNCkge1xuICAgIGljb25Ob2RlID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQodHlwZVRvSWNvbiQxW3R5cGU0XSB8fCBudWxsLCB7XG4gICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItaWNvbiBcIikuY29uY2F0KHByZWZpeENscywgXCItaWNvbi1cIikuY29uY2F0KHR5cGU0KVxuICAgIH0pO1xuICB9XG4gIHZhciBjbG9zZUljb25Ub1JlbmRlciA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWNsb3NlLXhcIilcbiAgfSwgY2xvc2VJY29uIHx8IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENsb3NlT3V0bGluZWQkMSwge1xuICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1jbG9zZS1pY29uXCIpXG4gIH0pKTtcbiAgdmFyIGF1dG9NYXJnaW5UYWcgPSAhZGVzY3JpcHRpb24gJiYgaWNvbk5vZGUgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1tZXNzYWdlLXNpbmdsZS1saW5lLWF1dG8tbWFyZ2luXCIpXG4gIH0pIDogbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBjb250ZW50OiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb25maWdQcm92aWRlciwge1xuICAgICAgaWNvblByZWZpeENsc1xuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogaWNvbk5vZGUgPyBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXdpdGgtaWNvblwiKSA6IFwiXCIsXG4gICAgICByb2xlOiBcImFsZXJ0XCJcbiAgICB9LCBpY29uTm9kZSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLW1lc3NhZ2VcIilcbiAgICB9LCBhdXRvTWFyZ2luVGFnLCBtZXNzYWdlMiksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1kZXNjcmlwdGlvblwiKVxuICAgIH0sIGRlc2NyaXB0aW9uKSwgYnRuID8gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1idG5cIilcbiAgICB9LCBidG4pIDogbnVsbCkpLFxuICAgIGR1cmF0aW9uLFxuICAgIGNsb3NhYmxlOiB0cnVlLFxuICAgIGNsb3NlSWNvbjogY2xvc2VJY29uVG9SZW5kZXIsXG4gICAgb25DbG9zZTogb25DbG9zZTIsXG4gICAgb25DbGljayxcbiAgICBrZXk6IGtleTIsXG4gICAgc3R5bGU6IHN0eWxlMiB8fCB7fSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoY2xhc3NOYW1lLCBfZGVmaW5lUHJvcGVydHkkMSh7fSwgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1cIikuY29uY2F0KHR5cGU0KSwgISF0eXBlNCkpXG4gIH07XG59XG5mdW5jdGlvbiBub3RpY2UkMShhcmdzKSB7XG4gIGdldE5vdGlmaWNhdGlvbkluc3RhbmNlKGFyZ3MsIGZ1bmN0aW9uKF9yZWYpIHtcbiAgICB2YXIgcHJlZml4Q2xzID0gX3JlZi5wcmVmaXhDbHMsIGljb25QcmVmaXhDbHMgPSBfcmVmLmljb25QcmVmaXhDbHMsIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICBpbnN0YW5jZS5ub3RpY2UoZ2V0UkNOb3RpY2VQcm9wcyQxKGFyZ3MsIHByZWZpeENscywgaWNvblByZWZpeENscykpO1xuICB9KTtcbn1cbnZhciBhcGkkMSA9IHtcbiAgb3Blbjogbm90aWNlJDEsXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZShrZXkyKSB7XG4gICAgT2JqZWN0LmtleXMobm90aWZpY2F0aW9uSW5zdGFuY2UpLmZvckVhY2goZnVuY3Rpb24oY2FjaGVLZXkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobm90aWZpY2F0aW9uSW5zdGFuY2VbY2FjaGVLZXldKS50aGVuKGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbW92ZU5vdGljZShrZXkyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBjb25maWc6IHNldE5vdGlmaWNhdGlvbkNvbmZpZyxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBPYmplY3Qua2V5cyhub3RpZmljYXRpb25JbnN0YW5jZSkuZm9yRWFjaChmdW5jdGlvbihjYWNoZUtleSkge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKG5vdGlmaWNhdGlvbkluc3RhbmNlW2NhY2hlS2V5XSkudGhlbihmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBub3RpZmljYXRpb25JbnN0YW5jZVtjYWNoZUtleV07XG4gICAgfSk7XG4gIH1cbn07XG5bXCJzdWNjZXNzXCIsIFwiaW5mb1wiLCBcIndhcm5pbmdcIiwgXCJlcnJvclwiXS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGU0KSB7XG4gIGFwaSQxW3R5cGU0XSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICByZXR1cm4gYXBpJDEub3BlbihfZXh0ZW5kcyQxKF9leHRlbmRzJDEoe30sIGFyZ3MpLCB7XG4gICAgICB0eXBlOiB0eXBlNFxuICAgIH0pKTtcbiAgfTtcbn0pO1xuYXBpJDEud2FybiA9IGFwaSQxLndhcm5pbmc7XG5hcGkkMS51c2VOb3RpZmljYXRpb24gPSBjcmVhdGVVc2VOb3RpZmljYXRpb24oZ2V0Tm90aWZpY2F0aW9uSW5zdGFuY2UsIGdldFJDTm90aWNlUHJvcHMkMSk7XG52YXIgbm90aWZpY2F0aW9uID0gYXBpJDE7XG52YXIgZHluYW1pY1N0eWxlTWFyayA9IFwiLWFudC1cIi5jb25jYXQoRGF0ZS5ub3coKSwgXCItXCIpLmNvbmNhdChNYXRoLnJhbmRvbSgpKTtcbmZ1bmN0aW9uIHJlZ2lzdGVyVGhlbWUoZ2xvYmFsUHJlZml4Q2xzMiwgdGhlbWUpIHtcbiAgdmFyIHZhcmlhYmxlcyA9IHt9O1xuICB2YXIgZm9ybWF0Q29sb3IgPSBmdW5jdGlvbiBmb3JtYXRDb2xvcjIoY29sb3IsIHVwZGF0ZXIpIHtcbiAgICB2YXIgY2xvbmUyID0gY29sb3IuY2xvbmUoKTtcbiAgICBjbG9uZTIgPSAodXBkYXRlciA9PT0gbnVsbCB8fCB1cGRhdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1cGRhdGVyKGNsb25lMikpIHx8IGNsb25lMjtcbiAgICByZXR1cm4gY2xvbmUyLnRvUmdiU3RyaW5nKCk7XG4gIH07XG4gIHZhciBmaWxsQ29sb3IgPSBmdW5jdGlvbiBmaWxsQ29sb3IyKGNvbG9yVmFsLCB0eXBlNCkge1xuICAgIHZhciBiYXNlQ29sb3IgPSBuZXcgVGlueUNvbG9yKGNvbG9yVmFsKTtcbiAgICB2YXIgY29sb3JQYWxldHRlcyA9IGdlbmVyYXRlJDEoYmFzZUNvbG9yLnRvUmdiU3RyaW5nKCkpO1xuICAgIHZhcmlhYmxlc1tcIlwiLmNvbmNhdCh0eXBlNCwgXCItY29sb3JcIildID0gZm9ybWF0Q29sb3IoYmFzZUNvbG9yKTtcbiAgICB2YXJpYWJsZXNbXCJcIi5jb25jYXQodHlwZTQsIFwiLWNvbG9yLWRpc2FibGVkXCIpXSA9IGNvbG9yUGFsZXR0ZXNbMV07XG4gICAgdmFyaWFibGVzW1wiXCIuY29uY2F0KHR5cGU0LCBcIi1jb2xvci1ob3ZlclwiKV0gPSBjb2xvclBhbGV0dGVzWzRdO1xuICAgIHZhcmlhYmxlc1tcIlwiLmNvbmNhdCh0eXBlNCwgXCItY29sb3ItYWN0aXZlXCIpXSA9IGNvbG9yUGFsZXR0ZXNbN107XG4gICAgdmFyaWFibGVzW1wiXCIuY29uY2F0KHR5cGU0LCBcIi1jb2xvci1vdXRsaW5lXCIpXSA9IGJhc2VDb2xvci5jbG9uZSgpLnNldEFscGhhKDAuMikudG9SZ2JTdHJpbmcoKTtcbiAgICB2YXJpYWJsZXNbXCJcIi5jb25jYXQodHlwZTQsIFwiLWNvbG9yLWRlcHJlY2F0ZWQtYmdcIildID0gY29sb3JQYWxldHRlc1sxXTtcbiAgICB2YXJpYWJsZXNbXCJcIi5jb25jYXQodHlwZTQsIFwiLWNvbG9yLWRlcHJlY2F0ZWQtYm9yZGVyXCIpXSA9IGNvbG9yUGFsZXR0ZXNbM107XG4gIH07XG4gIGlmICh0aGVtZS5wcmltYXJ5Q29sb3IpIHtcbiAgICBmaWxsQ29sb3IodGhlbWUucHJpbWFyeUNvbG9yLCBcInByaW1hcnlcIik7XG4gICAgdmFyIHByaW1hcnlDb2xvciA9IG5ldyBUaW55Q29sb3IodGhlbWUucHJpbWFyeUNvbG9yKTtcbiAgICB2YXIgcHJpbWFyeUNvbG9ycyA9IGdlbmVyYXRlJDEocHJpbWFyeUNvbG9yLnRvUmdiU3RyaW5nKCkpO1xuICAgIHByaW1hcnlDb2xvcnMuZm9yRWFjaChmdW5jdGlvbihjb2xvciwgaW5kZXgyKSB7XG4gICAgICB2YXJpYWJsZXNbXCJwcmltYXJ5LVwiLmNvbmNhdChpbmRleDIgKyAxKV0gPSBjb2xvcjtcbiAgICB9KTtcbiAgICB2YXJpYWJsZXNbXCJwcmltYXJ5LWNvbG9yLWRlcHJlY2F0ZWQtbC0zNVwiXSA9IGZvcm1hdENvbG9yKHByaW1hcnlDb2xvciwgZnVuY3Rpb24oYzIpIHtcbiAgICAgIHJldHVybiBjMi5saWdodGVuKDM1KTtcbiAgICB9KTtcbiAgICB2YXJpYWJsZXNbXCJwcmltYXJ5LWNvbG9yLWRlcHJlY2F0ZWQtbC0yMFwiXSA9IGZvcm1hdENvbG9yKHByaW1hcnlDb2xvciwgZnVuY3Rpb24oYzIpIHtcbiAgICAgIHJldHVybiBjMi5saWdodGVuKDIwKTtcbiAgICB9KTtcbiAgICB2YXJpYWJsZXNbXCJwcmltYXJ5LWNvbG9yLWRlcHJlY2F0ZWQtdC0yMFwiXSA9IGZvcm1hdENvbG9yKHByaW1hcnlDb2xvciwgZnVuY3Rpb24oYzIpIHtcbiAgICAgIHJldHVybiBjMi50aW50KDIwKTtcbiAgICB9KTtcbiAgICB2YXJpYWJsZXNbXCJwcmltYXJ5LWNvbG9yLWRlcHJlY2F0ZWQtdC01MFwiXSA9IGZvcm1hdENvbG9yKHByaW1hcnlDb2xvciwgZnVuY3Rpb24oYzIpIHtcbiAgICAgIHJldHVybiBjMi50aW50KDUwKTtcbiAgICB9KTtcbiAgICB2YXJpYWJsZXNbXCJwcmltYXJ5LWNvbG9yLWRlcHJlY2F0ZWQtZi0xMlwiXSA9IGZvcm1hdENvbG9yKHByaW1hcnlDb2xvciwgZnVuY3Rpb24oYzIpIHtcbiAgICAgIHJldHVybiBjMi5zZXRBbHBoYShjMi5nZXRBbHBoYSgpICogMC4xMik7XG4gICAgfSk7XG4gICAgdmFyIHByaW1hcnlBY3RpdmVDb2xvciA9IG5ldyBUaW55Q29sb3IocHJpbWFyeUNvbG9yc1swXSk7XG4gICAgdmFyaWFibGVzW1wicHJpbWFyeS1jb2xvci1hY3RpdmUtZGVwcmVjYXRlZC1mLTMwXCJdID0gZm9ybWF0Q29sb3IocHJpbWFyeUFjdGl2ZUNvbG9yLCBmdW5jdGlvbihjMikge1xuICAgICAgcmV0dXJuIGMyLnNldEFscGhhKGMyLmdldEFscGhhKCkgKiAwLjMpO1xuICAgIH0pO1xuICAgIHZhcmlhYmxlc1tcInByaW1hcnktY29sb3ItYWN0aXZlLWRlcHJlY2F0ZWQtZC0wMlwiXSA9IGZvcm1hdENvbG9yKHByaW1hcnlBY3RpdmVDb2xvciwgZnVuY3Rpb24oYzIpIHtcbiAgICAgIHJldHVybiBjMi5kYXJrZW4oMik7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHRoZW1lLnN1Y2Nlc3NDb2xvcikge1xuICAgIGZpbGxDb2xvcih0aGVtZS5zdWNjZXNzQ29sb3IsIFwic3VjY2Vzc1wiKTtcbiAgfVxuICBpZiAodGhlbWUud2FybmluZ0NvbG9yKSB7XG4gICAgZmlsbENvbG9yKHRoZW1lLndhcm5pbmdDb2xvciwgXCJ3YXJuaW5nXCIpO1xuICB9XG4gIGlmICh0aGVtZS5lcnJvckNvbG9yKSB7XG4gICAgZmlsbENvbG9yKHRoZW1lLmVycm9yQ29sb3IsIFwiZXJyb3JcIik7XG4gIH1cbiAgaWYgKHRoZW1lLmluZm9Db2xvcikge1xuICAgIGZpbGxDb2xvcih0aGVtZS5pbmZvQ29sb3IsIFwiaW5mb1wiKTtcbiAgfVxuICB2YXIgY3NzTGlzdCA9IE9iamVjdC5rZXlzKHZhcmlhYmxlcykubWFwKGZ1bmN0aW9uKGtleTIpIHtcbiAgICByZXR1cm4gXCItLVwiLmNvbmNhdChnbG9iYWxQcmVmaXhDbHMyLCBcIi1cIikuY29uY2F0KGtleTIsIFwiOiBcIikuY29uY2F0KHZhcmlhYmxlc1trZXkyXSwgXCI7XCIpO1xuICB9KTtcbiAgaWYgKGNhblVzZURvbSgpKSB7XG4gICAgdXBkYXRlQ1NTKFwiXFxuICA6cm9vdCB7XFxuICAgIFwiLmNvbmNhdChjc3NMaXN0LmpvaW4oXCJcXG5cIiksIFwiXFxuICB9XFxuICBcIiksIFwiXCIuY29uY2F0KGR5bmFtaWNTdHlsZU1hcmssIFwiLWR5bmFtaWMtdGhlbWVcIikpO1xuICB9IGVsc2Uge1xuICAgIGRldldhcm5pbmcoZmFsc2UsIFwiQ29uZmlnUHJvdmlkZXJcIiwgXCJTU1IgZG8gbm90IHN1cHBvcnQgZHluYW1pYyB0aGVtZSB3aXRoIGNzcyB2YXJpYWJsZXMuXCIpO1xuICB9XG59XG52YXIgUEFTU0VEX1BST1BTID0gW1wiZ2V0VGFyZ2V0Q29udGFpbmVyXCIsIFwiZ2V0UG9wdXBDb250YWluZXJcIiwgXCJyZW5kZXJFbXB0eVwiLCBcInBhZ2VIZWFkZXJcIiwgXCJpbnB1dFwiLCBcImZvcm1cIl07XG52YXIgZGVmYXVsdFByZWZpeENscyA9IFwiYW50XCI7XG52YXIgZGVmYXVsdEljb25QcmVmaXhDbHMgPSBcImFudGljb25cIjtcbnZhciBnbG9iYWxQcmVmaXhDbHM7XG52YXIgZ2xvYmFsSWNvblByZWZpeENscztcbmZ1bmN0aW9uIGdldEdsb2JhbFByZWZpeENscygpIHtcbiAgcmV0dXJuIGdsb2JhbFByZWZpeENscyB8fCBkZWZhdWx0UHJlZml4Q2xzO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsSWNvblByZWZpeENscygpIHtcbiAgcmV0dXJuIGdsb2JhbEljb25QcmVmaXhDbHMgfHwgZGVmYXVsdEljb25QcmVmaXhDbHM7XG59XG52YXIgc2V0R2xvYmFsQ29uZmlnID0gZnVuY3Rpb24gc2V0R2xvYmFsQ29uZmlnMihfcmVmKSB7XG4gIHZhciBwcmVmaXhDbHMgPSBfcmVmLnByZWZpeENscywgaWNvblByZWZpeENscyA9IF9yZWYuaWNvblByZWZpeENscywgdGhlbWUgPSBfcmVmLnRoZW1lO1xuICBpZiAocHJlZml4Q2xzICE9PSB2b2lkIDApIHtcbiAgICBnbG9iYWxQcmVmaXhDbHMgPSBwcmVmaXhDbHM7XG4gIH1cbiAgaWYgKGljb25QcmVmaXhDbHMgIT09IHZvaWQgMCkge1xuICAgIGdsb2JhbEljb25QcmVmaXhDbHMgPSBpY29uUHJlZml4Q2xzO1xuICB9XG4gIGlmICh0aGVtZSkge1xuICAgIHJlZ2lzdGVyVGhlbWUoZ2V0R2xvYmFsUHJlZml4Q2xzKCksIHRoZW1lKTtcbiAgfVxufTtcbnZhciBnbG9iYWxDb25maWcgPSBmdW5jdGlvbiBnbG9iYWxDb25maWcyKCkge1xuICByZXR1cm4ge1xuICAgIGdldFByZWZpeENsczogZnVuY3Rpb24gZ2V0UHJlZml4Q2xzKHN1ZmZpeENscywgY3VzdG9taXplUHJlZml4Q2xzKSB7XG4gICAgICBpZiAoY3VzdG9taXplUHJlZml4Q2xzKVxuICAgICAgICByZXR1cm4gY3VzdG9taXplUHJlZml4Q2xzO1xuICAgICAgcmV0dXJuIHN1ZmZpeENscyA/IFwiXCIuY29uY2F0KGdldEdsb2JhbFByZWZpeENscygpLCBcIi1cIikuY29uY2F0KHN1ZmZpeENscykgOiBnZXRHbG9iYWxQcmVmaXhDbHMoKTtcbiAgICB9LFxuICAgIGdldEljb25QcmVmaXhDbHM6IGdldEdsb2JhbEljb25QcmVmaXhDbHMsXG4gICAgZ2V0Um9vdFByZWZpeENsczogZnVuY3Rpb24gZ2V0Um9vdFByZWZpeENscyhyb290UHJlZml4Q2xzLCBjdXN0b21pemVQcmVmaXhDbHMpIHtcbiAgICAgIGlmIChyb290UHJlZml4Q2xzKSB7XG4gICAgICAgIHJldHVybiByb290UHJlZml4Q2xzO1xuICAgICAgfVxuICAgICAgaWYgKGdsb2JhbFByZWZpeENscykge1xuICAgICAgICByZXR1cm4gZ2xvYmFsUHJlZml4Q2xzO1xuICAgICAgfVxuICAgICAgaWYgKGN1c3RvbWl6ZVByZWZpeENscyAmJiBjdXN0b21pemVQcmVmaXhDbHMuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgICAgIHJldHVybiBjdXN0b21pemVQcmVmaXhDbHMucmVwbGFjZSgvXiguKiktW14tXSokLywgXCIkMVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRHbG9iYWxQcmVmaXhDbHMoKTtcbiAgICB9XG4gIH07XG59O1xudmFyIFByb3ZpZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbiBQcm92aWRlckNoaWxkcmVuMihwcm9wcykge1xuICB2YXIgX2EsIF9iO1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbiwgY3NwID0gcHJvcHMuY3NwLCBhdXRvSW5zZXJ0U3BhY2VJbkJ1dHRvbiA9IHByb3BzLmF1dG9JbnNlcnRTcGFjZUluQnV0dG9uLCBmb3JtID0gcHJvcHMuZm9ybSwgbG9jYWxlMiA9IHByb3BzLmxvY2FsZSwgY29tcG9uZW50U2l6ZSA9IHByb3BzLmNvbXBvbmVudFNpemUsIGRpcmVjdGlvbiA9IHByb3BzLmRpcmVjdGlvbiwgc3BhY2UgPSBwcm9wcy5zcGFjZSwgdmlydHVhbCA9IHByb3BzLnZpcnR1YWwsIGRyb3Bkb3duTWF0Y2hTZWxlY3RXaWR0aCA9IHByb3BzLmRyb3Bkb3duTWF0Y2hTZWxlY3RXaWR0aCwgbGVnYWN5TG9jYWxlID0gcHJvcHMubGVnYWN5TG9jYWxlLCBwYXJlbnRDb250ZXh0ID0gcHJvcHMucGFyZW50Q29udGV4dCwgaWNvblByZWZpeENscyA9IHByb3BzLmljb25QcmVmaXhDbHM7XG4gIHZhciBnZXRQcmVmaXhDbHMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbihzdWZmaXhDbHMsIGN1c3RvbWl6ZVByZWZpeENscykge1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgaWYgKGN1c3RvbWl6ZVByZWZpeENscylcbiAgICAgIHJldHVybiBjdXN0b21pemVQcmVmaXhDbHM7XG4gICAgdmFyIG1lcmdlZFByZWZpeENscyA9IHByZWZpeENscyB8fCBwYXJlbnRDb250ZXh0LmdldFByZWZpeENscyhcIlwiKTtcbiAgICByZXR1cm4gc3VmZml4Q2xzID8gXCJcIi5jb25jYXQobWVyZ2VkUHJlZml4Q2xzLCBcIi1cIikuY29uY2F0KHN1ZmZpeENscykgOiBtZXJnZWRQcmVmaXhDbHM7XG4gIH0sIFtwYXJlbnRDb250ZXh0LmdldFByZWZpeENscywgcHJvcHMucHJlZml4Q2xzXSk7XG4gIHZhciBjb25maWcgPSBfZXh0ZW5kcyQxKF9leHRlbmRzJDEoe30sIHBhcmVudENvbnRleHQpLCB7XG4gICAgY3NwLFxuICAgIGF1dG9JbnNlcnRTcGFjZUluQnV0dG9uLFxuICAgIGxvY2FsZTogbG9jYWxlMiB8fCBsZWdhY3lMb2NhbGUsXG4gICAgZGlyZWN0aW9uLFxuICAgIHNwYWNlLFxuICAgIHZpcnR1YWwsXG4gICAgZHJvcGRvd25NYXRjaFNlbGVjdFdpZHRoLFxuICAgIGdldFByZWZpeENsc1xuICB9KTtcbiAgUEFTU0VEX1BST1BTLmZvckVhY2goZnVuY3Rpb24ocHJvcE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgIGNvbmZpZ1twcm9wTmFtZV0gPSBwcm9wVmFsdWU7XG4gICAgfVxuICB9KTtcbiAgdmFyIG1lbW9lZENvbmZpZyA9IHVzZU1lbW8oZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfSwgY29uZmlnLCBmdW5jdGlvbihwcmV2Q29uZmlnLCBjdXJyZW50Q29uZmlnKSB7XG4gICAgdmFyIHByZXZLZXlzID0gT2JqZWN0LmtleXMocHJldkNvbmZpZyk7XG4gICAgdmFyIGN1cnJlbnRLZXlzID0gT2JqZWN0LmtleXMoY3VycmVudENvbmZpZyk7XG4gICAgcmV0dXJuIHByZXZLZXlzLmxlbmd0aCAhPT0gY3VycmVudEtleXMubGVuZ3RoIHx8IHByZXZLZXlzLnNvbWUoZnVuY3Rpb24oa2V5Mikge1xuICAgICAgcmV0dXJuIHByZXZDb25maWdba2V5Ml0gIT09IGN1cnJlbnRDb25maWdba2V5Ml07XG4gICAgfSk7XG4gIH0pO1xuICB2YXIgbWVtb0ljb25Db250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXhDbHM6IGljb25QcmVmaXhDbHMsXG4gICAgICBjc3BcbiAgICB9O1xuICB9LCBbaWNvblByZWZpeENsc10pO1xuICB2YXIgY2hpbGROb2RlID0gY2hpbGRyZW47XG4gIHZhciB2YWxpZGF0ZU1lc3NhZ2VzID0ge307XG4gIGlmIChsb2NhbGUyKSB7XG4gICAgdmFsaWRhdGVNZXNzYWdlcyA9ICgoX2EgPSBsb2NhbGUyLkZvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0VmFsaWRhdGVNZXNzYWdlcykgfHwgKChfYiA9IGRlZmF1bHRMb2NhbGUuRm9ybSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlZmF1bHRWYWxpZGF0ZU1lc3NhZ2VzKSB8fCB7fTtcbiAgfVxuICBpZiAoZm9ybSAmJiBmb3JtLnZhbGlkYXRlTWVzc2FnZXMpIHtcbiAgICB2YWxpZGF0ZU1lc3NhZ2VzID0gX2V4dGVuZHMkMShfZXh0ZW5kcyQxKHt9LCB2YWxpZGF0ZU1lc3NhZ2VzKSwgZm9ybS52YWxpZGF0ZU1lc3NhZ2VzKTtcbiAgfVxuICBpZiAoT2JqZWN0LmtleXModmFsaWRhdGVNZXNzYWdlcykubGVuZ3RoID4gMCkge1xuICAgIGNoaWxkTm9kZSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1Qcm92aWRlciwge1xuICAgICAgdmFsaWRhdGVNZXNzYWdlc1xuICAgIH0sIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAobG9jYWxlMikge1xuICAgIGNoaWxkTm9kZSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KExvY2FsZVByb3ZpZGVyLCB7XG4gICAgICBsb2NhbGU6IGxvY2FsZTIsXG4gICAgICBfQU5UX01BUktfXzogQU5UX01BUktcbiAgICB9LCBjaGlsZE5vZGUpO1xuICB9XG4gIGlmIChpY29uUHJlZml4Q2xzKSB7XG4gICAgY2hpbGROb2RlID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkNvbnRleHQkMS5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IG1lbW9JY29uQ29udGV4dFZhbHVlXG4gICAgfSwgY2hpbGROb2RlKTtcbiAgfVxuICBpZiAoY29tcG9uZW50U2l6ZSkge1xuICAgIGNoaWxkTm9kZSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFNpemVDb250ZXh0UHJvdmlkZXIsIHtcbiAgICAgIHNpemU6IGNvbXBvbmVudFNpemVcbiAgICB9LCBjaGlsZE5vZGUpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb25maWdDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG1lbW9lZENvbmZpZ1xuICB9LCBjaGlsZE5vZGUpO1xufTtcbnZhciBDb25maWdQcm92aWRlciA9IGZ1bmN0aW9uIENvbmZpZ1Byb3ZpZGVyMihwcm9wcykge1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHByb3BzLmRpcmVjdGlvbikge1xuICAgICAgbWVzc2FnZS5jb25maWcoe1xuICAgICAgICBydGw6IHByb3BzLmRpcmVjdGlvbiA9PT0gXCJydGxcIlxuICAgICAgfSk7XG4gICAgICBub3RpZmljYXRpb24uY29uZmlnKHtcbiAgICAgICAgcnRsOiBwcm9wcy5kaXJlY3Rpb24gPT09IFwicnRsXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW3Byb3BzLmRpcmVjdGlvbl0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTG9jYWxlUmVjZWl2ZXIsIG51bGwsIGZ1bmN0aW9uKF8sIF9fLCBsZWdhY3lMb2NhbGUpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29uZmlnQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChQcm92aWRlckNoaWxkcmVuLCBfZXh0ZW5kcyQxKHtcbiAgICAgICAgcGFyZW50Q29udGV4dDogY29udGV4dCxcbiAgICAgICAgbGVnYWN5TG9jYWxlXG4gICAgICB9LCBwcm9wcykpO1xuICAgIH0pO1xuICB9KTtcbn07XG5Db25maWdQcm92aWRlci5Db25maWdDb250ZXh0ID0gQ29uZmlnQ29udGV4dDtcbkNvbmZpZ1Byb3ZpZGVyLlNpemVDb250ZXh0ID0gU2l6ZUNvbnRleHQkMTtcbkNvbmZpZ1Byb3ZpZGVyLmNvbmZpZyA9IHNldEdsb2JhbENvbmZpZztcbmZ1bmN0aW9uIGNyZWF0ZVVzZU1lc3NhZ2UoZ2V0UmNOb3RpZmljYXRpb25JbnN0YW5jZSwgZ2V0UkNOb3RpY2VQcm9wczIpIHtcbiAgdmFyIHVzZU1lc3NhZ2UgPSBmdW5jdGlvbiB1c2VNZXNzYWdlMigpIHtcbiAgICB2YXIgZ2V0UHJlZml4Q2xzO1xuICAgIHZhciBnZXRQb3B1cENvbnRhaW5lcjtcbiAgICB2YXIgaW5uZXJJbnN0YW5jZSA9IG51bGw7XG4gICAgdmFyIHByb3h5ID0ge1xuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQobm90aWNlUHJvcHMsIGhvbGRlckNhbGxiYWNrKSB7XG4gICAgICAgIGlubmVySW5zdGFuY2UgPT09IG51bGwgfHwgaW5uZXJJbnN0YW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5uZXJJbnN0YW5jZS5jb21wb25lbnQuYWRkKG5vdGljZVByb3BzLCBob2xkZXJDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgX3VzZVJDTm90aWZpY2F0aW9uID0gdXNlTm90aWZpY2F0aW9uKHByb3h5KSwgX3VzZVJDTm90aWZpY2F0aW9uMiA9IF9zbGljZWRUb0FycmF5KF91c2VSQ05vdGlmaWNhdGlvbiwgMiksIGhvb2tOb3RpZnkgPSBfdXNlUkNOb3RpZmljYXRpb24yWzBdLCBob2xkZXIgPSBfdXNlUkNOb3RpZmljYXRpb24yWzFdO1xuICAgIGZ1bmN0aW9uIG5vdGlmeShhcmdzKSB7XG4gICAgICB2YXIgY3VzdG9taXplUHJlZml4Q2xzID0gYXJncy5wcmVmaXhDbHM7XG4gICAgICB2YXIgbWVyZ2VkUHJlZml4Q2xzID0gZ2V0UHJlZml4Q2xzKFwibWVzc2FnZVwiLCBjdXN0b21pemVQcmVmaXhDbHMpO1xuICAgICAgdmFyIHJvb3RQcmVmaXhDbHMgPSBnZXRQcmVmaXhDbHMoKTtcbiAgICAgIHZhciB0YXJnZXQgPSBhcmdzLmtleSB8fCBnZXRLZXlUaGVuSW5jcmVhc2VLZXkoKTtcbiAgICAgIHZhciBjbG9zZVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrMigpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZ3Mub25DbG9zZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhcmdzLm9uQ2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGdldFJjTm90aWZpY2F0aW9uSW5zdGFuY2UoX2V4dGVuZHMkMShfZXh0ZW5kcyQxKHt9LCBhcmdzKSwge1xuICAgICAgICAgIHByZWZpeENsczogbWVyZ2VkUHJlZml4Q2xzLFxuICAgICAgICAgIHJvb3RQcmVmaXhDbHMsXG4gICAgICAgICAgZ2V0UG9wdXBDb250YWluZXJcbiAgICAgICAgfSksIGZ1bmN0aW9uKF9yZWYpIHtcbiAgICAgICAgICB2YXIgcHJlZml4Q2xzID0gX3JlZi5wcmVmaXhDbHMsIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICAgICAgICBpbm5lckluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgICAgaG9va05vdGlmeShnZXRSQ05vdGljZVByb3BzMihfZXh0ZW5kcyQxKF9leHRlbmRzJDEoe30sIGFyZ3MpLCB7XG4gICAgICAgICAgICBrZXk6IHRhcmdldCxcbiAgICAgICAgICAgIG9uQ2xvc2U6IGNhbGxiYWNrXG4gICAgICAgICAgfSksIHByZWZpeENscykpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uIHJlc3VsdDIoKSB7XG4gICAgICAgIGlmIChpbm5lckluc3RhbmNlKSB7XG4gICAgICAgICAgaW5uZXJJbnN0YW5jZS5yZW1vdmVOb3RpY2UodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlc3VsdC50aGVuID0gZnVuY3Rpb24oZmlsbGVkLCByZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gY2xvc2VQcm9taXNlLnRoZW4oZmlsbGVkLCByZWplY3RlZCk7XG4gICAgICB9O1xuICAgICAgcmVzdWx0LnByb21pc2UgPSBjbG9zZVByb21pc2U7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2YXIgaG9va0FwaVJlZiA9IFJlYWN0LnVzZVJlZih7fSk7XG4gICAgaG9va0FwaVJlZi5jdXJyZW50Lm9wZW4gPSBub3RpZnk7XG4gICAgW1wic3VjY2Vzc1wiLCBcImluZm9cIiwgXCJ3YXJuaW5nXCIsIFwiZXJyb3JcIiwgXCJsb2FkaW5nXCJdLmZvckVhY2goZnVuY3Rpb24odHlwZTQpIHtcbiAgICAgIHJldHVybiBhdHRhY2hUeXBlQXBpKGhvb2tBcGlSZWYuY3VycmVudCwgdHlwZTQpO1xuICAgIH0pO1xuICAgIHJldHVybiBbaG9va0FwaVJlZi5jdXJyZW50LCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb25maWdDb25zdW1lciwge1xuICAgICAga2V5OiBcImhvbGRlclwiXG4gICAgfSwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgZ2V0UHJlZml4Q2xzID0gY29udGV4dC5nZXRQcmVmaXhDbHM7XG4gICAgICBnZXRQb3B1cENvbnRhaW5lciA9IGNvbnRleHQuZ2V0UG9wdXBDb250YWluZXI7XG4gICAgICByZXR1cm4gaG9sZGVyO1xuICAgIH0pXTtcbiAgfTtcbiAgcmV0dXJuIHVzZU1lc3NhZ2U7XG59XG52YXIgbWVzc2FnZUluc3RhbmNlO1xudmFyIGRlZmF1bHREdXJhdGlvbiA9IDM7XG52YXIgZGVmYXVsdFRvcDtcbnZhciBrZXkgPSAxO1xudmFyIGxvY2FsUHJlZml4Q2xzID0gXCJcIjtcbnZhciB0cmFuc2l0aW9uTmFtZSA9IFwibW92ZS11cFwiO1xudmFyIGhhc1RyYW5zaXRpb25OYW1lID0gZmFsc2U7XG52YXIgZ2V0Q29udGFpbmVyO1xudmFyIG1heENvdW50O1xudmFyIHJ0bCA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0S2V5VGhlbkluY3JlYXNlS2V5KCkge1xuICByZXR1cm4ga2V5Kys7XG59XG5mdW5jdGlvbiBzZXRNZXNzYWdlQ29uZmlnKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMudG9wICE9PSB2b2lkIDApIHtcbiAgICBkZWZhdWx0VG9wID0gb3B0aW9ucy50b3A7XG4gICAgbWVzc2FnZUluc3RhbmNlID0gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucy5kdXJhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgZGVmYXVsdER1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcbiAgfVxuICBpZiAob3B0aW9ucy5wcmVmaXhDbHMgIT09IHZvaWQgMCkge1xuICAgIGxvY2FsUHJlZml4Q2xzID0gb3B0aW9ucy5wcmVmaXhDbHM7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZ2V0Q29udGFpbmVyICE9PSB2b2lkIDApIHtcbiAgICBnZXRDb250YWluZXIgPSBvcHRpb25zLmdldENvbnRhaW5lcjtcbiAgICBtZXNzYWdlSW5zdGFuY2UgPSBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zLnRyYW5zaXRpb25OYW1lICE9PSB2b2lkIDApIHtcbiAgICB0cmFuc2l0aW9uTmFtZSA9IG9wdGlvbnMudHJhbnNpdGlvbk5hbWU7XG4gICAgbWVzc2FnZUluc3RhbmNlID0gbnVsbDtcbiAgICBoYXNUcmFuc2l0aW9uTmFtZSA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdGlvbnMubWF4Q291bnQgIT09IHZvaWQgMCkge1xuICAgIG1heENvdW50ID0gb3B0aW9ucy5tYXhDb3VudDtcbiAgICBtZXNzYWdlSW5zdGFuY2UgPSBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zLnJ0bCAhPT0gdm9pZCAwKSB7XG4gICAgcnRsID0gb3B0aW9ucy5ydGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJDTm90aWZpY2F0aW9uSW5zdGFuY2UoYXJncywgY2FsbGJhY2spIHtcbiAgdmFyIGN1c3RvbWl6ZVByZWZpeENscyA9IGFyZ3MucHJlZml4Q2xzLCBnZXRDb250ZXh0UG9wdXBDb250YWluZXIgPSBhcmdzLmdldFBvcHVwQ29udGFpbmVyO1xuICB2YXIgX2dsb2JhbENvbmZpZyA9IGdsb2JhbENvbmZpZygpLCBnZXRQcmVmaXhDbHMgPSBfZ2xvYmFsQ29uZmlnLmdldFByZWZpeENscywgZ2V0Um9vdFByZWZpeENscyA9IF9nbG9iYWxDb25maWcuZ2V0Um9vdFByZWZpeENscywgZ2V0SWNvblByZWZpeENscyA9IF9nbG9iYWxDb25maWcuZ2V0SWNvblByZWZpeENscztcbiAgdmFyIHByZWZpeENscyA9IGdldFByZWZpeENscyhcIm1lc3NhZ2VcIiwgY3VzdG9taXplUHJlZml4Q2xzIHx8IGxvY2FsUHJlZml4Q2xzKTtcbiAgdmFyIHJvb3RQcmVmaXhDbHMgPSBnZXRSb290UHJlZml4Q2xzKGFyZ3Mucm9vdFByZWZpeENscywgcHJlZml4Q2xzKTtcbiAgdmFyIGljb25QcmVmaXhDbHMgPSBnZXRJY29uUHJlZml4Q2xzKCk7XG4gIGlmIChtZXNzYWdlSW5zdGFuY2UpIHtcbiAgICBjYWxsYmFjayh7XG4gICAgICBwcmVmaXhDbHMsXG4gICAgICByb290UHJlZml4Q2xzLFxuICAgICAgaWNvblByZWZpeENscyxcbiAgICAgIGluc3RhbmNlOiBtZXNzYWdlSW5zdGFuY2VcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGluc3RhbmNlQ29uZmlnID0ge1xuICAgIHByZWZpeENscyxcbiAgICB0cmFuc2l0aW9uTmFtZTogaGFzVHJhbnNpdGlvbk5hbWUgPyB0cmFuc2l0aW9uTmFtZSA6IFwiXCIuY29uY2F0KHJvb3RQcmVmaXhDbHMsIFwiLVwiKS5jb25jYXQodHJhbnNpdGlvbk5hbWUpLFxuICAgIHN0eWxlOiB7XG4gICAgICB0b3A6IGRlZmF1bHRUb3BcbiAgICB9LFxuICAgIGdldENvbnRhaW5lcjogZ2V0Q29udGFpbmVyIHx8IGdldENvbnRleHRQb3B1cENvbnRhaW5lcixcbiAgICBtYXhDb3VudFxuICB9O1xuICBOb3RpZmljYXRpb24ubmV3SW5zdGFuY2UoaW5zdGFuY2VDb25maWcsIGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgaWYgKG1lc3NhZ2VJbnN0YW5jZSkge1xuICAgICAgY2FsbGJhY2soe1xuICAgICAgICBwcmVmaXhDbHMsXG4gICAgICAgIHJvb3RQcmVmaXhDbHMsXG4gICAgICAgIGljb25QcmVmaXhDbHMsXG4gICAgICAgIGluc3RhbmNlOiBtZXNzYWdlSW5zdGFuY2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZXNzYWdlSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICBjYWxsYmFjayh7XG4gICAgICBwcmVmaXhDbHMsXG4gICAgICByb290UHJlZml4Q2xzLFxuICAgICAgaWNvblByZWZpeENscyxcbiAgICAgIGluc3RhbmNlXG4gICAgfSk7XG4gIH0pO1xufVxudmFyIHR5cGVUb0ljb24gPSB7XG4gIGluZm86IEluZm9DaXJjbGVGaWxsZWQkMSxcbiAgc3VjY2VzczogQ2hlY2tDaXJjbGVGaWxsZWQkMSxcbiAgZXJyb3I6IENsb3NlQ2lyY2xlRmlsbGVkJDEsXG4gIHdhcm5pbmc6IEV4Y2xhbWF0aW9uQ2lyY2xlRmlsbGVkJDEsXG4gIGxvYWRpbmc6IExvYWRpbmdPdXRsaW5lZCQxXG59O1xuZnVuY3Rpb24gZ2V0UkNOb3RpY2VQcm9wcyhhcmdzLCBwcmVmaXhDbHMsIGljb25QcmVmaXhDbHMpIHtcbiAgdmFyIF9jbGFzc05hbWVzO1xuICB2YXIgZHVyYXRpb24gPSBhcmdzLmR1cmF0aW9uICE9PSB2b2lkIDAgPyBhcmdzLmR1cmF0aW9uIDogZGVmYXVsdER1cmF0aW9uO1xuICB2YXIgSWNvbkNvbXBvbmVudCA9IHR5cGVUb0ljb25bYXJncy50eXBlXTtcbiAgdmFyIG1lc3NhZ2VDbGFzcyA9IGNsYXNzTmFtZXMoXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1jdXN0b20tY29udGVudFwiKSwgKF9jbGFzc05hbWVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLVwiKS5jb25jYXQoYXJncy50eXBlKSwgYXJncy50eXBlKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItcnRsXCIpLCBydGwgPT09IHRydWUpLCBfY2xhc3NOYW1lcykpO1xuICByZXR1cm4ge1xuICAgIGtleTogYXJncy5rZXksXG4gICAgZHVyYXRpb24sXG4gICAgc3R5bGU6IGFyZ3Muc3R5bGUgfHwge30sXG4gICAgY2xhc3NOYW1lOiBhcmdzLmNsYXNzTmFtZSxcbiAgICBjb250ZW50OiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb25maWdQcm92aWRlciwge1xuICAgICAgaWNvblByZWZpeENsc1xuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogbWVzc2FnZUNsYXNzXG4gICAgfSwgYXJncy5pY29uIHx8IEljb25Db21wb25lbnQgJiYgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkNvbXBvbmVudCwgbnVsbCksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBhcmdzLmNvbnRlbnQpKSksXG4gICAgb25DbG9zZTogYXJncy5vbkNsb3NlLFxuICAgIG9uQ2xpY2s6IGFyZ3Mub25DbGlja1xuICB9O1xufVxuZnVuY3Rpb24gbm90aWNlKGFyZ3MpIHtcbiAgdmFyIHRhcmdldCA9IGFyZ3Mua2V5IHx8IGdldEtleVRoZW5JbmNyZWFzZUtleSgpO1xuICB2YXIgY2xvc2VQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrMigpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJncy5vbkNsb3NlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYXJncy5vbkNsb3NlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKTtcbiAgICB9O1xuICAgIGdldFJDTm90aWZpY2F0aW9uSW5zdGFuY2UoYXJncywgZnVuY3Rpb24oX3JlZikge1xuICAgICAgdmFyIHByZWZpeENscyA9IF9yZWYucHJlZml4Q2xzLCBpY29uUHJlZml4Q2xzID0gX3JlZi5pY29uUHJlZml4Q2xzLCBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2U7XG4gICAgICBpbnN0YW5jZS5ub3RpY2UoZ2V0UkNOb3RpY2VQcm9wcyhfZXh0ZW5kcyQxKF9leHRlbmRzJDEoe30sIGFyZ3MpLCB7XG4gICAgICAgIGtleTogdGFyZ2V0LFxuICAgICAgICBvbkNsb3NlOiBjYWxsYmFja1xuICAgICAgfSksIHByZWZpeENscywgaWNvblByZWZpeENscykpO1xuICAgIH0pO1xuICB9KTtcbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uIHJlc3VsdDIoKSB7XG4gICAgaWYgKG1lc3NhZ2VJbnN0YW5jZSkge1xuICAgICAgbWVzc2FnZUluc3RhbmNlLnJlbW92ZU5vdGljZSh0YXJnZXQpO1xuICAgIH1cbiAgfTtcbiAgcmVzdWx0LnRoZW4gPSBmdW5jdGlvbihmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIGNsb3NlUHJvbWlzZS50aGVuKGZpbGxlZCwgcmVqZWN0ZWQpO1xuICB9O1xuICByZXN1bHQucHJvbWlzZSA9IGNsb3NlUHJvbWlzZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzQXJnc1Byb3BzKGNvbnRlbnQpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjb250ZW50KSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIiAmJiAhIWNvbnRlbnQuY29udGVudDtcbn1cbnZhciBhcGkgPSB7XG4gIG9wZW46IG5vdGljZSxcbiAgY29uZmlnOiBzZXRNZXNzYWdlQ29uZmlnLFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95MihtZXNzYWdlS2V5KSB7XG4gICAgaWYgKG1lc3NhZ2VJbnN0YW5jZSkge1xuICAgICAgaWYgKG1lc3NhZ2VLZXkpIHtcbiAgICAgICAgdmFyIF9tZXNzYWdlSW5zdGFuY2UgPSBtZXNzYWdlSW5zdGFuY2UsIHJlbW92ZU5vdGljZSA9IF9tZXNzYWdlSW5zdGFuY2UucmVtb3ZlTm90aWNlO1xuICAgICAgICByZW1vdmVOb3RpY2UobWVzc2FnZUtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX21lc3NhZ2VJbnN0YW5jZTIgPSBtZXNzYWdlSW5zdGFuY2UsIGRlc3Ryb3kzID0gX21lc3NhZ2VJbnN0YW5jZTIuZGVzdHJveTtcbiAgICAgICAgZGVzdHJveTMoKTtcbiAgICAgICAgbWVzc2FnZUluc3RhbmNlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBhdHRhY2hUeXBlQXBpKG9yaWdpbmFsQXBpLCB0eXBlNCkge1xuICBvcmlnaW5hbEFwaVt0eXBlNF0gPSBmdW5jdGlvbihjb250ZW50LCBkdXJhdGlvbiwgb25DbG9zZTIpIHtcbiAgICBpZiAoaXNBcmdzUHJvcHMoY29udGVudCkpIHtcbiAgICAgIHJldHVybiBvcmlnaW5hbEFwaS5vcGVuKF9leHRlbmRzJDEoX2V4dGVuZHMkMSh7fSwgY29udGVudCksIHtcbiAgICAgICAgdHlwZTogdHlwZTRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvbkNsb3NlMiA9IGR1cmF0aW9uO1xuICAgICAgZHVyYXRpb24gPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBvcmlnaW5hbEFwaS5vcGVuKHtcbiAgICAgIGNvbnRlbnQsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIHR5cGU6IHR5cGU0LFxuICAgICAgb25DbG9zZTogb25DbG9zZTJcbiAgICB9KTtcbiAgfTtcbn1cbltcInN1Y2Nlc3NcIiwgXCJpbmZvXCIsIFwid2FybmluZ1wiLCBcImVycm9yXCIsIFwibG9hZGluZ1wiXS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGU0KSB7XG4gIHJldHVybiBhdHRhY2hUeXBlQXBpKGFwaSwgdHlwZTQpO1xufSk7XG5hcGkud2FybiA9IGFwaS53YXJuaW5nO1xuYXBpLnVzZU1lc3NhZ2UgPSBjcmVhdGVVc2VNZXNzYWdlKGdldFJDTm90aWZpY2F0aW9uSW5zdGFuY2UsIGdldFJDTm90aWNlUHJvcHMpO1xudmFyIG1lc3NhZ2UgPSBhcGk7XG5mdW5jdGlvbiBvbWl0KG9iaiwgZmllbGRzKSB7XG4gIHZhciBjbG9uZTIgPSBfb2JqZWN0U3ByZWFkMiQxKHt9LCBvYmopO1xuICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZHMpKSB7XG4gICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24oa2V5Mikge1xuICAgICAgZGVsZXRlIGNsb25lMltrZXkyXTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY2xvbmUyO1xufVxudmFyIF9fcmVzdCQ3ID0gZ2xvYmFsVGhpcyAmJiBnbG9iYWxUaGlzLl9fcmVzdCB8fCBmdW5jdGlvbihzLCBlMikge1xuICB2YXIgdDIgPSB7fTtcbiAgZm9yICh2YXIgcDIgaW4gcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcDIpICYmIGUyLmluZGV4T2YocDIpIDwgMClcbiAgICAgIHQyW3AyXSA9IHNbcDJdO1xuICB9XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICBmb3IgKHZhciBpID0gMCwgcDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChlMi5pbmRleE9mKHAyW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHAyW2ldKSlcbiAgICAgICAgdDJbcDJbaV1dID0gc1twMltpXV07XG4gICAgfVxuICByZXR1cm4gdDI7XG59O1xudmFyIENoZWNrYWJsZVRhZyA9IGZ1bmN0aW9uIENoZWNrYWJsZVRhZzIoX2EpIHtcbiAgdmFyIF9jbGFzc05hbWVzO1xuICB2YXIgY3VzdG9taXplUHJlZml4Q2xzID0gX2EucHJlZml4Q2xzLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIGNoZWNrZWQgPSBfYS5jaGVja2VkLCBvbkNoYW5nZSA9IF9hLm9uQ2hhbmdlLCBvbkNsaWNrID0gX2Eub25DbGljaywgcmVzdFByb3BzID0gX19yZXN0JDcoX2EsIFtcInByZWZpeENsc1wiLCBcImNsYXNzTmFtZVwiLCBcImNoZWNrZWRcIiwgXCJvbkNoYW5nZVwiLCBcIm9uQ2xpY2tcIl0pO1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KENvbmZpZ0NvbnRleHQpLCBnZXRQcmVmaXhDbHMgPSBfUmVhY3QkdXNlQ29udGV4dC5nZXRQcmVmaXhDbHM7XG4gIHZhciBoYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrMihlMikge1xuICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZSghY2hlY2tlZCk7XG4gICAgb25DbGljayA9PT0gbnVsbCB8fCBvbkNsaWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNsaWNrKGUyKTtcbiAgfTtcbiAgdmFyIHByZWZpeENscyA9IGdldFByZWZpeENscyhcInRhZ1wiLCBjdXN0b21pemVQcmVmaXhDbHMpO1xuICB2YXIgY2xzID0gY2xhc3NOYW1lcyhwcmVmaXhDbHMsIChfY2xhc3NOYW1lcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lcywgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1jaGVja2FibGVcIiksIHRydWUpLCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lcywgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1jaGVja2FibGUtY2hlY2tlZFwiKSwgY2hlY2tlZCksIF9jbGFzc05hbWVzKSwgY2xhc3NOYW1lKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfZXh0ZW5kcyQxKHt9LCByZXN0UHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNscyxcbiAgICBvbkNsaWNrOiBoYW5kbGVDbGlja1xuICB9KSk7XG59O1xudmFyIENoZWNrYWJsZVRhZyQxID0gQ2hlY2thYmxlVGFnO1xudmFyIHR1cGxlID0gZnVuY3Rpb24gdHVwbGUyKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBhcmdzO1xufTtcbnZhciBQcmVzZXRTdGF0dXNDb2xvclR5cGVzID0gdHVwbGUoXCJzdWNjZXNzXCIsIFwicHJvY2Vzc2luZ1wiLCBcImVycm9yXCIsIFwiZGVmYXVsdFwiLCBcIndhcm5pbmdcIik7XG52YXIgUHJlc2V0Q29sb3JUeXBlcyA9IHR1cGxlKFwicGlua1wiLCBcInJlZFwiLCBcInllbGxvd1wiLCBcIm9yYW5nZVwiLCBcImN5YW5cIiwgXCJncmVlblwiLCBcImJsdWVcIiwgXCJwdXJwbGVcIiwgXCJnZWVrYmx1ZVwiLCBcIm1hZ2VudGFcIiwgXCJ2b2xjYW5vXCIsIFwiZ29sZFwiLCBcImxpbWVcIik7XG52YXIgaWQgPSAwO1xudmFyIGlkcyA9IHt9O1xuZnVuY3Rpb24gd3JhcHBlclJhZihjYWxsYmFjaykge1xuICB2YXIgZGVsYXlGcmFtZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gIHZhciBteUlkID0gaWQrKztcbiAgdmFyIHJlc3RGcmFtZXMgPSBkZWxheUZyYW1lcztcbiAgZnVuY3Rpb24gaW50ZXJuYWxDYWxsYmFjaygpIHtcbiAgICByZXN0RnJhbWVzIC09IDE7XG4gICAgaWYgKHJlc3RGcmFtZXMgPD0gMCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIGRlbGV0ZSBpZHNbbXlJZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkc1tteUlkXSA9IHdyYXBwZXJSYWYkMShpbnRlcm5hbENhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgaWRzW215SWRdID0gd3JhcHBlclJhZiQxKGludGVybmFsQ2FsbGJhY2spO1xuICByZXR1cm4gbXlJZDtcbn1cbndyYXBwZXJSYWYuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKHBpZCkge1xuICBpZiAocGlkID09PSB2b2lkIDApXG4gICAgcmV0dXJuO1xuICB3cmFwcGVyUmFmJDEuY2FuY2VsKGlkc1twaWRdKTtcbiAgZGVsZXRlIGlkc1twaWRdO1xufTtcbndyYXBwZXJSYWYuaWRzID0gaWRzO1xudmFyIGlzVmFsaWRFbGVtZW50ID0gUmVhY3QuaXNWYWxpZEVsZW1lbnQ7XG5mdW5jdGlvbiByZXBsYWNlRWxlbWVudChlbGVtZW50LCByZXBsYWNlbWVudCwgcHJvcHMpIHtcbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChlbGVtZW50KSlcbiAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY2xvbmVFbGVtZW50KGVsZW1lbnQsIHR5cGVvZiBwcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gcHJvcHMoZWxlbWVudC5wcm9wcyB8fCB7fSkgOiBwcm9wcyk7XG59XG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgcHJvcHMpIHtcbiAgcmV0dXJuIHJlcGxhY2VFbGVtZW50KGVsZW1lbnQsIGVsZW1lbnQsIHByb3BzKTtcbn1cbnZhciBzdHlsZUZvclBzZXVkbztcbmZ1bmN0aW9uIGlzSGlkZGVuKGVsZW1lbnQpIHtcbiAgcmV0dXJuICFlbGVtZW50IHx8IGVsZW1lbnQub2Zmc2V0UGFyZW50ID09PSBudWxsIHx8IGVsZW1lbnQuaGlkZGVuO1xufVxuZnVuY3Rpb24gaXNOb3RHcmV5KGNvbG9yKSB7XG4gIHZhciBtYXRjaCA9IChjb2xvciB8fCBcIlwiKS5tYXRjaCgvcmdiYT9cXCgoXFxkKiksIChcXGQqKSwgKFxcZCopKCwgW1xcZC5dKik/XFwpLyk7XG4gIGlmIChtYXRjaCAmJiBtYXRjaFsxXSAmJiBtYXRjaFsyXSAmJiBtYXRjaFszXSkge1xuICAgIHJldHVybiAhKG1hdGNoWzFdID09PSBtYXRjaFsyXSAmJiBtYXRjaFsyXSA9PT0gbWF0Y2hbM10pO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxudmFyIFdhdmUgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoV2F2ZTIsIF9SZWFjdCRDb21wb25lbnQpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFdhdmUyKTtcbiAgZnVuY3Rpb24gV2F2ZTIoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXYXZlMik7XG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy5jb250YWluZXJSZWYgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgX3RoaXMuYW5pbWF0aW9uU3RhcnQgPSBmYWxzZTtcbiAgICBfdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5vbkNsaWNrID0gZnVuY3Rpb24obm9kZSwgd2F2ZUNvbG9yKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsIGluc2VydEV4dHJhTm9kZSA9IF90aGlzJHByb3BzLmluc2VydEV4dHJhTm9kZSwgZGlzYWJsZWQgPSBfdGhpcyRwcm9wcy5kaXNhYmxlZDtcbiAgICAgIGlmIChkaXNhYmxlZCB8fCAhbm9kZSB8fCBpc0hpZGRlbihub2RlKSB8fCBub2RlLmNsYXNzTmFtZS5pbmRleE9mKFwiLWxlYXZlXCIpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMuZXh0cmFOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemUgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgZXh0cmFOb2RlID0gX2Fzc2VydFRoaXNJbml0aWFsaXplLmV4dHJhTm9kZTtcbiAgICAgIHZhciBnZXRQcmVmaXhDbHMgPSBfdGhpcy5jb250ZXh0LmdldFByZWZpeENscztcbiAgICAgIGV4dHJhTm9kZS5jbGFzc05hbWUgPSBcIlwiLmNvbmNhdChnZXRQcmVmaXhDbHMoXCJcIiksIFwiLWNsaWNrLWFuaW1hdGluZy1ub2RlXCIpO1xuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBfdGhpcy5nZXRBdHRyaWJ1dGVOYW1lKCk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBcInRydWVcIik7XG4gICAgICBpZiAod2F2ZUNvbG9yICYmIHdhdmVDb2xvciAhPT0gXCIjZmZmZmZmXCIgJiYgd2F2ZUNvbG9yICE9PSBcInJnYigyNTUsIDI1NSwgMjU1KVwiICYmIGlzTm90R3JleSh3YXZlQ29sb3IpICYmICEvcmdiYVxcKCg/OlxcZCosICl7M30wXFwpLy50ZXN0KHdhdmVDb2xvcikgJiYgd2F2ZUNvbG9yICE9PSBcInRyYW5zcGFyZW50XCIpIHtcbiAgICAgICAgZXh0cmFOb2RlLnN0eWxlLmJvcmRlckNvbG9yID0gd2F2ZUNvbG9yO1xuICAgICAgICB2YXIgbm9kZVJvb3QgPSAoKF9hID0gbm9kZS5nZXRSb290Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobm9kZSkpIHx8IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICAgICAgdmFyIG5vZGVCb2R5ID0gbm9kZVJvb3QgaW5zdGFuY2VvZiBEb2N1bWVudCA/IG5vZGVSb290LmJvZHkgOiAoX2IgPSBub2RlUm9vdC5maXJzdENoaWxkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBub2RlUm9vdDtcbiAgICAgICAgc3R5bGVGb3JQc2V1ZG8gPSB1cGRhdGVDU1MoXCJcXG4gICAgICBbXCIuY29uY2F0KGdldFByZWZpeENscyhcIlwiKSwgXCItY2xpY2stYW5pbWF0aW5nLXdpdGhvdXQtZXh0cmEtbm9kZT0ndHJ1ZSddOjphZnRlciwgLlwiKS5jb25jYXQoZ2V0UHJlZml4Q2xzKFwiXCIpLCBcIi1jbGljay1hbmltYXRpbmctbm9kZSB7XFxuICAgICAgICAtLWFudGQtd2F2ZS1zaGFkb3ctY29sb3I6IFwiKS5jb25jYXQod2F2ZUNvbG9yLCBcIjtcXG4gICAgICB9XCIpLCBcImFudGQtd2F2ZVwiLCB7XG4gICAgICAgICAgY3NwOiBfdGhpcy5jc3AsXG4gICAgICAgICAgYXR0YWNoVG86IG5vZGVCb2R5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGluc2VydEV4dHJhTm9kZSkge1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGV4dHJhTm9kZSk7XG4gICAgICB9XG4gICAgICBbXCJ0cmFuc2l0aW9uXCIsIFwiYW5pbWF0aW9uXCJdLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJcIi5jb25jYXQobmFtZSwgXCJzdGFydFwiKSwgX3RoaXMub25UcmFuc2l0aW9uU3RhcnQpO1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJcIi5jb25jYXQobmFtZSwgXCJlbmRcIiksIF90aGlzLm9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF90aGlzLm9uVHJhbnNpdGlvblN0YXJ0ID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgIGlmIChfdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUgPSBfdGhpcy5jb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgIGlmICghZTIgfHwgZTIudGFyZ2V0ICE9PSBub2RlIHx8IF90aGlzLmFuaW1hdGlvblN0YXJ0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF90aGlzLnJlc2V0RWZmZWN0KG5vZGUpO1xuICAgIH07XG4gICAgX3RoaXMub25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgIGlmICghZTIgfHwgZTIuYW5pbWF0aW9uTmFtZSAhPT0gXCJmYWRlRWZmZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMucmVzZXRFZmZlY3QoZTIudGFyZ2V0KTtcbiAgICB9O1xuICAgIF90aGlzLmJpbmRBbmltYXRpb25FdmVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSB8fCAhbm9kZS5nZXRBdHRyaWJ1dGUgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSB8fCBub2RlLmNsYXNzTmFtZS5pbmRleE9mKFwiZGlzYWJsZWRcIikgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb25DbGljayA9IGZ1bmN0aW9uIG9uQ2xpY2syKGUyKSB7XG4gICAgICAgIGlmIChlMi50YXJnZXQudGFnTmFtZSA9PT0gXCJJTlBVVFwiIHx8IGlzSGlkZGVuKGUyLnRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMucmVzZXRFZmZlY3Qobm9kZSk7XG4gICAgICAgIHZhciB3YXZlQ29sb3IgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpLmdldFByb3BlcnR5VmFsdWUoXCJib3JkZXItdG9wLWNvbG9yXCIpIHx8IGdldENvbXB1dGVkU3R5bGUobm9kZSkuZ2V0UHJvcGVydHlWYWx1ZShcImJvcmRlci1jb2xvclwiKSB8fCBnZXRDb21wdXRlZFN0eWxlKG5vZGUpLmdldFByb3BlcnR5VmFsdWUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIpO1xuICAgICAgICBfdGhpcy5jbGlja1dhdmVUaW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMub25DbGljayhub2RlLCB3YXZlQ29sb3IpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgd3JhcHBlclJhZi5jYW5jZWwoX3RoaXMuYW5pbWF0aW9uU3RhcnRJZCk7XG4gICAgICAgIF90aGlzLmFuaW1hdGlvblN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuYW5pbWF0aW9uU3RhcnRJZCA9IHdyYXBwZXJSYWYoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMuYW5pbWF0aW9uU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgfTtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xpY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwyKCkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xpY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgX3RoaXMucmVuZGVyV2F2ZSA9IGZ1bmN0aW9uKF9yZWYpIHtcbiAgICAgIHZhciBjc3AgPSBfcmVmLmNzcDtcbiAgICAgIHZhciBjaGlsZHJlbiA9IF90aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgX3RoaXMuY3NwID0gY3NwO1xuICAgICAgaWYgKCEvKiBAX19QVVJFX18gKi8gUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKVxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICB2YXIgcmVmID0gX3RoaXMuY29udGFpbmVyUmVmO1xuICAgICAgaWYgKHN1cHBvcnRSZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIHJlZiA9IGNvbXBvc2VSZWYoY2hpbGRyZW4ucmVmLCBfdGhpcy5jb250YWluZXJSZWYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZHJlbiwge1xuICAgICAgICByZWZcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhXYXZlMiwgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmluc3RhbmNlID0gdGhpcy5iaW5kQW5pbWF0aW9uRXZlbnQobm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZS5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsaWNrV2F2ZVRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jbGlja1dhdmVUaW1lb3V0SWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdHRyaWJ1dGVOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZU5hbWUoKSB7XG4gICAgICB2YXIgZ2V0UHJlZml4Q2xzID0gdGhpcy5jb250ZXh0LmdldFByZWZpeENscztcbiAgICAgIHZhciBpbnNlcnRFeHRyYU5vZGUgPSB0aGlzLnByb3BzLmluc2VydEV4dHJhTm9kZTtcbiAgICAgIHJldHVybiBpbnNlcnRFeHRyYU5vZGUgPyBcIlwiLmNvbmNhdChnZXRQcmVmaXhDbHMoXCJcIiksIFwiLWNsaWNrLWFuaW1hdGluZ1wiKSA6IFwiXCIuY29uY2F0KGdldFByZWZpeENscyhcIlwiKSwgXCItY2xpY2stYW5pbWF0aW5nLXdpdGhvdXQtZXh0cmEtbm9kZVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRFZmZlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRFZmZlY3Qobm9kZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAoIW5vZGUgfHwgbm9kZSA9PT0gdGhpcy5leHRyYU5vZGUgfHwgIShub2RlIGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGluc2VydEV4dHJhTm9kZSA9IHRoaXMucHJvcHMuaW5zZXJ0RXh0cmFOb2RlO1xuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZU5hbWUoKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIFwiZmFsc2VcIik7XG4gICAgICBpZiAoc3R5bGVGb3JQc2V1ZG8pIHtcbiAgICAgICAgc3R5bGVGb3JQc2V1ZG8uaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpbnNlcnRFeHRyYU5vZGUgJiYgdGhpcy5leHRyYU5vZGUgJiYgbm9kZS5jb250YWlucyh0aGlzLmV4dHJhTm9kZSkpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVDaGlsZCh0aGlzLmV4dHJhTm9kZSk7XG4gICAgICB9XG4gICAgICBbXCJ0cmFuc2l0aW9uXCIsIFwiYW5pbWF0aW9uXCJdLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJcIi5jb25jYXQobmFtZSwgXCJzdGFydFwiKSwgX3RoaXMyLm9uVHJhbnNpdGlvblN0YXJ0KTtcbiAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiXCIuY29uY2F0KG5hbWUsIFwiZW5kXCIpLCBfdGhpczIub25UcmFuc2l0aW9uRW5kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbmZpZ0NvbnN1bWVyLCBudWxsLCB0aGlzLnJlbmRlcldhdmUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gV2F2ZTI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5XYXZlLmNvbnRleHRUeXBlID0gQ29uZmlnQ29udGV4dDtcbnZhciBfX3Jlc3QkNiA9IGdsb2JhbFRoaXMgJiYgZ2xvYmFsVGhpcy5fX3Jlc3QgfHwgZnVuY3Rpb24ocywgZTIpIHtcbiAgdmFyIHQyID0ge307XG4gIGZvciAodmFyIHAyIGluIHMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHAyKSAmJiBlMi5pbmRleE9mKHAyKSA8IDApXG4gICAgICB0MltwMl0gPSBzW3AyXTtcbiAgfVxuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgZm9yICh2YXIgaSA9IDAsIHAyID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZTIuaW5kZXhPZihwMltpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwMltpXSkpXG4gICAgICAgIHQyW3AyW2ldXSA9IHNbcDJbaV1dO1xuICAgIH1cbiAgcmV0dXJuIHQyO1xufTtcbnZhciBQcmVzZXRDb2xvclJlZ2V4JDEgPSBuZXcgUmVnRXhwKFwiXihcIi5jb25jYXQoUHJlc2V0Q29sb3JUeXBlcy5qb2luKFwifFwiKSwgXCIpKC1pbnZlcnNlKT8kXCIpKTtcbnZhciBQcmVzZXRTdGF0dXNDb2xvclJlZ2V4ID0gbmV3IFJlZ0V4cChcIl4oXCIuY29uY2F0KFByZXNldFN0YXR1c0NvbG9yVHlwZXMuam9pbihcInxcIiksIFwiKSRcIikpO1xudmFyIEludGVybmFsVGFnID0gZnVuY3Rpb24gSW50ZXJuYWxUYWcyKF9hLCByZWYpIHtcbiAgdmFyIF9jbGFzc05hbWVzO1xuICB2YXIgY3VzdG9taXplUHJlZml4Q2xzID0gX2EucHJlZml4Q2xzLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIHN0eWxlMiA9IF9hLnN0eWxlLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBpY29uID0gX2EuaWNvbiwgY29sb3IgPSBfYS5jb2xvciwgb25DbG9zZTIgPSBfYS5vbkNsb3NlLCBjbG9zZUljb24gPSBfYS5jbG9zZUljb24sIF9hJGNsb3NhYmxlID0gX2EuY2xvc2FibGUsIGNsb3NhYmxlID0gX2EkY2xvc2FibGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX2EkY2xvc2FibGUsIHByb3BzID0gX19yZXN0JDYoX2EsIFtcInByZWZpeENsc1wiLCBcImNsYXNzTmFtZVwiLCBcInN0eWxlXCIsIFwiY2hpbGRyZW5cIiwgXCJpY29uXCIsIFwiY29sb3JcIiwgXCJvbkNsb3NlXCIsIFwiY2xvc2VJY29uXCIsIFwiY2xvc2FibGVcIl0pO1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KENvbmZpZ0NvbnRleHQpLCBnZXRQcmVmaXhDbHMgPSBfUmVhY3QkdXNlQ29udGV4dC5nZXRQcmVmaXhDbHMsIGRpcmVjdGlvbiA9IF9SZWFjdCR1c2VDb250ZXh0LmRpcmVjdGlvbjtcbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKHRydWUpLCBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSwgdmlzaWJsZSA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sIHNldFZpc2libGUgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24oKSB7XG4gICAgaWYgKFwidmlzaWJsZVwiIGluIHByb3BzKSB7XG4gICAgICBzZXRWaXNpYmxlKHByb3BzLnZpc2libGUpO1xuICAgIH1cbiAgfSwgW3Byb3BzLnZpc2libGVdKTtcbiAgdmFyIGlzUHJlc2V0Q29sb3IgPSBmdW5jdGlvbiBpc1ByZXNldENvbG9yMigpIHtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBQcmVzZXRDb2xvclJlZ2V4JDEudGVzdChjb2xvcikgfHwgUHJlc2V0U3RhdHVzQ29sb3JSZWdleC50ZXN0KGNvbG9yKTtcbiAgfTtcbiAgdmFyIHRhZ1N0eWxlID0gX2V4dGVuZHMkMSh7XG4gICAgYmFja2dyb3VuZENvbG9yOiBjb2xvciAmJiAhaXNQcmVzZXRDb2xvcigpID8gY29sb3IgOiB2b2lkIDBcbiAgfSwgc3R5bGUyKTtcbiAgdmFyIHByZXNldENvbG9yID0gaXNQcmVzZXRDb2xvcigpO1xuICB2YXIgcHJlZml4Q2xzID0gZ2V0UHJlZml4Q2xzKFwidGFnXCIsIGN1c3RvbWl6ZVByZWZpeENscyk7XG4gIHZhciB0YWdDbGFzc05hbWUgPSBjbGFzc05hbWVzKHByZWZpeENscywgKF9jbGFzc05hbWVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLVwiKS5jb25jYXQoY29sb3IpLCBwcmVzZXRDb2xvciksIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWhhcy1jb2xvclwiKSwgY29sb3IgJiYgIXByZXNldENvbG9yKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItaGlkZGVuXCIpLCAhdmlzaWJsZSksIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXJ0bFwiKSwgZGlyZWN0aW9uID09PSBcInJ0bFwiKSwgX2NsYXNzTmFtZXMpLCBjbGFzc05hbWUpO1xuICB2YXIgaGFuZGxlQ2xvc2VDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsb3NlQ2xpY2syKGUyKSB7XG4gICAgZTIuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgb25DbG9zZTIgPT09IG51bGwgfHwgb25DbG9zZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2xvc2UyKGUyKTtcbiAgICBpZiAoZTIuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIShcInZpc2libGVcIiBpbiBwcm9wcykpIHtcbiAgICAgIHNldFZpc2libGUoZmFsc2UpO1xuICAgIH1cbiAgfTtcbiAgdmFyIHJlbmRlckNsb3NlSWNvbiA9IGZ1bmN0aW9uIHJlbmRlckNsb3NlSWNvbjIoKSB7XG4gICAgaWYgKGNsb3NhYmxlKSB7XG4gICAgICByZXR1cm4gY2xvc2VJY29uID8gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWNsb3NlLWljb25cIiksXG4gICAgICAgIG9uQ2xpY2s6IGhhbmRsZUNsb3NlQ2xpY2tcbiAgICAgIH0sIGNsb3NlSWNvbikgOiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDbG9zZU91dGxpbmVkJDEsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWNsb3NlLWljb25cIiksXG4gICAgICAgIG9uQ2xpY2s6IGhhbmRsZUNsb3NlQ2xpY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgdmFyIGlzTmVlZFdhdmUgPSBcIm9uQ2xpY2tcIiBpbiBwcm9wcyB8fCBjaGlsZHJlbiAmJiBjaGlsZHJlbi50eXBlID09PSBcImFcIjtcbiAgdmFyIHRhZ1Byb3BzID0gb21pdChwcm9wcywgW1widmlzaWJsZVwiXSk7XG4gIHZhciBpY29uTm9kZSA9IGljb24gfHwgbnVsbDtcbiAgdmFyIGtpZHMgPSBpY29uTm9kZSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBpY29uTm9kZSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIGNoaWxkcmVuKSkgOiBjaGlsZHJlbjtcbiAgdmFyIHRhZ05vZGUgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgX2V4dGVuZHMkMSh7fSwgdGFnUHJvcHMsIHtcbiAgICByZWYsXG4gICAgY2xhc3NOYW1lOiB0YWdDbGFzc05hbWUsXG4gICAgc3R5bGU6IHRhZ1N0eWxlXG4gIH0pLCBraWRzLCByZW5kZXJDbG9zZUljb24oKSk7XG4gIHJldHVybiBpc05lZWRXYXZlID8gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoV2F2ZSwgbnVsbCwgdGFnTm9kZSkgOiB0YWdOb2RlO1xufTtcbnZhciBUYWcgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuZm9yd2FyZFJlZihJbnRlcm5hbFRhZyk7XG5UYWcuZGlzcGxheU5hbWUgPSBcIlRhZ1wiO1xuVGFnLkNoZWNrYWJsZVRhZyA9IENoZWNrYWJsZVRhZyQxO1xudmFyIFRhZyQxID0gVGFnO1xuZnVuY3Rpb24gY29udGFpbnMocm9vdDIsIG4yKSB7XG4gIGlmICghcm9vdDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJvb3QyLmNvbnRhaW5zKG4yKTtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJXcmFwKHRhcmdldCwgZXZlbnRUeXBlLCBjYiwgb3B0aW9uKSB7XG4gIHZhciBjYWxsYmFjayA9IFJlYWN0RE9NLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID8gZnVuY3Rpb24gcnVuKGUyKSB7XG4gICAgUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoY2IsIGUyKTtcbiAgfSA6IGNiO1xuICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBvcHRpb24pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICBpZiAodGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxudmFyIFBvcnRhbCA9IC8qIEBfX1BVUkVfXyAqLyBmb3J3YXJkUmVmKGZ1bmN0aW9uKHByb3BzLCByZWYpIHtcbiAgdmFyIGRpZFVwZGF0ZSA9IHByb3BzLmRpZFVwZGF0ZSwgZ2V0Q29udGFpbmVyMiA9IHByb3BzLmdldENvbnRhaW5lciwgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGNvbnRhaW5lclJlZiA9IHVzZVJlZigpO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9KTtcbiAgdmFyIGluaXRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICBpZiAoIWluaXRSZWYuY3VycmVudCAmJiBjYW5Vc2VEb20oKSkge1xuICAgIGNvbnRhaW5lclJlZi5jdXJyZW50ID0gZ2V0Q29udGFpbmVyMigpO1xuICAgIGluaXRSZWYuY3VycmVudCA9IHRydWU7XG4gIH1cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgIGRpZFVwZGF0ZSA9PT0gbnVsbCB8fCBkaWRVcGRhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpZFVwZGF0ZShwcm9wcyk7XG4gIH0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9jb250YWluZXJSZWYkY3VycmVudCwgX2NvbnRhaW5lclJlZiRjdXJyZW50MjtcbiAgICAgIChfY29udGFpbmVyUmVmJGN1cnJlbnQgPSBjb250YWluZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2NvbnRhaW5lclJlZiRjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2NvbnRhaW5lclJlZiRjdXJyZW50MiA9IF9jb250YWluZXJSZWYkY3VycmVudC5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfY29udGFpbmVyUmVmJGN1cnJlbnQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29udGFpbmVyUmVmJGN1cnJlbnQyLnJlbW92ZUNoaWxkKGNvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBjb250YWluZXJSZWYuY3VycmVudCA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdERPTS5jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lclJlZi5jdXJyZW50KSA6IG51bGw7XG59KTtcbmZ1bmN0aW9uIGlzUG9pbnRzRXEoYTEsIGEyLCBpc0FsaWduUG9pbnQpIHtcbiAgaWYgKGlzQWxpZ25Qb2ludCkge1xuICAgIHJldHVybiBhMVswXSA9PT0gYTJbMF07XG4gIH1cbiAgcmV0dXJuIGExWzBdID09PSBhMlswXSAmJiBhMVsxXSA9PT0gYTJbMV07XG59XG5mdW5jdGlvbiBnZXRBbGlnbkZyb21QbGFjZW1lbnQoYnVpbHRpblBsYWNlbWVudHMsIHBsYWNlbWVudFN0ciwgYWxpZ24pIHtcbiAgdmFyIGJhc2VBbGlnbiA9IGJ1aWx0aW5QbGFjZW1lbnRzW3BsYWNlbWVudFN0cl0gfHwge307XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMiQxKF9vYmplY3RTcHJlYWQyJDEoe30sIGJhc2VBbGlnbiksIGFsaWduKTtcbn1cbmZ1bmN0aW9uIGdldEFsaWduUG9wdXBDbGFzc05hbWUoYnVpbHRpblBsYWNlbWVudHMsIHByZWZpeENscywgYWxpZ24sIGlzQWxpZ25Qb2ludCkge1xuICB2YXIgcG9pbnRzID0gYWxpZ24ucG9pbnRzO1xuICB2YXIgcGxhY2VtZW50czIgPSBPYmplY3Qua2V5cyhidWlsdGluUGxhY2VtZW50cyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50czIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50czJbaV07XG4gICAgaWYgKGlzUG9pbnRzRXEoYnVpbHRpblBsYWNlbWVudHNbcGxhY2VtZW50XS5wb2ludHMsIHBvaW50cywgaXNBbGlnblBvaW50KSkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItcGxhY2VtZW50LVwiKS5jb25jYXQocGxhY2VtZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG52YXIgaXNNb2JpbGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8IG5hdmlnYXRvci52ZW5kb3IgfHwgd2luZG93Lm9wZXJhO1xuICBpZiAoLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWlub3xhbmRyb2lkfGlwYWR8cGxheWJvb2t8c2lsay9pLnRlc3QoYWdlbnQpIHx8IC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3LShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtLXxjZWxsfGNodG18Y2xkY3xjbWQtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8LWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseSgtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmLTV8Zy1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkLShtfHB8dCl8aGVpLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzLWN8aHQoYygtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aS0oMjB8Z298bWEpfGkyMzB8aWFjKCB8LXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHwtW2Etd10pfGxpYnd8bHlueHxtMS13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bS1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dCgtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSktfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3wtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdC1nfHFhLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8LVsyLTddfGktKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aC18b298cC0pfHNka1xcL3xzZShjKC18MHwxKXw0N3xtY3xuZHxyaSl8c2doLXxzaGFyfHNpZSgtfG0pfHNrLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aC18di18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2wtfHRkZy18dGVsKGl8bSl8dGltLXx0LW1vfHRvKHBsfHNoKXx0cyg3MHxtLXxtM3xtNSl8dHgtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118LXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhcy18eW91cnx6ZXRvfHp0ZS0vaS50ZXN0KGFnZW50ID09PSBudWxsIHx8IGFnZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZ2VudC5zdWJzdHIoMCwgNCkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbmZ1bmN0aW9uIGdldE1vdGlvbihfcmVmKSB7XG4gIHZhciBwcmVmaXhDbHMgPSBfcmVmLnByZWZpeENscywgbW90aW9uID0gX3JlZi5tb3Rpb24sIGFuaW1hdGlvbiA9IF9yZWYuYW5pbWF0aW9uLCB0cmFuc2l0aW9uTmFtZTIgPSBfcmVmLnRyYW5zaXRpb25OYW1lO1xuICBpZiAobW90aW9uKSB7XG4gICAgcmV0dXJuIG1vdGlvbjtcbiAgfVxuICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vdGlvbk5hbWU6IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItXCIpLmNvbmNhdChhbmltYXRpb24pXG4gICAgfTtcbiAgfVxuICBpZiAodHJhbnNpdGlvbk5hbWUyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vdGlvbk5hbWU6IHRyYW5zaXRpb25OYW1lMlxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBNYXNrKHByb3BzKSB7XG4gIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHMsIHZpc2libGUgPSBwcm9wcy52aXNpYmxlLCB6SW5kZXggPSBwcm9wcy56SW5kZXgsIG1hc2sgPSBwcm9wcy5tYXNrLCBtYXNrTW90aW9uID0gcHJvcHMubWFza01vdGlvbiwgbWFza0FuaW1hdGlvbiA9IHByb3BzLm1hc2tBbmltYXRpb24sIG1hc2tUcmFuc2l0aW9uTmFtZSA9IHByb3BzLm1hc2tUcmFuc2l0aW9uTmFtZTtcbiAgaWYgKCFtYXNrKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG1vdGlvbiA9IHt9O1xuICBpZiAobWFza01vdGlvbiB8fCBtYXNrVHJhbnNpdGlvbk5hbWUgfHwgbWFza0FuaW1hdGlvbikge1xuICAgIG1vdGlvbiA9IF9vYmplY3RTcHJlYWQyJDEoe1xuICAgICAgbW90aW9uQXBwZWFyOiB0cnVlXG4gICAgfSwgZ2V0TW90aW9uKHtcbiAgICAgIG1vdGlvbjogbWFza01vdGlvbixcbiAgICAgIHByZWZpeENscyxcbiAgICAgIHRyYW5zaXRpb25OYW1lOiBtYXNrVHJhbnNpdGlvbk5hbWUsXG4gICAgICBhbmltYXRpb246IG1hc2tBbmltYXRpb25cbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENTU01vdGlvbiwgX2V4dGVuZHMkMSh7fSwgbW90aW9uLCB7XG4gICAgdmlzaWJsZSxcbiAgICByZW1vdmVPbkxlYXZlOiB0cnVlXG4gIH0pLCBmdW5jdGlvbihfcmVmKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICB6SW5kZXhcbiAgICAgIH0sXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1tYXNrXCIpLCBjbGFzc05hbWUpXG4gICAgfSk7XG4gIH0pO1xufVxudmFyIGlzVmlzaWJsZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlbGVtZW50Lm9mZnNldFBhcmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlbGVtZW50LmdldEJCb3gpIHtcbiAgICB2YXIgYm94ID0gZWxlbWVudC5nZXRCQm94KCk7XG4gICAgaWYgKGJveC53aWR0aCB8fCBib3guaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgdmFyIF9ib3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChfYm94LndpZHRoIHx8IF9ib3guaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0NCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMyID0gT2JqZWN0LmtleXMob2JqZWN0NCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdDQpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkge1xuICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3Q0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICB9XG4gICAga2V5czIucHVzaC5hcHBseShrZXlzMiwgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXMyO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleTIpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5Miwgc291cmNlW2tleTJdKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24oa2V5Mikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXkyLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5MikpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbihvYmoyKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajI7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24ob2JqMikge1xuICAgICAgcmV0dXJuIG9iajIgJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iajIuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmoyICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmoyO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleTIsIHZhbHVlKSB7XG4gIGlmIChrZXkyIGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleTIsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleTJdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbnZhciB2ZW5kb3JQcmVmaXg7XG52YXIganNDc3NNYXAgPSB7XG4gIFdlYmtpdDogXCItd2Via2l0LVwiLFxuICBNb3o6IFwiLW1vei1cIixcbiAgbXM6IFwiLW1zLVwiLFxuICBPOiBcIi1vLVwiXG59O1xuZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4KCkge1xuICBpZiAodmVuZG9yUHJlZml4ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdmVuZG9yUHJlZml4O1xuICB9XG4gIHZlbmRvclByZWZpeCA9IFwiXCI7XG4gIHZhciBzdHlsZTIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKS5zdHlsZTtcbiAgdmFyIHRlc3RQcm9wID0gXCJUcmFuc2Zvcm1cIjtcbiAgZm9yICh2YXIga2V5MiBpbiBqc0Nzc01hcCkge1xuICAgIGlmIChrZXkyICsgdGVzdFByb3AgaW4gc3R5bGUyKSB7XG4gICAgICB2ZW5kb3JQcmVmaXggPSBrZXkyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmVuZG9yUHJlZml4O1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbk5hbWUkMSgpIHtcbiAgcmV0dXJuIGdldFZlbmRvclByZWZpeCgpID8gXCJcIi5jb25jYXQoZ2V0VmVuZG9yUHJlZml4KCksIFwiVHJhbnNpdGlvblByb3BlcnR5XCIpIDogXCJ0cmFuc2l0aW9uUHJvcGVydHlcIjtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybU5hbWUoKSB7XG4gIHJldHVybiBnZXRWZW5kb3JQcmVmaXgoKSA/IFwiXCIuY29uY2F0KGdldFZlbmRvclByZWZpeCgpLCBcIlRyYW5zZm9ybVwiKSA6IFwidHJhbnNmb3JtXCI7XG59XG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uUHJvcGVydHkobm9kZSwgdmFsdWUpIHtcbiAgdmFyIG5hbWUgPSBnZXRUcmFuc2l0aW9uTmFtZSQxKCk7XG4gIGlmIChuYW1lKSB7XG4gICAgbm9kZS5zdHlsZVtuYW1lXSA9IHZhbHVlO1xuICAgIGlmIChuYW1lICE9PSBcInRyYW5zaXRpb25Qcm9wZXJ0eVwiKSB7XG4gICAgICBub2RlLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0VHJhbnNmb3JtKG5vZGUsIHZhbHVlKSB7XG4gIHZhciBuYW1lID0gZ2V0VHJhbnNmb3JtTmFtZSgpO1xuICBpZiAobmFtZSkge1xuICAgIG5vZGUuc3R5bGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBpZiAobmFtZSAhPT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25Qcm9wZXJ0eShub2RlKSB7XG4gIHJldHVybiBub2RlLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSB8fCBub2RlLnN0eWxlW2dldFRyYW5zaXRpb25OYW1lJDEoKV07XG59XG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1YWShub2RlKSB7XG4gIHZhciBzdHlsZTIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKTtcbiAgdmFyIHRyYW5zZm9ybSA9IHN0eWxlMi5nZXRQcm9wZXJ0eVZhbHVlKFwidHJhbnNmb3JtXCIpIHx8IHN0eWxlMi5nZXRQcm9wZXJ0eVZhbHVlKGdldFRyYW5zZm9ybU5hbWUoKSk7XG4gIGlmICh0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtICE9PSBcIm5vbmVcIikge1xuICAgIHZhciBtYXRyaXggPSB0cmFuc2Zvcm0ucmVwbGFjZSgvW14wLTlcXC0uLF0vZywgXCJcIikuc3BsaXQoXCIsXCIpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwYXJzZUZsb2F0KG1hdHJpeFsxMl0gfHwgbWF0cml4WzRdLCAwKSxcbiAgICAgIHk6IHBhcnNlRmxvYXQobWF0cml4WzEzXSB8fCBtYXRyaXhbNV0sIDApXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xufVxudmFyIG1hdHJpeDJkID0gL21hdHJpeFxcKCguKilcXCkvO1xudmFyIG1hdHJpeDNkID0gL21hdHJpeDNkXFwoKC4qKVxcKS87XG5mdW5jdGlvbiBzZXRUcmFuc2Zvcm1YWShub2RlLCB4eSkge1xuICB2YXIgc3R5bGUyID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCk7XG4gIHZhciB0cmFuc2Zvcm0gPSBzdHlsZTIuZ2V0UHJvcGVydHlWYWx1ZShcInRyYW5zZm9ybVwiKSB8fCBzdHlsZTIuZ2V0UHJvcGVydHlWYWx1ZShnZXRUcmFuc2Zvcm1OYW1lKCkpO1xuICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybSAhPT0gXCJub25lXCIpIHtcbiAgICB2YXIgYXJyO1xuICAgIHZhciBtYXRjaDJkID0gdHJhbnNmb3JtLm1hdGNoKG1hdHJpeDJkKTtcbiAgICBpZiAobWF0Y2gyZCkge1xuICAgICAgbWF0Y2gyZCA9IG1hdGNoMmRbMV07XG4gICAgICBhcnIgPSBtYXRjaDJkLnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChpdGVtLCAxMCk7XG4gICAgICB9KTtcbiAgICAgIGFycls0XSA9IHh5Lng7XG4gICAgICBhcnJbNV0gPSB4eS55O1xuICAgICAgc2V0VHJhbnNmb3JtKG5vZGUsIFwibWF0cml4KFwiLmNvbmNhdChhcnIuam9pbihcIixcIiksIFwiKVwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXRjaDNkID0gdHJhbnNmb3JtLm1hdGNoKG1hdHJpeDNkKVsxXTtcbiAgICAgIGFyciA9IG1hdGNoM2Quc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGl0ZW0sIDEwKTtcbiAgICAgIH0pO1xuICAgICAgYXJyWzEyXSA9IHh5Lng7XG4gICAgICBhcnJbMTNdID0geHkueTtcbiAgICAgIHNldFRyYW5zZm9ybShub2RlLCBcIm1hdHJpeDNkKFwiLmNvbmNhdChhcnIuam9pbihcIixcIiksIFwiKVwiKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNldFRyYW5zZm9ybShub2RlLCBcInRyYW5zbGF0ZVgoXCIuY29uY2F0KHh5LngsIFwicHgpIHRyYW5zbGF0ZVkoXCIpLmNvbmNhdCh4eS55LCBcInB4KSB0cmFuc2xhdGVaKDApXCIpKTtcbiAgfVxufVxudmFyIFJFX05VTSA9IC9bXFwtK10/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bXFwtK10/XFxkK3wpLy5zb3VyY2U7XG52YXIgZ2V0Q29tcHV0ZWRTdHlsZVg7XG5mdW5jdGlvbiBmb3JjZVJlbGF5b3V0KGVsZW0pIHtcbiAgdmFyIG9yaWdpbmFsU3R5bGUgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG4gIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICBlbGVtLm9mZnNldEhlaWdodDtcbiAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxTdHlsZTtcbn1cbmZ1bmN0aW9uIGNzcyhlbCwgbmFtZSwgdjIpIHtcbiAgdmFyIHZhbHVlID0gdjI7XG4gIGlmIChfdHlwZW9mKG5hbWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgZm9yICh2YXIgaSBpbiBuYW1lKSB7XG4gICAgICBpZiAobmFtZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBjc3MoZWwsIGksIG5hbWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZSA9IFwiXCIuY29uY2F0KHZhbHVlLCBcInB4XCIpO1xuICAgIH1cbiAgICBlbC5zdHlsZVtuYW1lXSA9IHZhbHVlO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGVYKGVsLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFBvc2l0aW9uKGVsZW0pIHtcbiAgdmFyIGJveDtcbiAgdmFyIHgyO1xuICB2YXIgeTI7XG4gIHZhciBkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG4gIHZhciBib2R5ID0gZG9jLmJvZHk7XG4gIHZhciBkb2NFbGVtID0gZG9jICYmIGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gIGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHgyID0gYm94LmxlZnQ7XG4gIHkyID0gYm94LnRvcDtcbiAgeDIgLT0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICB5MiAtPSBkb2NFbGVtLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IHgyLFxuICAgIHRvcDogeTJcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbCh3MiwgdG9wKSB7XG4gIHZhciByZXQgPSB3MltcInBhZ2VcIi5jb25jYXQodG9wID8gXCJZXCIgOiBcIlhcIiwgXCJPZmZzZXRcIildO1xuICB2YXIgbWV0aG9kNCA9IFwic2Nyb2xsXCIuY29uY2F0KHRvcCA/IFwiVG9wXCIgOiBcIkxlZnRcIik7XG4gIGlmICh0eXBlb2YgcmV0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgdmFyIGQyID0gdzIuZG9jdW1lbnQ7XG4gICAgcmV0ID0gZDIuZG9jdW1lbnRFbGVtZW50W21ldGhvZDRdO1xuICAgIGlmICh0eXBlb2YgcmV0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXQgPSBkMi5ib2R5W21ldGhvZDRdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsTGVmdCh3Mikge1xuICByZXR1cm4gZ2V0U2Nyb2xsKHcyKTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbFRvcCh3Mikge1xuICByZXR1cm4gZ2V0U2Nyb2xsKHcyLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGdldE9mZnNldChlbCkge1xuICB2YXIgcG9zID0gZ2V0Q2xpZW50UG9zaXRpb24oZWwpO1xuICB2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudDtcbiAgdmFyIHcyID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gIHBvcy5sZWZ0ICs9IGdldFNjcm9sbExlZnQodzIpO1xuICBwb3MudG9wICs9IGdldFNjcm9sbFRvcCh3Mik7XG4gIHJldHVybiBwb3M7XG59XG5mdW5jdGlvbiBpc1dpbmRvdyhvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiBvYmogIT09IHZvaWQgMCAmJiBvYmogPT0gb2JqLndpbmRvdztcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50KG5vZGUpIHtcbiAgaWYgKGlzV2luZG93KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUuZG9jdW1lbnQ7XG4gIH1cbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xufVxuZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGUoZWxlbSwgbmFtZSwgY3MpIHtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBjcztcbiAgdmFyIHZhbCA9IFwiXCI7XG4gIHZhciBkMiA9IGdldERvY3VtZW50KGVsZW0pO1xuICBjb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZSB8fCBkMi5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpO1xuICBpZiAoY29tcHV0ZWRTdHlsZSkge1xuICAgIHZhbCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSB8fCBjb21wdXRlZFN0eWxlW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG52YXIgX1JFX05VTV9OT19QWCA9IG5ldyBSZWdFeHAoXCJeKFwiLmNvbmNhdChSRV9OVU0sIFwiKSg/IXB4KVthLXolXSskXCIpLCBcImlcIik7XG52YXIgUkVfUE9TID0gL14odG9wfHJpZ2h0fGJvdHRvbXxsZWZ0KSQvO1xudmFyIENVUlJFTlRfU1RZTEUgPSBcImN1cnJlbnRTdHlsZVwiO1xudmFyIFJVTlRJTUVfU1RZTEUgPSBcInJ1bnRpbWVTdHlsZVwiO1xudmFyIExFRlQgPSBcImxlZnRcIjtcbnZhciBQWCA9IFwicHhcIjtcbmZ1bmN0aW9uIF9nZXRDb21wdXRlZFN0eWxlSUUoZWxlbSwgbmFtZSkge1xuICB2YXIgcmV0ID0gZWxlbVtDVVJSRU5UX1NUWUxFXSAmJiBlbGVtW0NVUlJFTlRfU1RZTEVdW25hbWVdO1xuICBpZiAoX1JFX05VTV9OT19QWC50ZXN0KHJldCkgJiYgIVJFX1BPUy50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIHN0eWxlMiA9IGVsZW0uc3R5bGU7XG4gICAgdmFyIGxlZnQgPSBzdHlsZTJbTEVGVF07XG4gICAgdmFyIHJzTGVmdCA9IGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF07XG4gICAgZWxlbVtSVU5USU1FX1NUWUxFXVtMRUZUXSA9IGVsZW1bQ1VSUkVOVF9TVFlMRV1bTEVGVF07XG4gICAgc3R5bGUyW0xFRlRdID0gbmFtZSA9PT0gXCJmb250U2l6ZVwiID8gXCIxZW1cIiA6IHJldCB8fCAwO1xuICAgIHJldCA9IHN0eWxlMi5waXhlbExlZnQgKyBQWDtcbiAgICBzdHlsZTJbTEVGVF0gPSBsZWZ0O1xuICAgIGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF0gPSByc0xlZnQ7XG4gIH1cbiAgcmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiYXV0b1wiIDogcmV0O1xufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgZ2V0Q29tcHV0ZWRTdHlsZVggPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IF9nZXRDb21wdXRlZFN0eWxlIDogX2dldENvbXB1dGVkU3R5bGVJRTtcbn1cbmZ1bmN0aW9uIGdldE9mZnNldERpcmVjdGlvbihkaXIsIG9wdGlvbikge1xuICBpZiAoZGlyID09PSBcImxlZnRcIikge1xuICAgIHJldHVybiBvcHRpb24udXNlQ3NzUmlnaHQgPyBcInJpZ2h0XCIgOiBkaXI7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbi51c2VDc3NCb3R0b20gPyBcImJvdHRvbVwiIDogZGlyO1xufVxuZnVuY3Rpb24gb3Bwb3NpdGVPZmZzZXREaXJlY3Rpb24oZGlyKSB7XG4gIGlmIChkaXIgPT09IFwibGVmdFwiKSB7XG4gICAgcmV0dXJuIFwicmlnaHRcIjtcbiAgfSBlbHNlIGlmIChkaXIgPT09IFwicmlnaHRcIikge1xuICAgIHJldHVybiBcImxlZnRcIjtcbiAgfSBlbHNlIGlmIChkaXIgPT09IFwidG9wXCIpIHtcbiAgICByZXR1cm4gXCJib3R0b21cIjtcbiAgfSBlbHNlIGlmIChkaXIgPT09IFwiYm90dG9tXCIpIHtcbiAgICByZXR1cm4gXCJ0b3BcIjtcbiAgfVxufVxuZnVuY3Rpb24gc2V0TGVmdFRvcChlbGVtLCBvZmZzZXQyLCBvcHRpb24pIHtcbiAgaWYgKGNzcyhlbGVtLCBcInBvc2l0aW9uXCIpID09PSBcInN0YXRpY1wiKSB7XG4gICAgZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgfVxuICB2YXIgcHJlc2V0SCA9IC05OTk7XG4gIHZhciBwcmVzZXRWID0gLTk5OTtcbiAgdmFyIGhvcml6b250YWxQcm9wZXJ0eSA9IGdldE9mZnNldERpcmVjdGlvbihcImxlZnRcIiwgb3B0aW9uKTtcbiAgdmFyIHZlcnRpY2FsUHJvcGVydHkgPSBnZXRPZmZzZXREaXJlY3Rpb24oXCJ0b3BcIiwgb3B0aW9uKTtcbiAgdmFyIG9wcG9zaXRlSG9yaXpvbnRhbFByb3BlcnR5ID0gb3Bwb3NpdGVPZmZzZXREaXJlY3Rpb24oaG9yaXpvbnRhbFByb3BlcnR5KTtcbiAgdmFyIG9wcG9zaXRlVmVydGljYWxQcm9wZXJ0eSA9IG9wcG9zaXRlT2Zmc2V0RGlyZWN0aW9uKHZlcnRpY2FsUHJvcGVydHkpO1xuICBpZiAoaG9yaXpvbnRhbFByb3BlcnR5ICE9PSBcImxlZnRcIikge1xuICAgIHByZXNldEggPSA5OTk7XG4gIH1cbiAgaWYgKHZlcnRpY2FsUHJvcGVydHkgIT09IFwidG9wXCIpIHtcbiAgICBwcmVzZXRWID0gOTk5O1xuICB9XG4gIHZhciBvcmlnaW5hbFRyYW5zaXRpb24gPSBcIlwiO1xuICB2YXIgb3JpZ2luYWxPZmZzZXQgPSBnZXRPZmZzZXQoZWxlbSk7XG4gIGlmIChcImxlZnRcIiBpbiBvZmZzZXQyIHx8IFwidG9wXCIgaW4gb2Zmc2V0Mikge1xuICAgIG9yaWdpbmFsVHJhbnNpdGlvbiA9IGdldFRyYW5zaXRpb25Qcm9wZXJ0eShlbGVtKSB8fCBcIlwiO1xuICAgIHNldFRyYW5zaXRpb25Qcm9wZXJ0eShlbGVtLCBcIm5vbmVcIik7XG4gIH1cbiAgaWYgKFwibGVmdFwiIGluIG9mZnNldDIpIHtcbiAgICBlbGVtLnN0eWxlW29wcG9zaXRlSG9yaXpvbnRhbFByb3BlcnR5XSA9IFwiXCI7XG4gICAgZWxlbS5zdHlsZVtob3Jpem9udGFsUHJvcGVydHldID0gXCJcIi5jb25jYXQocHJlc2V0SCwgXCJweFwiKTtcbiAgfVxuICBpZiAoXCJ0b3BcIiBpbiBvZmZzZXQyKSB7XG4gICAgZWxlbS5zdHlsZVtvcHBvc2l0ZVZlcnRpY2FsUHJvcGVydHldID0gXCJcIjtcbiAgICBlbGVtLnN0eWxlW3ZlcnRpY2FsUHJvcGVydHldID0gXCJcIi5jb25jYXQocHJlc2V0ViwgXCJweFwiKTtcbiAgfVxuICBmb3JjZVJlbGF5b3V0KGVsZW0pO1xuICB2YXIgb2xkID0gZ2V0T2Zmc2V0KGVsZW0pO1xuICB2YXIgb3JpZ2luYWxTdHlsZSA9IHt9O1xuICBmb3IgKHZhciBrZXkyIGluIG9mZnNldDIpIHtcbiAgICBpZiAob2Zmc2V0Mi5oYXNPd25Qcm9wZXJ0eShrZXkyKSkge1xuICAgICAgdmFyIGRpciA9IGdldE9mZnNldERpcmVjdGlvbihrZXkyLCBvcHRpb24pO1xuICAgICAgdmFyIHByZXNldCA9IGtleTIgPT09IFwibGVmdFwiID8gcHJlc2V0SCA6IHByZXNldFY7XG4gICAgICB2YXIgb2ZmID0gb3JpZ2luYWxPZmZzZXRba2V5Ml0gLSBvbGRba2V5Ml07XG4gICAgICBpZiAoZGlyID09PSBrZXkyKSB7XG4gICAgICAgIG9yaWdpbmFsU3R5bGVbZGlyXSA9IHByZXNldCArIG9mZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9yaWdpbmFsU3R5bGVbZGlyXSA9IHByZXNldCAtIG9mZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3NzKGVsZW0sIG9yaWdpbmFsU3R5bGUpO1xuICBmb3JjZVJlbGF5b3V0KGVsZW0pO1xuICBpZiAoXCJsZWZ0XCIgaW4gb2Zmc2V0MiB8fCBcInRvcFwiIGluIG9mZnNldDIpIHtcbiAgICBzZXRUcmFuc2l0aW9uUHJvcGVydHkoZWxlbSwgb3JpZ2luYWxUcmFuc2l0aW9uKTtcbiAgfVxuICB2YXIgcmV0ID0ge307XG4gIGZvciAodmFyIF9rZXkgaW4gb2Zmc2V0Mikge1xuICAgIGlmIChvZmZzZXQyLmhhc093blByb3BlcnR5KF9rZXkpKSB7XG4gICAgICB2YXIgX2RpciA9IGdldE9mZnNldERpcmVjdGlvbihfa2V5LCBvcHRpb24pO1xuICAgICAgdmFyIF9vZmYgPSBvZmZzZXQyW19rZXldIC0gb3JpZ2luYWxPZmZzZXRbX2tleV07XG4gICAgICBpZiAoX2tleSA9PT0gX2Rpcikge1xuICAgICAgICByZXRbX2Rpcl0gPSBvcmlnaW5hbFN0eWxlW19kaXJdICsgX29mZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldFtfZGlyXSA9IG9yaWdpbmFsU3R5bGVbX2Rpcl0gLSBfb2ZmO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjc3MoZWxlbSwgcmV0KTtcbn1cbmZ1bmN0aW9uIHNldFRyYW5zZm9ybSQxKGVsZW0sIG9mZnNldDIpIHtcbiAgdmFyIG9yaWdpbmFsT2Zmc2V0ID0gZ2V0T2Zmc2V0KGVsZW0pO1xuICB2YXIgb3JpZ2luYWxYWSA9IGdldFRyYW5zZm9ybVhZKGVsZW0pO1xuICB2YXIgcmVzdWx0WFkgPSB7XG4gICAgeDogb3JpZ2luYWxYWS54LFxuICAgIHk6IG9yaWdpbmFsWFkueVxuICB9O1xuICBpZiAoXCJsZWZ0XCIgaW4gb2Zmc2V0Mikge1xuICAgIHJlc3VsdFhZLnggPSBvcmlnaW5hbFhZLnggKyBvZmZzZXQyLmxlZnQgLSBvcmlnaW5hbE9mZnNldC5sZWZ0O1xuICB9XG4gIGlmIChcInRvcFwiIGluIG9mZnNldDIpIHtcbiAgICByZXN1bHRYWS55ID0gb3JpZ2luYWxYWS55ICsgb2Zmc2V0Mi50b3AgLSBvcmlnaW5hbE9mZnNldC50b3A7XG4gIH1cbiAgc2V0VHJhbnNmb3JtWFkoZWxlbSwgcmVzdWx0WFkpO1xufVxuZnVuY3Rpb24gc2V0T2Zmc2V0KGVsZW0sIG9mZnNldDIsIG9wdGlvbikge1xuICBpZiAob3B0aW9uLmlnbm9yZVNoYWtlKSB7XG4gICAgdmFyIG9yaU9mZnNldCA9IGdldE9mZnNldChlbGVtKTtcbiAgICB2YXIgb0xlZnQgPSBvcmlPZmZzZXQubGVmdC50b0ZpeGVkKDApO1xuICAgIHZhciBvVG9wID0gb3JpT2Zmc2V0LnRvcC50b0ZpeGVkKDApO1xuICAgIHZhciB0TGVmdCA9IG9mZnNldDIubGVmdC50b0ZpeGVkKDApO1xuICAgIHZhciB0VG9wID0gb2Zmc2V0Mi50b3AudG9GaXhlZCgwKTtcbiAgICBpZiAob0xlZnQgPT09IHRMZWZ0ICYmIG9Ub3AgPT09IHRUb3ApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbi51c2VDc3NSaWdodCB8fCBvcHRpb24udXNlQ3NzQm90dG9tKSB7XG4gICAgc2V0TGVmdFRvcChlbGVtLCBvZmZzZXQyLCBvcHRpb24pO1xuICB9IGVsc2UgaWYgKG9wdGlvbi51c2VDc3NUcmFuc2Zvcm0gJiYgZ2V0VHJhbnNmb3JtTmFtZSgpIGluIGRvY3VtZW50LmJvZHkuc3R5bGUpIHtcbiAgICBzZXRUcmFuc2Zvcm0kMShlbGVtLCBvZmZzZXQyKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRMZWZ0VG9wKGVsZW0sIG9mZnNldDIsIG9wdGlvbik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVhY2goYXJyLCBmbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGZuKGFycltpXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQm9yZGVyQm94Rm4oZWxlbSkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZVgoZWxlbSwgXCJib3hTaXppbmdcIikgPT09IFwiYm9yZGVyLWJveFwiO1xufVxudmFyIEJPWF9NT0RFTFMgPSBbXCJtYXJnaW5cIiwgXCJib3JkZXJcIiwgXCJwYWRkaW5nXCJdO1xudmFyIENPTlRFTlRfSU5ERVggPSAtMTtcbnZhciBQQURESU5HX0lOREVYID0gMjtcbnZhciBCT1JERVJfSU5ERVggPSAxO1xudmFyIE1BUkdJTl9JTkRFWCA9IDA7XG5mdW5jdGlvbiBzd2FwKGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBvbGQgPSB7fTtcbiAgdmFyIHN0eWxlMiA9IGVsZW0uc3R5bGU7XG4gIHZhciBuYW1lO1xuICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBvbGRbbmFtZV0gPSBzdHlsZTJbbmFtZV07XG4gICAgICBzdHlsZTJbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgIH1cbiAgfVxuICBjYWxsYmFjay5jYWxsKGVsZW0pO1xuICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBzdHlsZTJbbmFtZV0gPSBvbGRbbmFtZV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRQQk1XaWR0aChlbGVtLCBwcm9wcywgd2hpY2gpIHtcbiAgdmFyIHZhbHVlID0gMDtcbiAgdmFyIHByb3A7XG4gIHZhciBqO1xuICB2YXIgaTtcbiAgZm9yIChqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgcHJvcCA9IHByb3BzW2pdO1xuICAgIGlmIChwcm9wKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgd2hpY2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNzc1Byb3AgPSB2b2lkIDA7XG4gICAgICAgIGlmIChwcm9wID09PSBcImJvcmRlclwiKSB7XG4gICAgICAgICAgY3NzUHJvcCA9IFwiXCIuY29uY2F0KHByb3ApLmNvbmNhdCh3aGljaFtpXSwgXCJXaWR0aFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjc3NQcm9wID0gcHJvcCArIHdoaWNoW2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlICs9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZVgoZWxlbSwgY3NzUHJvcCkpIHx8IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbnZhciBkb21VdGlscyA9IHtcbiAgZ2V0UGFyZW50OiBmdW5jdGlvbiBnZXRQYXJlbnQoZWxlbWVudCkge1xuICAgIHZhciBwYXJlbnQgPSBlbGVtZW50O1xuICAgIGRvIHtcbiAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT09IDExICYmIHBhcmVudC5ob3N0KSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfSB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMSAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDkpO1xuICAgIHJldHVybiBwYXJlbnQ7XG4gIH1cbn07XG5lYWNoKFtcIldpZHRoXCIsIFwiSGVpZ2h0XCJdLCBmdW5jdGlvbihuYW1lKSB7XG4gIGRvbVV0aWxzW1wiZG9jXCIuY29uY2F0KG5hbWUpXSA9IGZ1bmN0aW9uKHJlZldpbikge1xuICAgIHZhciBkMiA9IHJlZldpbi5kb2N1bWVudDtcbiAgICByZXR1cm4gTWF0aC5tYXgoZDIuZG9jdW1lbnRFbGVtZW50W1wic2Nyb2xsXCIuY29uY2F0KG5hbWUpXSwgZDIuYm9keVtcInNjcm9sbFwiLmNvbmNhdChuYW1lKV0sIGRvbVV0aWxzW1widmlld3BvcnRcIi5jb25jYXQobmFtZSldKGQyKSk7XG4gIH07XG4gIGRvbVV0aWxzW1widmlld3BvcnRcIi5jb25jYXQobmFtZSldID0gZnVuY3Rpb24od2luKSB7XG4gICAgdmFyIHByb3AgPSBcImNsaWVudFwiLmNvbmNhdChuYW1lKTtcbiAgICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuICAgIHZhciBib2R5ID0gZG9jLmJvZHk7XG4gICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIGRvY3VtZW50RWxlbWVudFByb3AgPSBkb2N1bWVudEVsZW1lbnRbcHJvcF07XG4gICAgcmV0dXJuIGRvYy5jb21wYXRNb2RlID09PSBcIkNTUzFDb21wYXRcIiAmJiBkb2N1bWVudEVsZW1lbnRQcm9wIHx8IGJvZHkgJiYgYm9keVtwcm9wXSB8fCBkb2N1bWVudEVsZW1lbnRQcm9wO1xuICB9O1xufSk7XG5mdW5jdGlvbiBnZXRXSChlbGVtLCBuYW1lLCBleCkge1xuICB2YXIgZXh0cmEgPSBleDtcbiAgaWYgKGlzV2luZG93KGVsZW0pKSB7XG4gICAgcmV0dXJuIG5hbWUgPT09IFwid2lkdGhcIiA/IGRvbVV0aWxzLnZpZXdwb3J0V2lkdGgoZWxlbSkgOiBkb21VdGlscy52aWV3cG9ydEhlaWdodChlbGVtKTtcbiAgfSBlbHNlIGlmIChlbGVtLm5vZGVUeXBlID09PSA5KSB7XG4gICAgcmV0dXJuIG5hbWUgPT09IFwid2lkdGhcIiA/IGRvbVV0aWxzLmRvY1dpZHRoKGVsZW0pIDogZG9tVXRpbHMuZG9jSGVpZ2h0KGVsZW0pO1xuICB9XG4gIHZhciB3aGljaCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IFtcIkxlZnRcIiwgXCJSaWdodFwiXSA6IFtcIlRvcFwiLCBcIkJvdHRvbVwiXTtcbiAgdmFyIGJvcmRlckJveFZhbHVlID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA6IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICB2YXIgaXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveEZuKGVsZW0pO1xuICB2YXIgY3NzQm94VmFsdWUgPSAwO1xuICBpZiAoYm9yZGVyQm94VmFsdWUgPT09IG51bGwgfHwgYm9yZGVyQm94VmFsdWUgPT09IHZvaWQgMCB8fCBib3JkZXJCb3hWYWx1ZSA8PSAwKSB7XG4gICAgYm9yZGVyQm94VmFsdWUgPSB2b2lkIDA7XG4gICAgY3NzQm94VmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlWChlbGVtLCBuYW1lKTtcbiAgICBpZiAoY3NzQm94VmFsdWUgPT09IG51bGwgfHwgY3NzQm94VmFsdWUgPT09IHZvaWQgMCB8fCBOdW1iZXIoY3NzQm94VmFsdWUpIDwgMCkge1xuICAgICAgY3NzQm94VmFsdWUgPSBlbGVtLnN0eWxlW25hbWVdIHx8IDA7XG4gICAgfVxuICAgIGNzc0JveFZhbHVlID0gcGFyc2VGbG9hdChjc3NCb3hWYWx1ZSkgfHwgMDtcbiAgfVxuICBpZiAoZXh0cmEgPT09IHZvaWQgMCkge1xuICAgIGV4dHJhID0gaXNCb3JkZXJCb3ggPyBCT1JERVJfSU5ERVggOiBDT05URU5UX0lOREVYO1xuICB9XG4gIHZhciBib3JkZXJCb3hWYWx1ZU9ySXNCb3JkZXJCb3ggPSBib3JkZXJCb3hWYWx1ZSAhPT0gdm9pZCAwIHx8IGlzQm9yZGVyQm94O1xuICB2YXIgdmFsID0gYm9yZGVyQm94VmFsdWUgfHwgY3NzQm94VmFsdWU7XG4gIGlmIChleHRyYSA9PT0gQ09OVEVOVF9JTkRFWCkge1xuICAgIGlmIChib3JkZXJCb3hWYWx1ZU9ySXNCb3JkZXJCb3gpIHtcbiAgICAgIHJldHVybiB2YWwgLSBnZXRQQk1XaWR0aChlbGVtLCBbXCJib3JkZXJcIiwgXCJwYWRkaW5nXCJdLCB3aGljaCk7XG4gICAgfVxuICAgIHJldHVybiBjc3NCb3hWYWx1ZTtcbiAgfSBlbHNlIGlmIChib3JkZXJCb3hWYWx1ZU9ySXNCb3JkZXJCb3gpIHtcbiAgICBpZiAoZXh0cmEgPT09IEJPUkRFUl9JTkRFWCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbCArIChleHRyYSA9PT0gUEFERElOR19JTkRFWCA/IC1nZXRQQk1XaWR0aChlbGVtLCBbXCJib3JkZXJcIl0sIHdoaWNoKSA6IGdldFBCTVdpZHRoKGVsZW0sIFtcIm1hcmdpblwiXSwgd2hpY2gpKTtcbiAgfVxuICByZXR1cm4gY3NzQm94VmFsdWUgKyBnZXRQQk1XaWR0aChlbGVtLCBCT1hfTU9ERUxTLnNsaWNlKGV4dHJhKSwgd2hpY2gpO1xufVxudmFyIGNzc1Nob3cgPSB7XG4gIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsXG4gIGRpc3BsYXk6IFwiYmxvY2tcIlxufTtcbmZ1bmN0aW9uIGdldFdISWdub3JlRGlzcGxheSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG4gIHZhciB2YWw7XG4gIHZhciBlbGVtID0gYXJnc1swXTtcbiAgaWYgKGVsZW0ub2Zmc2V0V2lkdGggIT09IDApIHtcbiAgICB2YWwgPSBnZXRXSC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHN3YXAoZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG4gICAgICB2YWwgPSBnZXRXSC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5lYWNoKFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBmaXJzdCA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICBkb21VdGlsc1tcIm91dGVyXCIuY29uY2F0KGZpcnN0KV0gPSBmdW5jdGlvbihlbCwgaW5jbHVkZU1hcmdpbikge1xuICAgIHJldHVybiBlbCAmJiBnZXRXSElnbm9yZURpc3BsYXkoZWwsIG5hbWUsIGluY2x1ZGVNYXJnaW4gPyBNQVJHSU5fSU5ERVggOiBCT1JERVJfSU5ERVgpO1xuICB9O1xuICB2YXIgd2hpY2ggPSBuYW1lID09PSBcIndpZHRoXCIgPyBbXCJMZWZ0XCIsIFwiUmlnaHRcIl0gOiBbXCJUb3BcIiwgXCJCb3R0b21cIl07XG4gIGRvbVV0aWxzW25hbWVdID0gZnVuY3Rpb24oZWxlbSwgdjIpIHtcbiAgICB2YXIgdmFsID0gdjI7XG4gICAgaWYgKHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoZWxlbSkge1xuICAgICAgICB2YXIgaXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveEZuKGVsZW0pO1xuICAgICAgICBpZiAoaXNCb3JkZXJCb3gpIHtcbiAgICAgICAgICB2YWwgKz0gZ2V0UEJNV2lkdGgoZWxlbSwgW1wicGFkZGluZ1wiLCBcImJvcmRlclwiXSwgd2hpY2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjc3MoZWxlbSwgbmFtZSwgdmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBlbGVtICYmIGdldFdISWdub3JlRGlzcGxheShlbGVtLCBuYW1lLCBDT05URU5UX0lOREVYKTtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gbWl4KHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGkgaW4gZnJvbSkge1xuICAgIGlmIChmcm9tLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICB0b1tpXSA9IGZyb21baV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cbnZhciB1dGlscyA9IHtcbiAgZ2V0V2luZG93OiBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICAgIGlmIChub2RlICYmIG5vZGUuZG9jdW1lbnQgJiYgbm9kZS5zZXRUaW1lb3V0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlO1xuICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgfSxcbiAgZ2V0RG9jdW1lbnQsXG4gIG9mZnNldDogZnVuY3Rpb24gb2Zmc2V0KGVsLCB2YWx1ZSwgb3B0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgc2V0T2Zmc2V0KGVsLCB2YWx1ZSwgb3B0aW9uIHx8IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldE9mZnNldChlbCk7XG4gICAgfVxuICB9LFxuICBpc1dpbmRvdyxcbiAgZWFjaCxcbiAgY3NzLFxuICBjbG9uZTogZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgcmV0W2ldID0gb2JqW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3ZlcmZsb3cgPSBvYmoub3ZlcmZsb3c7XG4gICAgaWYgKG92ZXJmbG93KSB7XG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICByZXQub3ZlcmZsb3dbaV0gPSBvYmoub3ZlcmZsb3dbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgbWl4LFxuICBnZXRXaW5kb3dTY3JvbGxMZWZ0OiBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxMZWZ0KHcyKSB7XG4gICAgcmV0dXJuIGdldFNjcm9sbExlZnQodzIpO1xuICB9LFxuICBnZXRXaW5kb3dTY3JvbGxUb3A6IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbFRvcCh3Mikge1xuICAgIHJldHVybiBnZXRTY3JvbGxUb3AodzIpO1xuICB9LFxuICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1dGlscy5taXgocmV0LCBpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB2b2lkIDAgOiBhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICB2aWV3cG9ydFdpZHRoOiAwLFxuICB2aWV3cG9ydEhlaWdodDogMFxufTtcbm1peCh1dGlscywgZG9tVXRpbHMpO1xudmFyIGdldFBhcmVudDIgPSB1dGlscy5nZXRQYXJlbnQ7XG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAodXRpbHMuaXNXaW5kb3coZWxlbWVudCkgfHwgZWxlbWVudC5ub2RlVHlwZSA9PT0gOSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBkb2MgPSB1dGlscy5nZXREb2N1bWVudChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIHBhcmVudDtcbiAgdmFyIHBvc2l0aW9uU3R5bGUgPSB1dGlscy5jc3MoZWxlbWVudCwgXCJwb3NpdGlvblwiKTtcbiAgdmFyIHNraXBTdGF0aWMgPSBwb3NpdGlvblN0eWxlID09PSBcImZpeGVkXCIgfHwgcG9zaXRpb25TdHlsZSA9PT0gXCJhYnNvbHV0ZVwiO1xuICBpZiAoIXNraXBTdGF0aWMpIHtcbiAgICByZXR1cm4gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImh0bWxcIiA/IG51bGwgOiBnZXRQYXJlbnQyKGVsZW1lbnQpO1xuICB9XG4gIGZvciAocGFyZW50ID0gZ2V0UGFyZW50MihlbGVtZW50KTsgcGFyZW50ICYmIHBhcmVudCAhPT0gYm9keSAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDk7IHBhcmVudCA9IGdldFBhcmVudDIocGFyZW50KSkge1xuICAgIHBvc2l0aW9uU3R5bGUgPSB1dGlscy5jc3MocGFyZW50LCBcInBvc2l0aW9uXCIpO1xuICAgIGlmIChwb3NpdGlvblN0eWxlICE9PSBcInN0YXRpY1wiKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbnZhciBnZXRQYXJlbnQkMSA9IHV0aWxzLmdldFBhcmVudDtcbmZ1bmN0aW9uIGlzQW5jZXN0b3JGaXhlZChlbGVtZW50KSB7XG4gIGlmICh1dGlscy5pc1dpbmRvdyhlbGVtZW50KSB8fCBlbGVtZW50Lm5vZGVUeXBlID09PSA5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBkb2MgPSB1dGlscy5nZXREb2N1bWVudChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIHBhcmVudCA9IG51bGw7XG4gIGZvciAocGFyZW50ID0gZ2V0UGFyZW50JDEoZWxlbWVudCk7IHBhcmVudCAmJiBwYXJlbnQgIT09IGJvZHkgJiYgcGFyZW50ICE9PSBkb2M7IHBhcmVudCA9IGdldFBhcmVudCQxKHBhcmVudCkpIHtcbiAgICB2YXIgcG9zaXRpb25TdHlsZSA9IHV0aWxzLmNzcyhwYXJlbnQsIFwicG9zaXRpb25cIik7XG4gICAgaWYgKHBvc2l0aW9uU3R5bGUgPT09IFwiZml4ZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFZpc2libGVSZWN0Rm9yRWxlbWVudChlbGVtZW50LCBhbHdheXNCeVZpZXdwb3J0KSB7XG4gIHZhciB2aXNpYmxlUmVjdCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiBJbmZpbml0eSxcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiBJbmZpbml0eVxuICB9O1xuICB2YXIgZWwgPSBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBkb2MgPSB1dGlscy5nZXREb2N1bWVudChlbGVtZW50KTtcbiAgdmFyIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICB2YXIgYm9keSA9IGRvYy5ib2R5O1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgd2hpbGUgKGVsKSB7XG4gICAgaWYgKChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpID09PSAtMSB8fCBlbC5jbGllbnRXaWR0aCAhPT0gMCkgJiYgZWwgIT09IGJvZHkgJiYgZWwgIT09IGRvY3VtZW50RWxlbWVudCAmJiB1dGlscy5jc3MoZWwsIFwib3ZlcmZsb3dcIikgIT09IFwidmlzaWJsZVwiKSB7XG4gICAgICB2YXIgcG9zID0gdXRpbHMub2Zmc2V0KGVsKTtcbiAgICAgIHBvcy5sZWZ0ICs9IGVsLmNsaWVudExlZnQ7XG4gICAgICBwb3MudG9wICs9IGVsLmNsaWVudFRvcDtcbiAgICAgIHZpc2libGVSZWN0LnRvcCA9IE1hdGgubWF4KHZpc2libGVSZWN0LnRvcCwgcG9zLnRvcCk7XG4gICAgICB2aXNpYmxlUmVjdC5yaWdodCA9IE1hdGgubWluKHZpc2libGVSZWN0LnJpZ2h0LCBwb3MubGVmdCArIGVsLmNsaWVudFdpZHRoKTtcbiAgICAgIHZpc2libGVSZWN0LmJvdHRvbSA9IE1hdGgubWluKHZpc2libGVSZWN0LmJvdHRvbSwgcG9zLnRvcCArIGVsLmNsaWVudEhlaWdodCk7XG4gICAgICB2aXNpYmxlUmVjdC5sZWZ0ID0gTWF0aC5tYXgodmlzaWJsZVJlY3QubGVmdCwgcG9zLmxlZnQpO1xuICAgIH0gZWxzZSBpZiAoZWwgPT09IGJvZHkgfHwgZWwgPT09IGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVsID0gZ2V0T2Zmc2V0UGFyZW50KGVsKTtcbiAgfVxuICB2YXIgb3JpZ2luYWxQb3NpdGlvbiA9IG51bGw7XG4gIGlmICghdXRpbHMuaXNXaW5kb3coZWxlbWVudCkgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gOSkge1xuICAgIG9yaWdpbmFsUG9zaXRpb24gPSBlbGVtZW50LnN0eWxlLnBvc2l0aW9uO1xuICAgIHZhciBwb3NpdGlvbiA9IHV0aWxzLmNzcyhlbGVtZW50LCBcInBvc2l0aW9uXCIpO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgIH1cbiAgfVxuICB2YXIgc2Nyb2xsWCA9IHV0aWxzLmdldFdpbmRvd1Njcm9sbExlZnQod2luKTtcbiAgdmFyIHNjcm9sbFkgPSB1dGlscy5nZXRXaW5kb3dTY3JvbGxUb3Aod2luKTtcbiAgdmFyIHZpZXdwb3J0V2lkdGggPSB1dGlscy52aWV3cG9ydFdpZHRoKHdpbik7XG4gIHZhciB2aWV3cG9ydEhlaWdodCA9IHV0aWxzLnZpZXdwb3J0SGVpZ2h0KHdpbik7XG4gIHZhciBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoO1xuICB2YXIgZG9jdW1lbnRIZWlnaHQgPSBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICB2YXIgYm9keVN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoYm9keSk7XG4gIGlmIChib2R5U3R5bGUub3ZlcmZsb3dYID09PSBcImhpZGRlblwiKSB7XG4gICAgZG9jdW1lbnRXaWR0aCA9IHdpbi5pbm5lcldpZHRoO1xuICB9XG4gIGlmIChib2R5U3R5bGUub3ZlcmZsb3dZID09PSBcImhpZGRlblwiKSB7XG4gICAgZG9jdW1lbnRIZWlnaHQgPSB3aW4uaW5uZXJIZWlnaHQ7XG4gIH1cbiAgaWYgKGVsZW1lbnQuc3R5bGUpIHtcbiAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gb3JpZ2luYWxQb3NpdGlvbjtcbiAgfVxuICBpZiAoYWx3YXlzQnlWaWV3cG9ydCB8fCBpc0FuY2VzdG9yRml4ZWQoZWxlbWVudCkpIHtcbiAgICB2aXNpYmxlUmVjdC5sZWZ0ID0gTWF0aC5tYXgodmlzaWJsZVJlY3QubGVmdCwgc2Nyb2xsWCk7XG4gICAgdmlzaWJsZVJlY3QudG9wID0gTWF0aC5tYXgodmlzaWJsZVJlY3QudG9wLCBzY3JvbGxZKTtcbiAgICB2aXNpYmxlUmVjdC5yaWdodCA9IE1hdGgubWluKHZpc2libGVSZWN0LnJpZ2h0LCBzY3JvbGxYICsgdmlld3BvcnRXaWR0aCk7XG4gICAgdmlzaWJsZVJlY3QuYm90dG9tID0gTWF0aC5taW4odmlzaWJsZVJlY3QuYm90dG9tLCBzY3JvbGxZICsgdmlld3BvcnRIZWlnaHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtYXhWaXNpYmxlV2lkdGggPSBNYXRoLm1heChkb2N1bWVudFdpZHRoLCBzY3JvbGxYICsgdmlld3BvcnRXaWR0aCk7XG4gICAgdmlzaWJsZVJlY3QucmlnaHQgPSBNYXRoLm1pbih2aXNpYmxlUmVjdC5yaWdodCwgbWF4VmlzaWJsZVdpZHRoKTtcbiAgICB2YXIgbWF4VmlzaWJsZUhlaWdodCA9IE1hdGgubWF4KGRvY3VtZW50SGVpZ2h0LCBzY3JvbGxZICsgdmlld3BvcnRIZWlnaHQpO1xuICAgIHZpc2libGVSZWN0LmJvdHRvbSA9IE1hdGgubWluKHZpc2libGVSZWN0LmJvdHRvbSwgbWF4VmlzaWJsZUhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIHZpc2libGVSZWN0LnRvcCA+PSAwICYmIHZpc2libGVSZWN0LmxlZnQgPj0gMCAmJiB2aXNpYmxlUmVjdC5ib3R0b20gPiB2aXNpYmxlUmVjdC50b3AgJiYgdmlzaWJsZVJlY3QucmlnaHQgPiB2aXNpYmxlUmVjdC5sZWZ0ID8gdmlzaWJsZVJlY3QgOiBudWxsO1xufVxuZnVuY3Rpb24gYWRqdXN0Rm9yVmlld3BvcnQoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCwgb3ZlcmZsb3cpIHtcbiAgdmFyIHBvcyA9IHV0aWxzLmNsb25lKGVsRnV0dXJlUG9zKTtcbiAgdmFyIHNpemUgPSB7XG4gICAgd2lkdGg6IGVsUmVnaW9uLndpZHRoLFxuICAgIGhlaWdodDogZWxSZWdpb24uaGVpZ2h0XG4gIH07XG4gIGlmIChvdmVyZmxvdy5hZGp1c3RYICYmIHBvcy5sZWZ0IDwgdmlzaWJsZVJlY3QubGVmdCkge1xuICAgIHBvcy5sZWZ0ID0gdmlzaWJsZVJlY3QubGVmdDtcbiAgfVxuICBpZiAob3ZlcmZsb3cucmVzaXplV2lkdGggJiYgcG9zLmxlZnQgPj0gdmlzaWJsZVJlY3QubGVmdCAmJiBwb3MubGVmdCArIHNpemUud2lkdGggPiB2aXNpYmxlUmVjdC5yaWdodCkge1xuICAgIHNpemUud2lkdGggLT0gcG9zLmxlZnQgKyBzaXplLndpZHRoIC0gdmlzaWJsZVJlY3QucmlnaHQ7XG4gIH1cbiAgaWYgKG92ZXJmbG93LmFkanVzdFggJiYgcG9zLmxlZnQgKyBzaXplLndpZHRoID4gdmlzaWJsZVJlY3QucmlnaHQpIHtcbiAgICBwb3MubGVmdCA9IE1hdGgubWF4KHZpc2libGVSZWN0LnJpZ2h0IC0gc2l6ZS53aWR0aCwgdmlzaWJsZVJlY3QubGVmdCk7XG4gIH1cbiAgaWYgKG92ZXJmbG93LmFkanVzdFkgJiYgcG9zLnRvcCA8IHZpc2libGVSZWN0LnRvcCkge1xuICAgIHBvcy50b3AgPSB2aXNpYmxlUmVjdC50b3A7XG4gIH1cbiAgaWYgKG92ZXJmbG93LnJlc2l6ZUhlaWdodCAmJiBwb3MudG9wID49IHZpc2libGVSZWN0LnRvcCAmJiBwb3MudG9wICsgc2l6ZS5oZWlnaHQgPiB2aXNpYmxlUmVjdC5ib3R0b20pIHtcbiAgICBzaXplLmhlaWdodCAtPSBwb3MudG9wICsgc2l6ZS5oZWlnaHQgLSB2aXNpYmxlUmVjdC5ib3R0b207XG4gIH1cbiAgaWYgKG92ZXJmbG93LmFkanVzdFkgJiYgcG9zLnRvcCArIHNpemUuaGVpZ2h0ID4gdmlzaWJsZVJlY3QuYm90dG9tKSB7XG4gICAgcG9zLnRvcCA9IE1hdGgubWF4KHZpc2libGVSZWN0LmJvdHRvbSAtIHNpemUuaGVpZ2h0LCB2aXNpYmxlUmVjdC50b3ApO1xuICB9XG4gIHJldHVybiB1dGlscy5taXgocG9zLCBzaXplKTtcbn1cbmZ1bmN0aW9uIGdldFJlZ2lvbihub2RlKSB7XG4gIHZhciBvZmZzZXQyO1xuICB2YXIgdzI7XG4gIHZhciBoO1xuICBpZiAoIXV0aWxzLmlzV2luZG93KG5vZGUpICYmIG5vZGUubm9kZVR5cGUgIT09IDkpIHtcbiAgICBvZmZzZXQyID0gdXRpbHMub2Zmc2V0KG5vZGUpO1xuICAgIHcyID0gdXRpbHMub3V0ZXJXaWR0aChub2RlKTtcbiAgICBoID0gdXRpbHMub3V0ZXJIZWlnaHQobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdpbiA9IHV0aWxzLmdldFdpbmRvdyhub2RlKTtcbiAgICBvZmZzZXQyID0ge1xuICAgICAgbGVmdDogdXRpbHMuZ2V0V2luZG93U2Nyb2xsTGVmdCh3aW4pLFxuICAgICAgdG9wOiB1dGlscy5nZXRXaW5kb3dTY3JvbGxUb3Aod2luKVxuICAgIH07XG4gICAgdzIgPSB1dGlscy52aWV3cG9ydFdpZHRoKHdpbik7XG4gICAgaCA9IHV0aWxzLnZpZXdwb3J0SGVpZ2h0KHdpbik7XG4gIH1cbiAgb2Zmc2V0Mi53aWR0aCA9IHcyO1xuICBvZmZzZXQyLmhlaWdodCA9IGg7XG4gIHJldHVybiBvZmZzZXQyO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25PZmZzZXQocmVnaW9uLCBhbGlnbikge1xuICB2YXIgViA9IGFsaWduLmNoYXJBdCgwKTtcbiAgdmFyIEggPSBhbGlnbi5jaGFyQXQoMSk7XG4gIHZhciB3MiA9IHJlZ2lvbi53aWR0aDtcbiAgdmFyIGggPSByZWdpb24uaGVpZ2h0O1xuICB2YXIgeDIgPSByZWdpb24ubGVmdDtcbiAgdmFyIHkyID0gcmVnaW9uLnRvcDtcbiAgaWYgKFYgPT09IFwiY1wiKSB7XG4gICAgeTIgKz0gaCAvIDI7XG4gIH0gZWxzZSBpZiAoViA9PT0gXCJiXCIpIHtcbiAgICB5MiArPSBoO1xuICB9XG4gIGlmIChIID09PSBcImNcIikge1xuICAgIHgyICs9IHcyIC8gMjtcbiAgfSBlbHNlIGlmIChIID09PSBcInJcIikge1xuICAgIHgyICs9IHcyO1xuICB9XG4gIHJldHVybiB7XG4gICAgbGVmdDogeDIsXG4gICAgdG9wOiB5MlxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RWxGdXR1cmVQb3MoZWxSZWdpb24sIHJlZk5vZGVSZWdpb24sIHBvaW50cywgb2Zmc2V0MiwgdGFyZ2V0T2Zmc2V0Mikge1xuICB2YXIgcDEgPSBnZXRBbGlnbk9mZnNldChyZWZOb2RlUmVnaW9uLCBwb2ludHNbMV0pO1xuICB2YXIgcDIgPSBnZXRBbGlnbk9mZnNldChlbFJlZ2lvbiwgcG9pbnRzWzBdKTtcbiAgdmFyIGRpZmYgPSBbcDIubGVmdCAtIHAxLmxlZnQsIHAyLnRvcCAtIHAxLnRvcF07XG4gIHJldHVybiB7XG4gICAgbGVmdDogTWF0aC5yb3VuZChlbFJlZ2lvbi5sZWZ0IC0gZGlmZlswXSArIG9mZnNldDJbMF0gLSB0YXJnZXRPZmZzZXQyWzBdKSxcbiAgICB0b3A6IE1hdGgucm91bmQoZWxSZWdpb24udG9wIC0gZGlmZlsxXSArIG9mZnNldDJbMV0gLSB0YXJnZXRPZmZzZXQyWzFdKVxuICB9O1xufVxuZnVuY3Rpb24gaXNGYWlsWChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSB7XG4gIHJldHVybiBlbEZ1dHVyZVBvcy5sZWZ0IDwgdmlzaWJsZVJlY3QubGVmdCB8fCBlbEZ1dHVyZVBvcy5sZWZ0ICsgZWxSZWdpb24ud2lkdGggPiB2aXNpYmxlUmVjdC5yaWdodDtcbn1cbmZ1bmN0aW9uIGlzRmFpbFkoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCkge1xuICByZXR1cm4gZWxGdXR1cmVQb3MudG9wIDwgdmlzaWJsZVJlY3QudG9wIHx8IGVsRnV0dXJlUG9zLnRvcCArIGVsUmVnaW9uLmhlaWdodCA+IHZpc2libGVSZWN0LmJvdHRvbTtcbn1cbmZ1bmN0aW9uIGlzQ29tcGxldGVGYWlsWChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSB7XG4gIHJldHVybiBlbEZ1dHVyZVBvcy5sZWZ0ID4gdmlzaWJsZVJlY3QucmlnaHQgfHwgZWxGdXR1cmVQb3MubGVmdCArIGVsUmVnaW9uLndpZHRoIDwgdmlzaWJsZVJlY3QubGVmdDtcbn1cbmZ1bmN0aW9uIGlzQ29tcGxldGVGYWlsWShlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSB7XG4gIHJldHVybiBlbEZ1dHVyZVBvcy50b3AgPiB2aXNpYmxlUmVjdC5ib3R0b20gfHwgZWxGdXR1cmVQb3MudG9wICsgZWxSZWdpb24uaGVpZ2h0IDwgdmlzaWJsZVJlY3QudG9wO1xufVxuZnVuY3Rpb24gZmxpcChwb2ludHMsIHJlZywgbWFwKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgdXRpbHMuZWFjaChwb2ludHMsIGZ1bmN0aW9uKHAyKSB7XG4gICAgcmV0LnB1c2gocDIucmVwbGFjZShyZWcsIGZ1bmN0aW9uKG0yKSB7XG4gICAgICByZXR1cm4gbWFwW20yXTtcbiAgICB9KSk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gZmxpcE9mZnNldChvZmZzZXQyLCBpbmRleDIpIHtcbiAgb2Zmc2V0MltpbmRleDJdID0gLW9mZnNldDJbaW5kZXgyXTtcbiAgcmV0dXJuIG9mZnNldDI7XG59XG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0KHN0ciwgb2Zmc2V0TGVuKSB7XG4gIHZhciBuMjtcbiAgaWYgKC8lJC8udGVzdChzdHIpKSB7XG4gICAgbjIgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKSwgMTApIC8gMTAwICogb2Zmc2V0TGVuO1xuICB9IGVsc2Uge1xuICAgIG4yID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gIH1cbiAgcmV0dXJuIG4yIHx8IDA7XG59XG5mdW5jdGlvbiBub3JtYWxpemVPZmZzZXQob2Zmc2V0MiwgZWwpIHtcbiAgb2Zmc2V0MlswXSA9IGNvbnZlcnRPZmZzZXQob2Zmc2V0MlswXSwgZWwud2lkdGgpO1xuICBvZmZzZXQyWzFdID0gY29udmVydE9mZnNldChvZmZzZXQyWzFdLCBlbC5oZWlnaHQpO1xufVxuZnVuY3Rpb24gZG9BbGlnbihlbCwgdGd0UmVnaW9uLCBhbGlnbiwgaXNUZ3RSZWdpb25WaXNpYmxlKSB7XG4gIHZhciBwb2ludHMgPSBhbGlnbi5wb2ludHM7XG4gIHZhciBvZmZzZXQyID0gYWxpZ24ub2Zmc2V0IHx8IFswLCAwXTtcbiAgdmFyIHRhcmdldE9mZnNldDIgPSBhbGlnbi50YXJnZXRPZmZzZXQgfHwgWzAsIDBdO1xuICB2YXIgb3ZlcmZsb3cgPSBhbGlnbi5vdmVyZmxvdztcbiAgdmFyIHNvdXJjZSA9IGFsaWduLnNvdXJjZSB8fCBlbDtcbiAgb2Zmc2V0MiA9IFtdLmNvbmNhdChvZmZzZXQyKTtcbiAgdGFyZ2V0T2Zmc2V0MiA9IFtdLmNvbmNhdCh0YXJnZXRPZmZzZXQyKTtcbiAgb3ZlcmZsb3cgPSBvdmVyZmxvdyB8fCB7fTtcbiAgdmFyIG5ld092ZXJmbG93Q2ZnID0ge307XG4gIHZhciBmYWlsID0gMDtcbiAgdmFyIGFsd2F5c0J5Vmlld3BvcnQgPSAhIShvdmVyZmxvdyAmJiBvdmVyZmxvdy5hbHdheXNCeVZpZXdwb3J0KTtcbiAgdmFyIHZpc2libGVSZWN0ID0gZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50KHNvdXJjZSwgYWx3YXlzQnlWaWV3cG9ydCk7XG4gIHZhciBlbFJlZ2lvbiA9IGdldFJlZ2lvbihzb3VyY2UpO1xuICBub3JtYWxpemVPZmZzZXQob2Zmc2V0MiwgZWxSZWdpb24pO1xuICBub3JtYWxpemVPZmZzZXQodGFyZ2V0T2Zmc2V0MiwgdGd0UmVnaW9uKTtcbiAgdmFyIGVsRnV0dXJlUG9zID0gZ2V0RWxGdXR1cmVQb3MoZWxSZWdpb24sIHRndFJlZ2lvbiwgcG9pbnRzLCBvZmZzZXQyLCB0YXJnZXRPZmZzZXQyKTtcbiAgdmFyIG5ld0VsUmVnaW9uID0gdXRpbHMubWVyZ2UoZWxSZWdpb24sIGVsRnV0dXJlUG9zKTtcbiAgaWYgKHZpc2libGVSZWN0ICYmIChvdmVyZmxvdy5hZGp1c3RYIHx8IG92ZXJmbG93LmFkanVzdFkpICYmIGlzVGd0UmVnaW9uVmlzaWJsZSkge1xuICAgIGlmIChvdmVyZmxvdy5hZGp1c3RYKSB7XG4gICAgICBpZiAoaXNGYWlsWChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSkge1xuICAgICAgICB2YXIgbmV3UG9pbnRzID0gZmxpcChwb2ludHMsIC9bbHJdL2dpLCB7XG4gICAgICAgICAgbDogXCJyXCIsXG4gICAgICAgICAgcjogXCJsXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuZXdPZmZzZXQgPSBmbGlwT2Zmc2V0KG9mZnNldDIsIDApO1xuICAgICAgICB2YXIgbmV3VGFyZ2V0T2Zmc2V0ID0gZmxpcE9mZnNldCh0YXJnZXRPZmZzZXQyLCAwKTtcbiAgICAgICAgdmFyIG5ld0VsRnV0dXJlUG9zID0gZ2V0RWxGdXR1cmVQb3MoZWxSZWdpb24sIHRndFJlZ2lvbiwgbmV3UG9pbnRzLCBuZXdPZmZzZXQsIG5ld1RhcmdldE9mZnNldCk7XG4gICAgICAgIGlmICghaXNDb21wbGV0ZUZhaWxYKG5ld0VsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpKSB7XG4gICAgICAgICAgZmFpbCA9IDE7XG4gICAgICAgICAgcG9pbnRzID0gbmV3UG9pbnRzO1xuICAgICAgICAgIG9mZnNldDIgPSBuZXdPZmZzZXQ7XG4gICAgICAgICAgdGFyZ2V0T2Zmc2V0MiA9IG5ld1RhcmdldE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3ZlcmZsb3cuYWRqdXN0WSkge1xuICAgICAgaWYgKGlzRmFpbFkoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCkpIHtcbiAgICAgICAgdmFyIF9uZXdQb2ludHMgPSBmbGlwKHBvaW50cywgL1t0Yl0vZ2ksIHtcbiAgICAgICAgICB0OiBcImJcIixcbiAgICAgICAgICBiOiBcInRcIlxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9uZXdPZmZzZXQgPSBmbGlwT2Zmc2V0KG9mZnNldDIsIDEpO1xuICAgICAgICB2YXIgX25ld1RhcmdldE9mZnNldCA9IGZsaXBPZmZzZXQodGFyZ2V0T2Zmc2V0MiwgMSk7XG4gICAgICAgIHZhciBfbmV3RWxGdXR1cmVQb3MgPSBnZXRFbEZ1dHVyZVBvcyhlbFJlZ2lvbiwgdGd0UmVnaW9uLCBfbmV3UG9pbnRzLCBfbmV3T2Zmc2V0LCBfbmV3VGFyZ2V0T2Zmc2V0KTtcbiAgICAgICAgaWYgKCFpc0NvbXBsZXRlRmFpbFkoX25ld0VsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpKSB7XG4gICAgICAgICAgZmFpbCA9IDE7XG4gICAgICAgICAgcG9pbnRzID0gX25ld1BvaW50cztcbiAgICAgICAgICBvZmZzZXQyID0gX25ld09mZnNldDtcbiAgICAgICAgICB0YXJnZXRPZmZzZXQyID0gX25ld1RhcmdldE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmFpbCkge1xuICAgICAgZWxGdXR1cmVQb3MgPSBnZXRFbEZ1dHVyZVBvcyhlbFJlZ2lvbiwgdGd0UmVnaW9uLCBwb2ludHMsIG9mZnNldDIsIHRhcmdldE9mZnNldDIpO1xuICAgICAgdXRpbHMubWl4KG5ld0VsUmVnaW9uLCBlbEZ1dHVyZVBvcyk7XG4gICAgfVxuICAgIHZhciBpc1N0aWxsRmFpbFggPSBpc0ZhaWxYKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpO1xuICAgIHZhciBpc1N0aWxsRmFpbFkgPSBpc0ZhaWxZKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpO1xuICAgIGlmIChpc1N0aWxsRmFpbFggfHwgaXNTdGlsbEZhaWxZKSB7XG4gICAgICB2YXIgX25ld1BvaW50czIgPSBwb2ludHM7XG4gICAgICBpZiAoaXNTdGlsbEZhaWxYKSB7XG4gICAgICAgIF9uZXdQb2ludHMyID0gZmxpcChwb2ludHMsIC9bbHJdL2dpLCB7XG4gICAgICAgICAgbDogXCJyXCIsXG4gICAgICAgICAgcjogXCJsXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNTdGlsbEZhaWxZKSB7XG4gICAgICAgIF9uZXdQb2ludHMyID0gZmxpcChwb2ludHMsIC9bdGJdL2dpLCB7XG4gICAgICAgICAgdDogXCJiXCIsXG4gICAgICAgICAgYjogXCJ0XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwb2ludHMgPSBfbmV3UG9pbnRzMjtcbiAgICAgIG9mZnNldDIgPSBhbGlnbi5vZmZzZXQgfHwgWzAsIDBdO1xuICAgICAgdGFyZ2V0T2Zmc2V0MiA9IGFsaWduLnRhcmdldE9mZnNldCB8fCBbMCwgMF07XG4gICAgfVxuICAgIG5ld092ZXJmbG93Q2ZnLmFkanVzdFggPSBvdmVyZmxvdy5hZGp1c3RYICYmIGlzU3RpbGxGYWlsWDtcbiAgICBuZXdPdmVyZmxvd0NmZy5hZGp1c3RZID0gb3ZlcmZsb3cuYWRqdXN0WSAmJiBpc1N0aWxsRmFpbFk7XG4gICAgaWYgKG5ld092ZXJmbG93Q2ZnLmFkanVzdFggfHwgbmV3T3ZlcmZsb3dDZmcuYWRqdXN0WSkge1xuICAgICAgbmV3RWxSZWdpb24gPSBhZGp1c3RGb3JWaWV3cG9ydChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0LCBuZXdPdmVyZmxvd0NmZyk7XG4gICAgfVxuICB9XG4gIGlmIChuZXdFbFJlZ2lvbi53aWR0aCAhPT0gZWxSZWdpb24ud2lkdGgpIHtcbiAgICB1dGlscy5jc3Moc291cmNlLCBcIndpZHRoXCIsIHV0aWxzLndpZHRoKHNvdXJjZSkgKyBuZXdFbFJlZ2lvbi53aWR0aCAtIGVsUmVnaW9uLndpZHRoKTtcbiAgfVxuICBpZiAobmV3RWxSZWdpb24uaGVpZ2h0ICE9PSBlbFJlZ2lvbi5oZWlnaHQpIHtcbiAgICB1dGlscy5jc3Moc291cmNlLCBcImhlaWdodFwiLCB1dGlscy5oZWlnaHQoc291cmNlKSArIG5ld0VsUmVnaW9uLmhlaWdodCAtIGVsUmVnaW9uLmhlaWdodCk7XG4gIH1cbiAgdXRpbHMub2Zmc2V0KHNvdXJjZSwge1xuICAgIGxlZnQ6IG5ld0VsUmVnaW9uLmxlZnQsXG4gICAgdG9wOiBuZXdFbFJlZ2lvbi50b3BcbiAgfSwge1xuICAgIHVzZUNzc1JpZ2h0OiBhbGlnbi51c2VDc3NSaWdodCxcbiAgICB1c2VDc3NCb3R0b206IGFsaWduLnVzZUNzc0JvdHRvbSxcbiAgICB1c2VDc3NUcmFuc2Zvcm06IGFsaWduLnVzZUNzc1RyYW5zZm9ybSxcbiAgICBpZ25vcmVTaGFrZTogYWxpZ24uaWdub3JlU2hha2VcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcG9pbnRzLFxuICAgIG9mZnNldDogb2Zmc2V0MixcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldDIsXG4gICAgb3ZlcmZsb3c6IG5ld092ZXJmbG93Q2ZnXG4gIH07XG59XG5mdW5jdGlvbiBpc091dE9mVmlzaWJsZVJlY3QodGFyZ2V0LCBhbHdheXNCeVZpZXdwb3J0KSB7XG4gIHZhciB2aXNpYmxlUmVjdCA9IGdldFZpc2libGVSZWN0Rm9yRWxlbWVudCh0YXJnZXQsIGFsd2F5c0J5Vmlld3BvcnQpO1xuICB2YXIgdGFyZ2V0UmVnaW9uID0gZ2V0UmVnaW9uKHRhcmdldCk7XG4gIHJldHVybiAhdmlzaWJsZVJlY3QgfHwgdGFyZ2V0UmVnaW9uLmxlZnQgKyB0YXJnZXRSZWdpb24ud2lkdGggPD0gdmlzaWJsZVJlY3QubGVmdCB8fCB0YXJnZXRSZWdpb24udG9wICsgdGFyZ2V0UmVnaW9uLmhlaWdodCA8PSB2aXNpYmxlUmVjdC50b3AgfHwgdGFyZ2V0UmVnaW9uLmxlZnQgPj0gdmlzaWJsZVJlY3QucmlnaHQgfHwgdGFyZ2V0UmVnaW9uLnRvcCA+PSB2aXNpYmxlUmVjdC5ib3R0b207XG59XG5mdW5jdGlvbiBhbGlnbkVsZW1lbnQoZWwsIHJlZk5vZGUsIGFsaWduKSB7XG4gIHZhciB0YXJnZXQgPSBhbGlnbi50YXJnZXQgfHwgcmVmTm9kZTtcbiAgdmFyIHJlZk5vZGVSZWdpb24gPSBnZXRSZWdpb24odGFyZ2V0KTtcbiAgdmFyIGlzVGFyZ2V0Tm90T3V0T2ZWaXNpYmxlID0gIWlzT3V0T2ZWaXNpYmxlUmVjdCh0YXJnZXQsIGFsaWduLm92ZXJmbG93ICYmIGFsaWduLm92ZXJmbG93LmFsd2F5c0J5Vmlld3BvcnQpO1xuICByZXR1cm4gZG9BbGlnbihlbCwgcmVmTm9kZVJlZ2lvbiwgYWxpZ24sIGlzVGFyZ2V0Tm90T3V0T2ZWaXNpYmxlKTtcbn1cbmFsaWduRWxlbWVudC5fX2dldE9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudDtcbmFsaWduRWxlbWVudC5fX2dldFZpc2libGVSZWN0Rm9yRWxlbWVudCA9IGdldFZpc2libGVSZWN0Rm9yRWxlbWVudDtcbmZ1bmN0aW9uIGFsaWduUG9pbnQoZWwsIHRndFBvaW50LCBhbGlnbikge1xuICB2YXIgcGFnZVg7XG4gIHZhciBwYWdlWTtcbiAgdmFyIGRvYyA9IHV0aWxzLmdldERvY3VtZW50KGVsKTtcbiAgdmFyIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICB2YXIgc2Nyb2xsWCA9IHV0aWxzLmdldFdpbmRvd1Njcm9sbExlZnQod2luKTtcbiAgdmFyIHNjcm9sbFkgPSB1dGlscy5nZXRXaW5kb3dTY3JvbGxUb3Aod2luKTtcbiAgdmFyIHZpZXdwb3J0V2lkdGggPSB1dGlscy52aWV3cG9ydFdpZHRoKHdpbik7XG4gIHZhciB2aWV3cG9ydEhlaWdodCA9IHV0aWxzLnZpZXdwb3J0SGVpZ2h0KHdpbik7XG4gIGlmIChcInBhZ2VYXCIgaW4gdGd0UG9pbnQpIHtcbiAgICBwYWdlWCA9IHRndFBvaW50LnBhZ2VYO1xuICB9IGVsc2Uge1xuICAgIHBhZ2VYID0gc2Nyb2xsWCArIHRndFBvaW50LmNsaWVudFg7XG4gIH1cbiAgaWYgKFwicGFnZVlcIiBpbiB0Z3RQb2ludCkge1xuICAgIHBhZ2VZID0gdGd0UG9pbnQucGFnZVk7XG4gIH0gZWxzZSB7XG4gICAgcGFnZVkgPSBzY3JvbGxZICsgdGd0UG9pbnQuY2xpZW50WTtcbiAgfVxuICB2YXIgdGd0UmVnaW9uID0ge1xuICAgIGxlZnQ6IHBhZ2VYLFxuICAgIHRvcDogcGFnZVksXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG4gIHZhciBwb2ludEluVmlldyA9IHBhZ2VYID49IDAgJiYgcGFnZVggPD0gc2Nyb2xsWCArIHZpZXdwb3J0V2lkdGggJiYgcGFnZVkgPj0gMCAmJiBwYWdlWSA8PSBzY3JvbGxZICsgdmlld3BvcnRIZWlnaHQ7XG4gIHZhciBwb2ludHMgPSBbYWxpZ24ucG9pbnRzWzBdLCBcImNjXCJdO1xuICByZXR1cm4gZG9BbGlnbihlbCwgdGd0UmVnaW9uLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYWxpZ24pLCB7fSwge1xuICAgIHBvaW50c1xuICB9KSwgcG9pbnRJblZpZXcpO1xufVxuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIkMSgpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxudmFyIF9saXN0Q2FjaGVDbGVhciA9IGxpc3RDYWNoZUNsZWFyJDE7XG5mdW5jdGlvbiBlcSQyKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8IHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG59XG52YXIgZXFfMSA9IGVxJDI7XG52YXIgZXEkMSA9IGVxXzE7XG5mdW5jdGlvbiBhc3NvY0luZGV4T2YkNChhcnJheTQsIGtleTIpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5NC5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcSQxKGFycmF5NFtsZW5ndGhdWzBdLCBrZXkyKSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxudmFyIF9hc3NvY0luZGV4T2YgPSBhc3NvY0luZGV4T2YkNDtcbnZhciBhc3NvY0luZGV4T2YkMyA9IF9hc3NvY0luZGV4T2Y7XG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZSQxKGtleTIpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLCBpbmRleDIgPSBhc3NvY0luZGV4T2YkMyhkYXRhLCBrZXkyKTtcbiAgaWYgKGluZGV4MiA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4MiA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4MiwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxudmFyIF9saXN0Q2FjaGVEZWxldGUgPSBsaXN0Q2FjaGVEZWxldGUkMTtcbnZhciBhc3NvY0luZGV4T2YkMiA9IF9hc3NvY0luZGV4T2Y7XG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQkMShrZXkyKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXywgaW5kZXgyID0gYXNzb2NJbmRleE9mJDIoZGF0YSwga2V5Mik7XG4gIHJldHVybiBpbmRleDIgPCAwID8gdm9pZCAwIDogZGF0YVtpbmRleDJdWzFdO1xufVxudmFyIF9saXN0Q2FjaGVHZXQgPSBsaXN0Q2FjaGVHZXQkMTtcbnZhciBhc3NvY0luZGV4T2YkMSA9IF9hc3NvY0luZGV4T2Y7XG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMkMShrZXkyKSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YkMSh0aGlzLl9fZGF0YV9fLCBrZXkyKSA+IC0xO1xufVxudmFyIF9saXN0Q2FjaGVIYXMgPSBsaXN0Q2FjaGVIYXMkMTtcbnZhciBhc3NvY0luZGV4T2YgPSBfYXNzb2NJbmRleE9mO1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0JDEoa2V5MiwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLCBpbmRleDIgPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5Mik7XG4gIGlmIChpbmRleDIgPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXkyLCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXgyXVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxudmFyIF9saXN0Q2FjaGVTZXQgPSBsaXN0Q2FjaGVTZXQkMTtcbnZhciBsaXN0Q2FjaGVDbGVhciA9IF9saXN0Q2FjaGVDbGVhciwgbGlzdENhY2hlRGVsZXRlID0gX2xpc3RDYWNoZURlbGV0ZSwgbGlzdENhY2hlR2V0ID0gX2xpc3RDYWNoZUdldCwgbGlzdENhY2hlSGFzID0gX2xpc3RDYWNoZUhhcywgbGlzdENhY2hlU2V0ID0gX2xpc3RDYWNoZVNldDtcbmZ1bmN0aW9uIExpc3RDYWNoZSQ0KGVudHJpZXMpIHtcbiAgdmFyIGluZGV4MiA9IC0xLCBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXgyIDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleDJdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cbkxpc3RDYWNoZSQ0LnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlJDQucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlJDQucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZSQ0LnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUkNC5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xudmFyIF9MaXN0Q2FjaGUgPSBMaXN0Q2FjaGUkNDtcbnZhciBMaXN0Q2FjaGUkMyA9IF9MaXN0Q2FjaGU7XG5mdW5jdGlvbiBzdGFja0NsZWFyJDEoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlJDMoKTtcbiAgdGhpcy5zaXplID0gMDtcbn1cbnZhciBfc3RhY2tDbGVhciA9IHN0YWNrQ2xlYXIkMTtcbmZ1bmN0aW9uIHN0YWNrRGVsZXRlJDEoa2V5Mikge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sIHJlc3VsdCA9IGRhdGFbXCJkZWxldGVcIl0oa2V5Mik7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBfc3RhY2tEZWxldGUgPSBzdGFja0RlbGV0ZSQxO1xuZnVuY3Rpb24gc3RhY2tHZXQkMShrZXkyKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkyKTtcbn1cbnZhciBfc3RhY2tHZXQgPSBzdGFja0dldCQxO1xuZnVuY3Rpb24gc3RhY2tIYXMkMShrZXkyKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkyKTtcbn1cbnZhciBfc3RhY2tIYXMgPSBzdGFja0hhcyQxO1xudmFyIGZyZWVHbG9iYWwkMSA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSBcIm9iamVjdFwiICYmIGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGNvbW1vbmpzR2xvYmFsO1xudmFyIF9mcmVlR2xvYmFsID0gZnJlZUdsb2JhbCQxO1xudmFyIGZyZWVHbG9iYWwgPSBfZnJlZUdsb2JhbDtcbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG52YXIgcm9vdCQ4ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG52YXIgX3Jvb3QgPSByb290JDg7XG52YXIgcm9vdCQ3ID0gX3Jvb3Q7XG52YXIgU3ltYm9sJDQgPSByb290JDcuU3ltYm9sO1xudmFyIF9TeW1ib2wgPSBTeW1ib2wkNDtcbnZhciBTeW1ib2wkMyA9IF9TeW1ib2w7XG52YXIgb2JqZWN0UHJvdG8kYiA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaGFzT3duUHJvcGVydHkkOSA9IG9iamVjdFByb3RvJGIuaGFzT3duUHJvcGVydHk7XG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmckMSA9IG9iamVjdFByb3RvJGIudG9TdHJpbmc7XG52YXIgc3ltVG9TdHJpbmdUYWckMSA9IFN5bWJvbCQzID8gU3ltYm9sJDMudG9TdHJpbmdUYWcgOiB2b2lkIDA7XG5mdW5jdGlvbiBnZXRSYXdUYWckMSh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eSQ5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnJDEpLCB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXTtcbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHZvaWQgMDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlMikge1xuICB9XG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZyQxLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgX2dldFJhd1RhZyA9IGdldFJhd1RhZyQxO1xudmFyIG9iamVjdFByb3RvJGEgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8kYS50b1N0cmluZztcbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nJDEodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxudmFyIF9vYmplY3RUb1N0cmluZyA9IG9iamVjdFRvU3RyaW5nJDE7XG52YXIgU3ltYm9sJDIgPSBfU3ltYm9sLCBnZXRSYXdUYWcgPSBfZ2V0UmF3VGFnLCBvYmplY3RUb1N0cmluZyA9IF9vYmplY3RUb1N0cmluZztcbnZhciBudWxsVGFnID0gXCJbb2JqZWN0IE51bGxdXCIsIHVuZGVmaW5lZFRhZyA9IFwiW29iamVjdCBVbmRlZmluZWRdXCI7XG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wkMiA/IFN5bWJvbCQyLnRvU3RyaW5nVGFnIDogdm9pZCAwO1xuZnVuY3Rpb24gYmFzZUdldFRhZyQ0KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiBzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpID8gZ2V0UmF3VGFnKHZhbHVlKSA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cbnZhciBfYmFzZUdldFRhZyA9IGJhc2VHZXRUYWckNDtcbmZ1bmN0aW9uIGlzT2JqZWN0JDIodmFsdWUpIHtcbiAgdmFyIHR5cGU0ID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZTQgPT0gXCJvYmplY3RcIiB8fCB0eXBlNCA9PSBcImZ1bmN0aW9uXCIpO1xufVxudmFyIGlzT2JqZWN0XzEgPSBpc09iamVjdCQyO1xudmFyIGJhc2VHZXRUYWckMyA9IF9iYXNlR2V0VGFnLCBpc09iamVjdCQxID0gaXNPYmplY3RfMTtcbnZhciBhc3luY1RhZyA9IFwiW29iamVjdCBBc3luY0Z1bmN0aW9uXVwiLCBmdW5jVGFnJDEgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsIGdlblRhZyA9IFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiwgcHJveHlUYWcgPSBcIltvYmplY3QgUHJveHldXCI7XG5mdW5jdGlvbiBpc0Z1bmN0aW9uJDIodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCQxKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdGFnID0gYmFzZUdldFRhZyQzKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnJDEgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxudmFyIGlzRnVuY3Rpb25fMSA9IGlzRnVuY3Rpb24kMjtcbnZhciByb290JDYgPSBfcm9vdDtcbnZhciBjb3JlSnNEYXRhJDEgPSByb290JDZbXCJfX2NvcmUtanNfc2hhcmVkX19cIl07XG52YXIgX2NvcmVKc0RhdGEgPSBjb3JlSnNEYXRhJDE7XG52YXIgY29yZUpzRGF0YSA9IF9jb3JlSnNEYXRhO1xudmFyIG1hc2tTcmNLZXkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8IFwiXCIpO1xuICByZXR1cm4gdWlkID8gXCJTeW1ib2woc3JjKV8xLlwiICsgdWlkIDogXCJcIjtcbn0oKTtcbmZ1bmN0aW9uIGlzTWFza2VkJDEoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIG1hc2tTcmNLZXkgaW4gZnVuYztcbn1cbnZhciBfaXNNYXNrZWQgPSBpc01hc2tlZCQxO1xudmFyIGZ1bmNQcm90byQxID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGZ1bmNUb1N0cmluZyQxID0gZnVuY1Byb3RvJDEudG9TdHJpbmc7XG5mdW5jdGlvbiB0b1NvdXJjZSQyKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nJDEuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmMgKyBcIlwiO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIlwiO1xufVxudmFyIF90b1NvdXJjZSA9IHRvU291cmNlJDI7XG52YXIgaXNGdW5jdGlvbiQxID0gaXNGdW5jdGlvbl8xLCBpc01hc2tlZCA9IF9pc01hc2tlZCwgaXNPYmplY3QgPSBpc09iamVjdF8xLCB0b1NvdXJjZSQxID0gX3RvU291cmNlO1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSwgb2JqZWN0UHJvdG8kOSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xudmFyIGhhc093blByb3BlcnR5JDggPSBvYmplY3RQcm90byQ5Lmhhc093blByb3BlcnR5O1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoXCJeXCIgKyBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSQ4KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgXCJcXFxcJCZcIikucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgXCIkMS4qP1wiKSArIFwiJFwiKTtcbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSQxKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybjQgPSBpc0Z1bmN0aW9uJDEodmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm40LnRlc3QodG9Tb3VyY2UkMSh2YWx1ZSkpO1xufVxudmFyIF9iYXNlSXNOYXRpdmUgPSBiYXNlSXNOYXRpdmUkMTtcbmZ1bmN0aW9uIGdldFZhbHVlJDEob2JqZWN0NCwga2V5Mikge1xuICByZXR1cm4gb2JqZWN0NCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0NFtrZXkyXTtcbn1cbnZhciBfZ2V0VmFsdWUgPSBnZXRWYWx1ZSQxO1xudmFyIGJhc2VJc05hdGl2ZSA9IF9iYXNlSXNOYXRpdmUsIGdldFZhbHVlID0gX2dldFZhbHVlO1xuZnVuY3Rpb24gZ2V0TmF0aXZlJDYob2JqZWN0NCwga2V5Mikge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3Q0LCBrZXkyKTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHZvaWQgMDtcbn1cbnZhciBfZ2V0TmF0aXZlID0gZ2V0TmF0aXZlJDY7XG52YXIgZ2V0TmF0aXZlJDUgPSBfZ2V0TmF0aXZlLCByb290JDUgPSBfcm9vdDtcbnZhciBNYXAkNCA9IGdldE5hdGl2ZSQ1KHJvb3QkNSwgXCJNYXBcIik7XG52YXIgX01hcCA9IE1hcCQ0O1xudmFyIGdldE5hdGl2ZSQ0ID0gX2dldE5hdGl2ZTtcbnZhciBuYXRpdmVDcmVhdGUkNCA9IGdldE5hdGl2ZSQ0KE9iamVjdCwgXCJjcmVhdGVcIik7XG52YXIgX25hdGl2ZUNyZWF0ZSA9IG5hdGl2ZUNyZWF0ZSQ0O1xudmFyIG5hdGl2ZUNyZWF0ZSQzID0gX25hdGl2ZUNyZWF0ZTtcbmZ1bmN0aW9uIGhhc2hDbGVhciQxKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlJDMgPyBuYXRpdmVDcmVhdGUkMyhudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxudmFyIF9oYXNoQ2xlYXIgPSBoYXNoQ2xlYXIkMTtcbmZ1bmN0aW9uIGhhc2hEZWxldGUkMShrZXkyKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkyKSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXkyXTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIF9oYXNoRGVsZXRlID0gaGFzaERlbGV0ZSQxO1xudmFyIG5hdGl2ZUNyZWF0ZSQyID0gX25hdGl2ZUNyZWF0ZTtcbnZhciBIQVNIX1VOREVGSU5FRCQyID0gXCJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fXCI7XG52YXIgb2JqZWN0UHJvdG8kOCA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaGFzT3duUHJvcGVydHkkNyA9IG9iamVjdFByb3RvJDguaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNoR2V0JDEoa2V5Mikge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUkMikge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleTJdO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEJDIgPyB2b2lkIDAgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5JDcuY2FsbChkYXRhLCBrZXkyKSA/IGRhdGFba2V5Ml0gOiB2b2lkIDA7XG59XG52YXIgX2hhc2hHZXQgPSBoYXNoR2V0JDE7XG52YXIgbmF0aXZlQ3JlYXRlJDEgPSBfbmF0aXZlQ3JlYXRlO1xudmFyIG9iamVjdFByb3RvJDcgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIGhhc093blByb3BlcnR5JDYgPSBvYmplY3RQcm90byQ3Lmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzaEhhcyQxKGtleTIpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlJDEgPyBkYXRhW2tleTJdICE9PSB2b2lkIDAgOiBoYXNPd25Qcm9wZXJ0eSQ2LmNhbGwoZGF0YSwga2V5Mik7XG59XG52YXIgX2hhc2hIYXMgPSBoYXNoSGFzJDE7XG52YXIgbmF0aXZlQ3JlYXRlID0gX25hdGl2ZUNyZWF0ZTtcbnZhciBIQVNIX1VOREVGSU5FRCQxID0gXCJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fXCI7XG5mdW5jdGlvbiBoYXNoU2V0JDEoa2V5MiwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5MikgPyAwIDogMTtcbiAgZGF0YVtrZXkyXSA9IG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdm9pZCAwID8gSEFTSF9VTkRFRklORUQkMSA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cbnZhciBfaGFzaFNldCA9IGhhc2hTZXQkMTtcbnZhciBoYXNoQ2xlYXIgPSBfaGFzaENsZWFyLCBoYXNoRGVsZXRlID0gX2hhc2hEZWxldGUsIGhhc2hHZXQgPSBfaGFzaEdldCwgaGFzaEhhcyA9IF9oYXNoSGFzLCBoYXNoU2V0ID0gX2hhc2hTZXQ7XG5mdW5jdGlvbiBIYXNoJDEoZW50cmllcykge1xuICB2YXIgaW5kZXgyID0gLTEsIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleDIgPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4Ml07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuSGFzaCQxLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gkMS5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBoYXNoRGVsZXRlO1xuSGFzaCQxLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaCQxLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaCQxLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xudmFyIF9IYXNoID0gSGFzaCQxO1xudmFyIEhhc2ggPSBfSGFzaCwgTGlzdENhY2hlJDIgPSBfTGlzdENhY2hlLCBNYXAkMyA9IF9NYXA7XG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyJDEoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgXCJoYXNoXCI6IG5ldyBIYXNoKCksXG4gICAgXCJtYXBcIjogbmV3IChNYXAkMyB8fCBMaXN0Q2FjaGUkMikoKSxcbiAgICBcInN0cmluZ1wiOiBuZXcgSGFzaCgpXG4gIH07XG59XG52YXIgX21hcENhY2hlQ2xlYXIgPSBtYXBDYWNoZUNsZWFyJDE7XG5mdW5jdGlvbiBpc0tleWFibGUkMSh2YWx1ZSkge1xuICB2YXIgdHlwZTQgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlNCA9PSBcInN0cmluZ1wiIHx8IHR5cGU0ID09IFwibnVtYmVyXCIgfHwgdHlwZTQgPT0gXCJzeW1ib2xcIiB8fCB0eXBlNCA9PSBcImJvb2xlYW5cIiA/IHZhbHVlICE9PSBcIl9fcHJvdG9fX1wiIDogdmFsdWUgPT09IG51bGw7XG59XG52YXIgX2lzS2V5YWJsZSA9IGlzS2V5YWJsZSQxO1xudmFyIGlzS2V5YWJsZSA9IF9pc0tleWFibGU7XG5mdW5jdGlvbiBnZXRNYXBEYXRhJDQobWFwLCBrZXkyKSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleTIpID8gZGF0YVt0eXBlb2Yga2V5MiA9PSBcInN0cmluZ1wiID8gXCJzdHJpbmdcIiA6IFwiaGFzaFwiXSA6IGRhdGEubWFwO1xufVxudmFyIF9nZXRNYXBEYXRhID0gZ2V0TWFwRGF0YSQ0O1xudmFyIGdldE1hcERhdGEkMyA9IF9nZXRNYXBEYXRhO1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUkMShrZXkyKSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhJDModGhpcywga2V5MilbXCJkZWxldGVcIl0oa2V5Mik7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBfbWFwQ2FjaGVEZWxldGUgPSBtYXBDYWNoZURlbGV0ZSQxO1xudmFyIGdldE1hcERhdGEkMiA9IF9nZXRNYXBEYXRhO1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQkMShrZXkyKSB7XG4gIHJldHVybiBnZXRNYXBEYXRhJDIodGhpcywga2V5MikuZ2V0KGtleTIpO1xufVxudmFyIF9tYXBDYWNoZUdldCA9IG1hcENhY2hlR2V0JDE7XG52YXIgZ2V0TWFwRGF0YSQxID0gX2dldE1hcERhdGE7XG5mdW5jdGlvbiBtYXBDYWNoZUhhcyQxKGtleTIpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEkMSh0aGlzLCBrZXkyKS5oYXMoa2V5Mik7XG59XG52YXIgX21hcENhY2hlSGFzID0gbWFwQ2FjaGVIYXMkMTtcbnZhciBnZXRNYXBEYXRhID0gX2dldE1hcERhdGE7XG5mdW5jdGlvbiBtYXBDYWNoZVNldCQxKGtleTIsIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkyKSwgc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgZGF0YS5zZXQoa2V5MiwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG52YXIgX21hcENhY2hlU2V0ID0gbWFwQ2FjaGVTZXQkMTtcbnZhciBtYXBDYWNoZUNsZWFyID0gX21hcENhY2hlQ2xlYXIsIG1hcENhY2hlRGVsZXRlID0gX21hcENhY2hlRGVsZXRlLCBtYXBDYWNoZUdldCA9IF9tYXBDYWNoZUdldCwgbWFwQ2FjaGVIYXMgPSBfbWFwQ2FjaGVIYXMsIG1hcENhY2hlU2V0ID0gX21hcENhY2hlU2V0O1xuZnVuY3Rpb24gTWFwQ2FjaGUkMihlbnRyaWVzKSB7XG4gIHZhciBpbmRleDIgPSAtMSwgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4MiA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXgyXTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5NYXBDYWNoZSQyLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZSQyLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUkMi5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZSQyLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlJDIucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xudmFyIF9NYXBDYWNoZSA9IE1hcENhY2hlJDI7XG52YXIgTGlzdENhY2hlJDEgPSBfTGlzdENhY2hlLCBNYXAkMiA9IF9NYXAsIE1hcENhY2hlJDEgPSBfTWFwQ2FjaGU7XG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcbmZ1bmN0aW9uIHN0YWNrU2V0JDEoa2V5MiwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSQxKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCQyIHx8IHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXkyLCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUkMShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5MiwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxudmFyIF9zdGFja1NldCA9IHN0YWNrU2V0JDE7XG52YXIgTGlzdENhY2hlID0gX0xpc3RDYWNoZSwgc3RhY2tDbGVhciA9IF9zdGFja0NsZWFyLCBzdGFja0RlbGV0ZSA9IF9zdGFja0RlbGV0ZSwgc3RhY2tHZXQgPSBfc3RhY2tHZXQsIHN0YWNrSGFzID0gX3N0YWNrSGFzLCBzdGFja1NldCA9IF9zdGFja1NldDtcbmZ1bmN0aW9uIFN0YWNrJDEoZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5TdGFjayQxLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjayQxLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2skMS5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjayQxLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrJDEucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xudmFyIF9TdGFjayA9IFN0YWNrJDE7XG52YXIgSEFTSF9VTkRFRklORUQgPSBcIl9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX19cIjtcbmZ1bmN0aW9uIHNldENhY2hlQWRkJDEodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG52YXIgX3NldENhY2hlQWRkID0gc2V0Q2FjaGVBZGQkMTtcbmZ1bmN0aW9uIHNldENhY2hlSGFzJDEodmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cbnZhciBfc2V0Q2FjaGVIYXMgPSBzZXRDYWNoZUhhcyQxO1xudmFyIE1hcENhY2hlID0gX01hcENhY2hlLCBzZXRDYWNoZUFkZCA9IF9zZXRDYWNoZUFkZCwgc2V0Q2FjaGVIYXMgPSBfc2V0Q2FjaGVIYXM7XG5mdW5jdGlvbiBTZXRDYWNoZSQxKHZhbHVlcykge1xuICB2YXIgaW5kZXgyID0gLTEsIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUoKTtcbiAgd2hpbGUgKCsraW5kZXgyIDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4Ml0pO1xuICB9XG59XG5TZXRDYWNoZSQxLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZSQxLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZSQxLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcbnZhciBfU2V0Q2FjaGUgPSBTZXRDYWNoZSQxO1xuZnVuY3Rpb24gYXJyYXlTb21lJDEoYXJyYXk0LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4MiA9IC0xLCBsZW5ndGggPSBhcnJheTQgPT0gbnVsbCA/IDAgOiBhcnJheTQubGVuZ3RoO1xuICB3aGlsZSAoKytpbmRleDIgPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5NFtpbmRleDJdLCBpbmRleDIsIGFycmF5NCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgX2FycmF5U29tZSA9IGFycmF5U29tZSQxO1xuZnVuY3Rpb24gY2FjaGVIYXMkMShjYWNoZSwga2V5Mikge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleTIpO1xufVxudmFyIF9jYWNoZUhhcyA9IGNhY2hlSGFzJDE7XG52YXIgU2V0Q2FjaGUgPSBfU2V0Q2FjaGUsIGFycmF5U29tZSA9IF9hcnJheVNvbWUsIGNhY2hlSGFzID0gX2NhY2hlSGFzO1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDMgPSAxLCBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDEgPSAyO1xuZnVuY3Rpb24gZXF1YWxBcnJheXMkMihhcnJheTQsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMywgYXJyTGVuZ3RoID0gYXJyYXk0Lmxlbmd0aCwgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBhcnJTdGFja2VkID0gc3RhY2suZ2V0KGFycmF5NCk7XG4gIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgaWYgKGFyclN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk0O1xuICB9XG4gIHZhciBpbmRleDIgPSAtMSwgcmVzdWx0ID0gdHJ1ZSwgc2VlbiA9IGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDEgPyBuZXcgU2V0Q2FjaGUoKSA6IHZvaWQgMDtcbiAgc3RhY2suc2V0KGFycmF5NCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5NCk7XG4gIHdoaWxlICgrK2luZGV4MiA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5NFtpbmRleDJdLCBvdGhWYWx1ZSA9IG90aGVyW2luZGV4Ml07XG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbCA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleDIsIG90aGVyLCBhcnJheTQsIHN0YWNrKSA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleDIsIGFycmF5NCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUyLCBvdGhJbmRleCkge1xuICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJiAoYXJyVmFsdWUgPT09IG90aFZhbHVlMiB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlMiwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1tcImRlbGV0ZVwiXShhcnJheTQpO1xuICBzdGFja1tcImRlbGV0ZVwiXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgX2VxdWFsQXJyYXlzID0gZXF1YWxBcnJheXMkMjtcbnZhciByb290JDQgPSBfcm9vdDtcbnZhciBVaW50OEFycmF5JDEgPSByb290JDQuVWludDhBcnJheTtcbnZhciBfVWludDhBcnJheSA9IFVpbnQ4QXJyYXkkMTtcbmZ1bmN0aW9uIG1hcFRvQXJyYXkkMShtYXApIHtcbiAgdmFyIGluZGV4MiA9IC0xLCByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkyKSB7XG4gICAgcmVzdWx0WysraW5kZXgyXSA9IFtrZXkyLCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIF9tYXBUb0FycmF5ID0gbWFwVG9BcnJheSQxO1xuZnVuY3Rpb24gc2V0VG9BcnJheSQxKHNldDIpIHtcbiAgdmFyIGluZGV4MiA9IC0xLCByZXN1bHQgPSBBcnJheShzZXQyLnNpemUpO1xuICBzZXQyLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleDJdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIF9zZXRUb0FycmF5ID0gc2V0VG9BcnJheSQxO1xudmFyIFN5bWJvbCQxID0gX1N5bWJvbCwgVWludDhBcnJheTIgPSBfVWludDhBcnJheSwgZXEgPSBlcV8xLCBlcXVhbEFycmF5cyQxID0gX2VxdWFsQXJyYXlzLCBtYXBUb0FycmF5ID0gX21hcFRvQXJyYXksIHNldFRvQXJyYXkgPSBfc2V0VG9BcnJheTtcbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyQyID0gMSwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG52YXIgYm9vbFRhZyQxID0gXCJbb2JqZWN0IEJvb2xlYW5dXCIsIGRhdGVUYWckMSA9IFwiW29iamVjdCBEYXRlXVwiLCBlcnJvclRhZyQxID0gXCJbb2JqZWN0IEVycm9yXVwiLCBtYXBUYWckMiA9IFwiW29iamVjdCBNYXBdXCIsIG51bWJlclRhZyQxID0gXCJbb2JqZWN0IE51bWJlcl1cIiwgcmVnZXhwVGFnJDEgPSBcIltvYmplY3QgUmVnRXhwXVwiLCBzZXRUYWckMiA9IFwiW29iamVjdCBTZXRdXCIsIHN0cmluZ1RhZyQxID0gXCJbb2JqZWN0IFN0cmluZ11cIiwgc3ltYm9sVGFnID0gXCJbb2JqZWN0IFN5bWJvbF1cIjtcbnZhciBhcnJheUJ1ZmZlclRhZyQxID0gXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiLCBkYXRhVmlld1RhZyQyID0gXCJbb2JqZWN0IERhdGFWaWV3XVwiO1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sJDEgPyBTeW1ib2wkMS5wcm90b3R5cGUgOiB2b2lkIDAsIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB2b2lkIDA7XG5mdW5jdGlvbiBlcXVhbEJ5VGFnJDEob2JqZWN0NCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWckMjpcbiAgICAgIGlmIChvYmplY3Q0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCB8fCBvYmplY3Q0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3Q0ID0gb2JqZWN0NC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnJDE6XG4gICAgICBpZiAob2JqZWN0NC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGggfHwgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheTIob2JqZWN0NCksIG5ldyBVaW50OEFycmF5MihvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgYm9vbFRhZyQxOlxuICAgIGNhc2UgZGF0ZVRhZyQxOlxuICAgIGNhc2UgbnVtYmVyVGFnJDE6XG4gICAgICByZXR1cm4gZXEoK29iamVjdDQsICtvdGhlcik7XG4gICAgY2FzZSBlcnJvclRhZyQxOlxuICAgICAgcmV0dXJuIG9iamVjdDQubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdDQubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuICAgIGNhc2UgcmVnZXhwVGFnJDE6XG4gICAgY2FzZSBzdHJpbmdUYWckMTpcbiAgICAgIHJldHVybiBvYmplY3Q0ID09IG90aGVyICsgXCJcIjtcbiAgICBjYXNlIG1hcFRhZyQyOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuICAgIGNhc2Ugc2V0VGFnJDI6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHJDI7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG4gICAgICBpZiAob2JqZWN0NC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3Q0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuICAgICAgc3RhY2suc2V0KG9iamVjdDQsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyQxKGNvbnZlcnQob2JqZWN0NCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrW1wiZGVsZXRlXCJdKG9iamVjdDQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0NCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgX2VxdWFsQnlUYWcgPSBlcXVhbEJ5VGFnJDE7XG5mdW5jdGlvbiBhcnJheVB1c2gkMShhcnJheTQsIHZhbHVlcykge1xuICB2YXIgaW5kZXgyID0gLTEsIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsIG9mZnNldDIgPSBhcnJheTQubGVuZ3RoO1xuICB3aGlsZSAoKytpbmRleDIgPCBsZW5ndGgpIHtcbiAgICBhcnJheTRbb2Zmc2V0MiArIGluZGV4Ml0gPSB2YWx1ZXNbaW5kZXgyXTtcbiAgfVxuICByZXR1cm4gYXJyYXk0O1xufVxudmFyIF9hcnJheVB1c2ggPSBhcnJheVB1c2gkMTtcbnZhciBpc0FycmF5JDMgPSBBcnJheS5pc0FycmF5O1xudmFyIGlzQXJyYXlfMSA9IGlzQXJyYXkkMztcbnZhciBhcnJheVB1c2ggPSBfYXJyYXlQdXNoLCBpc0FycmF5JDIgPSBpc0FycmF5XzE7XG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyQxKG9iamVjdDQsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0NCk7XG4gIHJldHVybiBpc0FycmF5JDIob2JqZWN0NCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3Q0KSk7XG59XG52YXIgX2Jhc2VHZXRBbGxLZXlzID0gYmFzZUdldEFsbEtleXMkMTtcbmZ1bmN0aW9uIGFycmF5RmlsdGVyJDEoYXJyYXk0LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4MiA9IC0xLCBsZW5ndGggPSBhcnJheTQgPT0gbnVsbCA/IDAgOiBhcnJheTQubGVuZ3RoLCByZXNJbmRleCA9IDAsIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAoKytpbmRleDIgPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheTRbaW5kZXgyXTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleDIsIGFycmF5NCkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIF9hcnJheUZpbHRlciA9IGFycmF5RmlsdGVyJDE7XG5mdW5jdGlvbiBzdHViQXJyYXkkMSgpIHtcbiAgcmV0dXJuIFtdO1xufVxudmFyIHN0dWJBcnJheV8xID0gc3R1YkFycmF5JDE7XG52YXIgYXJyYXlGaWx0ZXIgPSBfYXJyYXlGaWx0ZXIsIHN0dWJBcnJheSA9IHN0dWJBcnJheV8xO1xudmFyIG9iamVjdFByb3RvJDYgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlJDEgPSBvYmplY3RQcm90byQ2LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldFN5bWJvbHMkMSA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0NCkge1xuICBpZiAob2JqZWN0NCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdDQgPSBPYmplY3Qob2JqZWN0NCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdDQpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUkMS5jYWxsKG9iamVjdDQsIHN5bWJvbCk7XG4gIH0pO1xufTtcbnZhciBfZ2V0U3ltYm9scyA9IGdldFN5bWJvbHMkMTtcbmZ1bmN0aW9uIGJhc2VUaW1lcyQxKG4yLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXgyID0gLTEsIHJlc3VsdCA9IEFycmF5KG4yKTtcbiAgd2hpbGUgKCsraW5kZXgyIDwgbjIpIHtcbiAgICByZXN1bHRbaW5kZXgyXSA9IGl0ZXJhdGVlKGluZGV4Mik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBfYmFzZVRpbWVzID0gYmFzZVRpbWVzJDE7XG5mdW5jdGlvbiBpc09iamVjdExpa2UkNCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIjtcbn1cbnZhciBpc09iamVjdExpa2VfMSA9IGlzT2JqZWN0TGlrZSQ0O1xudmFyIGJhc2VHZXRUYWckMiA9IF9iYXNlR2V0VGFnLCBpc09iamVjdExpa2UkMyA9IGlzT2JqZWN0TGlrZV8xO1xudmFyIGFyZ3NUYWckMiA9IFwiW29iamVjdCBBcmd1bWVudHNdXCI7XG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHMkMSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlJDModmFsdWUpICYmIGJhc2VHZXRUYWckMih2YWx1ZSkgPT0gYXJnc1RhZyQyO1xufVxudmFyIF9iYXNlSXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMkMTtcbnZhciBiYXNlSXNBcmd1bWVudHMgPSBfYmFzZUlzQXJndW1lbnRzLCBpc09iamVjdExpa2UkMiA9IGlzT2JqZWN0TGlrZV8xO1xudmFyIG9iamVjdFByb3RvJDUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIGhhc093blByb3BlcnR5JDUgPSBvYmplY3RQcm90byQ1Lmhhc093blByb3BlcnR5O1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8kNS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBpc0FyZ3VtZW50cyQxID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYXJndW1lbnRzO1xufSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UkMih2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkkNS5jYWxsKHZhbHVlLCBcImNhbGxlZVwiKSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgXCJjYWxsZWVcIik7XG59O1xudmFyIGlzQXJndW1lbnRzXzEgPSBpc0FyZ3VtZW50cyQxO1xudmFyIGlzQnVmZmVyJDIgPSB7IGV4cG9ydHM6IHt9IH07XG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBzdHViRmFsc2VfMSA9IHN0dWJGYWxzZTtcbihmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcbiAgdmFyIHJvb3QyID0gX3Jvb3QsIHN0dWJGYWxzZTIgPSBzdHViRmFsc2VfMTtcbiAgdmFyIGZyZWVFeHBvcnRzID0gZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHRydWUgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcbiAgdmFyIEJ1ZmZlcjIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdDIuQnVmZmVyIDogdm9pZCAwO1xuICB2YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIyID8gQnVmZmVyMi5pc0J1ZmZlciA6IHZvaWQgMDtcbiAgdmFyIGlzQnVmZmVyMiA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTI7XG4gIG1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXIyO1xufSkoaXNCdWZmZXIkMiwgaXNCdWZmZXIkMi5leHBvcnRzKTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSJDEgPSA5MDA3MTk5MjU0NzQwOTkxO1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcbmZ1bmN0aW9uIGlzSW5kZXgkMSh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlNCA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSJDEgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiAodHlwZTQgPT0gXCJudW1iZXJcIiB8fCB0eXBlNCAhPSBcInN5bWJvbFwiICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJiAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG52YXIgX2lzSW5kZXggPSBpc0luZGV4JDE7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5mdW5jdGlvbiBpc0xlbmd0aCQyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG52YXIgaXNMZW5ndGhfMSA9IGlzTGVuZ3RoJDI7XG52YXIgYmFzZUdldFRhZyQxID0gX2Jhc2VHZXRUYWcsIGlzTGVuZ3RoJDEgPSBpc0xlbmd0aF8xLCBpc09iamVjdExpa2UkMSA9IGlzT2JqZWN0TGlrZV8xO1xudmFyIGFyZ3NUYWckMSA9IFwiW29iamVjdCBBcmd1bWVudHNdXCIsIGFycmF5VGFnJDEgPSBcIltvYmplY3QgQXJyYXldXCIsIGJvb2xUYWcgPSBcIltvYmplY3QgQm9vbGVhbl1cIiwgZGF0ZVRhZyA9IFwiW29iamVjdCBEYXRlXVwiLCBlcnJvclRhZyA9IFwiW29iamVjdCBFcnJvcl1cIiwgZnVuY1RhZyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIiwgbWFwVGFnJDEgPSBcIltvYmplY3QgTWFwXVwiLCBudW1iZXJUYWcgPSBcIltvYmplY3QgTnVtYmVyXVwiLCBvYmplY3RUYWckMiA9IFwiW29iamVjdCBPYmplY3RdXCIsIHJlZ2V4cFRhZyA9IFwiW29iamVjdCBSZWdFeHBdXCIsIHNldFRhZyQxID0gXCJbb2JqZWN0IFNldF1cIiwgc3RyaW5nVGFnID0gXCJbb2JqZWN0IFN0cmluZ11cIiwgd2Vha01hcFRhZyQxID0gXCJbb2JqZWN0IFdlYWtNYXBdXCI7XG52YXIgYXJyYXlCdWZmZXJUYWcgPSBcIltvYmplY3QgQXJyYXlCdWZmZXJdXCIsIGRhdGFWaWV3VGFnJDEgPSBcIltvYmplY3QgRGF0YVZpZXddXCIsIGZsb2F0MzJUYWcgPSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiLCBmbG9hdDY0VGFnID0gXCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIiwgaW50OFRhZyA9IFwiW29iamVjdCBJbnQ4QXJyYXldXCIsIGludDE2VGFnID0gXCJbb2JqZWN0IEludDE2QXJyYXldXCIsIGludDMyVGFnID0gXCJbb2JqZWN0IEludDMyQXJyYXldXCIsIHVpbnQ4VGFnID0gXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIsIHVpbnQ4Q2xhbXBlZFRhZyA9IFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIiwgdWludDE2VGFnID0gXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiLCB1aW50MzJUYWcgPSBcIltvYmplY3QgVWludDMyQXJyYXldXCI7XG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnJDFdID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWckMV0gPSB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnJDFdID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPSB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZyQxXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWckMl0gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnJDFdID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWckMV0gPSBmYWxzZTtcbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkkMSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlJDEodmFsdWUpICYmIGlzTGVuZ3RoJDEodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWckMSh2YWx1ZSldO1xufVxudmFyIF9iYXNlSXNUeXBlZEFycmF5ID0gYmFzZUlzVHlwZWRBcnJheSQxO1xuZnVuY3Rpb24gYmFzZVVuYXJ5JDEoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG52YXIgX2Jhc2VVbmFyeSA9IGJhc2VVbmFyeSQxO1xudmFyIF9ub2RlVXRpbCA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcbiAgdmFyIGZyZWVHbG9iYWwyID0gX2ZyZWVHbG9iYWw7XG4gIHZhciBmcmVlRXhwb3J0cyA9IGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcbiAgdmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0cnVlICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG4gIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbDIucHJvY2VzcztcbiAgdmFyIG5vZGVVdGlsMiA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgdHlwZXMyID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKFwidXRpbFwiKS50eXBlcztcbiAgICAgIGlmICh0eXBlczIpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoXCJ1dGlsXCIpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9KCk7XG4gIG1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWwyO1xufSkoX25vZGVVdGlsLCBfbm9kZVV0aWwuZXhwb3J0cyk7XG52YXIgYmFzZUlzVHlwZWRBcnJheSA9IF9iYXNlSXNUeXBlZEFycmF5LCBiYXNlVW5hcnkgPSBfYmFzZVVuYXJ5LCBub2RlVXRpbCA9IF9ub2RlVXRpbC5leHBvcnRzO1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG52YXIgaXNUeXBlZEFycmF5JDIgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcbnZhciBpc1R5cGVkQXJyYXlfMSA9IGlzVHlwZWRBcnJheSQyO1xudmFyIGJhc2VUaW1lcyA9IF9iYXNlVGltZXMsIGlzQXJndW1lbnRzID0gaXNBcmd1bWVudHNfMSwgaXNBcnJheSQxID0gaXNBcnJheV8xLCBpc0J1ZmZlciQxID0gaXNCdWZmZXIkMi5leHBvcnRzLCBpc0luZGV4ID0gX2lzSW5kZXgsIGlzVHlwZWRBcnJheSQxID0gaXNUeXBlZEFycmF5XzE7XG52YXIgb2JqZWN0UHJvdG8kNCA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaGFzT3duUHJvcGVydHkkNCA9IG9iamVjdFByb3RvJDQuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzJDEodmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5JDEodmFsdWUpLCBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIkMSh2YWx1ZSksIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkkMSh2YWx1ZSksIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSwgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gIGZvciAodmFyIGtleTIgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eSQ0LmNhbGwodmFsdWUsIGtleTIpKSAmJiAhKHNraXBJbmRleGVzICYmIChrZXkyID09IFwibGVuZ3RoXCIgfHwgaXNCdWZmICYmIChrZXkyID09IFwib2Zmc2V0XCIgfHwga2V5MiA9PSBcInBhcmVudFwiKSB8fCBpc1R5cGUgJiYgKGtleTIgPT0gXCJidWZmZXJcIiB8fCBrZXkyID09IFwiYnl0ZUxlbmd0aFwiIHx8IGtleTIgPT0gXCJieXRlT2Zmc2V0XCIpIHx8IGlzSW5kZXgoa2V5MiwgbGVuZ3RoKSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBfYXJyYXlMaWtlS2V5cyA9IGFycmF5TGlrZUtleXMkMTtcbnZhciBvYmplY3RQcm90byQzID0gT2JqZWN0LnByb3RvdHlwZTtcbmZ1bmN0aW9uIGlzUHJvdG90eXBlJDEodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciwgcHJvdG8gPSB0eXBlb2YgQ3RvciA9PSBcImZ1bmN0aW9uXCIgJiYgQ3Rvci5wcm90b3R5cGUgfHwgb2JqZWN0UHJvdG8kMztcbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cbnZhciBfaXNQcm90b3R5cGUgPSBpc1Byb3RvdHlwZSQxO1xuZnVuY3Rpb24gb3ZlckFyZyQxKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxudmFyIF9vdmVyQXJnID0gb3ZlckFyZyQxO1xudmFyIG92ZXJBcmcgPSBfb3ZlckFyZztcbnZhciBuYXRpdmVLZXlzJDEgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xudmFyIF9uYXRpdmVLZXlzID0gbmF0aXZlS2V5cyQxO1xudmFyIGlzUHJvdG90eXBlID0gX2lzUHJvdG90eXBlLCBuYXRpdmVLZXlzID0gX25hdGl2ZUtleXM7XG52YXIgb2JqZWN0UHJvdG8kMiA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaGFzT3duUHJvcGVydHkkMyA9IG9iamVjdFByb3RvJDIuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBiYXNlS2V5cyQxKG9iamVjdDQpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3Q0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdDQpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5MiBpbiBPYmplY3Qob2JqZWN0NCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkkMy5jYWxsKG9iamVjdDQsIGtleTIpICYmIGtleTIgIT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBfYmFzZUtleXMgPSBiYXNlS2V5cyQxO1xudmFyIGlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uXzEsIGlzTGVuZ3RoID0gaXNMZW5ndGhfMTtcbmZ1bmN0aW9uIGlzQXJyYXlMaWtlJDEodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG52YXIgaXNBcnJheUxpa2VfMSA9IGlzQXJyYXlMaWtlJDE7XG52YXIgYXJyYXlMaWtlS2V5cyA9IF9hcnJheUxpa2VLZXlzLCBiYXNlS2V5cyA9IF9iYXNlS2V5cywgaXNBcnJheUxpa2UgPSBpc0FycmF5TGlrZV8xO1xuZnVuY3Rpb24ga2V5cyQxKG9iamVjdDQpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdDQpID8gYXJyYXlMaWtlS2V5cyhvYmplY3Q0KSA6IGJhc2VLZXlzKG9iamVjdDQpO1xufVxudmFyIGtleXNfMSA9IGtleXMkMTtcbnZhciBiYXNlR2V0QWxsS2V5cyA9IF9iYXNlR2V0QWxsS2V5cywgZ2V0U3ltYm9scyA9IF9nZXRTeW1ib2xzLCBrZXlzID0ga2V5c18xO1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyQxKG9iamVjdDQpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdDQsIGtleXMsIGdldFN5bWJvbHMpO1xufVxudmFyIF9nZXRBbGxLZXlzID0gZ2V0QWxsS2V5cyQxO1xudmFyIGdldEFsbEtleXMgPSBfZ2V0QWxsS2V5cztcbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyQxID0gMTtcbnZhciBvYmplY3RQcm90byQxID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gb2JqZWN0UHJvdG8kMS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyQxKG9iamVjdDQsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMSwgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdDQpLCBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXgyID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgyLS0pIHtcbiAgICB2YXIga2V5MiA9IG9ialByb3BzW2luZGV4Ml07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5MiBpbiBvdGhlciA6IGhhc093blByb3BlcnR5JDIuY2FsbChvdGhlciwga2V5MikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHZhciBvYmpTdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdDQpO1xuICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gIGlmIChvYmpTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDQ7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3Q0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0NCk7XG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXgyIDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5MiA9IG9ialByb3BzW2luZGV4Ml07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0NFtrZXkyXSwgb3RoVmFsdWUgPSBvdGhlcltrZXkyXTtcbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleTIsIG90aGVyLCBvYmplY3Q0LCBzdGFjaykgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5Miwgb2JqZWN0NCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHZvaWQgMCA/IG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykgOiBjb21wYXJlZCkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleTIgPT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0NC5jb25zdHJ1Y3Rvciwgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiYgKFwiY29uc3RydWN0b3JcIiBpbiBvYmplY3Q0ICYmIFwiY29uc3RydWN0b3JcIiBpbiBvdGhlcikgJiYgISh0eXBlb2Ygb2JqQ3RvciA9PSBcImZ1bmN0aW9uXCIgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiYgdHlwZW9mIG90aEN0b3IgPT0gXCJmdW5jdGlvblwiICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrW1wiZGVsZXRlXCJdKG9iamVjdDQpO1xuICBzdGFja1tcImRlbGV0ZVwiXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgX2VxdWFsT2JqZWN0cyA9IGVxdWFsT2JqZWN0cyQxO1xudmFyIGdldE5hdGl2ZSQzID0gX2dldE5hdGl2ZSwgcm9vdCQzID0gX3Jvb3Q7XG52YXIgRGF0YVZpZXckMSA9IGdldE5hdGl2ZSQzKHJvb3QkMywgXCJEYXRhVmlld1wiKTtcbnZhciBfRGF0YVZpZXcgPSBEYXRhVmlldyQxO1xudmFyIGdldE5hdGl2ZSQyID0gX2dldE5hdGl2ZSwgcm9vdCQyID0gX3Jvb3Q7XG52YXIgUHJvbWlzZSQyID0gZ2V0TmF0aXZlJDIocm9vdCQyLCBcIlByb21pc2VcIik7XG52YXIgX1Byb21pc2UgPSBQcm9taXNlJDI7XG52YXIgZ2V0TmF0aXZlJDEgPSBfZ2V0TmF0aXZlLCByb290JDEgPSBfcm9vdDtcbnZhciBTZXQkMiA9IGdldE5hdGl2ZSQxKHJvb3QkMSwgXCJTZXRcIik7XG52YXIgX1NldCA9IFNldCQyO1xudmFyIGdldE5hdGl2ZSA9IF9nZXROYXRpdmUsIHJvb3QgPSBfcm9vdDtcbnZhciBXZWFrTWFwJDIgPSBnZXROYXRpdmUocm9vdCwgXCJXZWFrTWFwXCIpO1xudmFyIF9XZWFrTWFwID0gV2Vha01hcCQyO1xudmFyIERhdGFWaWV3ID0gX0RhdGFWaWV3LCBNYXAkMSA9IF9NYXAsIFByb21pc2UkMSA9IF9Qcm9taXNlLCBTZXQkMSA9IF9TZXQsIFdlYWtNYXAkMSA9IF9XZWFrTWFwLCBiYXNlR2V0VGFnID0gX2Jhc2VHZXRUYWcsIHRvU291cmNlID0gX3RvU291cmNlO1xudmFyIG1hcFRhZyA9IFwiW29iamVjdCBNYXBdXCIsIG9iamVjdFRhZyQxID0gXCJbb2JqZWN0IE9iamVjdF1cIiwgcHJvbWlzZVRhZyA9IFwiW29iamVjdCBQcm9taXNlXVwiLCBzZXRUYWcgPSBcIltvYmplY3QgU2V0XVwiLCB3ZWFrTWFwVGFnID0gXCJbb2JqZWN0IFdlYWtNYXBdXCI7XG52YXIgZGF0YVZpZXdUYWcgPSBcIltvYmplY3QgRGF0YVZpZXddXCI7XG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLCBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwJDEpLCBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UkMSksIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQkMSksIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCQxKTtcbnZhciBnZXRUYWckMSA9IGJhc2VHZXRUYWc7XG5pZiAoRGF0YVZpZXcgJiYgZ2V0VGFnJDEobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnIHx8IE1hcCQxICYmIGdldFRhZyQxKG5ldyBNYXAkMSgpKSAhPSBtYXBUYWcgfHwgUHJvbWlzZSQxICYmIGdldFRhZyQxKFByb21pc2UkMS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcgfHwgU2V0JDEgJiYgZ2V0VGFnJDEobmV3IFNldCQxKCkpICE9IHNldFRhZyB8fCBXZWFrTWFwJDEgJiYgZ2V0VGFnJDEobmV3IFdlYWtNYXAkMSgpKSAhPSB3ZWFrTWFwVGFnKSB7XG4gIGdldFRhZyQxID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnJDEgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHZvaWQgMCwgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6IFwiXCI7XG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzpcbiAgICAgICAgICByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzpcbiAgICAgICAgICByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOlxuICAgICAgICAgIHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6XG4gICAgICAgICAgcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzpcbiAgICAgICAgICByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbnZhciBfZ2V0VGFnID0gZ2V0VGFnJDE7XG52YXIgU3RhY2sgPSBfU3RhY2ssIGVxdWFsQXJyYXlzID0gX2VxdWFsQXJyYXlzLCBlcXVhbEJ5VGFnID0gX2VxdWFsQnlUYWcsIGVxdWFsT2JqZWN0cyA9IF9lcXVhbE9iamVjdHMsIGdldFRhZyA9IF9nZXRUYWcsIGlzQXJyYXkgPSBpc0FycmF5XzEsIGlzQnVmZmVyID0gaXNCdWZmZXIkMi5leHBvcnRzLCBpc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXlfMTtcbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG52YXIgYXJnc1RhZyA9IFwiW29iamVjdCBBcmd1bWVudHNdXCIsIGFycmF5VGFnID0gXCJbb2JqZWN0IEFycmF5XVwiLCBvYmplY3RUYWcgPSBcIltvYmplY3QgT2JqZWN0XVwiO1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAkMShvYmplY3Q0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdDQpLCBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLCBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdDQpLCBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLCBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0NCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjaygpKTtcbiAgICByZXR1cm4gb2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdDQpID8gZXF1YWxBcnJheXMob2JqZWN0NCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIDogZXF1YWxCeVRhZyhvYmplY3Q0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5JDEuY2FsbChvYmplY3Q0LCBcIl9fd3JhcHBlZF9fXCIpLCBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eSQxLmNhbGwob3RoZXIsIFwiX193cmFwcGVkX19cIik7XG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3Q0LnZhbHVlKCkgOiBvYmplY3Q0LCBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2soKSk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjaygpKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3Q0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG52YXIgX2Jhc2VJc0VxdWFsRGVlcCA9IGJhc2VJc0VxdWFsRGVlcCQxO1xudmFyIGJhc2VJc0VxdWFsRGVlcCA9IF9iYXNlSXNFcXVhbERlZXAsIGlzT2JqZWN0TGlrZSA9IGlzT2JqZWN0TGlrZV8xO1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwkMSh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsJDEsIHN0YWNrKTtcbn1cbnZhciBfYmFzZUlzRXF1YWwgPSBiYXNlSXNFcXVhbCQxO1xudmFyIGJhc2VJc0VxdWFsID0gX2Jhc2VJc0VxdWFsO1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59XG52YXIgaXNFcXVhbF8xID0gaXNFcXVhbDtcbnZhciBNYXBTaGltID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIE1hcDtcbiAgfVxuICBmdW5jdGlvbiBnZXRJbmRleChhcnIsIGtleTIpIHtcbiAgICB2YXIgcmVzdWx0ID0gLTE7XG4gICAgYXJyLnNvbWUoZnVuY3Rpb24oZW50cnksIGluZGV4Mikge1xuICAgICAgaWYgKGVudHJ5WzBdID09PSBrZXkyKSB7XG4gICAgICAgIHJlc3VsdCA9IGluZGV4MjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgIHRoaXMuX19lbnRyaWVzX18gPSBbXTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19lbnRyaWVzX18ubGVuZ3RoO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBjbGFzc18xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkyKSB7XG4gICAgICB2YXIgaW5kZXgyID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5Mik7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLl9fZW50cmllc19fW2luZGV4Ml07XG4gICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMV07XG4gICAgfTtcbiAgICBjbGFzc18xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXkyLCB2YWx1ZSkge1xuICAgICAgdmFyIGluZGV4MiA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleTIpO1xuICAgICAgaWYgKH5pbmRleDIpIHtcbiAgICAgICAgdGhpcy5fX2VudHJpZXNfX1tpbmRleDJdWzFdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fZW50cmllc19fLnB1c2goW2tleTIsIHZhbHVlXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjbGFzc18xLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbihrZXkyKSB7XG4gICAgICB2YXIgZW50cmllcyA9IHRoaXMuX19lbnRyaWVzX187XG4gICAgICB2YXIgaW5kZXgyID0gZ2V0SW5kZXgoZW50cmllcywga2V5Mik7XG4gICAgICBpZiAofmluZGV4Mikge1xuICAgICAgICBlbnRyaWVzLnNwbGljZShpbmRleDIsIDEpO1xuICAgICAgfVxuICAgIH07XG4gICAgY2xhc3NfMS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5Mikge1xuICAgICAgcmV0dXJuICEhfmdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleTIpO1xuICAgIH07XG4gICAgY2xhc3NfMS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX19lbnRyaWVzX18uc3BsaWNlKDApO1xuICAgIH07XG4gICAgY2xhc3NfMS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBjdHgpIHtcbiAgICAgIGlmIChjdHggPT09IHZvaWQgMCkge1xuICAgICAgICBjdHggPSBudWxsO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX19lbnRyaWVzX187IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcbiAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVudHJ5WzFdLCBlbnRyeVswXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gY2xhc3NfMTtcbiAgfSgpO1xufSgpO1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5kb2N1bWVudCA9PT0gZG9jdW1lbnQ7XG52YXIgZ2xvYmFsJDEgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLk1hdGggPT09IE1hdGgpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLk1hdGggPT09IE1hdGgpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbiAgcmV0dXJuIEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0oKTtcbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKGdsb2JhbCQxKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhEYXRlLm5vdygpKTtcbiAgICB9LCAxZTMgLyA2MCk7XG4gIH07XG59KCk7XG52YXIgdHJhaWxpbmdUaW1lb3V0ID0gMjtcbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCBkZWxheSkge1xuICB2YXIgbGVhZGluZ0NhbGwgPSBmYWxzZSwgdHJhaWxpbmdDYWxsID0gZmFsc2UsIGxhc3RDYWxsVGltZSA9IDA7XG4gIGZ1bmN0aW9uIHJlc29sdmVQZW5kaW5nKCkge1xuICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgbGVhZGluZ0NhbGwgPSBmYWxzZTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGlmICh0cmFpbGluZ0NhbGwpIHtcbiAgICAgIHByb3h5KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMShyZXNvbHZlUGVuZGluZyk7XG4gIH1cbiAgZnVuY3Rpb24gcHJveHkoKSB7XG4gICAgdmFyIHRpbWVTdGFtcCA9IERhdGUubm93KCk7XG4gICAgaWYgKGxlYWRpbmdDYWxsKSB7XG4gICAgICBpZiAodGltZVN0YW1wIC0gbGFzdENhbGxUaW1lIDwgdHJhaWxpbmdUaW1lb3V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyYWlsaW5nQ2FsbCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlYWRpbmdDYWxsID0gdHJ1ZTtcbiAgICAgIHRyYWlsaW5nQ2FsbCA9IGZhbHNlO1xuICAgICAgc2V0VGltZW91dCh0aW1lb3V0Q2FsbGJhY2ssIGRlbGF5KTtcbiAgICB9XG4gICAgbGFzdENhbGxUaW1lID0gdGltZVN0YW1wO1xuICB9XG4gIHJldHVybiBwcm94eTtcbn1cbnZhciBSRUZSRVNIX0RFTEFZID0gMjA7XG52YXIgdHJhbnNpdGlvbktleXMgPSBbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcInNpemVcIiwgXCJ3ZWlnaHRcIl07XG52YXIgbXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCA9IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIyKCkge1xuICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xuICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcbiAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XG4gICAgdGhpcy5vYnNlcnZlcnNfID0gW107XG4gICAgdGhpcy5vblRyYW5zaXRpb25FbmRfID0gdGhpcy5vblRyYW5zaXRpb25FbmRfLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZWZyZXNoID0gdGhyb3R0bGUodGhpcy5yZWZyZXNoLmJpbmQodGhpcyksIFJFRlJFU0hfREVMQVkpO1xuICB9XG4gIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjIucHJvdG90eXBlLmFkZE9ic2VydmVyID0gZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICBpZiAoIX50aGlzLm9ic2VydmVyc18uaW5kZXhPZihvYnNlcnZlcikpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzXy5wdXNoKG9ic2VydmVyKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgIHRoaXMuY29ubmVjdF8oKTtcbiAgICB9XG4gIH07XG4gIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjIucHJvdG90eXBlLnJlbW92ZU9ic2VydmVyID0gZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICB2YXIgb2JzZXJ2ZXJzMiA9IHRoaXMub2JzZXJ2ZXJzXztcbiAgICB2YXIgaW5kZXgyID0gb2JzZXJ2ZXJzMi5pbmRleE9mKG9ic2VydmVyKTtcbiAgICBpZiAofmluZGV4Mikge1xuICAgICAgb2JzZXJ2ZXJzMi5zcGxpY2UoaW5kZXgyLCAxKTtcbiAgICB9XG4gICAgaWYgKCFvYnNlcnZlcnMyLmxlbmd0aCAmJiB0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdF8oKTtcbiAgICB9XG4gIH07XG4gIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2hhbmdlc0RldGVjdGVkID0gdGhpcy51cGRhdGVPYnNlcnZlcnNfKCk7XG4gICAgaWYgKGNoYW5nZXNEZXRlY3RlZCkge1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuICB9O1xuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIyLnByb3RvdHlwZS51cGRhdGVPYnNlcnZlcnNfID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFjdGl2ZU9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXy5maWx0ZXIoZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBvYnNlcnZlci5nYXRoZXJBY3RpdmUoKSwgb2JzZXJ2ZXIuaGFzQWN0aXZlKCk7XG4gICAgfSk7XG4gICAgYWN0aXZlT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBvYnNlcnZlci5icm9hZGNhc3RBY3RpdmUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWN0aXZlT2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XG4gIH07XG4gIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjIucHJvdG90eXBlLmNvbm5lY3RfID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFpc0Jyb3dzZXIgfHwgdGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5yZWZyZXNoKTtcbiAgICBpZiAobXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLnJlZnJlc2gpO1xuICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8ub2JzZXJ2ZShkb2N1bWVudCwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NU3VidHJlZU1vZGlmaWVkXCIsIHRoaXMucmVmcmVzaCk7XG4gICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcbiAgfTtcbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyMi5wcm90b3R5cGUuZGlzY29ubmVjdF8gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWlzQnJvd3NlciB8fCAhdGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5yZWZyZXNoKTtcbiAgICBpZiAodGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8pIHtcbiAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8pIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01TdWJ0cmVlTW9kaWZpZWRcIiwgdGhpcy5yZWZyZXNoKTtcbiAgICB9XG4gICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xuICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcbiAgfTtcbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyMi5wcm90b3R5cGUub25UcmFuc2l0aW9uRW5kXyA9IGZ1bmN0aW9uKF9hKSB7XG4gICAgdmFyIF9iID0gX2EucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWUgPSBfYiA9PT0gdm9pZCAwID8gXCJcIiA6IF9iO1xuICAgIHZhciBpc1JlZmxvd1Byb3BlcnR5ID0gdHJhbnNpdGlvbktleXMuc29tZShmdW5jdGlvbihrZXkyKSB7XG4gICAgICByZXR1cm4gISF+cHJvcGVydHlOYW1lLmluZGV4T2Yoa2V5Mik7XG4gICAgfSk7XG4gICAgaWYgKGlzUmVmbG93UHJvcGVydHkpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cbiAgfTtcbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyMi5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5pbnN0YW5jZV8pIHtcbiAgICAgIHRoaXMuaW5zdGFuY2VfID0gbmV3IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VfO1xuICB9O1xuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIyLmluc3RhbmNlXyA9IG51bGw7XG4gIHJldHVybiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIyO1xufSgpO1xudmFyIGRlZmluZUNvbmZpZ3VyYWJsZSA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHByb3BzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIga2V5MiA9IF9hW19pXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXkyLCB7XG4gICAgICB2YWx1ZTogcHJvcHNba2V5Ml0sXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIGdldFdpbmRvd09mID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gIHZhciBvd25lckdsb2JhbCA9IHRhcmdldCAmJiB0YXJnZXQub3duZXJEb2N1bWVudCAmJiB0YXJnZXQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgcmV0dXJuIG93bmVyR2xvYmFsIHx8IGdsb2JhbCQxO1xufTtcbnZhciBlbXB0eVJlY3QgPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcbmZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcbiAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XG59XG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMyKSB7XG4gIHZhciBwb3NpdGlvbnMgPSBbXTtcbiAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBwb3NpdGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cbiAgcmV0dXJuIHBvc2l0aW9ucy5yZWR1Y2UoZnVuY3Rpb24oc2l6ZSwgcG9zaXRpb24pIHtcbiAgICB2YXIgdmFsdWUgPSBzdHlsZXMyW1wiYm9yZGVyLVwiICsgcG9zaXRpb24gKyBcIi13aWR0aFwiXTtcbiAgICByZXR1cm4gc2l6ZSArIHRvRmxvYXQodmFsdWUpO1xuICB9LCAwKTtcbn1cbmZ1bmN0aW9uIGdldFBhZGRpbmdzKHN0eWxlczIpIHtcbiAgdmFyIHBvc2l0aW9ucyA9IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXTtcbiAgdmFyIHBhZGRpbmdzID0ge307XG4gIGZvciAodmFyIF9pID0gMCwgcG9zaXRpb25zXzEgPSBwb3NpdGlvbnM7IF9pIDwgcG9zaXRpb25zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gcG9zaXRpb25zXzFbX2ldO1xuICAgIHZhciB2YWx1ZSA9IHN0eWxlczJbXCJwYWRkaW5nLVwiICsgcG9zaXRpb25dO1xuICAgIHBhZGRpbmdzW3Bvc2l0aW9uXSA9IHRvRmxvYXQodmFsdWUpO1xuICB9XG4gIHJldHVybiBwYWRkaW5ncztcbn1cbmZ1bmN0aW9uIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCkge1xuICB2YXIgYmJveCA9IHRhcmdldC5nZXRCQm94KCk7XG4gIHJldHVybiBjcmVhdGVSZWN0SW5pdCgwLCAwLCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG59XG5mdW5jdGlvbiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCkge1xuICB2YXIgY2xpZW50V2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCA9IHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gIGlmICghY2xpZW50V2lkdGggJiYgIWNsaWVudEhlaWdodCkge1xuICAgIHJldHVybiBlbXB0eVJlY3Q7XG4gIH1cbiAgdmFyIHN0eWxlczIgPSBnZXRXaW5kb3dPZih0YXJnZXQpLmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgdmFyIHBhZGRpbmdzID0gZ2V0UGFkZGluZ3Moc3R5bGVzMik7XG4gIHZhciBob3JpelBhZCA9IHBhZGRpbmdzLmxlZnQgKyBwYWRkaW5ncy5yaWdodDtcbiAgdmFyIHZlcnRQYWQgPSBwYWRkaW5ncy50b3AgKyBwYWRkaW5ncy5ib3R0b207XG4gIHZhciB3aWR0aCA9IHRvRmxvYXQoc3R5bGVzMi53aWR0aCksIGhlaWdodCA9IHRvRmxvYXQoc3R5bGVzMi5oZWlnaHQpO1xuICBpZiAoc3R5bGVzMi5ib3hTaXppbmcgPT09IFwiYm9yZGVyLWJveFwiKSB7XG4gICAgaWYgKE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgIT09IGNsaWVudFdpZHRoKSB7XG4gICAgICB3aWR0aCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMyLCBcImxlZnRcIiwgXCJyaWdodFwiKSArIGhvcml6UGFkO1xuICAgIH1cbiAgICBpZiAoTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAhPT0gY2xpZW50SGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzMiwgXCJ0b3BcIiwgXCJib3R0b21cIikgKyB2ZXJ0UGFkO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkpIHtcbiAgICB2YXIgdmVydFNjcm9sbGJhciA9IE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgLSBjbGllbnRXaWR0aDtcbiAgICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKGhlaWdodCArIHZlcnRQYWQpIC0gY2xpZW50SGVpZ2h0O1xuICAgIGlmIChNYXRoLmFicyh2ZXJ0U2Nyb2xsYmFyKSAhPT0gMSkge1xuICAgICAgd2lkdGggLT0gdmVydFNjcm9sbGJhcjtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKGhvcml6U2Nyb2xsYmFyKSAhPT0gMSkge1xuICAgICAgaGVpZ2h0IC09IGhvcml6U2Nyb2xsYmFyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlUmVjdEluaXQocGFkZGluZ3MubGVmdCwgcGFkZGluZ3MudG9wLCB3aWR0aCwgaGVpZ2h0KTtcbn1cbnZhciBpc1NWR0dyYXBoaWNzRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIFNWR0dyYXBoaWNzRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0dyYXBoaWNzRWxlbWVudDtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdFbGVtZW50ICYmIHR5cGVvZiB0YXJnZXQuZ2V0QkJveCA9PT0gXCJmdW5jdGlvblwiO1xuICB9O1xufSgpO1xuZnVuY3Rpb24gaXNEb2N1bWVudEVsZW1lbnQodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQgPT09IGdldFdpbmRvd09mKHRhcmdldCkuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QodGFyZ2V0KSB7XG4gIGlmICghaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIGVtcHR5UmVjdDtcbiAgfVxuICBpZiAoaXNTVkdHcmFwaGljc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpO1xuICB9XG4gIHJldHVybiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFkT25seVJlY3QoX2EpIHtcbiAgdmFyIHgyID0gX2EueCwgeTIgPSBfYS55LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gIHZhciBDb25zdHIgPSB0eXBlb2YgRE9NUmVjdFJlYWRPbmx5ICE9PSBcInVuZGVmaW5lZFwiID8gRE9NUmVjdFJlYWRPbmx5IDogT2JqZWN0O1xuICB2YXIgcmVjdCA9IE9iamVjdC5jcmVhdGUoQ29uc3RyLnByb3RvdHlwZSk7XG4gIGRlZmluZUNvbmZpZ3VyYWJsZShyZWN0LCB7XG4gICAgeDogeDIsXG4gICAgeTogeTIsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHRvcDogeTIsXG4gICAgcmlnaHQ6IHgyICsgd2lkdGgsXG4gICAgYm90dG9tOiBoZWlnaHQgKyB5MixcbiAgICBsZWZ0OiB4MlxuICB9KTtcbiAgcmV0dXJuIHJlY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWN0SW5pdCh4MiwgeTIsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIHsgeDogeDIsIHk6IHkyLCB3aWR0aCwgaGVpZ2h0IH07XG59XG52YXIgUmVzaXplT2JzZXJ2YXRpb24gPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2YXRpb24yKHRhcmdldCkge1xuICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSAwO1xuICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gMDtcbiAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG4gIFJlc2l6ZU9ic2VydmF0aW9uMi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVjdCA9IGdldENvbnRlbnRSZWN0KHRoaXMudGFyZ2V0KTtcbiAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IHJlY3Q7XG4gICAgcmV0dXJuIHJlY3Qud2lkdGggIT09IHRoaXMuYnJvYWRjYXN0V2lkdGggfHwgcmVjdC5oZWlnaHQgIT09IHRoaXMuYnJvYWRjYXN0SGVpZ2h0O1xuICB9O1xuICBSZXNpemVPYnNlcnZhdGlvbjIucHJvdG90eXBlLmJyb2FkY2FzdFJlY3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuY29udGVudFJlY3RfO1xuICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSByZWN0LndpZHRoO1xuICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH07XG4gIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjI7XG59KCk7XG52YXIgUmVzaXplT2JzZXJ2ZXJFbnRyeSA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5Mih0YXJnZXQsIHJlY3RJbml0KSB7XG4gICAgdmFyIGNvbnRlbnRSZWN0ID0gY3JlYXRlUmVhZE9ubHlSZWN0KHJlY3RJbml0KTtcbiAgICBkZWZpbmVDb25maWd1cmFibGUodGhpcywgeyB0YXJnZXQsIGNvbnRlbnRSZWN0IH0pO1xuICB9XG4gIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5Mjtcbn0oKTtcbnZhciBSZXNpemVPYnNlcnZlclNQSSA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlclNQSTIoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIGNhbGxiYWNrQ3R4KSB7XG4gICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfID0gW107XG4gICAgdGhpcy5vYnNlcnZhdGlvbnNfID0gbmV3IE1hcFNoaW0oKTtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgY2FsbGJhY2sgcHJvdmlkZWQgYXMgcGFyYW1ldGVyIDEgaXMgbm90IGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cbiAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xuICAgIHRoaXMuY29udHJvbGxlcl8gPSBjb250cm9sbGVyO1xuICAgIHRoaXMuY2FsbGJhY2tDdHhfID0gY2FsbGJhY2tDdHg7XG4gIH1cbiAgUmVzaXplT2JzZXJ2ZXJTUEkyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSBcInVuZGVmaW5lZFwiIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XG4gICAgfVxuICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XG4gICAgaWYgKG9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvYnNlcnZhdGlvbnMuc2V0KHRhcmdldCwgbmV3IFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkpO1xuICAgIHRoaXMuY29udHJvbGxlcl8uYWRkT2JzZXJ2ZXIodGhpcyk7XG4gICAgdGhpcy5jb250cm9sbGVyXy5yZWZyZXNoKCk7XG4gIH07XG4gIFJlc2l6ZU9ic2VydmVyU1BJMi5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSBcInVuZGVmaW5lZFwiIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XG4gICAgfVxuICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XG4gICAgaWYgKCFvYnNlcnZhdGlvbnMuaGFzKHRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb2JzZXJ2YXRpb25zLmRlbGV0ZSh0YXJnZXQpO1xuICAgIGlmICghb2JzZXJ2YXRpb25zLnNpemUpIHtcbiAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XG4gICAgfVxuICB9O1xuICBSZXNpemVPYnNlcnZlclNQSTIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XG4gICAgdGhpcy5vYnNlcnZhdGlvbnNfLmNsZWFyKCk7XG4gICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcbiAgfTtcbiAgUmVzaXplT2JzZXJ2ZXJTUEkyLnByb3RvdHlwZS5nYXRoZXJBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcbiAgICB0aGlzLm9ic2VydmF0aW9uc18uZm9yRWFjaChmdW5jdGlvbihvYnNlcnZhdGlvbikge1xuICAgICAgaWYgKG9ic2VydmF0aW9uLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgX3RoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5wdXNoKG9ic2VydmF0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgUmVzaXplT2JzZXJ2ZXJTUEkyLnByb3RvdHlwZS5icm9hZGNhc3RBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaGFzQWN0aXZlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FsbGJhY2tDdHhfO1xuICAgIHZhciBlbnRyaWVzID0gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLm1hcChmdW5jdGlvbihvYnNlcnZhdGlvbikge1xuICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlckVudHJ5KG9ic2VydmF0aW9uLnRhcmdldCwgb2JzZXJ2YXRpb24uYnJvYWRjYXN0UmVjdCgpKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhbGxiYWNrXy5jYWxsKGN0eCwgZW50cmllcywgY3R4KTtcbiAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XG4gIH07XG4gIFJlc2l6ZU9ic2VydmVyU1BJMi5wcm90b3R5cGUuY2xlYXJBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18uc3BsaWNlKDApO1xuICB9O1xuICBSZXNpemVPYnNlcnZlclNQSTIucHJvdG90eXBlLmhhc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubGVuZ3RoID4gMDtcbiAgfTtcbiAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU1BJMjtcbn0oKTtcbnZhciBvYnNlcnZlcnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gXCJ1bmRlZmluZWRcIiA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpIDogbmV3IE1hcFNoaW0oKTtcbnZhciBSZXNpemVPYnNlcnZlciQxID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyMihjYWxsYmFjaykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNpemVPYnNlcnZlcjIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtcbiAgICB9XG4gICAgdmFyIGNvbnRyb2xsZXIgPSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIHRoaXMpO1xuICAgIG9ic2VydmVycy5zZXQodGhpcywgb2JzZXJ2ZXIpO1xuICB9XG4gIHJldHVybiBSZXNpemVPYnNlcnZlcjI7XG59KCk7XG5bXG4gIFwib2JzZXJ2ZVwiLFxuICBcInVub2JzZXJ2ZVwiLFxuICBcImRpc2Nvbm5lY3RcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZDQpIHtcbiAgUmVzaXplT2JzZXJ2ZXIkMS5wcm90b3R5cGVbbWV0aG9kNF0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IG9ic2VydmVycy5nZXQodGhpcykpW21ldGhvZDRdLmFwcGx5KF9hLCBhcmd1bWVudHMpO1xuICB9O1xufSk7XG52YXIgaW5kZXggPSBmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlcjtcbiAgfVxuICByZXR1cm4gUmVzaXplT2JzZXJ2ZXIkMTtcbn0oKTtcbmZ1bmN0aW9uIGlzU2FtZVBvaW50KHByZXYsIG5leHQpIHtcbiAgaWYgKHByZXYgPT09IG5leHQpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmICghcHJldiB8fCAhbmV4dClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChcInBhZ2VYXCIgaW4gbmV4dCAmJiBcInBhZ2VZXCIgaW4gbmV4dCkge1xuICAgIHJldHVybiBwcmV2LnBhZ2VYID09PSBuZXh0LnBhZ2VYICYmIHByZXYucGFnZVkgPT09IG5leHQucGFnZVk7XG4gIH1cbiAgaWYgKFwiY2xpZW50WFwiIGluIG5leHQgJiYgXCJjbGllbnRZXCIgaW4gbmV4dCkge1xuICAgIHJldHVybiBwcmV2LmNsaWVudFggPT09IG5leHQuY2xpZW50WCAmJiBwcmV2LmNsaWVudFkgPT09IG5leHQuY2xpZW50WTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZXN0b3JlRm9jdXMoYWN0aXZlRWxlbWVudCwgY29udGFpbmVyKSB7XG4gIGlmIChhY3RpdmVFbGVtZW50ICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGNvbnRhaW5zKGNvbnRhaW5lciwgYWN0aXZlRWxlbWVudCkgJiYgdHlwZW9mIGFjdGl2ZUVsZW1lbnQuZm9jdXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxufVxuZnVuY3Rpb24gbW9uaXRvclJlc2l6ZShlbGVtZW50LCBjYWxsYmFjaykge1xuICB2YXIgcHJldldpZHRoID0gbnVsbDtcbiAgdmFyIHByZXZIZWlnaHQgPSBudWxsO1xuICBmdW5jdGlvbiBvblJlc2l6ZTIoX3JlZikge1xuICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDEpLCB0YXJnZXQgPSBfcmVmMlswXS50YXJnZXQ7XG4gICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGFyZ2V0KSlcbiAgICAgIHJldHVybjtcbiAgICB2YXIgX3RhcmdldCRnZXRCb3VuZGluZ0NsID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB3aWR0aCA9IF90YXJnZXQkZ2V0Qm91bmRpbmdDbC53aWR0aCwgaGVpZ2h0ID0gX3RhcmdldCRnZXRCb3VuZGluZ0NsLmhlaWdodDtcbiAgICB2YXIgZml4ZWRXaWR0aCA9IE1hdGguZmxvb3Iod2lkdGgpO1xuICAgIHZhciBmaXhlZEhlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0KTtcbiAgICBpZiAocHJldldpZHRoICE9PSBmaXhlZFdpZHRoIHx8IHByZXZIZWlnaHQgIT09IGZpeGVkSGVpZ2h0KSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgd2lkdGg6IGZpeGVkV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBmaXhlZEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwcmV2V2lkdGggPSBmaXhlZFdpZHRoO1xuICAgIHByZXZIZWlnaHQgPSBmaXhlZEhlaWdodDtcbiAgfVxuICB2YXIgcmVzaXplT2JzZXJ2ZXIyID0gbmV3IGluZGV4KG9uUmVzaXplMik7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgcmVzaXplT2JzZXJ2ZXIyLm9ic2VydmUoZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJlc2l6ZU9ic2VydmVyMi5kaXNjb25uZWN0KCk7XG4gIH07XG59XG52YXIgdXNlQnVmZmVyID0gZnVuY3Rpb24oY2FsbGJhY2ssIGJ1ZmZlcikge1xuICB2YXIgY2FsbGVkUmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKGZhbHNlKTtcbiAgdmFyIHRpbWVvdXRSZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gIGZ1bmN0aW9uIGNhbmNlbFRyaWdnZXIoKSB7XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHRyaWdnZXIoZm9yY2UpIHtcbiAgICBpZiAoIWNhbGxlZFJlZi5jdXJyZW50IHx8IGZvcmNlID09PSB0cnVlKSB7XG4gICAgICBpZiAoY2FsbGJhY2soKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgY2FuY2VsVHJpZ2dlcigpO1xuICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9LCBidWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW5jZWxUcmlnZ2VyKCk7XG4gICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgdHJpZ2dlcigpO1xuICAgICAgfSwgYnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFt0cmlnZ2VyLCBmdW5jdGlvbigpIHtcbiAgICBjYWxsZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIGNhbmNlbFRyaWdnZXIoKTtcbiAgfV07XG59O1xuZnVuY3Rpb24gZ2V0RWxlbWVudChmdW5jKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBudWxsO1xuICByZXR1cm4gZnVuYygpO1xufVxuZnVuY3Rpb24gZ2V0UG9pbnQocG9pbnQpIHtcbiAgaWYgKF90eXBlb2YkMShwb2ludCkgIT09IFwib2JqZWN0XCIgfHwgIXBvaW50KVxuICAgIHJldHVybiBudWxsO1xuICByZXR1cm4gcG9pbnQ7XG59XG52YXIgQWxpZ24gPSBmdW5jdGlvbiBBbGlnbjIoX3JlZiwgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sIGRpc2FibGVkID0gX3JlZi5kaXNhYmxlZCwgdGFyZ2V0ID0gX3JlZi50YXJnZXQsIGFsaWduID0gX3JlZi5hbGlnbiwgb25BbGlnbiA9IF9yZWYub25BbGlnbiwgbW9uaXRvcldpbmRvd1Jlc2l6ZSA9IF9yZWYubW9uaXRvcldpbmRvd1Jlc2l6ZSwgX3JlZiRtb25pdG9yQnVmZmVyVGltID0gX3JlZi5tb25pdG9yQnVmZmVyVGltZSwgbW9uaXRvckJ1ZmZlclRpbWUgPSBfcmVmJG1vbml0b3JCdWZmZXJUaW0gPT09IHZvaWQgMCA/IDAgOiBfcmVmJG1vbml0b3JCdWZmZXJUaW07XG4gIHZhciBjYWNoZVJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZih7fSk7XG4gIHZhciBub2RlUmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKCk7XG4gIHZhciBjaGlsZE5vZGUgPSBSZWFjdF9fZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgdmFyIGZvcmNlQWxpZ25Qcm9wc1JlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZih7fSk7XG4gIGZvcmNlQWxpZ25Qcm9wc1JlZi5jdXJyZW50LmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gIGZvcmNlQWxpZ25Qcm9wc1JlZi5jdXJyZW50LnRhcmdldCA9IHRhcmdldDtcbiAgZm9yY2VBbGlnblByb3BzUmVmLmN1cnJlbnQuYWxpZ24gPSBhbGlnbjtcbiAgZm9yY2VBbGlnblByb3BzUmVmLmN1cnJlbnQub25BbGlnbiA9IG9uQWxpZ247XG4gIHZhciBfdXNlQnVmZmVyID0gdXNlQnVmZmVyKGZ1bmN0aW9uKCkge1xuICAgIHZhciBfZm9yY2VBbGlnblByb3BzUmVmJGMgPSBmb3JjZUFsaWduUHJvcHNSZWYuY3VycmVudCwgbGF0ZXN0RGlzYWJsZWQgPSBfZm9yY2VBbGlnblByb3BzUmVmJGMuZGlzYWJsZWQsIGxhdGVzdFRhcmdldCA9IF9mb3JjZUFsaWduUHJvcHNSZWYkYy50YXJnZXQsIGxhdGVzdEFsaWduID0gX2ZvcmNlQWxpZ25Qcm9wc1JlZiRjLmFsaWduLCBsYXRlc3RPbkFsaWduID0gX2ZvcmNlQWxpZ25Qcm9wc1JlZiRjLm9uQWxpZ247XG4gICAgaWYgKCFsYXRlc3REaXNhYmxlZCAmJiBsYXRlc3RUYXJnZXQpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBub2RlUmVmLmN1cnJlbnQ7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgdmFyIGVsZW1lbnQgPSBnZXRFbGVtZW50KGxhdGVzdFRhcmdldCk7XG4gICAgICB2YXIgcG9pbnQgPSBnZXRQb2ludChsYXRlc3RUYXJnZXQpO1xuICAgICAgY2FjaGVSZWYuY3VycmVudC5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIGNhY2hlUmVmLmN1cnJlbnQucG9pbnQgPSBwb2ludDtcbiAgICAgIGNhY2hlUmVmLmN1cnJlbnQuYWxpZ24gPSBsYXRlc3RBbGlnbjtcbiAgICAgIHZhciBfZG9jdW1lbnQgPSBkb2N1bWVudCwgYWN0aXZlRWxlbWVudCA9IF9kb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgaWYgKGVsZW1lbnQgJiYgaXNWaXNpYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgIHJlc3VsdCA9IGFsaWduRWxlbWVudChzb3VyY2UsIGVsZW1lbnQsIGxhdGVzdEFsaWduKTtcbiAgICAgIH0gZWxzZSBpZiAocG9pbnQpIHtcbiAgICAgICAgcmVzdWx0ID0gYWxpZ25Qb2ludChzb3VyY2UsIHBvaW50LCBsYXRlc3RBbGlnbik7XG4gICAgICB9XG4gICAgICByZXN0b3JlRm9jdXMoYWN0aXZlRWxlbWVudCwgc291cmNlKTtcbiAgICAgIGlmIChsYXRlc3RPbkFsaWduICYmIHJlc3VsdCkge1xuICAgICAgICBsYXRlc3RPbkFsaWduKHNvdXJjZSwgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIG1vbml0b3JCdWZmZXJUaW1lKSwgX3VzZUJ1ZmZlcjIgPSBfc2xpY2VkVG9BcnJheShfdXNlQnVmZmVyLCAyKSwgX2ZvcmNlQWxpZ24gPSBfdXNlQnVmZmVyMlswXSwgY2FuY2VsRm9yY2VBbGlnbiA9IF91c2VCdWZmZXIyWzFdO1xuICB2YXIgcmVzaXplTW9uaXRvciA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZih7XG4gICAgY2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwyKCkge1xuICAgIH1cbiAgfSk7XG4gIHZhciBzb3VyY2VSZXNpemVNb25pdG9yID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKHtcbiAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbDIoKSB7XG4gICAgfVxuICB9KTtcbiAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbGVtZW50ID0gZ2V0RWxlbWVudCh0YXJnZXQpO1xuICAgIHZhciBwb2ludCA9IGdldFBvaW50KHRhcmdldCk7XG4gICAgaWYgKG5vZGVSZWYuY3VycmVudCAhPT0gc291cmNlUmVzaXplTW9uaXRvci5jdXJyZW50LmVsZW1lbnQpIHtcbiAgICAgIHNvdXJjZVJlc2l6ZU1vbml0b3IuY3VycmVudC5jYW5jZWwoKTtcbiAgICAgIHNvdXJjZVJlc2l6ZU1vbml0b3IuY3VycmVudC5lbGVtZW50ID0gbm9kZVJlZi5jdXJyZW50O1xuICAgICAgc291cmNlUmVzaXplTW9uaXRvci5jdXJyZW50LmNhbmNlbCA9IG1vbml0b3JSZXNpemUobm9kZVJlZi5jdXJyZW50LCBfZm9yY2VBbGlnbik7XG4gICAgfVxuICAgIGlmIChjYWNoZVJlZi5jdXJyZW50LmVsZW1lbnQgIT09IGVsZW1lbnQgfHwgIWlzU2FtZVBvaW50KGNhY2hlUmVmLmN1cnJlbnQucG9pbnQsIHBvaW50KSB8fCAhaXNFcXVhbF8xKGNhY2hlUmVmLmN1cnJlbnQuYWxpZ24sIGFsaWduKSkge1xuICAgICAgX2ZvcmNlQWxpZ24oKTtcbiAgICAgIGlmIChyZXNpemVNb25pdG9yLmN1cnJlbnQuZWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgICAgICByZXNpemVNb25pdG9yLmN1cnJlbnQuY2FuY2VsKCk7XG4gICAgICAgIHJlc2l6ZU1vbml0b3IuY3VycmVudC5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgcmVzaXplTW9uaXRvci5jdXJyZW50LmNhbmNlbCA9IG1vbml0b3JSZXNpemUoZWxlbWVudCwgX2ZvcmNlQWxpZ24pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbigpIHtcbiAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICBfZm9yY2VBbGlnbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW5jZWxGb3JjZUFsaWduKCk7XG4gICAgfVxuICB9LCBbZGlzYWJsZWRdKTtcbiAgdmFyIHdpblJlc2l6ZVJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcbiAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgIGlmIChtb25pdG9yV2luZG93UmVzaXplKSB7XG4gICAgICBpZiAoIXdpblJlc2l6ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHdpblJlc2l6ZVJlZi5jdXJyZW50ID0gYWRkRXZlbnRMaXN0ZW5lcldyYXAod2luZG93LCBcInJlc2l6ZVwiLCBfZm9yY2VBbGlnbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3aW5SZXNpemVSZWYuY3VycmVudCkge1xuICAgICAgd2luUmVzaXplUmVmLmN1cnJlbnQucmVtb3ZlKCk7XG4gICAgICB3aW5SZXNpemVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbbW9uaXRvcldpbmRvd1Jlc2l6ZV0pO1xuICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmVzaXplTW9uaXRvci5jdXJyZW50LmNhbmNlbCgpO1xuICAgICAgc291cmNlUmVzaXplTW9uaXRvci5jdXJyZW50LmNhbmNlbCgpO1xuICAgICAgaWYgKHdpblJlc2l6ZVJlZi5jdXJyZW50KVxuICAgICAgICB3aW5SZXNpemVSZWYuY3VycmVudC5yZW1vdmUoKTtcbiAgICAgIGNhbmNlbEZvcmNlQWxpZ24oKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIFJlYWN0X19kZWZhdWx0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9yY2VBbGlnbjogZnVuY3Rpb24gZm9yY2VBbGlnbigpIHtcbiAgICAgICAgcmV0dXJuIF9mb3JjZUFsaWduKHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBpZiAoLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmlzVmFsaWRFbGVtZW50KGNoaWxkTm9kZSkpIHtcbiAgICBjaGlsZE5vZGUgPSAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkTm9kZSwge1xuICAgICAgcmVmOiBjb21wb3NlUmVmKGNoaWxkTm9kZS5yZWYsIG5vZGVSZWYpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNoaWxkTm9kZTtcbn07XG52YXIgUmNBbGlnbiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5mb3J3YXJkUmVmKEFsaWduKTtcblJjQWxpZ24uZGlzcGxheU5hbWUgPSBcIkFsaWduXCI7XG52YXIgU3RhdHVzUXVldWUgPSBbXCJtZWFzdXJlXCIsIFwiYWxpZ25cIiwgbnVsbCwgXCJtb3Rpb25cIl07XG52YXIgdXNlVmlzaWJsZVN0YXR1cyA9IGZ1bmN0aW9uKHZpc2libGUsIGRvTWVhc3VyZSkge1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUobnVsbCksIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLCBzdGF0dXMgPSBfdXNlU3RhdGUyWzBdLCBzZXRJbnRlcm5hbFN0YXR1cyA9IF91c2VTdGF0ZTJbMV07XG4gIHZhciByYWZSZWYgPSB1c2VSZWYoKTtcbiAgdmFyIGRlc3Ryb3lSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICBmdW5jdGlvbiBzZXRTdGF0dXMobmV4dFN0YXR1cykge1xuICAgIGlmICghZGVzdHJveVJlZi5jdXJyZW50KSB7XG4gICAgICBzZXRJbnRlcm5hbFN0YXR1cyhuZXh0U3RhdHVzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsUmFmKCkge1xuICAgIHdyYXBwZXJSYWYkMS5jYW5jZWwocmFmUmVmLmN1cnJlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGdvTmV4dFN0YXR1cyhjYWxsYmFjaykge1xuICAgIGNhbmNlbFJhZigpO1xuICAgIHJhZlJlZi5jdXJyZW50ID0gd3JhcHBlclJhZiQxKGZ1bmN0aW9uKCkge1xuICAgICAgc2V0U3RhdHVzKGZ1bmN0aW9uKHByZXYpIHtcbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICBjYXNlIFwiYWxpZ25cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1vdGlvblwiO1xuICAgICAgICAgIGNhc2UgXCJtb3Rpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBcInN0YWJsZVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfSk7XG4gICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfVxuICB1c2VFZmZlY3QoZnVuY3Rpb24oKSB7XG4gICAgc2V0U3RhdHVzKFwibWVhc3VyZVwiKTtcbiAgfSwgW3Zpc2libGVdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlIFwibWVhc3VyZVwiOlxuICAgICAgICBkb01lYXN1cmUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChzdGF0dXMpIHtcbiAgICAgIHJhZlJlZi5jdXJyZW50ID0gd3JhcHBlclJhZiQxKC8qIEBfX1BVUkVfXyAqLyBfYXN5bmNUb0dlbmVyYXRvcigvKiBAX19QVVJFX18gKi8gcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgaW5kZXgyLCBuZXh0U3RhdHVzO1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpbmRleDIgPSBTdGF0dXNRdWV1ZS5pbmRleE9mKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXR1cyA9IFN0YXR1c1F1ZXVlW2luZGV4MiArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U3RhdHVzICYmIGluZGV4MiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHNldFN0YXR1cyhuZXh0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgIH0pKSk7XG4gICAgfVxuICB9LCBbc3RhdHVzXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBkZXN0cm95UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgY2FuY2VsUmFmKCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gW3N0YXR1cywgZ29OZXh0U3RhdHVzXTtcbn07XG52YXIgdXNlU3RyZXRjaFN0eWxlID0gZnVuY3Rpb24oc3RyZXRjaCkge1xuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9KSwgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksIHRhcmdldFNpemUgPSBfUmVhY3QkdXNlU3RhdGUyWzBdLCBzZXRUYXJnZXRTaXplID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcbiAgZnVuY3Rpb24gbWVhc3VyZVN0cmV0Y2goZWxlbWVudCkge1xuICAgIHNldFRhcmdldFNpemUoe1xuICAgICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4gICAgfSk7XG4gIH1cbiAgdmFyIHN0eWxlMiA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNpemVTdHlsZSA9IHt9O1xuICAgIGlmIChzdHJldGNoKSB7XG4gICAgICB2YXIgd2lkdGggPSB0YXJnZXRTaXplLndpZHRoLCBoZWlnaHQgPSB0YXJnZXRTaXplLmhlaWdodDtcbiAgICAgIGlmIChzdHJldGNoLmluZGV4T2YoXCJoZWlnaHRcIikgIT09IC0xICYmIGhlaWdodCkge1xuICAgICAgICBzaXplU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChzdHJldGNoLmluZGV4T2YoXCJtaW5IZWlnaHRcIikgIT09IC0xICYmIGhlaWdodCkge1xuICAgICAgICBzaXplU3R5bGUubWluSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKHN0cmV0Y2guaW5kZXhPZihcIndpZHRoXCIpICE9PSAtMSAmJiB3aWR0aCkge1xuICAgICAgICBzaXplU3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZXRjaC5pbmRleE9mKFwibWluV2lkdGhcIikgIT09IC0xICYmIHdpZHRoKSB7XG4gICAgICAgIHNpemVTdHlsZS5taW5XaWR0aCA9IHdpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2l6ZVN0eWxlO1xuICB9LCBbc3RyZXRjaCwgdGFyZ2V0U2l6ZV0pO1xuICByZXR1cm4gW3N0eWxlMiwgbWVhc3VyZVN0cmV0Y2hdO1xufTtcbnZhciBQb3B1cElubmVyID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24ocHJvcHMsIHJlZikge1xuICB2YXIgdmlzaWJsZSA9IHByb3BzLnZpc2libGUsIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscywgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLCBzdHlsZTIgPSBwcm9wcy5zdHlsZSwgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbiwgekluZGV4ID0gcHJvcHMuekluZGV4LCBzdHJldGNoID0gcHJvcHMuc3RyZXRjaCwgZGVzdHJveVBvcHVwT25IaWRlID0gcHJvcHMuZGVzdHJveVBvcHVwT25IaWRlLCBmb3JjZVJlbmRlciA9IHByb3BzLmZvcmNlUmVuZGVyLCBhbGlnbiA9IHByb3BzLmFsaWduLCBwb2ludCA9IHByb3BzLnBvaW50LCBnZXRSb290RG9tTm9kZSA9IHByb3BzLmdldFJvb3REb21Ob2RlLCBnZXRDbGFzc05hbWVGcm9tQWxpZ24gPSBwcm9wcy5nZXRDbGFzc05hbWVGcm9tQWxpZ24sIG9uQWxpZ24gPSBwcm9wcy5vbkFsaWduLCBvbk1vdXNlRW50ZXIgPSBwcm9wcy5vbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSA9IHByb3BzLm9uTW91c2VMZWF2ZSwgb25Nb3VzZURvd24gPSBwcm9wcy5vbk1vdXNlRG93biwgb25Ub3VjaFN0YXJ0ID0gcHJvcHMub25Ub3VjaFN0YXJ0O1xuICB2YXIgYWxpZ25SZWYgPSB1c2VSZWYoKTtcbiAgdmFyIGVsZW1lbnRSZWYgPSB1c2VSZWYoKTtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKCksIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLCBhbGlnbmVkQ2xhc3NOYW1lID0gX3VzZVN0YXRlMlswXSwgc2V0QWxpZ25lZENsYXNzTmFtZSA9IF91c2VTdGF0ZTJbMV07XG4gIHZhciBfdXNlU3RyZXRjaFN0eWxlID0gdXNlU3RyZXRjaFN0eWxlKHN0cmV0Y2gpLCBfdXNlU3RyZXRjaFN0eWxlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdHJldGNoU3R5bGUsIDIpLCBzdHJldGNoU3R5bGUgPSBfdXNlU3RyZXRjaFN0eWxlMlswXSwgbWVhc3VyZVN0cmV0Y2hTdHlsZSA9IF91c2VTdHJldGNoU3R5bGUyWzFdO1xuICBmdW5jdGlvbiBkb01lYXN1cmUoKSB7XG4gICAgaWYgKHN0cmV0Y2gpIHtcbiAgICAgIG1lYXN1cmVTdHJldGNoU3R5bGUoZ2V0Um9vdERvbU5vZGUoKSk7XG4gICAgfVxuICB9XG4gIHZhciBfdXNlVmlzaWJsZVN0YXR1cyA9IHVzZVZpc2libGVTdGF0dXModmlzaWJsZSwgZG9NZWFzdXJlKSwgX3VzZVZpc2libGVTdGF0dXMyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVZpc2libGVTdGF0dXMsIDIpLCBzdGF0dXMgPSBfdXNlVmlzaWJsZVN0YXR1czJbMF0sIGdvTmV4dFN0YXR1cyA9IF91c2VWaXNpYmxlU3RhdHVzMlsxXTtcbiAgdmFyIHByZXBhcmVSZXNvbHZlUmVmID0gdXNlUmVmKCk7XG4gIGZ1bmN0aW9uIGdldEFsaWduVGFyZ2V0KCkge1xuICAgIGlmIChwb2ludCkge1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Um9vdERvbU5vZGU7XG4gIH1cbiAgZnVuY3Rpb24gZm9yY2VBbGlnbigpIHtcbiAgICB2YXIgX2FsaWduUmVmJGN1cnJlbnQ7XG4gICAgKF9hbGlnblJlZiRjdXJyZW50ID0gYWxpZ25SZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2FsaWduUmVmJGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hbGlnblJlZiRjdXJyZW50LmZvcmNlQWxpZ24oKTtcbiAgfVxuICBmdW5jdGlvbiBvbkludGVybmFsQWxpZ24ocG9wdXBEb21Ob2RlLCBtYXRjaEFsaWduKSB7XG4gICAgdmFyIG5leHRBbGlnbmVkQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lRnJvbUFsaWduKG1hdGNoQWxpZ24pO1xuICAgIGlmIChhbGlnbmVkQ2xhc3NOYW1lICE9PSBuZXh0QWxpZ25lZENsYXNzTmFtZSkge1xuICAgICAgc2V0QWxpZ25lZENsYXNzTmFtZShuZXh0QWxpZ25lZENsYXNzTmFtZSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IFwiYWxpZ25cIikge1xuICAgICAgaWYgKGFsaWduZWRDbGFzc05hbWUgIT09IG5leHRBbGlnbmVkQ2xhc3NOYW1lKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yY2VBbGlnbigpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdvTmV4dFN0YXR1cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX3ByZXBhcmVSZXNvbHZlUmVmJGN1O1xuICAgICAgICAgIChfcHJlcGFyZVJlc29sdmVSZWYkY3UgPSBwcmVwYXJlUmVzb2x2ZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfcHJlcGFyZVJlc29sdmVSZWYkY3UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcmVwYXJlUmVzb2x2ZVJlZiRjdS5jYWxsKHByZXBhcmVSZXNvbHZlUmVmKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBvbkFsaWduID09PSBudWxsIHx8IG9uQWxpZ24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQWxpZ24ocG9wdXBEb21Ob2RlLCBtYXRjaEFsaWduKTtcbiAgICB9XG4gIH1cbiAgdmFyIG1vdGlvbiA9IF9vYmplY3RTcHJlYWQyJDEoe30sIGdldE1vdGlvbihwcm9wcykpO1xuICBbXCJvbkFwcGVhckVuZFwiLCBcIm9uRW50ZXJFbmRcIiwgXCJvbkxlYXZlRW5kXCJdLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgdmFyIG9yaWdpbkhhbmRsZXIgPSBtb3Rpb25bZXZlbnROYW1lXTtcbiAgICBtb3Rpb25bZXZlbnROYW1lXSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50KSB7XG4gICAgICBnb05leHRTdGF0dXMoKTtcbiAgICAgIHJldHVybiBvcmlnaW5IYW5kbGVyID09PSBudWxsIHx8IG9yaWdpbkhhbmRsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbkhhbmRsZXIoZWxlbWVudCwgZXZlbnQpO1xuICAgIH07XG4gIH0pO1xuICBmdW5jdGlvbiBvblNob3dQcmVwYXJlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICBwcmVwYXJlUmVzb2x2ZVJlZi5jdXJyZW50ID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgfVxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFtb3Rpb24ubW90aW9uTmFtZSAmJiBzdGF0dXMgPT09IFwibW90aW9uXCIpIHtcbiAgICAgIGdvTmV4dFN0YXR1cygpO1xuICAgIH1cbiAgfSwgW21vdGlvbi5tb3Rpb25OYW1lLCBzdGF0dXNdKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JjZUFsaWduLFxuICAgICAgZ2V0RWxlbWVudDogZnVuY3Rpb24gZ2V0RWxlbWVudDIoKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHZhciBtZXJnZWRTdHlsZSA9IF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwgc3RyZXRjaFN0eWxlKSwge30sIHtcbiAgICB6SW5kZXgsXG4gICAgb3BhY2l0eTogc3RhdHVzID09PSBcIm1vdGlvblwiIHx8IHN0YXR1cyA9PT0gXCJzdGFibGVcIiB8fCAhdmlzaWJsZSA/IHZvaWQgMCA6IDAsXG4gICAgcG9pbnRlckV2ZW50czogc3RhdHVzID09PSBcInN0YWJsZVwiID8gdm9pZCAwIDogXCJub25lXCJcbiAgfSwgc3R5bGUyKTtcbiAgdmFyIGFsaWduRGlzYWJsZWQgPSB0cnVlO1xuICBpZiAoKGFsaWduID09PSBudWxsIHx8IGFsaWduID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGlnbi5wb2ludHMpICYmIChzdGF0dXMgPT09IFwiYWxpZ25cIiB8fCBzdGF0dXMgPT09IFwic3RhYmxlXCIpKSB7XG4gICAgYWxpZ25EaXNhYmxlZCA9IGZhbHNlO1xuICB9XG4gIHZhciBjaGlsZE5vZGUgPSBjaGlsZHJlbjtcbiAgaWYgKFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA+IDEpIHtcbiAgICBjaGlsZE5vZGUgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItY29udGVudFwiKVxuICAgIH0sIGNoaWxkcmVuKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ1NTTW90aW9uLCBfZXh0ZW5kcyQxKHtcbiAgICB2aXNpYmxlLFxuICAgIHJlZjogZWxlbWVudFJlZixcbiAgICBsZWF2ZWRDbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItaGlkZGVuXCIpXG4gIH0sIG1vdGlvbiwge1xuICAgIG9uQXBwZWFyUHJlcGFyZTogb25TaG93UHJlcGFyZSxcbiAgICBvbkVudGVyUHJlcGFyZTogb25TaG93UHJlcGFyZSxcbiAgICByZW1vdmVPbkxlYXZlOiBkZXN0cm95UG9wdXBPbkhpZGUsXG4gICAgZm9yY2VSZW5kZXJcbiAgfSksIGZ1bmN0aW9uKF9yZWYsIG1vdGlvblJlZikge1xuICAgIHZhciBtb3Rpb25DbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSwgbW90aW9uU3R5bGUgPSBfcmVmLnN0eWxlO1xuICAgIHZhciBtZXJnZWRDbGFzc05hbWUgPSBjbGFzc05hbWVzKHByZWZpeENscywgY2xhc3NOYW1lLCBhbGlnbmVkQ2xhc3NOYW1lLCBtb3Rpb25DbGFzc05hbWUpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSY0FsaWduLCB7XG4gICAgICB0YXJnZXQ6IGdldEFsaWduVGFyZ2V0KCksXG4gICAgICBrZXk6IFwicG9wdXBcIixcbiAgICAgIHJlZjogYWxpZ25SZWYsXG4gICAgICBtb25pdG9yV2luZG93UmVzaXplOiB0cnVlLFxuICAgICAgZGlzYWJsZWQ6IGFsaWduRGlzYWJsZWQsXG4gICAgICBhbGlnbixcbiAgICAgIG9uQWxpZ246IG9uSW50ZXJuYWxBbGlnblxuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIHJlZjogbW90aW9uUmVmLFxuICAgICAgY2xhc3NOYW1lOiBtZXJnZWRDbGFzc05hbWUsXG4gICAgICBvbk1vdXNlRW50ZXIsXG4gICAgICBvbk1vdXNlTGVhdmUsXG4gICAgICBvbk1vdXNlRG93bkNhcHR1cmU6IG9uTW91c2VEb3duLFxuICAgICAgb25Ub3VjaFN0YXJ0Q2FwdHVyZTogb25Ub3VjaFN0YXJ0LFxuICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwgbW90aW9uU3R5bGUpLCBtZXJnZWRTdHlsZSlcbiAgICB9LCBjaGlsZE5vZGUpKTtcbiAgfSk7XG59KTtcblBvcHVwSW5uZXIuZGlzcGxheU5hbWUgPSBcIlBvcHVwSW5uZXJcIjtcbnZhciBNb2JpbGVQb3B1cElubmVyID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24ocHJvcHMsIHJlZikge1xuICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzLCB2aXNpYmxlID0gcHJvcHMudmlzaWJsZSwgekluZGV4ID0gcHJvcHMuekluZGV4LCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLCBfcHJvcHMkbW9iaWxlID0gcHJvcHMubW9iaWxlO1xuICBfcHJvcHMkbW9iaWxlID0gX3Byb3BzJG1vYmlsZSA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkbW9iaWxlO1xuICB2YXIgcG9wdXBDbGFzc05hbWUgPSBfcHJvcHMkbW9iaWxlLnBvcHVwQ2xhc3NOYW1lLCBwb3B1cFN0eWxlID0gX3Byb3BzJG1vYmlsZS5wb3B1cFN0eWxlLCBfcHJvcHMkbW9iaWxlJHBvcHVwTW8gPSBfcHJvcHMkbW9iaWxlLnBvcHVwTW90aW9uLCBwb3B1cE1vdGlvbiA9IF9wcm9wcyRtb2JpbGUkcG9wdXBNbyA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkbW9iaWxlJHBvcHVwTW8sIHBvcHVwUmVuZGVyID0gX3Byb3BzJG1vYmlsZS5wb3B1cFJlbmRlcjtcbiAgdmFyIGVsZW1lbnRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JjZUFsaWduOiBmdW5jdGlvbiBmb3JjZUFsaWduKCkge1xuICAgICAgfSxcbiAgICAgIGdldEVsZW1lbnQ6IGZ1bmN0aW9uIGdldEVsZW1lbnQyKCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudFJlZi5jdXJyZW50O1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICB2YXIgbWVyZ2VkU3R5bGUgPSBfb2JqZWN0U3ByZWFkMiQxKHtcbiAgICB6SW5kZXhcbiAgfSwgcG9wdXBTdHlsZSk7XG4gIHZhciBjaGlsZE5vZGUgPSBjaGlsZHJlbjtcbiAgaWYgKFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA+IDEpIHtcbiAgICBjaGlsZE5vZGUgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItY29udGVudFwiKVxuICAgIH0sIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAocG9wdXBSZW5kZXIpIHtcbiAgICBjaGlsZE5vZGUgPSBwb3B1cFJlbmRlcihjaGlsZE5vZGUpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDU1NNb3Rpb24sIF9leHRlbmRzJDEoe1xuICAgIHZpc2libGUsXG4gICAgcmVmOiBlbGVtZW50UmVmLFxuICAgIHJlbW92ZU9uTGVhdmU6IHRydWVcbiAgfSwgcG9wdXBNb3Rpb24pLCBmdW5jdGlvbihfcmVmLCBtb3Rpb25SZWYpIHtcbiAgICB2YXIgbW90aW9uQ2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsIG1vdGlvblN0eWxlID0gX3JlZi5zdHlsZTtcbiAgICB2YXIgbWVyZ2VkQ2xhc3NOYW1lID0gY2xhc3NOYW1lcyhwcmVmaXhDbHMsIHBvcHVwQ2xhc3NOYW1lLCBtb3Rpb25DbGFzc05hbWUpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICByZWY6IG1vdGlvblJlZixcbiAgICAgIGNsYXNzTmFtZTogbWVyZ2VkQ2xhc3NOYW1lLFxuICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwgbW90aW9uU3R5bGUpLCBtZXJnZWRTdHlsZSlcbiAgICB9LCBjaGlsZE5vZGUpO1xuICB9KTtcbn0pO1xuTW9iaWxlUG9wdXBJbm5lci5kaXNwbGF5TmFtZSA9IFwiTW9iaWxlUG9wdXBJbm5lclwiO1xudmFyIF9leGNsdWRlZCA9IFtcInZpc2libGVcIiwgXCJtb2JpbGVcIl07XG52YXIgUG9wdXAgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbihfcmVmLCByZWYpIHtcbiAgdmFyIHZpc2libGUgPSBfcmVmLnZpc2libGUsIG1vYmlsZSA9IF9yZWYubW9iaWxlLCBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUodmlzaWJsZSksIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLCBpbm5lclZpc2libGUgPSBfdXNlU3RhdGUyWzBdLCBzZXJJbm5lclZpc2libGUgPSBfdXNlU3RhdGUyWzFdO1xuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKGZhbHNlKSwgX3VzZVN0YXRlNCA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTMsIDIpLCBpbk1vYmlsZSA9IF91c2VTdGF0ZTRbMF0sIHNldEluTW9iaWxlID0gX3VzZVN0YXRlNFsxXTtcbiAgdmFyIGNsb25lUHJvcHMgPSBfb2JqZWN0U3ByZWFkMiQxKF9vYmplY3RTcHJlYWQyJDEoe30sIHByb3BzKSwge30sIHtcbiAgICB2aXNpYmxlOiBpbm5lclZpc2libGVcbiAgfSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbigpIHtcbiAgICBzZXJJbm5lclZpc2libGUodmlzaWJsZSk7XG4gICAgaWYgKHZpc2libGUgJiYgbW9iaWxlKSB7XG4gICAgICBzZXRJbk1vYmlsZShpc01vYmlsZSgpKTtcbiAgICB9XG4gIH0sIFt2aXNpYmxlLCBtb2JpbGVdKTtcbiAgdmFyIHBvcHVwTm9kZSA9IGluTW9iaWxlID8gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTW9iaWxlUG9wdXBJbm5lciwgX2V4dGVuZHMkMSh7fSwgY2xvbmVQcm9wcywge1xuICAgIG1vYmlsZSxcbiAgICByZWZcbiAgfSkpIDogLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUG9wdXBJbm5lciwgX2V4dGVuZHMkMSh7fSwgY2xvbmVQcm9wcywge1xuICAgIHJlZlxuICB9KSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChNYXNrLCBjbG9uZVByb3BzKSwgcG9wdXBOb2RlKTtcbn0pO1xuUG9wdXAuZGlzcGxheU5hbWUgPSBcIlBvcHVwXCI7XG52YXIgVHJpZ2dlckNvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIG5vb3AoKSB7XG59XG5mdW5jdGlvbiByZXR1cm5FbXB0eVN0cmluZygpIHtcbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiByZXR1cm5Eb2N1bWVudChlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgfVxuICByZXR1cm4gd2luZG93LmRvY3VtZW50O1xufVxudmFyIEFMTF9IQU5ETEVSUyA9IFtcIm9uQ2xpY2tcIiwgXCJvbk1vdXNlRG93blwiLCBcIm9uVG91Y2hTdGFydFwiLCBcIm9uTW91c2VFbnRlclwiLCBcIm9uTW91c2VMZWF2ZVwiLCBcIm9uRm9jdXNcIiwgXCJvbkJsdXJcIiwgXCJvbkNvbnRleHRNZW51XCJdO1xuZnVuY3Rpb24gZ2VuZXJhdGVUcmlnZ2VyKFBvcnRhbENvbXBvbmVudCkge1xuICB2YXIgVHJpZ2dlcjIgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhUcmlnZ2VyMywgX1JlYWN0JENvbXBvbmVudCk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihUcmlnZ2VyMyk7XG4gICAgZnVuY3Rpb24gVHJpZ2dlcjMocHJvcHMpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmlnZ2VyMyk7XG4gICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICAgIF90aGlzLnBvcHVwUmVmID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgX3RoaXMudHJpZ2dlclJlZiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgIF90aGlzLmF0dGFjaElkID0gdm9pZCAwO1xuICAgICAgX3RoaXMuY2xpY2tPdXRzaWRlSGFuZGxlciA9IHZvaWQgMDtcbiAgICAgIF90aGlzLnRvdWNoT3V0c2lkZUhhbmRsZXIgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5jb250ZXh0TWVudU91dHNpZGVIYW5kbGVyMSA9IHZvaWQgMDtcbiAgICAgIF90aGlzLmNvbnRleHRNZW51T3V0c2lkZUhhbmRsZXIyID0gdm9pZCAwO1xuICAgICAgX3RoaXMubW91c2VEb3duVGltZW91dCA9IHZvaWQgMDtcbiAgICAgIF90aGlzLmZvY3VzVGltZSA9IHZvaWQgMDtcbiAgICAgIF90aGlzLnByZUNsaWNrVGltZSA9IHZvaWQgMDtcbiAgICAgIF90aGlzLnByZVRvdWNoVGltZSA9IHZvaWQgMDtcbiAgICAgIF90aGlzLmRlbGF5VGltZXIgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5oYXNQb3B1cE1vdXNlRG93biA9IHZvaWQgMDtcbiAgICAgIF90aGlzLm9uTW91c2VFbnRlciA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgIHZhciBtb3VzZUVudGVyRGVsYXkgPSBfdGhpcy5wcm9wcy5tb3VzZUVudGVyRGVsYXk7XG4gICAgICAgIF90aGlzLmZpcmVFdmVudHMoXCJvbk1vdXNlRW50ZXJcIiwgZTIpO1xuICAgICAgICBfdGhpcy5kZWxheVNldFBvcHVwVmlzaWJsZSh0cnVlLCBtb3VzZUVudGVyRGVsYXksIG1vdXNlRW50ZXJEZWxheSA/IG51bGwgOiBlMik7XG4gICAgICB9O1xuICAgICAgX3RoaXMub25Nb3VzZU1vdmUgPSBmdW5jdGlvbihlMikge1xuICAgICAgICBfdGhpcy5maXJlRXZlbnRzKFwib25Nb3VzZU1vdmVcIiwgZTIpO1xuICAgICAgICBfdGhpcy5zZXRQb2ludChlMik7XG4gICAgICB9O1xuICAgICAgX3RoaXMub25Nb3VzZUxlYXZlID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgX3RoaXMuZmlyZUV2ZW50cyhcIm9uTW91c2VMZWF2ZVwiLCBlMik7XG4gICAgICAgIF90aGlzLmRlbGF5U2V0UG9wdXBWaXNpYmxlKGZhbHNlLCBfdGhpcy5wcm9wcy5tb3VzZUxlYXZlRGVsYXkpO1xuICAgICAgfTtcbiAgICAgIF90aGlzLm9uUG9wdXBNb3VzZUVudGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLmNsZWFyRGVsYXlUaW1lcigpO1xuICAgICAgfTtcbiAgICAgIF90aGlzLm9uUG9wdXBNb3VzZUxlYXZlID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgdmFyIF90aGlzJHBvcHVwUmVmJGN1cnJlbjtcbiAgICAgICAgaWYgKGUyLnJlbGF0ZWRUYXJnZXQgJiYgIWUyLnJlbGF0ZWRUYXJnZXQuc2V0VGltZW91dCAmJiBjb250YWlucygoX3RoaXMkcG9wdXBSZWYkY3VycmVuID0gX3RoaXMucG9wdXBSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3RoaXMkcG9wdXBSZWYkY3VycmVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwb3B1cFJlZiRjdXJyZW4uZ2V0RWxlbWVudCgpLCBlMi5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5kZWxheVNldFBvcHVwVmlzaWJsZShmYWxzZSwgX3RoaXMucHJvcHMubW91c2VMZWF2ZURlbGF5KTtcbiAgICAgIH07XG4gICAgICBfdGhpcy5vbkZvY3VzID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgX3RoaXMuZmlyZUV2ZW50cyhcIm9uRm9jdXNcIiwgZTIpO1xuICAgICAgICBfdGhpcy5jbGVhckRlbGF5VGltZXIoKTtcbiAgICAgICAgaWYgKF90aGlzLmlzRm9jdXNUb1Nob3coKSkge1xuICAgICAgICAgIF90aGlzLmZvY3VzVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgX3RoaXMuZGVsYXlTZXRQb3B1cFZpc2libGUodHJ1ZSwgX3RoaXMucHJvcHMuZm9jdXNEZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfdGhpcy5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgIF90aGlzLmZpcmVFdmVudHMoXCJvbk1vdXNlRG93blwiLCBlMik7XG4gICAgICAgIF90aGlzLnByZUNsaWNrVGltZSA9IERhdGUubm93KCk7XG4gICAgICB9O1xuICAgICAgX3RoaXMub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgX3RoaXMuZmlyZUV2ZW50cyhcIm9uVG91Y2hTdGFydFwiLCBlMik7XG4gICAgICAgIF90aGlzLnByZVRvdWNoVGltZSA9IERhdGUubm93KCk7XG4gICAgICB9O1xuICAgICAgX3RoaXMub25CbHVyID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgX3RoaXMuZmlyZUV2ZW50cyhcIm9uQmx1clwiLCBlMik7XG4gICAgICAgIF90aGlzLmNsZWFyRGVsYXlUaW1lcigpO1xuICAgICAgICBpZiAoX3RoaXMuaXNCbHVyVG9IaWRlKCkpIHtcbiAgICAgICAgICBfdGhpcy5kZWxheVNldFBvcHVwVmlzaWJsZShmYWxzZSwgX3RoaXMucHJvcHMuYmx1ckRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF90aGlzLm9uQ29udGV4dE1lbnUgPSBmdW5jdGlvbihlMikge1xuICAgICAgICBlMi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBfdGhpcy5maXJlRXZlbnRzKFwib25Db250ZXh0TWVudVwiLCBlMik7XG4gICAgICAgIF90aGlzLnNldFBvcHVwVmlzaWJsZSh0cnVlLCBlMik7XG4gICAgICB9O1xuICAgICAgX3RoaXMub25Db250ZXh0TWVudUNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChfdGhpcy5pc0NvbnRleHRNZW51VG9TaG93KCkpIHtcbiAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX3RoaXMub25DbGljayA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIF90aGlzLmZpcmVFdmVudHMoXCJvbkNsaWNrXCIsIGV2ZW50KTtcbiAgICAgICAgaWYgKF90aGlzLmZvY3VzVGltZSkge1xuICAgICAgICAgIHZhciBwcmVUaW1lO1xuICAgICAgICAgIGlmIChfdGhpcy5wcmVDbGlja1RpbWUgJiYgX3RoaXMucHJlVG91Y2hUaW1lKSB7XG4gICAgICAgICAgICBwcmVUaW1lID0gTWF0aC5taW4oX3RoaXMucHJlQ2xpY2tUaW1lLCBfdGhpcy5wcmVUb3VjaFRpbWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMucHJlQ2xpY2tUaW1lKSB7XG4gICAgICAgICAgICBwcmVUaW1lID0gX3RoaXMucHJlQ2xpY2tUaW1lO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMucHJlVG91Y2hUaW1lKSB7XG4gICAgICAgICAgICBwcmVUaW1lID0gX3RoaXMucHJlVG91Y2hUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoTWF0aC5hYnMocHJlVGltZSAtIF90aGlzLmZvY3VzVGltZSkgPCAyMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5mb2N1c1RpbWUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnByZUNsaWNrVGltZSA9IDA7XG4gICAgICAgIF90aGlzLnByZVRvdWNoVGltZSA9IDA7XG4gICAgICAgIGlmIChfdGhpcy5pc0NsaWNrVG9TaG93KCkgJiYgKF90aGlzLmlzQ2xpY2tUb0hpZGUoKSB8fCBfdGhpcy5pc0JsdXJUb0hpZGUoKSkgJiYgZXZlbnQgJiYgZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0VmlzaWJsZSA9ICFfdGhpcy5zdGF0ZS5wb3B1cFZpc2libGU7XG4gICAgICAgIGlmIChfdGhpcy5pc0NsaWNrVG9IaWRlKCkgJiYgIW5leHRWaXNpYmxlIHx8IG5leHRWaXNpYmxlICYmIF90aGlzLmlzQ2xpY2tUb1Nob3coKSkge1xuICAgICAgICAgIF90aGlzLnNldFBvcHVwVmlzaWJsZSghX3RoaXMuc3RhdGUucG9wdXBWaXNpYmxlLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfdGhpcy5vblBvcHVwTW91c2VEb3duID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLmhhc1BvcHVwTW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLm1vdXNlRG93blRpbWVvdXQpO1xuICAgICAgICBfdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMuaGFzUG9wdXBNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGlmIChfdGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzJGNvbnRleHQ7XG4gICAgICAgICAgKF90aGlzJGNvbnRleHQgPSBfdGhpcy5jb250ZXh0KS5vblBvcHVwTW91c2VEb3duLmFwcGx5KF90aGlzJGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfdGhpcy5vbkRvY3VtZW50Q2xpY2sgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoX3RoaXMucHJvcHMubWFzayAmJiAhX3RoaXMucHJvcHMubWFza0Nsb3NhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHZhciByb290MiA9IF90aGlzLmdldFJvb3REb21Ob2RlKCk7XG4gICAgICAgIHZhciBwb3B1cE5vZGUgPSBfdGhpcy5nZXRQb3B1cERvbU5vZGUoKTtcbiAgICAgICAgaWYgKCghY29udGFpbnMocm9vdDIsIHRhcmdldCkgfHwgX3RoaXMuaXNDb250ZXh0TWVudU9ubHkoKSkgJiYgIWNvbnRhaW5zKHBvcHVwTm9kZSwgdGFyZ2V0KSAmJiAhX3RoaXMuaGFzUG9wdXBNb3VzZURvd24pIHtcbiAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX3RoaXMuZ2V0Um9vdERvbU5vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdldFRyaWdnZXJET01Ob2RlID0gX3RoaXMucHJvcHMuZ2V0VHJpZ2dlckRPTU5vZGU7XG4gICAgICAgIGlmIChnZXRUcmlnZ2VyRE9NTm9kZSkge1xuICAgICAgICAgIHJldHVybiBnZXRUcmlnZ2VyRE9NTm9kZShfdGhpcy50cmlnZ2VyUmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGRvbU5vZGUgPSBmaW5kRE9NTm9kZShfdGhpcy50cmlnZ2VyUmVmLmN1cnJlbnQpO1xuICAgICAgICAgIGlmIChkb21Ob2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFjdERPTS5maW5kRE9NTm9kZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICB9O1xuICAgICAgX3RoaXMuZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ24gPSBmdW5jdGlvbihhbGlnbikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gW107XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLCBwb3B1cFBsYWNlbWVudCA9IF90aGlzJHByb3BzLnBvcHVwUGxhY2VtZW50LCBidWlsdGluUGxhY2VtZW50cyA9IF90aGlzJHByb3BzLmJ1aWx0aW5QbGFjZW1lbnRzLCBwcmVmaXhDbHMgPSBfdGhpcyRwcm9wcy5wcmVmaXhDbHMsIGFsaWduUG9pbnQyID0gX3RoaXMkcHJvcHMuYWxpZ25Qb2ludCwgZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ24gPSBfdGhpcyRwcm9wcy5nZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbjtcbiAgICAgICAgaWYgKHBvcHVwUGxhY2VtZW50ICYmIGJ1aWx0aW5QbGFjZW1lbnRzKSB7XG4gICAgICAgICAgY2xhc3NOYW1lLnB1c2goZ2V0QWxpZ25Qb3B1cENsYXNzTmFtZShidWlsdGluUGxhY2VtZW50cywgcHJlZml4Q2xzLCBhbGlnbiwgYWxpZ25Qb2ludDIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ24pIHtcbiAgICAgICAgICBjbGFzc05hbWUucHVzaChnZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbihhbGlnbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc05hbWUuam9pbihcIiBcIik7XG4gICAgICB9O1xuICAgICAgX3RoaXMuZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcywgcHJlZml4Q2xzID0gX3RoaXMkcHJvcHMyLnByZWZpeENscywgZGVzdHJveVBvcHVwT25IaWRlID0gX3RoaXMkcHJvcHMyLmRlc3Ryb3lQb3B1cE9uSGlkZSwgcG9wdXBDbGFzc05hbWUgPSBfdGhpcyRwcm9wczIucG9wdXBDbGFzc05hbWUsIG9uUG9wdXBBbGlnbiA9IF90aGlzJHByb3BzMi5vblBvcHVwQWxpZ24sIHBvcHVwTW90aW9uID0gX3RoaXMkcHJvcHMyLnBvcHVwTW90aW9uLCBwb3B1cEFuaW1hdGlvbiA9IF90aGlzJHByb3BzMi5wb3B1cEFuaW1hdGlvbiwgcG9wdXBUcmFuc2l0aW9uTmFtZSA9IF90aGlzJHByb3BzMi5wb3B1cFRyYW5zaXRpb25OYW1lLCBwb3B1cFN0eWxlID0gX3RoaXMkcHJvcHMyLnBvcHVwU3R5bGUsIG1hc2sgPSBfdGhpcyRwcm9wczIubWFzaywgbWFza0FuaW1hdGlvbiA9IF90aGlzJHByb3BzMi5tYXNrQW5pbWF0aW9uLCBtYXNrVHJhbnNpdGlvbk5hbWUgPSBfdGhpcyRwcm9wczIubWFza1RyYW5zaXRpb25OYW1lLCBtYXNrTW90aW9uID0gX3RoaXMkcHJvcHMyLm1hc2tNb3Rpb24sIHpJbmRleCA9IF90aGlzJHByb3BzMi56SW5kZXgsIHBvcHVwID0gX3RoaXMkcHJvcHMyLnBvcHVwLCBzdHJldGNoID0gX3RoaXMkcHJvcHMyLnN0cmV0Y2gsIGFsaWduUG9pbnQyID0gX3RoaXMkcHJvcHMyLmFsaWduUG9pbnQsIG1vYmlsZSA9IF90aGlzJHByb3BzMi5tb2JpbGUsIGZvcmNlUmVuZGVyID0gX3RoaXMkcHJvcHMyLmZvcmNlUmVuZGVyO1xuICAgICAgICB2YXIgX3RoaXMkc3RhdGUgPSBfdGhpcy5zdGF0ZSwgcG9wdXBWaXNpYmxlID0gX3RoaXMkc3RhdGUucG9wdXBWaXNpYmxlLCBwb2ludCA9IF90aGlzJHN0YXRlLnBvaW50O1xuICAgICAgICB2YXIgYWxpZ24gPSBfdGhpcy5nZXRQb3B1cEFsaWduKCk7XG4gICAgICAgIHZhciBtb3VzZVByb3BzID0ge307XG4gICAgICAgIGlmIChfdGhpcy5pc01vdXNlRW50ZXJUb1Nob3coKSkge1xuICAgICAgICAgIG1vdXNlUHJvcHMub25Nb3VzZUVudGVyID0gX3RoaXMub25Qb3B1cE1vdXNlRW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzLmlzTW91c2VMZWF2ZVRvSGlkZSgpKSB7XG4gICAgICAgICAgbW91c2VQcm9wcy5vbk1vdXNlTGVhdmUgPSBfdGhpcy5vblBvcHVwTW91c2VMZWF2ZTtcbiAgICAgICAgfVxuICAgICAgICBtb3VzZVByb3BzLm9uTW91c2VEb3duID0gX3RoaXMub25Qb3B1cE1vdXNlRG93bjtcbiAgICAgICAgbW91c2VQcm9wcy5vblRvdWNoU3RhcnQgPSBfdGhpcy5vblBvcHVwTW91c2VEb3duO1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUG9wdXAsIF9leHRlbmRzJDEoe1xuICAgICAgICAgIHByZWZpeENscyxcbiAgICAgICAgICBkZXN0cm95UG9wdXBPbkhpZGUsXG4gICAgICAgICAgdmlzaWJsZTogcG9wdXBWaXNpYmxlLFxuICAgICAgICAgIHBvaW50OiBhbGlnblBvaW50MiAmJiBwb2ludCxcbiAgICAgICAgICBjbGFzc05hbWU6IHBvcHVwQ2xhc3NOYW1lLFxuICAgICAgICAgIGFsaWduLFxuICAgICAgICAgIG9uQWxpZ246IG9uUG9wdXBBbGlnbixcbiAgICAgICAgICBhbmltYXRpb246IHBvcHVwQW5pbWF0aW9uLFxuICAgICAgICAgIGdldENsYXNzTmFtZUZyb21BbGlnbjogX3RoaXMuZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ25cbiAgICAgICAgfSwgbW91c2VQcm9wcywge1xuICAgICAgICAgIHN0cmV0Y2gsXG4gICAgICAgICAgZ2V0Um9vdERvbU5vZGU6IF90aGlzLmdldFJvb3REb21Ob2RlLFxuICAgICAgICAgIHN0eWxlOiBwb3B1cFN0eWxlLFxuICAgICAgICAgIG1hc2ssXG4gICAgICAgICAgekluZGV4LFxuICAgICAgICAgIHRyYW5zaXRpb25OYW1lOiBwb3B1cFRyYW5zaXRpb25OYW1lLFxuICAgICAgICAgIG1hc2tBbmltYXRpb24sXG4gICAgICAgICAgbWFza1RyYW5zaXRpb25OYW1lLFxuICAgICAgICAgIG1hc2tNb3Rpb24sXG4gICAgICAgICAgcmVmOiBfdGhpcy5wb3B1cFJlZixcbiAgICAgICAgICBtb3Rpb246IHBvcHVwTW90aW9uLFxuICAgICAgICAgIG1vYmlsZSxcbiAgICAgICAgICBmb3JjZVJlbmRlclxuICAgICAgICB9KSwgdHlwZW9mIHBvcHVwID09PSBcImZ1bmN0aW9uXCIgPyBwb3B1cCgpIDogcG9wdXApO1xuICAgICAgfTtcbiAgICAgIF90aGlzLmF0dGFjaFBhcmVudCA9IGZ1bmN0aW9uKHBvcHVwQ29udGFpbmVyKSB7XG4gICAgICAgIHdyYXBwZXJSYWYkMS5jYW5jZWwoX3RoaXMuYXR0YWNoSWQpO1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHMzID0gX3RoaXMucHJvcHMsIGdldFBvcHVwQ29udGFpbmVyID0gX3RoaXMkcHJvcHMzLmdldFBvcHVwQ29udGFpbmVyLCBnZXREb2N1bWVudDIgPSBfdGhpcyRwcm9wczMuZ2V0RG9jdW1lbnQ7XG4gICAgICAgIHZhciBkb21Ob2RlID0gX3RoaXMuZ2V0Um9vdERvbU5vZGUoKTtcbiAgICAgICAgdmFyIG1vdW50Tm9kZTtcbiAgICAgICAgaWYgKCFnZXRQb3B1cENvbnRhaW5lcikge1xuICAgICAgICAgIG1vdW50Tm9kZSA9IGdldERvY3VtZW50MihfdGhpcy5nZXRSb290RG9tTm9kZSgpKS5ib2R5O1xuICAgICAgICB9IGVsc2UgaWYgKGRvbU5vZGUgfHwgZ2V0UG9wdXBDb250YWluZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgbW91bnROb2RlID0gZ2V0UG9wdXBDb250YWluZXIoZG9tTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdW50Tm9kZSkge1xuICAgICAgICAgIG1vdW50Tm9kZS5hcHBlbmRDaGlsZChwb3B1cENvbnRhaW5lcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuYXR0YWNoSWQgPSB3cmFwcGVyUmFmJDEoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfdGhpcy5hdHRhY2hQYXJlbnQocG9wdXBDb250YWluZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX3RoaXMuZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnZXREb2N1bWVudDIgPSBfdGhpcy5wcm9wcy5nZXREb2N1bWVudDtcbiAgICAgICAgdmFyIHBvcHVwQ29udGFpbmVyID0gZ2V0RG9jdW1lbnQyKF90aGlzLmdldFJvb3REb21Ob2RlKCkpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHBvcHVwQ29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBwb3B1cENvbnRhaW5lci5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgICAgcG9wdXBDb250YWluZXIuc3R5bGUubGVmdCA9IFwiMFwiO1xuICAgICAgICBwb3B1cENvbnRhaW5lci5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICBfdGhpcy5hdHRhY2hQYXJlbnQocG9wdXBDb250YWluZXIpO1xuICAgICAgICByZXR1cm4gcG9wdXBDb250YWluZXI7XG4gICAgICB9O1xuICAgICAgX3RoaXMuc2V0UG9pbnQgPSBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB2YXIgYWxpZ25Qb2ludDIgPSBfdGhpcy5wcm9wcy5hbGlnblBvaW50O1xuICAgICAgICBpZiAoIWFsaWduUG9pbnQyIHx8ICFwb2ludClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBwb2ludDoge1xuICAgICAgICAgICAgcGFnZVg6IHBvaW50LnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IHBvaW50LnBhZ2VZXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBfdGhpcy5oYW5kbGVQb3J0YWxVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKF90aGlzLnN0YXRlLnByZXZQb3B1cFZpc2libGUgIT09IF90aGlzLnN0YXRlLnBvcHVwVmlzaWJsZSkge1xuICAgICAgICAgIF90aGlzLnByb3BzLmFmdGVyUG9wdXBWaXNpYmxlQ2hhbmdlKF90aGlzLnN0YXRlLnBvcHVwVmlzaWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfdGhpcy50cmlnZ2VyQ29udGV4dFZhbHVlID0ge1xuICAgICAgICBvblBvcHVwTW91c2VEb3duOiBfdGhpcy5vblBvcHVwTW91c2VEb3duXG4gICAgICB9O1xuICAgICAgdmFyIF9wb3B1cFZpc2libGU7XG4gICAgICBpZiAoXCJwb3B1cFZpc2libGVcIiBpbiBwcm9wcykge1xuICAgICAgICBfcG9wdXBWaXNpYmxlID0gISFwcm9wcy5wb3B1cFZpc2libGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcG9wdXBWaXNpYmxlID0gISFwcm9wcy5kZWZhdWx0UG9wdXBWaXNpYmxlO1xuICAgICAgfVxuICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgIHByZXZQb3B1cFZpc2libGU6IF9wb3B1cFZpc2libGUsXG4gICAgICAgIHBvcHVwVmlzaWJsZTogX3BvcHVwVmlzaWJsZVxuICAgICAgfTtcbiAgICAgIEFMTF9IQU5ETEVSUy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgX3RoaXNbXCJmaXJlXCIuY29uY2F0KGgpXSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgX3RoaXMuZmlyZUV2ZW50cyhoLCBlMik7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKFRyaWdnZXIzLCBbe1xuICAgICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RGlkVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlLnBvcHVwVmlzaWJsZSkge1xuICAgICAgICAgIHZhciBjdXJyZW50RG9jdW1lbnQ7XG4gICAgICAgICAgaWYgKCF0aGlzLmNsaWNrT3V0c2lkZUhhbmRsZXIgJiYgKHRoaXMuaXNDbGlja1RvSGlkZSgpIHx8IHRoaXMuaXNDb250ZXh0TWVudVRvU2hvdygpKSkge1xuICAgICAgICAgICAgY3VycmVudERvY3VtZW50ID0gcHJvcHMuZ2V0RG9jdW1lbnQodGhpcy5nZXRSb290RG9tTm9kZSgpKTtcbiAgICAgICAgICAgIHRoaXMuY2xpY2tPdXRzaWRlSGFuZGxlciA9IGFkZEV2ZW50TGlzdGVuZXJXcmFwKGN1cnJlbnREb2N1bWVudCwgXCJtb3VzZWRvd25cIiwgdGhpcy5vbkRvY3VtZW50Q2xpY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMudG91Y2hPdXRzaWRlSGFuZGxlcikge1xuICAgICAgICAgICAgY3VycmVudERvY3VtZW50ID0gY3VycmVudERvY3VtZW50IHx8IHByb3BzLmdldERvY3VtZW50KHRoaXMuZ2V0Um9vdERvbU5vZGUoKSk7XG4gICAgICAgICAgICB0aGlzLnRvdWNoT3V0c2lkZUhhbmRsZXIgPSBhZGRFdmVudExpc3RlbmVyV3JhcChjdXJyZW50RG9jdW1lbnQsIFwidG91Y2hzdGFydFwiLCB0aGlzLm9uRG9jdW1lbnRDbGljayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0TWVudU91dHNpZGVIYW5kbGVyMSAmJiB0aGlzLmlzQ29udGV4dE1lbnVUb1Nob3coKSkge1xuICAgICAgICAgICAgY3VycmVudERvY3VtZW50ID0gY3VycmVudERvY3VtZW50IHx8IHByb3BzLmdldERvY3VtZW50KHRoaXMuZ2V0Um9vdERvbU5vZGUoKSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRNZW51T3V0c2lkZUhhbmRsZXIxID0gYWRkRXZlbnRMaXN0ZW5lcldyYXAoY3VycmVudERvY3VtZW50LCBcInNjcm9sbFwiLCB0aGlzLm9uQ29udGV4dE1lbnVDbG9zZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0TWVudU91dHNpZGVIYW5kbGVyMiAmJiB0aGlzLmlzQ29udGV4dE1lbnVUb1Nob3coKSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0TWVudU91dHNpZGVIYW5kbGVyMiA9IGFkZEV2ZW50TGlzdGVuZXJXcmFwKHdpbmRvdywgXCJibHVyXCIsIHRoaXMub25Db250ZXh0TWVudUNsb3NlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJPdXRzaWRlSGFuZGxlcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmNsZWFyRGVsYXlUaW1lcigpO1xuICAgICAgICB0aGlzLmNsZWFyT3V0c2lkZUhhbmRsZXIoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XG4gICAgICAgIHdyYXBwZXJSYWYkMS5jYW5jZWwodGhpcy5hdHRhY2hJZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFBvcHVwRG9tTm9kZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvcHVwRG9tTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzJHBvcHVwUmVmJGN1cnJlbjI7XG4gICAgICAgIHJldHVybiAoKF90aGlzJHBvcHVwUmVmJGN1cnJlbjIgPSB0aGlzLnBvcHVwUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF90aGlzJHBvcHVwUmVmJGN1cnJlbjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHBvcHVwUmVmJGN1cnJlbjIuZ2V0RWxlbWVudCgpKSB8fCBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRQb3B1cEFsaWduXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9wdXBBbGlnbigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIHBvcHVwUGxhY2VtZW50ID0gcHJvcHMucG9wdXBQbGFjZW1lbnQsIHBvcHVwQWxpZ24gPSBwcm9wcy5wb3B1cEFsaWduLCBidWlsdGluUGxhY2VtZW50cyA9IHByb3BzLmJ1aWx0aW5QbGFjZW1lbnRzO1xuICAgICAgICBpZiAocG9wdXBQbGFjZW1lbnQgJiYgYnVpbHRpblBsYWNlbWVudHMpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0QWxpZ25Gcm9tUGxhY2VtZW50KGJ1aWx0aW5QbGFjZW1lbnRzLCBwb3B1cFBsYWNlbWVudCwgcG9wdXBBbGlnbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcHVwQWxpZ247XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFBvcHVwVmlzaWJsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvcHVwVmlzaWJsZShwb3B1cFZpc2libGUsIGV2ZW50KSB7XG4gICAgICAgIHZhciBhbGlnblBvaW50MiA9IHRoaXMucHJvcHMuYWxpZ25Qb2ludDtcbiAgICAgICAgdmFyIHByZXZQb3B1cFZpc2libGUgPSB0aGlzLnN0YXRlLnBvcHVwVmlzaWJsZTtcbiAgICAgICAgdGhpcy5jbGVhckRlbGF5VGltZXIoKTtcbiAgICAgICAgaWYgKHByZXZQb3B1cFZpc2libGUgIT09IHBvcHVwVmlzaWJsZSkge1xuICAgICAgICAgIGlmICghKFwicG9wdXBWaXNpYmxlXCIgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICBwb3B1cFZpc2libGUsXG4gICAgICAgICAgICAgIHByZXZQb3B1cFZpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnByb3BzLm9uUG9wdXBWaXNpYmxlQ2hhbmdlKHBvcHVwVmlzaWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsaWduUG9pbnQyICYmIGV2ZW50ICYmIHBvcHVwVmlzaWJsZSkge1xuICAgICAgICAgIHRoaXMuc2V0UG9pbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlbGF5U2V0UG9wdXBWaXNpYmxlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsYXlTZXRQb3B1cFZpc2libGUodmlzaWJsZSwgZGVsYXlTLCBldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgICAgdmFyIGRlbGF5ID0gZGVsYXlTICogMWUzO1xuICAgICAgICB0aGlzLmNsZWFyRGVsYXlUaW1lcigpO1xuICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSBldmVudCA/IHtcbiAgICAgICAgICAgIHBhZ2VYOiBldmVudC5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBldmVudC5wYWdlWVxuICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICAgIHRoaXMuZGVsYXlUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX3RoaXMyLnNldFBvcHVwVmlzaWJsZSh2aXNpYmxlLCBwb2ludCk7XG4gICAgICAgICAgICBfdGhpczIuY2xlYXJEZWxheVRpbWVyKCk7XG4gICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0UG9wdXBWaXNpYmxlKHZpc2libGUsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbGVhckRlbGF5VGltZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckRlbGF5VGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGF5VGltZXIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVyKTtcbiAgICAgICAgICB0aGlzLmRlbGF5VGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsZWFyT3V0c2lkZUhhbmRsZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhck91dHNpZGVIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5jbGlja091dHNpZGVIYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5jbGlja091dHNpZGVIYW5kbGVyLnJlbW92ZSgpO1xuICAgICAgICAgIHRoaXMuY2xpY2tPdXRzaWRlSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dE1lbnVPdXRzaWRlSGFuZGxlcjEpIHtcbiAgICAgICAgICB0aGlzLmNvbnRleHRNZW51T3V0c2lkZUhhbmRsZXIxLnJlbW92ZSgpO1xuICAgICAgICAgIHRoaXMuY29udGV4dE1lbnVPdXRzaWRlSGFuZGxlcjEgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRNZW51T3V0c2lkZUhhbmRsZXIyKSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0TWVudU91dHNpZGVIYW5kbGVyMi5yZW1vdmUoKTtcbiAgICAgICAgICB0aGlzLmNvbnRleHRNZW51T3V0c2lkZUhhbmRsZXIyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50b3VjaE91dHNpZGVIYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy50b3VjaE91dHNpZGVIYW5kbGVyLnJlbW92ZSgpO1xuICAgICAgICAgIHRoaXMudG91Y2hPdXRzaWRlSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY3JlYXRlVHdvQ2hhaW5zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVHdvQ2hhaW5zKGV2ZW50KSB7XG4gICAgICAgIHZhciBjaGlsZFByb3MgPSB0aGlzLnByb3BzLmNoaWxkcmVuLnByb3BzO1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAoY2hpbGRQcm9zW2V2ZW50XSAmJiBwcm9wc1tldmVudF0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpc1tcImZpcmVcIi5jb25jYXQoZXZlbnQpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRQcm9zW2V2ZW50XSB8fCBwcm9wc1tldmVudF07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImlzQ2xpY2tUb1Nob3dcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0NsaWNrVG9TaG93KCkge1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcywgYWN0aW9uID0gX3RoaXMkcHJvcHM0LmFjdGlvbiwgc2hvd0FjdGlvbiA9IF90aGlzJHByb3BzNC5zaG93QWN0aW9uO1xuICAgICAgICByZXR1cm4gYWN0aW9uLmluZGV4T2YoXCJjbGlja1wiKSAhPT0gLTEgfHwgc2hvd0FjdGlvbi5pbmRleE9mKFwiY2xpY2tcIikgIT09IC0xO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpc0NvbnRleHRNZW51T25seVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzQ29udGV4dE1lbnVPbmx5KCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5wcm9wcy5hY3Rpb247XG4gICAgICAgIHJldHVybiBhY3Rpb24gPT09IFwiY29udGV4dE1lbnVcIiB8fCBhY3Rpb24ubGVuZ3RoID09PSAxICYmIGFjdGlvblswXSA9PT0gXCJjb250ZXh0TWVudVwiO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpc0NvbnRleHRNZW51VG9TaG93XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNDb250ZXh0TWVudVRvU2hvdygpIHtcbiAgICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsIGFjdGlvbiA9IF90aGlzJHByb3BzNS5hY3Rpb24sIHNob3dBY3Rpb24gPSBfdGhpcyRwcm9wczUuc2hvd0FjdGlvbjtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5pbmRleE9mKFwiY29udGV4dE1lbnVcIikgIT09IC0xIHx8IHNob3dBY3Rpb24uaW5kZXhPZihcImNvbnRleHRNZW51XCIpICE9PSAtMTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNDbGlja1RvSGlkZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzQ2xpY2tUb0hpZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wczYgPSB0aGlzLnByb3BzLCBhY3Rpb24gPSBfdGhpcyRwcm9wczYuYWN0aW9uLCBoaWRlQWN0aW9uID0gX3RoaXMkcHJvcHM2LmhpZGVBY3Rpb247XG4gICAgICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZihcImNsaWNrXCIpICE9PSAtMSB8fCBoaWRlQWN0aW9uLmluZGV4T2YoXCJjbGlja1wiKSAhPT0gLTE7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImlzTW91c2VFbnRlclRvU2hvd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzTW91c2VFbnRlclRvU2hvdygpIHtcbiAgICAgICAgdmFyIF90aGlzJHByb3BzNyA9IHRoaXMucHJvcHMsIGFjdGlvbiA9IF90aGlzJHByb3BzNy5hY3Rpb24sIHNob3dBY3Rpb24gPSBfdGhpcyRwcm9wczcuc2hvd0FjdGlvbjtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5pbmRleE9mKFwiaG92ZXJcIikgIT09IC0xIHx8IHNob3dBY3Rpb24uaW5kZXhPZihcIm1vdXNlRW50ZXJcIikgIT09IC0xO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpc01vdXNlTGVhdmVUb0hpZGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc01vdXNlTGVhdmVUb0hpZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wczggPSB0aGlzLnByb3BzLCBhY3Rpb24gPSBfdGhpcyRwcm9wczguYWN0aW9uLCBoaWRlQWN0aW9uID0gX3RoaXMkcHJvcHM4LmhpZGVBY3Rpb247XG4gICAgICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZihcImhvdmVyXCIpICE9PSAtMSB8fCBoaWRlQWN0aW9uLmluZGV4T2YoXCJtb3VzZUxlYXZlXCIpICE9PSAtMTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNGb2N1c1RvU2hvd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRm9jdXNUb1Nob3coKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wczkgPSB0aGlzLnByb3BzLCBhY3Rpb24gPSBfdGhpcyRwcm9wczkuYWN0aW9uLCBzaG93QWN0aW9uID0gX3RoaXMkcHJvcHM5LnNob3dBY3Rpb247XG4gICAgICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZihcImZvY3VzXCIpICE9PSAtMSB8fCBzaG93QWN0aW9uLmluZGV4T2YoXCJmb2N1c1wiKSAhPT0gLTE7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImlzQmx1clRvSGlkZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzQmx1clRvSGlkZSgpIHtcbiAgICAgICAgdmFyIF90aGlzJHByb3BzMTAgPSB0aGlzLnByb3BzLCBhY3Rpb24gPSBfdGhpcyRwcm9wczEwLmFjdGlvbiwgaGlkZUFjdGlvbiA9IF90aGlzJHByb3BzMTAuaGlkZUFjdGlvbjtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5pbmRleE9mKFwiZm9jdXNcIikgIT09IC0xIHx8IGhpZGVBY3Rpb24uaW5kZXhPZihcImJsdXJcIikgIT09IC0xO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmb3JjZVBvcHVwQWxpZ25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JjZVBvcHVwQWxpZ24oKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnBvcHVwVmlzaWJsZSkge1xuICAgICAgICAgIHZhciBfdGhpcyRwb3B1cFJlZiRjdXJyZW4zO1xuICAgICAgICAgIChfdGhpcyRwb3B1cFJlZiRjdXJyZW4zID0gdGhpcy5wb3B1cFJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfdGhpcyRwb3B1cFJlZiRjdXJyZW4zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwb3B1cFJlZiRjdXJyZW4zLmZvcmNlQWxpZ24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmaXJlRXZlbnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmlyZUV2ZW50cyh0eXBlNCwgZTIpIHtcbiAgICAgICAgdmFyIGNoaWxkQ2FsbGJhY2sgPSB0aGlzLnByb3BzLmNoaWxkcmVuLnByb3BzW3R5cGU0XTtcbiAgICAgICAgaWYgKGNoaWxkQ2FsbGJhY2spIHtcbiAgICAgICAgICBjaGlsZENhbGxiYWNrKGUyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLnByb3BzW3R5cGU0XTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb3NlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UyKCkge1xuICAgICAgICB0aGlzLnNldFBvcHVwVmlzaWJsZShmYWxzZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHBvcHVwVmlzaWJsZSA9IHRoaXMuc3RhdGUucG9wdXBWaXNpYmxlO1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHMxMSA9IHRoaXMucHJvcHMsIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMxMS5jaGlsZHJlbiwgZm9yY2VSZW5kZXIgPSBfdGhpcyRwcm9wczExLmZvcmNlUmVuZGVyLCBhbGlnblBvaW50MiA9IF90aGlzJHByb3BzMTEuYWxpZ25Qb2ludCwgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMxMS5jbGFzc05hbWUsIGF1dG9EZXN0cm95ID0gX3RoaXMkcHJvcHMxMS5hdXRvRGVzdHJveTtcbiAgICAgICAgdmFyIGNoaWxkID0gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgIHZhciBuZXdDaGlsZFByb3BzID0ge1xuICAgICAgICAgIGtleTogXCJ0cmlnZ2VyXCJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuaXNDb250ZXh0TWVudVRvU2hvdygpKSB7XG4gICAgICAgICAgbmV3Q2hpbGRQcm9wcy5vbkNvbnRleHRNZW51ID0gdGhpcy5vbkNvbnRleHRNZW51O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0NoaWxkUHJvcHMub25Db250ZXh0TWVudSA9IHRoaXMuY3JlYXRlVHdvQ2hhaW5zKFwib25Db250ZXh0TWVudVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0NsaWNrVG9IaWRlKCkgfHwgdGhpcy5pc0NsaWNrVG9TaG93KCkpIHtcbiAgICAgICAgICBuZXdDaGlsZFByb3BzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2s7XG4gICAgICAgICAgbmV3Q2hpbGRQcm9wcy5vbk1vdXNlRG93biA9IHRoaXMub25Nb3VzZURvd247XG4gICAgICAgICAgbmV3Q2hpbGRQcm9wcy5vblRvdWNoU3RhcnQgPSB0aGlzLm9uVG91Y2hTdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdDaGlsZFByb3BzLm9uQ2xpY2sgPSB0aGlzLmNyZWF0ZVR3b0NoYWlucyhcIm9uQ2xpY2tcIik7XG4gICAgICAgICAgbmV3Q2hpbGRQcm9wcy5vbk1vdXNlRG93biA9IHRoaXMuY3JlYXRlVHdvQ2hhaW5zKFwib25Nb3VzZURvd25cIik7XG4gICAgICAgICAgbmV3Q2hpbGRQcm9wcy5vblRvdWNoU3RhcnQgPSB0aGlzLmNyZWF0ZVR3b0NoYWlucyhcIm9uVG91Y2hTdGFydFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc01vdXNlRW50ZXJUb1Nob3coKSkge1xuICAgICAgICAgIG5ld0NoaWxkUHJvcHMub25Nb3VzZUVudGVyID0gdGhpcy5vbk1vdXNlRW50ZXI7XG4gICAgICAgICAgaWYgKGFsaWduUG9pbnQyKSB7XG4gICAgICAgICAgICBuZXdDaGlsZFByb3BzLm9uTW91c2VNb3ZlID0gdGhpcy5vbk1vdXNlTW92ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Q2hpbGRQcm9wcy5vbk1vdXNlRW50ZXIgPSB0aGlzLmNyZWF0ZVR3b0NoYWlucyhcIm9uTW91c2VFbnRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc01vdXNlTGVhdmVUb0hpZGUoKSkge1xuICAgICAgICAgIG5ld0NoaWxkUHJvcHMub25Nb3VzZUxlYXZlID0gdGhpcy5vbk1vdXNlTGVhdmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Q2hpbGRQcm9wcy5vbk1vdXNlTGVhdmUgPSB0aGlzLmNyZWF0ZVR3b0NoYWlucyhcIm9uTW91c2VMZWF2ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0ZvY3VzVG9TaG93KCkgfHwgdGhpcy5pc0JsdXJUb0hpZGUoKSkge1xuICAgICAgICAgIG5ld0NoaWxkUHJvcHMub25Gb2N1cyA9IHRoaXMub25Gb2N1cztcbiAgICAgICAgICBuZXdDaGlsZFByb3BzLm9uQmx1ciA9IHRoaXMub25CbHVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0NoaWxkUHJvcHMub25Gb2N1cyA9IHRoaXMuY3JlYXRlVHdvQ2hhaW5zKFwib25Gb2N1c1wiKTtcbiAgICAgICAgICBuZXdDaGlsZFByb3BzLm9uQmx1ciA9IHRoaXMuY3JlYXRlVHdvQ2hhaW5zKFwib25CbHVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGlsZHJlbkNsYXNzTmFtZSA9IGNsYXNzTmFtZXMoY2hpbGQgJiYgY2hpbGQucHJvcHMgJiYgY2hpbGQucHJvcHMuY2xhc3NOYW1lLCBjbGFzc05hbWUpO1xuICAgICAgICBpZiAoY2hpbGRyZW5DbGFzc05hbWUpIHtcbiAgICAgICAgICBuZXdDaGlsZFByb3BzLmNsYXNzTmFtZSA9IGNoaWxkcmVuQ2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbG9uZVByb3BzID0gX29iamVjdFNwcmVhZDIkMSh7fSwgbmV3Q2hpbGRQcm9wcyk7XG4gICAgICAgIGlmIChzdXBwb3J0UmVmKGNoaWxkKSkge1xuICAgICAgICAgIGNsb25lUHJvcHMucmVmID0gY29tcG9zZVJlZih0aGlzLnRyaWdnZXJSZWYsIGNoaWxkLnJlZik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyaWdnZXIgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBjbG9uZVByb3BzKTtcbiAgICAgICAgdmFyIHBvcnRhbDtcbiAgICAgICAgaWYgKHBvcHVwVmlzaWJsZSB8fCB0aGlzLnBvcHVwUmVmLmN1cnJlbnQgfHwgZm9yY2VSZW5kZXIpIHtcbiAgICAgICAgICBwb3J0YWwgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChQb3J0YWxDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGtleTogXCJwb3J0YWxcIixcbiAgICAgICAgICAgIGdldENvbnRhaW5lcjogdGhpcy5nZXRDb250YWluZXIsXG4gICAgICAgICAgICBkaWRVcGRhdGU6IHRoaXMuaGFuZGxlUG9ydGFsVXBkYXRlXG4gICAgICAgICAgfSwgdGhpcy5nZXRDb21wb25lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwb3B1cFZpc2libGUgJiYgYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgICBwb3J0YWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChUcmlnZ2VyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgIHZhbHVlOiB0aGlzLnRyaWdnZXJDb250ZXh0VmFsdWVcbiAgICAgICAgfSwgdHJpZ2dlciwgcG9ydGFsKTtcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoX3JlZiwgcHJldlN0YXRlKSB7XG4gICAgICAgIHZhciBwb3B1cFZpc2libGUgPSBfcmVmLnBvcHVwVmlzaWJsZTtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0ge307XG4gICAgICAgIGlmIChwb3B1cFZpc2libGUgIT09IHZvaWQgMCAmJiBwcmV2U3RhdGUucG9wdXBWaXNpYmxlICE9PSBwb3B1cFZpc2libGUpIHtcbiAgICAgICAgICBuZXdTdGF0ZS5wb3B1cFZpc2libGUgPSBwb3B1cFZpc2libGU7XG4gICAgICAgICAgbmV3U3RhdGUucHJldlBvcHVwVmlzaWJsZSA9IHByZXZTdGF0ZS5wb3B1cFZpc2libGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gVHJpZ2dlcjM7XG4gIH0oUmVhY3QuQ29tcG9uZW50KTtcbiAgVHJpZ2dlcjIuY29udGV4dFR5cGUgPSBUcmlnZ2VyQ29udGV4dDtcbiAgVHJpZ2dlcjIuZGVmYXVsdFByb3BzID0ge1xuICAgIHByZWZpeENsczogXCJyYy10cmlnZ2VyLXBvcHVwXCIsXG4gICAgZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ246IHJldHVybkVtcHR5U3RyaW5nLFxuICAgIGdldERvY3VtZW50OiByZXR1cm5Eb2N1bWVudCxcbiAgICBvblBvcHVwVmlzaWJsZUNoYW5nZTogbm9vcCxcbiAgICBhZnRlclBvcHVwVmlzaWJsZUNoYW5nZTogbm9vcCxcbiAgICBvblBvcHVwQWxpZ246IG5vb3AsXG4gICAgcG9wdXBDbGFzc05hbWU6IFwiXCIsXG4gICAgbW91c2VFbnRlckRlbGF5OiAwLFxuICAgIG1vdXNlTGVhdmVEZWxheTogMC4xLFxuICAgIGZvY3VzRGVsYXk6IDAsXG4gICAgYmx1ckRlbGF5OiAwLjE1LFxuICAgIHBvcHVwU3R5bGU6IHt9LFxuICAgIGRlc3Ryb3lQb3B1cE9uSGlkZTogZmFsc2UsXG4gICAgcG9wdXBBbGlnbjoge30sXG4gICAgZGVmYXVsdFBvcHVwVmlzaWJsZTogZmFsc2UsXG4gICAgbWFzazogZmFsc2UsXG4gICAgbWFza0Nsb3NhYmxlOiB0cnVlLFxuICAgIGFjdGlvbjogW10sXG4gICAgc2hvd0FjdGlvbjogW10sXG4gICAgaGlkZUFjdGlvbjogW10sXG4gICAgYXV0b0Rlc3Ryb3k6IGZhbHNlXG4gIH07XG4gIHJldHVybiBUcmlnZ2VyMjtcbn1cbnZhciBUcmlnZ2VyID0gZ2VuZXJhdGVUcmlnZ2VyKFBvcnRhbCk7XG52YXIgYXV0b0FkanVzdE92ZXJmbG93ID0ge1xuICBhZGp1c3RYOiAxLFxuICBhZGp1c3RZOiAxXG59O1xudmFyIHRhcmdldE9mZnNldCQxID0gWzAsIDBdO1xudmFyIHBsYWNlbWVudHMgPSB7XG4gIGxlZnQ6IHtcbiAgICBwb2ludHM6IFtcImNyXCIsIFwiY2xcIl0sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFstNCwgMF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXQkMVxuICB9LFxuICByaWdodDoge1xuICAgIHBvaW50czogW1wiY2xcIiwgXCJjclwiXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzQsIDBdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0JDFcbiAgfSxcbiAgdG9wOiB7XG4gICAgcG9pbnRzOiBbXCJiY1wiLCBcInRjXCJdLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgLTRdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0JDFcbiAgfSxcbiAgYm90dG9tOiB7XG4gICAgcG9pbnRzOiBbXCJ0Y1wiLCBcImJjXCJdLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgNF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXQkMVxuICB9LFxuICB0b3BMZWZ0OiB7XG4gICAgcG9pbnRzOiBbXCJibFwiLCBcInRsXCJdLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgLTRdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0JDFcbiAgfSxcbiAgbGVmdFRvcDoge1xuICAgIHBvaW50czogW1widHJcIiwgXCJ0bFwiXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWy00LCAwXSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldCQxXG4gIH0sXG4gIHRvcFJpZ2h0OiB7XG4gICAgcG9pbnRzOiBbXCJiclwiLCBcInRyXCJdLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgLTRdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0JDFcbiAgfSxcbiAgcmlnaHRUb3A6IHtcbiAgICBwb2ludHM6IFtcInRsXCIsIFwidHJcIl0sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFs0LCAwXSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldCQxXG4gIH0sXG4gIGJvdHRvbVJpZ2h0OiB7XG4gICAgcG9pbnRzOiBbXCJ0clwiLCBcImJyXCJdLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgNF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXQkMVxuICB9LFxuICByaWdodEJvdHRvbToge1xuICAgIHBvaW50czogW1wiYmxcIiwgXCJiclwiXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzQsIDBdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0JDFcbiAgfSxcbiAgYm90dG9tTGVmdDoge1xuICAgIHBvaW50czogW1widGxcIiwgXCJibFwiXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzAsIDRdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0JDFcbiAgfSxcbiAgbGVmdEJvdHRvbToge1xuICAgIHBvaW50czogW1wiYnJcIiwgXCJibFwiXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWy00LCAwXSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldCQxXG4gIH1cbn07XG52YXIgQ29udGVudCA9IGZ1bmN0aW9uIENvbnRlbnQyKHByb3BzKSB7XG4gIHZhciBvdmVybGF5ID0gcHJvcHMub3ZlcmxheSwgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzLCBpZDIgPSBwcm9wcy5pZCwgb3ZlcmxheUlubmVyU3R5bGUgPSBwcm9wcy5vdmVybGF5SW5uZXJTdHlsZTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItaW5uZXJcIiksXG4gICAgaWQ6IGlkMixcbiAgICByb2xlOiBcInRvb2x0aXBcIixcbiAgICBzdHlsZTogb3ZlcmxheUlubmVyU3R5bGVcbiAgfSwgdHlwZW9mIG92ZXJsYXkgPT09IFwiZnVuY3Rpb25cIiA/IG92ZXJsYXkoKSA6IG92ZXJsYXkpO1xufTtcbnZhciBUb29sdGlwJDIgPSBmdW5jdGlvbiBUb29sdGlwKHByb3BzLCByZWYpIHtcbiAgdmFyIG92ZXJsYXlDbGFzc05hbWUgPSBwcm9wcy5vdmVybGF5Q2xhc3NOYW1lLCBfcHJvcHMkdHJpZ2dlciA9IHByb3BzLnRyaWdnZXIsIHRyaWdnZXIgPSBfcHJvcHMkdHJpZ2dlciA9PT0gdm9pZCAwID8gW1wiaG92ZXJcIl0gOiBfcHJvcHMkdHJpZ2dlciwgX3Byb3BzJG1vdXNlRW50ZXJEZWxhID0gcHJvcHMubW91c2VFbnRlckRlbGF5LCBtb3VzZUVudGVyRGVsYXkgPSBfcHJvcHMkbW91c2VFbnRlckRlbGEgPT09IHZvaWQgMCA/IDAgOiBfcHJvcHMkbW91c2VFbnRlckRlbGEsIF9wcm9wcyRtb3VzZUxlYXZlRGVsYSA9IHByb3BzLm1vdXNlTGVhdmVEZWxheSwgbW91c2VMZWF2ZURlbGF5ID0gX3Byb3BzJG1vdXNlTGVhdmVEZWxhID09PSB2b2lkIDAgPyAwLjEgOiBfcHJvcHMkbW91c2VMZWF2ZURlbGEsIG92ZXJsYXlTdHlsZSA9IHByb3BzLm92ZXJsYXlTdHlsZSwgX3Byb3BzJHByZWZpeENscyA9IHByb3BzLnByZWZpeENscywgcHJlZml4Q2xzID0gX3Byb3BzJHByZWZpeENscyA9PT0gdm9pZCAwID8gXCJyYy10b29sdGlwXCIgOiBfcHJvcHMkcHJlZml4Q2xzLCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLCBvblZpc2libGVDaGFuZ2UgPSBwcm9wcy5vblZpc2libGVDaGFuZ2UsIGFmdGVyVmlzaWJsZUNoYW5nZSA9IHByb3BzLmFmdGVyVmlzaWJsZUNoYW5nZSwgdHJhbnNpdGlvbk5hbWUyID0gcHJvcHMudHJhbnNpdGlvbk5hbWUsIGFuaW1hdGlvbiA9IHByb3BzLmFuaW1hdGlvbiwgbW90aW9uID0gcHJvcHMubW90aW9uLCBfcHJvcHMkcGxhY2VtZW50ID0gcHJvcHMucGxhY2VtZW50LCBwbGFjZW1lbnQgPSBfcHJvcHMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBcInJpZ2h0XCIgOiBfcHJvcHMkcGxhY2VtZW50LCBfcHJvcHMkYWxpZ24gPSBwcm9wcy5hbGlnbiwgYWxpZ24gPSBfcHJvcHMkYWxpZ24gPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJGFsaWduLCBfcHJvcHMkZGVzdHJveVRvb2x0aXAgPSBwcm9wcy5kZXN0cm95VG9vbHRpcE9uSGlkZSwgZGVzdHJveVRvb2x0aXBPbkhpZGUgPSBfcHJvcHMkZGVzdHJveVRvb2x0aXAgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRlc3Ryb3lUb29sdGlwLCBkZWZhdWx0VmlzaWJsZSA9IHByb3BzLmRlZmF1bHRWaXNpYmxlLCBnZXRUb29sdGlwQ29udGFpbmVyID0gcHJvcHMuZ2V0VG9vbHRpcENvbnRhaW5lciwgb3ZlcmxheUlubmVyU3R5bGUgPSBwcm9wcy5vdmVybGF5SW5uZXJTdHlsZSwgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJvdmVybGF5Q2xhc3NOYW1lXCIsIFwidHJpZ2dlclwiLCBcIm1vdXNlRW50ZXJEZWxheVwiLCBcIm1vdXNlTGVhdmVEZWxheVwiLCBcIm92ZXJsYXlTdHlsZVwiLCBcInByZWZpeENsc1wiLCBcImNoaWxkcmVuXCIsIFwib25WaXNpYmxlQ2hhbmdlXCIsIFwiYWZ0ZXJWaXNpYmxlQ2hhbmdlXCIsIFwidHJhbnNpdGlvbk5hbWVcIiwgXCJhbmltYXRpb25cIiwgXCJtb3Rpb25cIiwgXCJwbGFjZW1lbnRcIiwgXCJhbGlnblwiLCBcImRlc3Ryb3lUb29sdGlwT25IaWRlXCIsIFwiZGVmYXVsdFZpc2libGVcIiwgXCJnZXRUb29sdGlwQ29udGFpbmVyXCIsIFwib3ZlcmxheUlubmVyU3R5bGVcIl0pO1xuICB2YXIgZG9tUmVmID0gdXNlUmVmKG51bGwpO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbVJlZi5jdXJyZW50O1xuICB9KTtcbiAgdmFyIGV4dHJhUHJvcHMgPSBfb2JqZWN0U3ByZWFkMiQxKHt9LCByZXN0UHJvcHMpO1xuICBpZiAoXCJ2aXNpYmxlXCIgaW4gcHJvcHMpIHtcbiAgICBleHRyYVByb3BzLnBvcHVwVmlzaWJsZSA9IHByb3BzLnZpc2libGU7XG4gIH1cbiAgdmFyIGdldFBvcHVwRWxlbWVudCA9IGZ1bmN0aW9uIGdldFBvcHVwRWxlbWVudDIoKSB7XG4gICAgdmFyIF9wcm9wcyRhcnJvd0NvbnRlbnQgPSBwcm9wcy5hcnJvd0NvbnRlbnQsIGFycm93Q29udGVudCA9IF9wcm9wcyRhcnJvd0NvbnRlbnQgPT09IHZvaWQgMCA/IG51bGwgOiBfcHJvcHMkYXJyb3dDb250ZW50LCBvdmVybGF5ID0gcHJvcHMub3ZlcmxheSwgaWQyID0gcHJvcHMuaWQ7XG4gICAgcmV0dXJuIFsvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItYXJyb3dcIiksXG4gICAgICBrZXk6IFwiYXJyb3dcIlxuICAgIH0sIGFycm93Q29udGVudCksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRlbnQsIHtcbiAgICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgICBwcmVmaXhDbHMsXG4gICAgICBpZDogaWQyLFxuICAgICAgb3ZlcmxheSxcbiAgICAgIG92ZXJsYXlJbm5lclN0eWxlXG4gICAgfSldO1xuICB9O1xuICB2YXIgZGVzdHJveVRvb2x0aXAgPSBmYWxzZTtcbiAgdmFyIGF1dG9EZXN0cm95ID0gZmFsc2U7XG4gIGlmICh0eXBlb2YgZGVzdHJveVRvb2x0aXBPbkhpZGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgZGVzdHJveVRvb2x0aXAgPSBkZXN0cm95VG9vbHRpcE9uSGlkZTtcbiAgfSBlbHNlIGlmIChkZXN0cm95VG9vbHRpcE9uSGlkZSAmJiBfdHlwZW9mJDEoZGVzdHJveVRvb2x0aXBPbkhpZGUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgdmFyIGtlZXBQYXJlbnQgPSBkZXN0cm95VG9vbHRpcE9uSGlkZS5rZWVwUGFyZW50O1xuICAgIGRlc3Ryb3lUb29sdGlwID0ga2VlcFBhcmVudCA9PT0gdHJ1ZTtcbiAgICBhdXRvRGVzdHJveSA9IGtlZXBQYXJlbnQgPT09IGZhbHNlO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChUcmlnZ2VyLCBfZXh0ZW5kcyQxKHtcbiAgICBwb3B1cENsYXNzTmFtZTogb3ZlcmxheUNsYXNzTmFtZSxcbiAgICBwcmVmaXhDbHMsXG4gICAgcG9wdXA6IGdldFBvcHVwRWxlbWVudCxcbiAgICBhY3Rpb246IHRyaWdnZXIsXG4gICAgYnVpbHRpblBsYWNlbWVudHM6IHBsYWNlbWVudHMsXG4gICAgcG9wdXBQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICByZWY6IGRvbVJlZixcbiAgICBwb3B1cEFsaWduOiBhbGlnbixcbiAgICBnZXRQb3B1cENvbnRhaW5lcjogZ2V0VG9vbHRpcENvbnRhaW5lcixcbiAgICBvblBvcHVwVmlzaWJsZUNoYW5nZTogb25WaXNpYmxlQ2hhbmdlLFxuICAgIGFmdGVyUG9wdXBWaXNpYmxlQ2hhbmdlOiBhZnRlclZpc2libGVDaGFuZ2UsXG4gICAgcG9wdXBUcmFuc2l0aW9uTmFtZTogdHJhbnNpdGlvbk5hbWUyLFxuICAgIHBvcHVwQW5pbWF0aW9uOiBhbmltYXRpb24sXG4gICAgcG9wdXBNb3Rpb246IG1vdGlvbixcbiAgICBkZWZhdWx0UG9wdXBWaXNpYmxlOiBkZWZhdWx0VmlzaWJsZSxcbiAgICBkZXN0cm95UG9wdXBPbkhpZGU6IGRlc3Ryb3lUb29sdGlwLFxuICAgIGF1dG9EZXN0cm95LFxuICAgIG1vdXNlTGVhdmVEZWxheSxcbiAgICBwb3B1cFN0eWxlOiBvdmVybGF5U3R5bGUsXG4gICAgbW91c2VFbnRlckRlbGF5XG4gIH0sIGV4dHJhUHJvcHMpLCBjaGlsZHJlbik7XG59O1xudmFyIFRvb2x0aXAkMyA9IC8qIEBfX1BVUkVfXyAqLyBmb3J3YXJkUmVmKFRvb2x0aXAkMik7XG5mdW5jdGlvbiB1c2VDb250cm9sbGVkU3RhdGUoZGVmYXVsdFN0YXRlVmFsdWUsIG9wdGlvbikge1xuICB2YXIgX3JlZiA9IG9wdGlvbiB8fCB7fSwgZGVmYXVsdFZhbHVlID0gX3JlZi5kZWZhdWx0VmFsdWUsIHZhbHVlID0gX3JlZi52YWx1ZSwgb25DaGFuZ2UgPSBfcmVmLm9uQ2hhbmdlLCBwb3N0U3RhdGUgPSBfcmVmLnBvc3RTdGF0ZTtcbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uKCkge1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRWYWx1ZSgpIDogZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRTdGF0ZVZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0U3RhdGVWYWx1ZSgpIDogZGVmYXVsdFN0YXRlVmFsdWU7XG4gIH0pLCBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSwgaW5uZXJWYWx1ZSA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sIHNldElubmVyVmFsdWUgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuICB2YXIgbWVyZ2VkVmFsdWUgPSB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBpbm5lclZhbHVlO1xuICBpZiAocG9zdFN0YXRlKSB7XG4gICAgbWVyZ2VkVmFsdWUgPSBwb3N0U3RhdGUobWVyZ2VkVmFsdWUpO1xuICB9XG4gIHZhciBvbkNoYW5nZVJlZiA9IFJlYWN0LnVzZVJlZihvbkNoYW5nZSk7XG4gIG9uQ2hhbmdlUmVmLmN1cnJlbnQgPSBvbkNoYW5nZTtcbiAgdmFyIHRyaWdnZXJDaGFuZ2UgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgIHNldElubmVyVmFsdWUobmV3VmFsdWUpO1xuICAgIGlmIChtZXJnZWRWYWx1ZSAhPT0gbmV3VmFsdWUgJiYgb25DaGFuZ2VSZWYuY3VycmVudCkge1xuICAgICAgb25DaGFuZ2VSZWYuY3VycmVudChuZXdWYWx1ZSwgbWVyZ2VkVmFsdWUpO1xuICAgIH1cbiAgfSwgW21lcmdlZFZhbHVlLCBvbkNoYW5nZVJlZl0pO1xuICB2YXIgZmlyc3RSZW5kZXJSZWYgPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbigpIHtcbiAgICBpZiAoZmlyc3RSZW5kZXJSZWYuY3VycmVudCkge1xuICAgICAgZmlyc3RSZW5kZXJSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgc2V0SW5uZXJWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIFttZXJnZWRWYWx1ZSwgdHJpZ2dlckNoYW5nZV07XG59XG52YXIgYXV0b0FkanVzdE92ZXJmbG93RW5hYmxlZCA9IHtcbiAgYWRqdXN0WDogMSxcbiAgYWRqdXN0WTogMVxufTtcbnZhciBhdXRvQWRqdXN0T3ZlcmZsb3dEaXNhYmxlZCA9IHtcbiAgYWRqdXN0WDogMCxcbiAgYWRqdXN0WTogMFxufTtcbnZhciB0YXJnZXRPZmZzZXQgPSBbMCwgMF07XG5mdW5jdGlvbiBnZXRPdmVyZmxvd09wdGlvbnMoYXV0b0FkanVzdE92ZXJmbG93Mikge1xuICBpZiAodHlwZW9mIGF1dG9BZGp1c3RPdmVyZmxvdzIgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIGF1dG9BZGp1c3RPdmVyZmxvdzIgPyBhdXRvQWRqdXN0T3ZlcmZsb3dFbmFibGVkIDogYXV0b0FkanVzdE92ZXJmbG93RGlzYWJsZWQ7XG4gIH1cbiAgcmV0dXJuIF9leHRlbmRzJDEoX2V4dGVuZHMkMSh7fSwgYXV0b0FkanVzdE92ZXJmbG93RGlzYWJsZWQpLCBhdXRvQWRqdXN0T3ZlcmZsb3cyKTtcbn1cbmZ1bmN0aW9uIGdldFBsYWNlbWVudHMoY29uZmlnKSB7XG4gIHZhciBfY29uZmlnJGFycm93V2lkdGggPSBjb25maWcuYXJyb3dXaWR0aCwgYXJyb3dXaWR0aCA9IF9jb25maWckYXJyb3dXaWR0aCA9PT0gdm9pZCAwID8gNCA6IF9jb25maWckYXJyb3dXaWR0aCwgX2NvbmZpZyRob3Jpem9udGFsQXJyID0gY29uZmlnLmhvcml6b250YWxBcnJvd1NoaWZ0LCBob3Jpem9udGFsQXJyb3dTaGlmdCA9IF9jb25maWckaG9yaXpvbnRhbEFyciA9PT0gdm9pZCAwID8gMTYgOiBfY29uZmlnJGhvcml6b250YWxBcnIsIF9jb25maWckdmVydGljYWxBcnJvdyA9IGNvbmZpZy52ZXJ0aWNhbEFycm93U2hpZnQsIHZlcnRpY2FsQXJyb3dTaGlmdCA9IF9jb25maWckdmVydGljYWxBcnJvdyA9PT0gdm9pZCAwID8gOCA6IF9jb25maWckdmVydGljYWxBcnJvdywgYXV0b0FkanVzdE92ZXJmbG93MiA9IGNvbmZpZy5hdXRvQWRqdXN0T3ZlcmZsb3c7XG4gIHZhciBwbGFjZW1lbnRNYXAgPSB7XG4gICAgbGVmdDoge1xuICAgICAgcG9pbnRzOiBbXCJjclwiLCBcImNsXCJdLFxuICAgICAgb2Zmc2V0OiBbLTQsIDBdXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgcG9pbnRzOiBbXCJjbFwiLCBcImNyXCJdLFxuICAgICAgb2Zmc2V0OiBbNCwgMF1cbiAgICB9LFxuICAgIHRvcDoge1xuICAgICAgcG9pbnRzOiBbXCJiY1wiLCBcInRjXCJdLFxuICAgICAgb2Zmc2V0OiBbMCwgLTRdXG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHBvaW50czogW1widGNcIiwgXCJiY1wiXSxcbiAgICAgIG9mZnNldDogWzAsIDRdXG4gICAgfSxcbiAgICB0b3BMZWZ0OiB7XG4gICAgICBwb2ludHM6IFtcImJsXCIsIFwidGNcIl0sXG4gICAgICBvZmZzZXQ6IFstKGhvcml6b250YWxBcnJvd1NoaWZ0ICsgYXJyb3dXaWR0aCksIC00XVxuICAgIH0sXG4gICAgbGVmdFRvcDoge1xuICAgICAgcG9pbnRzOiBbXCJ0clwiLCBcImNsXCJdLFxuICAgICAgb2Zmc2V0OiBbLTQsIC0odmVydGljYWxBcnJvd1NoaWZ0ICsgYXJyb3dXaWR0aCldXG4gICAgfSxcbiAgICB0b3BSaWdodDoge1xuICAgICAgcG9pbnRzOiBbXCJiclwiLCBcInRjXCJdLFxuICAgICAgb2Zmc2V0OiBbaG9yaXpvbnRhbEFycm93U2hpZnQgKyBhcnJvd1dpZHRoLCAtNF1cbiAgICB9LFxuICAgIHJpZ2h0VG9wOiB7XG4gICAgICBwb2ludHM6IFtcInRsXCIsIFwiY3JcIl0sXG4gICAgICBvZmZzZXQ6IFs0LCAtKHZlcnRpY2FsQXJyb3dTaGlmdCArIGFycm93V2lkdGgpXVxuICAgIH0sXG4gICAgYm90dG9tUmlnaHQ6IHtcbiAgICAgIHBvaW50czogW1widHJcIiwgXCJiY1wiXSxcbiAgICAgIG9mZnNldDogW2hvcml6b250YWxBcnJvd1NoaWZ0ICsgYXJyb3dXaWR0aCwgNF1cbiAgICB9LFxuICAgIHJpZ2h0Qm90dG9tOiB7XG4gICAgICBwb2ludHM6IFtcImJsXCIsIFwiY3JcIl0sXG4gICAgICBvZmZzZXQ6IFs0LCB2ZXJ0aWNhbEFycm93U2hpZnQgKyBhcnJvd1dpZHRoXVxuICAgIH0sXG4gICAgYm90dG9tTGVmdDoge1xuICAgICAgcG9pbnRzOiBbXCJ0bFwiLCBcImJjXCJdLFxuICAgICAgb2Zmc2V0OiBbLShob3Jpem9udGFsQXJyb3dTaGlmdCArIGFycm93V2lkdGgpLCA0XVxuICAgIH0sXG4gICAgbGVmdEJvdHRvbToge1xuICAgICAgcG9pbnRzOiBbXCJiclwiLCBcImNsXCJdLFxuICAgICAgb2Zmc2V0OiBbLTQsIHZlcnRpY2FsQXJyb3dTaGlmdCArIGFycm93V2lkdGhdXG4gICAgfVxuICB9O1xuICBPYmplY3Qua2V5cyhwbGFjZW1lbnRNYXApLmZvckVhY2goZnVuY3Rpb24oa2V5Mikge1xuICAgIHBsYWNlbWVudE1hcFtrZXkyXSA9IGNvbmZpZy5hcnJvd1BvaW50QXRDZW50ZXIgPyBfZXh0ZW5kcyQxKF9leHRlbmRzJDEoe30sIHBsYWNlbWVudE1hcFtrZXkyXSksIHtcbiAgICAgIG92ZXJmbG93OiBnZXRPdmVyZmxvd09wdGlvbnMoYXV0b0FkanVzdE92ZXJmbG93MiksXG4gICAgICB0YXJnZXRPZmZzZXRcbiAgICB9KSA6IF9leHRlbmRzJDEoX2V4dGVuZHMkMSh7fSwgcGxhY2VtZW50c1trZXkyXSksIHtcbiAgICAgIG92ZXJmbG93OiBnZXRPdmVyZmxvd09wdGlvbnMoYXV0b0FkanVzdE92ZXJmbG93MilcbiAgICB9KTtcbiAgICBwbGFjZW1lbnRNYXBba2V5Ml0uaWdub3JlU2hha2UgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHBsYWNlbWVudE1hcDtcbn1cbnZhciBnZXRUcmFuc2l0aW9uTmFtZSA9IGZ1bmN0aW9uIGdldFRyYW5zaXRpb25OYW1lMihyb290UHJlZml4Q2xzLCBtb3Rpb24sIHRyYW5zaXRpb25OYW1lMikge1xuICBpZiAodHJhbnNpdGlvbk5hbWUyICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk5hbWUyO1xuICB9XG4gIHJldHVybiBcIlwiLmNvbmNhdChyb290UHJlZml4Q2xzLCBcIi1cIikuY29uY2F0KG1vdGlvbik7XG59O1xudmFyIF9fcmVzdCQ1ID0gZ2xvYmFsVGhpcyAmJiBnbG9iYWxUaGlzLl9fcmVzdCB8fCBmdW5jdGlvbihzLCBlMikge1xuICB2YXIgdDIgPSB7fTtcbiAgZm9yICh2YXIgcDIgaW4gcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcDIpICYmIGUyLmluZGV4T2YocDIpIDwgMClcbiAgICAgIHQyW3AyXSA9IHNbcDJdO1xuICB9XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICBmb3IgKHZhciBpID0gMCwgcDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChlMi5pbmRleE9mKHAyW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHAyW2ldKSlcbiAgICAgICAgdDJbcDJbaV1dID0gc1twMltpXV07XG4gICAgfVxuICByZXR1cm4gdDI7XG59O1xudmFyIHNwbGl0T2JqZWN0ID0gZnVuY3Rpb24gc3BsaXRPYmplY3QyKG9iaiwga2V5czIpIHtcbiAgdmFyIHBpY2tlZCA9IHt9O1xuICB2YXIgb21pdHRlZCA9IF9leHRlbmRzJDEoe30sIG9iaik7XG4gIGtleXMyLmZvckVhY2goZnVuY3Rpb24oa2V5Mikge1xuICAgIGlmIChvYmogJiYga2V5MiBpbiBvYmopIHtcbiAgICAgIHBpY2tlZFtrZXkyXSA9IG9ialtrZXkyXTtcbiAgICAgIGRlbGV0ZSBvbWl0dGVkW2tleTJdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcGlja2VkLFxuICAgIG9taXR0ZWRcbiAgfTtcbn07XG52YXIgUHJlc2V0Q29sb3JSZWdleCA9IG5ldyBSZWdFeHAoXCJeKFwiLmNvbmNhdChQcmVzZXRDb2xvclR5cGVzLmpvaW4oXCJ8XCIpLCBcIikoLWludmVyc2UpPyRcIikpO1xuZnVuY3Rpb24gZ2V0RGlzYWJsZWRDb21wYXRpYmxlQ2hpbGRyZW4oZWxlbWVudCwgcHJlZml4Q2xzKSB7XG4gIHZhciBlbGVtZW50VHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKChlbGVtZW50VHlwZS5fX0FOVF9CVVRUT04gPT09IHRydWUgfHwgZWxlbWVudC50eXBlID09PSBcImJ1dHRvblwiKSAmJiBlbGVtZW50LnByb3BzLmRpc2FibGVkIHx8IGVsZW1lbnRUeXBlLl9fQU5UX1NXSVRDSCA9PT0gdHJ1ZSAmJiAoZWxlbWVudC5wcm9wcy5kaXNhYmxlZCB8fCBlbGVtZW50LnByb3BzLmxvYWRpbmcpKSB7XG4gICAgdmFyIF9zcGxpdE9iamVjdCA9IHNwbGl0T2JqZWN0KGVsZW1lbnQucHJvcHMuc3R5bGUsIFtcInBvc2l0aW9uXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwidG9wXCIsIFwiYm90dG9tXCIsIFwiZmxvYXRcIiwgXCJkaXNwbGF5XCIsIFwiekluZGV4XCJdKSwgcGlja2VkID0gX3NwbGl0T2JqZWN0LnBpY2tlZCwgb21pdHRlZCA9IF9zcGxpdE9iamVjdC5vbWl0dGVkO1xuICAgIHZhciBzcGFuU3R5bGUgPSBfZXh0ZW5kcyQxKF9leHRlbmRzJDEoe1xuICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIlxuICAgIH0sIHBpY2tlZCksIHtcbiAgICAgIGN1cnNvcjogXCJub3QtYWxsb3dlZFwiLFxuICAgICAgd2lkdGg6IGVsZW1lbnQucHJvcHMuYmxvY2sgPyBcIjEwMCVcIiA6IG51bGxcbiAgICB9KTtcbiAgICB2YXIgYnV0dG9uU3R5bGUgPSBfZXh0ZW5kcyQxKF9leHRlbmRzJDEoe30sIG9taXR0ZWQpLCB7XG4gICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgIH0pO1xuICAgIHZhciBjaGlsZCA9IGNsb25lRWxlbWVudChlbGVtZW50LCB7XG4gICAgICBzdHlsZTogYnV0dG9uU3R5bGUsXG4gICAgICBjbGFzc05hbWU6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIHN0eWxlOiBzcGFuU3R5bGUsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoZWxlbWVudC5wcm9wcy5jbGFzc05hbWUsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItZGlzYWJsZWQtY29tcGF0aWJsZS13cmFwcGVyXCIpKVxuICAgIH0sIGNoaWxkKTtcbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBUb29sdGlwMiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uKHByb3BzLCByZWYpIHtcbiAgdmFyIF9jbGFzc05hbWVzMjtcbiAgdmFyIF9SZWFjdCR1c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChDb25maWdDb250ZXh0KSwgZ2V0Q29udGV4dFBvcHVwQ29udGFpbmVyID0gX1JlYWN0JHVzZUNvbnRleHQuZ2V0UG9wdXBDb250YWluZXIsIGdldFByZWZpeENscyA9IF9SZWFjdCR1c2VDb250ZXh0LmdldFByZWZpeENscywgZGlyZWN0aW9uID0gX1JlYWN0JHVzZUNvbnRleHQuZGlyZWN0aW9uO1xuICB2YXIgX3VzZU1lcmdlZFN0YXRlID0gdXNlQ29udHJvbGxlZFN0YXRlKGZhbHNlLCB7XG4gICAgdmFsdWU6IHByb3BzLnZpc2libGUsXG4gICAgZGVmYXVsdFZhbHVlOiBwcm9wcy5kZWZhdWx0VmlzaWJsZVxuICB9KSwgX3VzZU1lcmdlZFN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VNZXJnZWRTdGF0ZSwgMiksIHZpc2libGUgPSBfdXNlTWVyZ2VkU3RhdGUyWzBdLCBzZXRWaXNpYmxlID0gX3VzZU1lcmdlZFN0YXRlMlsxXTtcbiAgdmFyIGlzTm9UaXRsZSA9IGZ1bmN0aW9uIGlzTm9UaXRsZTIoKSB7XG4gICAgdmFyIHRpdGxlID0gcHJvcHMudGl0bGUsIG92ZXJsYXkgPSBwcm9wcy5vdmVybGF5O1xuICAgIHJldHVybiAhdGl0bGUgJiYgIW92ZXJsYXkgJiYgdGl0bGUgIT09IDA7XG4gIH07XG4gIHZhciBvblZpc2libGVDaGFuZ2UgPSBmdW5jdGlvbiBvblZpc2libGVDaGFuZ2UyKHZpcykge1xuICAgIHZhciBfYTtcbiAgICBzZXRWaXNpYmxlKGlzTm9UaXRsZSgpID8gZmFsc2UgOiB2aXMpO1xuICAgIGlmICghaXNOb1RpdGxlKCkpIHtcbiAgICAgIChfYSA9IHByb3BzLm9uVmlzaWJsZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocHJvcHMsIHZpcyk7XG4gICAgfVxuICB9O1xuICB2YXIgZ2V0VG9vbHRpcFBsYWNlbWVudHMgPSBmdW5jdGlvbiBnZXRUb29sdGlwUGxhY2VtZW50czIoKSB7XG4gICAgdmFyIGJ1aWx0aW5QbGFjZW1lbnRzID0gcHJvcHMuYnVpbHRpblBsYWNlbWVudHMsIGFycm93UG9pbnRBdENlbnRlciA9IHByb3BzLmFycm93UG9pbnRBdENlbnRlciwgYXV0b0FkanVzdE92ZXJmbG93MiA9IHByb3BzLmF1dG9BZGp1c3RPdmVyZmxvdztcbiAgICByZXR1cm4gYnVpbHRpblBsYWNlbWVudHMgfHwgZ2V0UGxhY2VtZW50cyh7XG4gICAgICBhcnJvd1BvaW50QXRDZW50ZXIsXG4gICAgICBhdXRvQWRqdXN0T3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdzJcbiAgICB9KTtcbiAgfTtcbiAgdmFyIG9uUG9wdXBBbGlnbiA9IGZ1bmN0aW9uIG9uUG9wdXBBbGlnbjIoZG9tTm9kZSwgYWxpZ24pIHtcbiAgICB2YXIgcGxhY2VtZW50czIgPSBnZXRUb29sdGlwUGxhY2VtZW50cygpO1xuICAgIHZhciBwbGFjZW1lbnQgPSBPYmplY3Qua2V5cyhwbGFjZW1lbnRzMikuZmlsdGVyKGZ1bmN0aW9uKGtleTIpIHtcbiAgICAgIHJldHVybiBwbGFjZW1lbnRzMltrZXkyXS5wb2ludHNbMF0gPT09IGFsaWduLnBvaW50c1swXSAmJiBwbGFjZW1lbnRzMltrZXkyXS5wb2ludHNbMV0gPT09IGFsaWduLnBvaW50c1sxXTtcbiAgICB9KVswXTtcbiAgICBpZiAoIXBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmVjdCA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IHtcbiAgICAgIHRvcDogXCI1MCVcIixcbiAgICAgIGxlZnQ6IFwiNTAlXCJcbiAgICB9O1xuICAgIGlmIChwbGFjZW1lbnQuaW5kZXhPZihcInRvcFwiKSA+PSAwIHx8IHBsYWNlbWVudC5pbmRleE9mKFwiQm90dG9tXCIpID49IDApIHtcbiAgICAgIHRyYW5zZm9ybU9yaWdpbi50b3AgPSBcIlwiLmNvbmNhdChyZWN0LmhlaWdodCAtIGFsaWduLm9mZnNldFsxXSwgXCJweFwiKTtcbiAgICB9IGVsc2UgaWYgKHBsYWNlbWVudC5pbmRleE9mKFwiVG9wXCIpID49IDAgfHwgcGxhY2VtZW50LmluZGV4T2YoXCJib3R0b21cIikgPj0gMCkge1xuICAgICAgdHJhbnNmb3JtT3JpZ2luLnRvcCA9IFwiXCIuY29uY2F0KC1hbGlnbi5vZmZzZXRbMV0sIFwicHhcIik7XG4gICAgfVxuICAgIGlmIChwbGFjZW1lbnQuaW5kZXhPZihcImxlZnRcIikgPj0gMCB8fCBwbGFjZW1lbnQuaW5kZXhPZihcIlJpZ2h0XCIpID49IDApIHtcbiAgICAgIHRyYW5zZm9ybU9yaWdpbi5sZWZ0ID0gXCJcIi5jb25jYXQocmVjdC53aWR0aCAtIGFsaWduLm9mZnNldFswXSwgXCJweFwiKTtcbiAgICB9IGVsc2UgaWYgKHBsYWNlbWVudC5pbmRleE9mKFwicmlnaHRcIikgPj0gMCB8fCBwbGFjZW1lbnQuaW5kZXhPZihcIkxlZnRcIikgPj0gMCkge1xuICAgICAgdHJhbnNmb3JtT3JpZ2luLmxlZnQgPSBcIlwiLmNvbmNhdCgtYWxpZ24ub2Zmc2V0WzBdLCBcInB4XCIpO1xuICAgIH1cbiAgICBkb21Ob2RlLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IFwiXCIuY29uY2F0KHRyYW5zZm9ybU9yaWdpbi5sZWZ0LCBcIiBcIikuY29uY2F0KHRyYW5zZm9ybU9yaWdpbi50b3ApO1xuICB9O1xuICB2YXIgZ2V0T3ZlcmxheSA9IGZ1bmN0aW9uIGdldE92ZXJsYXkyKCkge1xuICAgIHZhciB0aXRsZSA9IHByb3BzLnRpdGxlLCBvdmVybGF5ID0gcHJvcHMub3ZlcmxheTtcbiAgICBpZiAodGl0bGUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aXRsZTtcbiAgICB9XG4gICAgcmV0dXJuIG92ZXJsYXkgfHwgdGl0bGUgfHwgXCJcIjtcbiAgfTtcbiAgdmFyIGdldFBvcHVwQ29udGFpbmVyID0gcHJvcHMuZ2V0UG9wdXBDb250YWluZXIsIG90aGVyUHJvcHMgPSBfX3Jlc3QkNShwcm9wcywgW1wiZ2V0UG9wdXBDb250YWluZXJcIl0pO1xuICB2YXIgY3VzdG9taXplUHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzLCBvcGVuQ2xhc3NOYW1lID0gcHJvcHMub3BlbkNsYXNzTmFtZSwgZ2V0VG9vbHRpcENvbnRhaW5lciA9IHByb3BzLmdldFRvb2x0aXBDb250YWluZXIsIG92ZXJsYXlDbGFzc05hbWUgPSBwcm9wcy5vdmVybGF5Q2xhc3NOYW1lLCBjb2xvciA9IHByb3BzLmNvbG9yLCBvdmVybGF5SW5uZXJTdHlsZSA9IHByb3BzLm92ZXJsYXlJbm5lclN0eWxlLCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICB2YXIgcHJlZml4Q2xzID0gZ2V0UHJlZml4Q2xzKFwidG9vbHRpcFwiLCBjdXN0b21pemVQcmVmaXhDbHMpO1xuICB2YXIgcm9vdFByZWZpeENscyA9IGdldFByZWZpeENscygpO1xuICB2YXIgdGVtcFZpc2libGUgPSB2aXNpYmxlO1xuICBpZiAoIShcInZpc2libGVcIiBpbiBwcm9wcykgJiYgaXNOb1RpdGxlKCkpIHtcbiAgICB0ZW1wVmlzaWJsZSA9IGZhbHNlO1xuICB9XG4gIHZhciBjaGlsZCA9IGdldERpc2FibGVkQ29tcGF0aWJsZUNoaWxkcmVuKGlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IGNoaWxkcmVuIDogLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIGNoaWxkcmVuKSwgcHJlZml4Q2xzKTtcbiAgdmFyIGNoaWxkUHJvcHMgPSBjaGlsZC5wcm9wcztcbiAgdmFyIGNoaWxkQ2xzID0gY2xhc3NOYW1lcyhjaGlsZFByb3BzLmNsYXNzTmFtZSwgX2RlZmluZVByb3BlcnR5JDEoe30sIG9wZW5DbGFzc05hbWUgfHwgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1vcGVuXCIpLCB0cnVlKSk7XG4gIHZhciBjdXN0b21PdmVybGF5Q2xhc3NOYW1lID0gY2xhc3NOYW1lcyhvdmVybGF5Q2xhc3NOYW1lLCAoX2NsYXNzTmFtZXMyID0ge30sIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzMiwgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1ydGxcIiksIGRpcmVjdGlvbiA9PT0gXCJydGxcIiksIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzMiwgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1cIikuY29uY2F0KGNvbG9yKSwgY29sb3IgJiYgUHJlc2V0Q29sb3JSZWdleC50ZXN0KGNvbG9yKSksIF9jbGFzc05hbWVzMikpO1xuICB2YXIgZm9ybWF0dGVkT3ZlcmxheUlubmVyU3R5bGUgPSBvdmVybGF5SW5uZXJTdHlsZTtcbiAgdmFyIGFycm93Q29udGVudFN0eWxlO1xuICBpZiAoY29sb3IgJiYgIVByZXNldENvbG9yUmVnZXgudGVzdChjb2xvcikpIHtcbiAgICBmb3JtYXR0ZWRPdmVybGF5SW5uZXJTdHlsZSA9IF9leHRlbmRzJDEoX2V4dGVuZHMkMSh7fSwgb3ZlcmxheUlubmVyU3R5bGUpLCB7XG4gICAgICBiYWNrZ3JvdW5kOiBjb2xvclxuICAgIH0pO1xuICAgIGFycm93Q29udGVudFN0eWxlID0ge1xuICAgICAgYmFja2dyb3VuZDogY29sb3JcbiAgICB9O1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwJDMsIF9leHRlbmRzJDEoe30sIG90aGVyUHJvcHMsIHtcbiAgICBwcmVmaXhDbHMsXG4gICAgb3ZlcmxheUNsYXNzTmFtZTogY3VzdG9tT3ZlcmxheUNsYXNzTmFtZSxcbiAgICBnZXRUb29sdGlwQ29udGFpbmVyOiBnZXRQb3B1cENvbnRhaW5lciB8fCBnZXRUb29sdGlwQ29udGFpbmVyIHx8IGdldENvbnRleHRQb3B1cENvbnRhaW5lcixcbiAgICByZWYsXG4gICAgYnVpbHRpblBsYWNlbWVudHM6IGdldFRvb2x0aXBQbGFjZW1lbnRzKCksXG4gICAgb3ZlcmxheTogZ2V0T3ZlcmxheSgpLFxuICAgIHZpc2libGU6IHRlbXBWaXNpYmxlLFxuICAgIG9uVmlzaWJsZUNoYW5nZSxcbiAgICBvblBvcHVwQWxpZ24sXG4gICAgb3ZlcmxheUlubmVyU3R5bGU6IGZvcm1hdHRlZE92ZXJsYXlJbm5lclN0eWxlLFxuICAgIGFycm93Q29udGVudDogLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1hcnJvdy1jb250ZW50XCIpLFxuICAgICAgc3R5bGU6IGFycm93Q29udGVudFN0eWxlXG4gICAgfSksXG4gICAgbW90aW9uOiB7XG4gICAgICBtb3Rpb25OYW1lOiBnZXRUcmFuc2l0aW9uTmFtZShyb290UHJlZml4Q2xzLCBcInpvb20tYmlnLWZhc3RcIiwgcHJvcHMudHJhbnNpdGlvbk5hbWUpLFxuICAgICAgbW90aW9uRGVhZGxpbmU6IDFlM1xuICAgIH1cbiAgfSksIHRlbXBWaXNpYmxlID8gY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgY2xhc3NOYW1lOiBjaGlsZENsc1xuICB9KSA6IGNoaWxkKTtcbn0pO1xuVG9vbHRpcDIuZGlzcGxheU5hbWUgPSBcIlRvb2x0aXBcIjtcblRvb2x0aXAyLmRlZmF1bHRQcm9wcyA9IHtcbiAgcGxhY2VtZW50OiBcInRvcFwiLFxuICBtb3VzZUVudGVyRGVsYXk6IDAuMSxcbiAgbW91c2VMZWF2ZURlbGF5OiAwLjEsXG4gIGFycm93UG9pbnRBdENlbnRlcjogZmFsc2UsXG4gIGF1dG9BZGp1c3RPdmVyZmxvdzogdHJ1ZVxufTtcbnZhciBUb29sdGlwJDEgPSBUb29sdGlwMjtcbmZ1bmN0aW9uIGdldElucHV0Q2xhc3NOYW1lKHByZWZpeENscywgYm9yZGVyZWQsIHNpemUsIGRpc2FibGVkLCBkaXJlY3Rpb24pIHtcbiAgdmFyIF9jbGFzc05hbWVzO1xuICByZXR1cm4gY2xhc3NOYW1lcyhwcmVmaXhDbHMsIChfY2xhc3NOYW1lcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lcywgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1zbVwiKSwgc2l6ZSA9PT0gXCJzbWFsbFwiKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItbGdcIiksIHNpemUgPT09IFwibGFyZ2VcIiksIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWRpc2FibGVkXCIpLCBkaXNhYmxlZCksIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXJ0bFwiKSwgZGlyZWN0aW9uID09PSBcInJ0bFwiKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItYm9yZGVybGVzc1wiKSwgIWJvcmRlcmVkKSwgX2NsYXNzTmFtZXMpKTtcbn1cbmZ1bmN0aW9uIGhhc1ByZWZpeFN1ZmZpeChwcm9wcykge1xuICByZXR1cm4gISEocHJvcHMucHJlZml4IHx8IHByb3BzLnN1ZmZpeCB8fCBwcm9wcy5hbGxvd0NsZWFyKTtcbn1cbnZhciBDbGVhcmFibGVJbnB1dFR5cGUgPSB0dXBsZShcInRleHRcIiwgXCJpbnB1dFwiKTtcbmZ1bmN0aW9uIGhhc0FkZG9uKHByb3BzKSB7XG4gIHJldHVybiAhIShwcm9wcy5hZGRvbkJlZm9yZSB8fCBwcm9wcy5hZGRvbkFmdGVyKTtcbn1cbnZhciBDbGVhcmFibGVMYWJlbGVkSW5wdXQgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQ2xlYXJhYmxlTGFiZWxlZElucHV0MiwgX1JlYWN0JENvbXBvbmVudCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQ2xlYXJhYmxlTGFiZWxlZElucHV0Mik7XG4gIGZ1bmN0aW9uIENsZWFyYWJsZUxhYmVsZWRJbnB1dDIoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGVhcmFibGVMYWJlbGVkSW5wdXQyKTtcbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLmNvbnRhaW5lclJlZiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICBfdGhpcy5vbklucHV0TW91c2VVcCA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoKF9hID0gX3RoaXMuY29udGFpbmVyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhlMi50YXJnZXQpKSB7XG4gICAgICAgIHZhciB0cmlnZ2VyRm9jdXMyID0gX3RoaXMucHJvcHMudHJpZ2dlckZvY3VzO1xuICAgICAgICB0cmlnZ2VyRm9jdXMyID09PSBudWxsIHx8IHRyaWdnZXJGb2N1czIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyaWdnZXJGb2N1czIoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoQ2xlYXJhYmxlTGFiZWxlZElucHV0MiwgW3tcbiAgICBrZXk6IFwicmVuZGVyQ2xlYXJJY29uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNsZWFySWNvbihwcmVmaXhDbHMpIHtcbiAgICAgIHZhciBfY2xhc3NOYW1lcztcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsIGFsbG93Q2xlYXIgPSBfdGhpcyRwcm9wcy5hbGxvd0NsZWFyLCB2YWx1ZSA9IF90aGlzJHByb3BzLnZhbHVlLCBkaXNhYmxlZCA9IF90aGlzJHByb3BzLmRpc2FibGVkLCByZWFkT25seSA9IF90aGlzJHByb3BzLnJlYWRPbmx5LCBoYW5kbGVSZXNldCA9IF90aGlzJHByb3BzLmhhbmRsZVJlc2V0LCBzdWZmaXggPSBfdGhpcyRwcm9wcy5zdWZmaXg7XG4gICAgICBpZiAoIWFsbG93Q2xlYXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbmVlZENsZWFyID0gIWRpc2FibGVkICYmICFyZWFkT25seSAmJiB2YWx1ZTtcbiAgICAgIHZhciBjbGFzc05hbWUgPSBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWNsZWFyLWljb25cIik7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2xvc2VDaXJjbGVGaWxsZWQkMSwge1xuICAgICAgICBvbkNsaWNrOiBoYW5kbGVSZXNldCxcbiAgICAgICAgb25Nb3VzZURvd246IGZ1bmN0aW9uIG9uTW91c2VEb3duKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIGUyLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcygoX2NsYXNzTmFtZXMgPSB7fSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KGNsYXNzTmFtZSwgXCItaGlkZGVuXCIpLCAhbmVlZENsZWFyKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KGNsYXNzTmFtZSwgXCItaGFzLXN1ZmZpeFwiKSwgISFzdWZmaXgpLCBfY2xhc3NOYW1lcyksIGNsYXNzTmFtZSksXG4gICAgICAgIHJvbGU6IFwiYnV0dG9uXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJTdWZmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyU3VmZml4KHByZWZpeENscykge1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsIHN1ZmZpeCA9IF90aGlzJHByb3BzMi5zdWZmaXgsIGFsbG93Q2xlYXIgPSBfdGhpcyRwcm9wczIuYWxsb3dDbGVhcjtcbiAgICAgIGlmIChzdWZmaXggfHwgYWxsb3dDbGVhcikge1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItc3VmZml4XCIpXG4gICAgICAgIH0sIHRoaXMucmVuZGVyQ2xlYXJJY29uKHByZWZpeENscyksIHN1ZmZpeCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyTGFiZWxlZEljb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTGFiZWxlZEljb24ocHJlZml4Q2xzLCBlbGVtZW50KSB7XG4gICAgICB2YXIgX2NsYXNzTmFtZXMyO1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsIGZvY3VzZWQgPSBfdGhpcyRwcm9wczMuZm9jdXNlZCwgdmFsdWUgPSBfdGhpcyRwcm9wczMudmFsdWUsIHByZWZpeCA9IF90aGlzJHByb3BzMy5wcmVmaXgsIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzMy5jbGFzc05hbWUsIHNpemUgPSBfdGhpcyRwcm9wczMuc2l6ZSwgc3VmZml4ID0gX3RoaXMkcHJvcHMzLnN1ZmZpeCwgZGlzYWJsZWQgPSBfdGhpcyRwcm9wczMuZGlzYWJsZWQsIGFsbG93Q2xlYXIgPSBfdGhpcyRwcm9wczMuYWxsb3dDbGVhciwgZGlyZWN0aW9uID0gX3RoaXMkcHJvcHMzLmRpcmVjdGlvbiwgc3R5bGUyID0gX3RoaXMkcHJvcHMzLnN0eWxlLCByZWFkT25seSA9IF90aGlzJHByb3BzMy5yZWFkT25seSwgYm9yZGVyZWQgPSBfdGhpcyRwcm9wczMuYm9yZGVyZWQsIGhpZGRlbiA9IF90aGlzJHByb3BzMy5oaWRkZW47XG4gICAgICBpZiAoIWhhc1ByZWZpeFN1ZmZpeCh0aGlzLnByb3BzKSkge1xuICAgICAgICByZXR1cm4gY2xvbmVFbGVtZW50KGVsZW1lbnQsIHtcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBzdWZmaXhOb2RlID0gdGhpcy5yZW5kZXJTdWZmaXgocHJlZml4Q2xzKTtcbiAgICAgIHZhciBwcmVmaXhOb2RlID0gcHJlZml4ID8gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXByZWZpeFwiKVxuICAgICAgfSwgcHJlZml4KSA6IG51bGw7XG4gICAgICB2YXIgYWZmaXhXcmFwcGVyQ2xzID0gY2xhc3NOYW1lcyhcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWFmZml4LXdyYXBwZXJcIiksIChfY2xhc3NOYW1lczIgPSB7fSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMyLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWFmZml4LXdyYXBwZXItZm9jdXNlZFwiKSwgZm9jdXNlZCksIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzMiwgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1hZmZpeC13cmFwcGVyLWRpc2FibGVkXCIpLCBkaXNhYmxlZCksIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzMiwgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1hZmZpeC13cmFwcGVyLXNtXCIpLCBzaXplID09PSBcInNtYWxsXCIpLCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lczIsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItYWZmaXgtd3JhcHBlci1sZ1wiKSwgc2l6ZSA9PT0gXCJsYXJnZVwiKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMyLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWFmZml4LXdyYXBwZXItaW5wdXQtd2l0aC1jbGVhci1idG5cIiksIHN1ZmZpeCAmJiBhbGxvd0NsZWFyICYmIHZhbHVlKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMyLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWFmZml4LXdyYXBwZXItcnRsXCIpLCBkaXJlY3Rpb24gPT09IFwicnRsXCIpLCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lczIsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItYWZmaXgtd3JhcHBlci1yZWFkb25seVwiKSwgcmVhZE9ubHkpLCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lczIsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItYWZmaXgtd3JhcHBlci1ib3JkZXJsZXNzXCIpLCAhYm9yZGVyZWQpLCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lczIsIFwiXCIuY29uY2F0KGNsYXNzTmFtZSksICFoYXNBZGRvbih0aGlzLnByb3BzKSAmJiBjbGFzc05hbWUpLCBfY2xhc3NOYW1lczIpKTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICByZWY6IHRoaXMuY29udGFpbmVyUmVmLFxuICAgICAgICBjbGFzc05hbWU6IGFmZml4V3JhcHBlckNscyxcbiAgICAgICAgc3R5bGU6IHN0eWxlMixcbiAgICAgICAgb25Nb3VzZVVwOiB0aGlzLm9uSW5wdXRNb3VzZVVwLFxuICAgICAgICBoaWRkZW5cbiAgICAgIH0sIHByZWZpeE5vZGUsIGNsb25lRWxlbWVudChlbGVtZW50LCB7XG4gICAgICAgIHN0eWxlOiBudWxsLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgY2xhc3NOYW1lOiBnZXRJbnB1dENsYXNzTmFtZShwcmVmaXhDbHMsIGJvcmRlcmVkLCBzaXplLCBkaXNhYmxlZClcbiAgICAgIH0pLCBzdWZmaXhOb2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVySW5wdXRXaXRoTGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVySW5wdXRXaXRoTGFiZWwocHJlZml4Q2xzLCBsYWJlbGVkRWxlbWVudCkge1xuICAgICAgdmFyIF9jbGFzc05hbWVzNDtcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLCBhZGRvbkJlZm9yZSA9IF90aGlzJHByb3BzNC5hZGRvbkJlZm9yZSwgYWRkb25BZnRlciA9IF90aGlzJHByb3BzNC5hZGRvbkFmdGVyLCBzdHlsZTIgPSBfdGhpcyRwcm9wczQuc3R5bGUsIHNpemUgPSBfdGhpcyRwcm9wczQuc2l6ZSwgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHM0LmNsYXNzTmFtZSwgZGlyZWN0aW9uID0gX3RoaXMkcHJvcHM0LmRpcmVjdGlvbiwgaGlkZGVuID0gX3RoaXMkcHJvcHM0LmhpZGRlbjtcbiAgICAgIGlmICghaGFzQWRkb24odGhpcy5wcm9wcykpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsZWRFbGVtZW50O1xuICAgICAgfVxuICAgICAgdmFyIHdyYXBwZXJDbGFzc05hbWUgPSBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWdyb3VwXCIpO1xuICAgICAgdmFyIGFkZG9uQ2xhc3NOYW1lID0gXCJcIi5jb25jYXQod3JhcHBlckNsYXNzTmFtZSwgXCItYWRkb25cIik7XG4gICAgICB2YXIgYWRkb25CZWZvcmVOb2RlID0gYWRkb25CZWZvcmUgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBjbGFzc05hbWU6IGFkZG9uQ2xhc3NOYW1lXG4gICAgICB9LCBhZGRvbkJlZm9yZSkgOiBudWxsO1xuICAgICAgdmFyIGFkZG9uQWZ0ZXJOb2RlID0gYWRkb25BZnRlciA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogYWRkb25DbGFzc05hbWVcbiAgICAgIH0sIGFkZG9uQWZ0ZXIpIDogbnVsbDtcbiAgICAgIHZhciBtZXJnZWRXcmFwcGVyQ2xhc3NOYW1lID0gY2xhc3NOYW1lcyhcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXdyYXBwZXJcIiksIHdyYXBwZXJDbGFzc05hbWUsIF9kZWZpbmVQcm9wZXJ0eSQxKHt9LCBcIlwiLmNvbmNhdCh3cmFwcGVyQ2xhc3NOYW1lLCBcIi1ydGxcIiksIGRpcmVjdGlvbiA9PT0gXCJydGxcIikpO1xuICAgICAgdmFyIG1lcmdlZEdyb3VwQ2xhc3NOYW1lID0gY2xhc3NOYW1lcyhcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWdyb3VwLXdyYXBwZXJcIiksIChfY2xhc3NOYW1lczQgPSB7fSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXM0LCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWdyb3VwLXdyYXBwZXItc21cIiksIHNpemUgPT09IFwic21hbGxcIiksIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzNCwgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1ncm91cC13cmFwcGVyLWxnXCIpLCBzaXplID09PSBcImxhcmdlXCIpLCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lczQsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItZ3JvdXAtd3JhcHBlci1ydGxcIiksIGRpcmVjdGlvbiA9PT0gXCJydGxcIiksIF9jbGFzc05hbWVzNCksIGNsYXNzTmFtZSk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBtZXJnZWRHcm91cENsYXNzTmFtZSxcbiAgICAgICAgc3R5bGU6IHN0eWxlMixcbiAgICAgICAgaGlkZGVuXG4gICAgICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBjbGFzc05hbWU6IG1lcmdlZFdyYXBwZXJDbGFzc05hbWVcbiAgICAgIH0sIGFkZG9uQmVmb3JlTm9kZSwgY2xvbmVFbGVtZW50KGxhYmVsZWRFbGVtZW50LCB7XG4gICAgICAgIHN0eWxlOiBudWxsXG4gICAgICB9KSwgYWRkb25BZnRlck5vZGUpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyVGV4dEFyZWFXaXRoQ2xlYXJJY29uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRleHRBcmVhV2l0aENsZWFySWNvbihwcmVmaXhDbHMsIGVsZW1lbnQpIHtcbiAgICAgIHZhciBfY2xhc3NOYW1lczU7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcywgdmFsdWUgPSBfdGhpcyRwcm9wczUudmFsdWUsIGFsbG93Q2xlYXIgPSBfdGhpcyRwcm9wczUuYWxsb3dDbGVhciwgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHM1LmNsYXNzTmFtZSwgc3R5bGUyID0gX3RoaXMkcHJvcHM1LnN0eWxlLCBkaXJlY3Rpb24gPSBfdGhpcyRwcm9wczUuZGlyZWN0aW9uLCBib3JkZXJlZCA9IF90aGlzJHByb3BzNS5ib3JkZXJlZCwgaGlkZGVuID0gX3RoaXMkcHJvcHM1LmhpZGRlbjtcbiAgICAgIGlmICghYWxsb3dDbGVhcikge1xuICAgICAgICByZXR1cm4gY2xvbmVFbGVtZW50KGVsZW1lbnQsIHtcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBhZmZpeFdyYXBwZXJDbHMgPSBjbGFzc05hbWVzKFwiXCIuY29uY2F0KHByZWZpeENscywgXCItYWZmaXgtd3JhcHBlclwiKSwgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1hZmZpeC13cmFwcGVyLXRleHRhcmVhLXdpdGgtY2xlYXItYnRuXCIpLCAoX2NsYXNzTmFtZXM1ID0ge30sIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzNSwgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1hZmZpeC13cmFwcGVyLXJ0bFwiKSwgZGlyZWN0aW9uID09PSBcInJ0bFwiKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXM1LCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWFmZml4LXdyYXBwZXItYm9yZGVybGVzc1wiKSwgIWJvcmRlcmVkKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXM1LCBcIlwiLmNvbmNhdChjbGFzc05hbWUpLCAhaGFzQWRkb24odGhpcy5wcm9wcykgJiYgY2xhc3NOYW1lKSwgX2NsYXNzTmFtZXM1KSk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBhZmZpeFdyYXBwZXJDbHMsXG4gICAgICAgIHN0eWxlOiBzdHlsZTIsXG4gICAgICAgIGhpZGRlblxuICAgICAgfSwgY2xvbmVFbGVtZW50KGVsZW1lbnQsIHtcbiAgICAgICAgc3R5bGU6IG51bGwsXG4gICAgICAgIHZhbHVlXG4gICAgICB9KSwgdGhpcy5yZW5kZXJDbGVhckljb24ocHJlZml4Q2xzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM2ID0gdGhpcy5wcm9wcywgcHJlZml4Q2xzID0gX3RoaXMkcHJvcHM2LnByZWZpeENscywgaW5wdXRUeXBlID0gX3RoaXMkcHJvcHM2LmlucHV0VHlwZSwgZWxlbWVudCA9IF90aGlzJHByb3BzNi5lbGVtZW50O1xuICAgICAgaWYgKGlucHV0VHlwZSA9PT0gQ2xlYXJhYmxlSW5wdXRUeXBlWzBdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclRleHRBcmVhV2l0aENsZWFySWNvbihwcmVmaXhDbHMsIGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVySW5wdXRXaXRoTGFiZWwocHJlZml4Q2xzLCB0aGlzLnJlbmRlckxhYmVsZWRJY29uKHByZWZpeENscywgZWxlbWVudCkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2xlYXJhYmxlTGFiZWxlZElucHV0Mjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcbnZhciBDbGVhcmFibGVMYWJlbGVkSW5wdXQkMSA9IENsZWFyYWJsZUxhYmVsZWRJbnB1dDtcbmZ1bmN0aW9uIGZpeENvbnRyb2xsZWRWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlT25DaGFuZ2UodGFyZ2V0LCBlMiwgb25DaGFuZ2UsIHRhcmdldFZhbHVlKSB7XG4gIGlmICghb25DaGFuZ2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGV2ZW50ID0gZTI7XG4gIGlmIChlMi50eXBlID09PSBcImNsaWNrXCIpIHtcbiAgICB2YXIgY3VycmVudFRhcmdldCA9IHRhcmdldC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgZXZlbnQgPSBPYmplY3QuY3JlYXRlKGUyLCB7XG4gICAgICB0YXJnZXQ6IHtcbiAgICAgICAgdmFsdWU6IGN1cnJlbnRUYXJnZXRcbiAgICAgIH0sXG4gICAgICBjdXJyZW50VGFyZ2V0OiB7XG4gICAgICAgIHZhbHVlOiBjdXJyZW50VGFyZ2V0XG4gICAgICB9XG4gICAgfSk7XG4gICAgY3VycmVudFRhcmdldC52YWx1ZSA9IFwiXCI7XG4gICAgb25DaGFuZ2UoZXZlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodGFyZ2V0VmFsdWUgIT09IHZvaWQgMCkge1xuICAgIGV2ZW50ID0gT2JqZWN0LmNyZWF0ZShlMiwge1xuICAgICAgdGFyZ2V0OiB7XG4gICAgICAgIHZhbHVlOiB0YXJnZXRcbiAgICAgIH0sXG4gICAgICBjdXJyZW50VGFyZ2V0OiB7XG4gICAgICAgIHZhbHVlOiB0YXJnZXRcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YXJnZXQudmFsdWUgPSB0YXJnZXRWYWx1ZTtcbiAgICBvbkNoYW5nZShldmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9uQ2hhbmdlKGV2ZW50KTtcbn1cbmZ1bmN0aW9uIHRyaWdnZXJGb2N1cyhlbGVtZW50LCBvcHRpb24pIHtcbiAgaWYgKCFlbGVtZW50KVxuICAgIHJldHVybjtcbiAgZWxlbWVudC5mb2N1cyhvcHRpb24pO1xuICB2YXIgX3JlZiA9IG9wdGlvbiB8fCB7fSwgY3Vyc29yID0gX3JlZi5jdXJzb3I7XG4gIGlmIChjdXJzb3IpIHtcbiAgICB2YXIgbGVuID0gZWxlbWVudC52YWx1ZS5sZW5ndGg7XG4gICAgc3dpdGNoIChjdXJzb3IpIHtcbiAgICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgICBlbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKDAsIDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgZWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZShsZW4sIGxlbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSgwLCBsZW4pO1xuICAgIH1cbiAgfVxufVxudmFyIElucHV0ID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKElucHV0MiwgX1JlYWN0JENvbXBvbmVudCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSW5wdXQyKTtcbiAgZnVuY3Rpb24gSW5wdXQyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnB1dDIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpO1xuICAgIF90aGlzLmRpcmVjdGlvbiA9IFwibHRyXCI7XG4gICAgX3RoaXMuZm9jdXMgPSBmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgIHRyaWdnZXJGb2N1cyhfdGhpcy5pbnB1dCwgb3B0aW9uKTtcbiAgICB9O1xuICAgIF90aGlzLnNhdmVDbGVhcmFibGVJbnB1dCA9IGZ1bmN0aW9uKGlucHV0Mikge1xuICAgICAgX3RoaXMuY2xlYXJhYmxlSW5wdXQgPSBpbnB1dDI7XG4gICAgfTtcbiAgICBfdGhpcy5zYXZlSW5wdXQgPSBmdW5jdGlvbihpbnB1dDIpIHtcbiAgICAgIF90aGlzLmlucHV0ID0gaW5wdXQyO1xuICAgIH07XG4gICAgX3RoaXMub25Gb2N1cyA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICB2YXIgb25Gb2N1cyA9IF90aGlzLnByb3BzLm9uRm9jdXM7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGZvY3VzZWQ6IHRydWVcbiAgICAgIH0sIF90aGlzLmNsZWFyUGFzc3dvcmRWYWx1ZUF0dHJpYnV0ZSk7XG4gICAgICBvbkZvY3VzID09PSBudWxsIHx8IG9uRm9jdXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRm9jdXMoZTIpO1xuICAgIH07XG4gICAgX3RoaXMub25CbHVyID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgIHZhciBvbkJsdXIgPSBfdGhpcy5wcm9wcy5vbkJsdXI7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICB9LCBfdGhpcy5jbGVhclBhc3N3b3JkVmFsdWVBdHRyaWJ1dGUpO1xuICAgICAgb25CbHVyID09PSBudWxsIHx8IG9uQmx1ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25CbHVyKGUyKTtcbiAgICB9O1xuICAgIF90aGlzLmhhbmRsZVJlc2V0ID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgIF90aGlzLnNldFZhbHVlKFwiXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5mb2N1cygpO1xuICAgICAgfSk7XG4gICAgICByZXNvbHZlT25DaGFuZ2UoX3RoaXMuaW5wdXQsIGUyLCBfdGhpcy5wcm9wcy5vbkNoYW5nZSk7XG4gICAgfTtcbiAgICBfdGhpcy5yZW5kZXJJbnB1dCA9IGZ1bmN0aW9uKHByZWZpeENscywgc2l6ZSwgYm9yZGVyZWQpIHtcbiAgICAgIHZhciBpbnB1dDIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzLmNsYXNzTmFtZSwgYWRkb25CZWZvcmUgPSBfdGhpcyRwcm9wcy5hZGRvbkJlZm9yZSwgYWRkb25BZnRlciA9IF90aGlzJHByb3BzLmFkZG9uQWZ0ZXIsIGN1c3RvbWl6ZVNpemUgPSBfdGhpcyRwcm9wcy5zaXplLCBkaXNhYmxlZCA9IF90aGlzJHByb3BzLmRpc2FibGVkLCBodG1sU2l6ZSA9IF90aGlzJHByb3BzLmh0bWxTaXplO1xuICAgICAgdmFyIG90aGVyUHJvcHMgPSBvbWl0KF90aGlzLnByb3BzLCBbXG4gICAgICAgIFwicHJlZml4Q2xzXCIsXG4gICAgICAgIFwib25QcmVzc0VudGVyXCIsXG4gICAgICAgIFwiYWRkb25CZWZvcmVcIixcbiAgICAgICAgXCJhZGRvbkFmdGVyXCIsXG4gICAgICAgIFwicHJlZml4XCIsXG4gICAgICAgIFwic3VmZml4XCIsXG4gICAgICAgIFwiYWxsb3dDbGVhclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiLFxuICAgICAgICBcInNpemVcIixcbiAgICAgICAgXCJpbnB1dFR5cGVcIixcbiAgICAgICAgXCJib3JkZXJlZFwiLFxuICAgICAgICBcImh0bWxTaXplXCIsXG4gICAgICAgIFwic2hvd0NvdW50XCJcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgX2V4dGVuZHMkMSh7XG4gICAgICAgIGF1dG9Db21wbGV0ZTogaW5wdXQyLmF1dG9Db21wbGV0ZVxuICAgICAgfSwgb3RoZXJQcm9wcywge1xuICAgICAgICBvbkNoYW5nZTogX3RoaXMuaGFuZGxlQ2hhbmdlLFxuICAgICAgICBvbkZvY3VzOiBfdGhpcy5vbkZvY3VzLFxuICAgICAgICBvbkJsdXI6IF90aGlzLm9uQmx1cixcbiAgICAgICAgb25LZXlEb3duOiBfdGhpcy5oYW5kbGVLZXlEb3duLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoZ2V0SW5wdXRDbGFzc05hbWUocHJlZml4Q2xzLCBib3JkZXJlZCwgY3VzdG9taXplU2l6ZSB8fCBzaXplLCBkaXNhYmxlZCwgX3RoaXMuZGlyZWN0aW9uKSwgX2RlZmluZVByb3BlcnR5JDEoe30sIGNsYXNzTmFtZSwgY2xhc3NOYW1lICYmICFhZGRvbkJlZm9yZSAmJiAhYWRkb25BZnRlcikpLFxuICAgICAgICByZWY6IF90aGlzLnNhdmVJbnB1dCxcbiAgICAgICAgc2l6ZTogaHRtbFNpemVcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIF90aGlzLmNsZWFyUGFzc3dvcmRWYWx1ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMucmVtb3ZlUGFzc3dvcmRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKF90aGlzLmlucHV0ICYmIF90aGlzLmlucHV0LmdldEF0dHJpYnV0ZShcInR5cGVcIikgPT09IFwicGFzc3dvcmRcIiAmJiBfdGhpcy5pbnB1dC5oYXNBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSkge1xuICAgICAgICAgIF90aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF90aGlzLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShlMi50YXJnZXQudmFsdWUsIF90aGlzLmNsZWFyUGFzc3dvcmRWYWx1ZUF0dHJpYnV0ZSk7XG4gICAgICByZXNvbHZlT25DaGFuZ2UoX3RoaXMuaW5wdXQsIGUyLCBfdGhpcy5wcm9wcy5vbkNoYW5nZSk7XG4gICAgfTtcbiAgICBfdGhpcy5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcywgb25QcmVzc0VudGVyID0gX3RoaXMkcHJvcHMyLm9uUHJlc3NFbnRlciwgb25LZXlEb3duID0gX3RoaXMkcHJvcHMyLm9uS2V5RG93bjtcbiAgICAgIGlmIChvblByZXNzRW50ZXIgJiYgZTIua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgb25QcmVzc0VudGVyKGUyKTtcbiAgICAgIH1cbiAgICAgIG9uS2V5RG93biA9PT0gbnVsbCB8fCBvbktleURvd24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uS2V5RG93bihlMik7XG4gICAgfTtcbiAgICBfdGhpcy5yZW5kZXJTaG93Q291bnRTdWZmaXggPSBmdW5jdGlvbihwcmVmaXhDbHMpIHtcbiAgICAgIHZhciB2YWx1ZTIgPSBfdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSBfdGhpcy5wcm9wcywgbWF4TGVuZ3RoID0gX3RoaXMkcHJvcHMzLm1heExlbmd0aCwgc3VmZml4ID0gX3RoaXMkcHJvcHMzLnN1ZmZpeCwgc2hvd0NvdW50ID0gX3RoaXMkcHJvcHMzLnNob3dDb3VudDtcbiAgICAgIHZhciBoYXNNYXhMZW5ndGggPSBOdW1iZXIobWF4TGVuZ3RoKSA+IDA7XG4gICAgICBpZiAoc3VmZml4IHx8IHNob3dDb3VudCkge1xuICAgICAgICB2YXIgdmFsdWVMZW5ndGggPSBfdG9Db25zdW1hYmxlQXJyYXkoZml4Q29udHJvbGxlZFZhbHVlKHZhbHVlMikpLmxlbmd0aDtcbiAgICAgICAgdmFyIGRhdGFDb3VudCA9IG51bGw7XG4gICAgICAgIGlmIChfdHlwZW9mJDEoc2hvd0NvdW50KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGRhdGFDb3VudCA9IHNob3dDb3VudC5mb3JtYXR0ZXIoe1xuICAgICAgICAgICAgY291bnQ6IHZhbHVlTGVuZ3RoLFxuICAgICAgICAgICAgbWF4TGVuZ3RoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YUNvdW50ID0gXCJcIi5jb25jYXQodmFsdWVMZW5ndGgpLmNvbmNhdChoYXNNYXhMZW5ndGggPyBcIiAvIFwiLmNvbmNhdChtYXhMZW5ndGgpIDogXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAhIXNob3dDb3VudCAmJiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXNob3ctY291bnQtc3VmZml4XCIpLCBfZGVmaW5lUHJvcGVydHkkMSh7fSwgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1zaG93LWNvdW50LWhhcy1zdWZmaXhcIiksICEhc3VmZml4KSlcbiAgICAgICAgfSwgZGF0YUNvdW50KSwgc3VmZml4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX3RoaXMucmVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24oX3JlZjIpIHtcbiAgICAgIHZhciBnZXRQcmVmaXhDbHMgPSBfcmVmMi5nZXRQcmVmaXhDbHMsIGRpcmVjdGlvbiA9IF9yZWYyLmRpcmVjdGlvbiwgaW5wdXQyID0gX3JlZjIuaW5wdXQ7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSBfdGhpcy5zdGF0ZSwgdmFsdWUyID0gX3RoaXMkc3RhdGUudmFsdWUsIGZvY3VzZWQgPSBfdGhpcyRzdGF0ZS5mb2N1c2VkO1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IF90aGlzLnByb3BzLCBjdXN0b21pemVQcmVmaXhDbHMgPSBfdGhpcyRwcm9wczQucHJlZml4Q2xzLCBfdGhpcyRwcm9wczQkYm9yZGVyZWQgPSBfdGhpcyRwcm9wczQuYm9yZGVyZWQsIGJvcmRlcmVkID0gX3RoaXMkcHJvcHM0JGJvcmRlcmVkID09PSB2b2lkIDAgPyB0cnVlIDogX3RoaXMkcHJvcHM0JGJvcmRlcmVkO1xuICAgICAgdmFyIHByZWZpeENscyA9IGdldFByZWZpeENscyhcImlucHV0XCIsIGN1c3RvbWl6ZVByZWZpeENscyk7XG4gICAgICBfdGhpcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICB2YXIgc2hvd0NvdW50U3VmZml4ID0gX3RoaXMucmVuZGVyU2hvd0NvdW50U3VmZml4KHByZWZpeENscyk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2l6ZUNvbnRleHQkMS5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2xlYXJhYmxlTGFiZWxlZElucHV0JDEsIF9leHRlbmRzJDEoe1xuICAgICAgICAgIHNpemVcbiAgICAgICAgfSwgX3RoaXMucHJvcHMsIHtcbiAgICAgICAgICBwcmVmaXhDbHMsXG4gICAgICAgICAgaW5wdXRUeXBlOiBcImlucHV0XCIsXG4gICAgICAgICAgdmFsdWU6IGZpeENvbnRyb2xsZWRWYWx1ZSh2YWx1ZTIpLFxuICAgICAgICAgIGVsZW1lbnQ6IF90aGlzLnJlbmRlcklucHV0KHByZWZpeENscywgc2l6ZSwgYm9yZGVyZWQsIGlucHV0MiksXG4gICAgICAgICAgaGFuZGxlUmVzZXQ6IF90aGlzLmhhbmRsZVJlc2V0LFxuICAgICAgICAgIHJlZjogX3RoaXMuc2F2ZUNsZWFyYWJsZUlucHV0LFxuICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICBmb2N1c2VkLFxuICAgICAgICAgIHRyaWdnZXJGb2N1czogX3RoaXMuZm9jdXMsXG4gICAgICAgICAgYm9yZGVyZWQsXG4gICAgICAgICAgc3VmZml4OiBzaG93Q291bnRTdWZmaXhcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgcHJvcHMudmFsdWUgPT09IFwidW5kZWZpbmVkXCIgPyBwcm9wcy5kZWZhdWx0VmFsdWUgOiBwcm9wcy52YWx1ZTtcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZm9jdXNlZDogZmFsc2UsXG4gICAgICBwcmV2VmFsdWU6IHByb3BzLnZhbHVlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKElucHV0MiwgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLmNsZWFyUGFzc3dvcmRWYWx1ZUF0dHJpYnV0ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIGlmIChoYXNQcmVmaXhTdWZmaXgocHJldlByb3BzKSAhPT0gaGFzUHJlZml4U3VmZml4KHRoaXMucHJvcHMpKSB7XG4gICAgICAgIGRldldhcm5pbmcodGhpcy5pbnB1dCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCwgXCJJbnB1dFwiLCBcIldoZW4gSW5wdXQgaXMgZm9jdXNlZCwgZHluYW1pYyBhZGQgb3IgcmVtb3ZlIHByZWZpeCAvIHN1ZmZpeCB3aWxsIG1ha2UgaXQgbG9zZSBmb2N1cyBjYXVzZWQgYnkgZG9tIHN0cnVjdHVyZSBjaGFuZ2UuIFJlYWQgbW9yZTogaHR0cHM6Ly9hbnQuZGVzaWduL2NvbXBvbmVudHMvaW5wdXQvI0ZBUVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLnJlbW92ZVBhc3N3b3JkVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZW1vdmVQYXNzd29yZFRpbWVvdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJibHVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgICB0aGlzLmlucHV0LmJsdXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2VsZWN0aW9uUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCwgZGlyZWN0aW9uKSB7XG4gICAgICB0aGlzLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQsIGRpcmVjdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3QoKSB7XG4gICAgICB0aGlzLmlucHV0LnNlbGVjdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZTIodmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbmZpZ0NvbnN1bWVyLCBudWxsLCB0aGlzLnJlbmRlckNvbXBvbmVudCk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIF9yZWYzKSB7XG4gICAgICB2YXIgcHJldlZhbHVlID0gX3JlZjMucHJldlZhbHVlO1xuICAgICAgdmFyIG5ld1N0YXRlID0ge1xuICAgICAgICBwcmV2VmFsdWU6IG5leHRQcm9wcy52YWx1ZVxuICAgICAgfTtcbiAgICAgIGlmIChuZXh0UHJvcHMudmFsdWUgIT09IHZvaWQgMCB8fCBwcmV2VmFsdWUgIT09IG5leHRQcm9wcy52YWx1ZSkge1xuICAgICAgICBuZXdTdGF0ZS52YWx1ZSA9IG5leHRQcm9wcy52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0UHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgbmV3U3RhdGUuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW5wdXQyO1xufShSZWFjdC5Db21wb25lbnQpO1xuSW5wdXQuZGVmYXVsdFByb3BzID0ge1xuICB0eXBlOiBcInRleHRcIlxufTtcbnZhciBJbnB1dCQxID0gSW5wdXQ7XG52YXIgR3JvdXAkMSA9IGZ1bmN0aW9uIEdyb3VwKHByb3BzKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb25maWdDb25zdW1lciwgbnVsbCwgZnVuY3Rpb24oX3JlZikge1xuICAgIHZhciBfY2xhc3NOYW1lcztcbiAgICB2YXIgZ2V0UHJlZml4Q2xzID0gX3JlZi5nZXRQcmVmaXhDbHMsIGRpcmVjdGlvbiA9IF9yZWYuZGlyZWN0aW9uO1xuICAgIHZhciBjdXN0b21pemVQcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHMsIF9wcm9wcyRjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsIGNsYXNzTmFtZSA9IF9wcm9wcyRjbGFzc05hbWUgPT09IHZvaWQgMCA/IFwiXCIgOiBfcHJvcHMkY2xhc3NOYW1lO1xuICAgIHZhciBwcmVmaXhDbHMgPSBnZXRQcmVmaXhDbHMoXCJpbnB1dC1ncm91cFwiLCBjdXN0b21pemVQcmVmaXhDbHMpO1xuICAgIHZhciBjbHMgPSBjbGFzc05hbWVzKHByZWZpeENscywgKF9jbGFzc05hbWVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWxnXCIpLCBwcm9wcy5zaXplID09PSBcImxhcmdlXCIpLCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lcywgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1zbVwiKSwgcHJvcHMuc2l6ZSA9PT0gXCJzbWFsbFwiKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItY29tcGFjdFwiKSwgcHJvcHMuY29tcGFjdCksIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXJ0bFwiKSwgZGlyZWN0aW9uID09PSBcInJ0bFwiKSwgX2NsYXNzTmFtZXMpLCBjbGFzc05hbWUpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiBjbHMsXG4gICAgICBzdHlsZTogcHJvcHMuc3R5bGUsXG4gICAgICBvbk1vdXNlRW50ZXI6IHByb3BzLm9uTW91c2VFbnRlcixcbiAgICAgIG9uTW91c2VMZWF2ZTogcHJvcHMub25Nb3VzZUxlYXZlLFxuICAgICAgb25Gb2N1czogcHJvcHMub25Gb2N1cyxcbiAgICAgIG9uQmx1cjogcHJvcHMub25CbHVyXG4gICAgfSwgcHJvcHMuY2hpbGRyZW4pO1xuICB9KTtcbn07XG52YXIgR3JvdXAkMiA9IEdyb3VwJDE7XG52YXIgU2VhcmNoT3V0bGluZWQkMiA9IHsgXCJpY29uXCI6IHsgXCJ0YWdcIjogXCJzdmdcIiwgXCJhdHRyc1wiOiB7IFwidmlld0JveFwiOiBcIjY0IDY0IDg5NiA4OTZcIiwgXCJmb2N1c2FibGVcIjogXCJmYWxzZVwiIH0sIFwiY2hpbGRyZW5cIjogW3sgXCJ0YWdcIjogXCJwYXRoXCIsIFwiYXR0cnNcIjogeyBcImRcIjogXCJNOTA5LjYgODU0LjVMNjQ5LjkgNTk0LjhDNjkwLjIgNTQyLjcgNzEyIDQ3OSA3MTIgNDEyYzAtODAuMi0zMS4zLTE1NS40LTg3LjktMjEyLjEtNTYuNi01Ni43LTEzMi04Ny45LTIxMi4xLTg3LjlzLTE1NS41IDMxLjMtMjEyLjEgODcuOUMxNDMuMiAyNTYuNSAxMTIgMzMxLjggMTEyIDQxMmMwIDgwLjEgMzEuMyAxNTUuNSA4Ny45IDIxMi4xQzI1Ni41IDY4MC44IDMzMS44IDcxMiA0MTIgNzEyYzY3IDAgMTMwLjYtMjEuOCAxODIuNy02MmwyNTkuNyAyNTkuNmE4LjIgOC4yIDAgMDAxMS42IDBsNDMuNi00My41YTguMiA4LjIgMCAwMDAtMTEuNnpNNTcwLjQgNTcwLjRDNTI4IDYxMi43IDQ3MS44IDYzNiA0MTIgNjM2cy0xMTYtMjMuMy0xNTguNC02NS42QzIxMS4zIDUyOCAxODggNDcxLjggMTg4IDQxMnMyMy4zLTExNi4xIDY1LjYtMTU4LjRDMjk2IDIxMS4zIDM1Mi4yIDE4OCA0MTIgMTg4czExNi4xIDIzLjIgMTU4LjQgNjUuNlM2MzYgMzUyLjIgNjM2IDQxMnMtMjMuMyAxMTYuMS02NS42IDE1OC40elwiIH0gfV0gfSwgXCJuYW1lXCI6IFwic2VhcmNoXCIsIFwidGhlbWVcIjogXCJvdXRsaW5lZFwiIH07XG52YXIgU2VhcmNoT3V0bGluZWRTdmcgPSBTZWFyY2hPdXRsaW5lZCQyO1xudmFyIFNlYXJjaE91dGxpbmVkID0gZnVuY3Rpb24gU2VhcmNoT3V0bGluZWQyKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEFudGRJY29uLCBfb2JqZWN0U3ByZWFkMiQxKF9vYmplY3RTcHJlYWQyJDEoe30sIHByb3BzKSwge30sIHtcbiAgICByZWYsXG4gICAgaWNvbjogU2VhcmNoT3V0bGluZWRTdmdcbiAgfSkpO1xufTtcblNlYXJjaE91dGxpbmVkLmRpc3BsYXlOYW1lID0gXCJTZWFyY2hPdXRsaW5lZFwiO1xudmFyIFNlYXJjaE91dGxpbmVkJDEgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuZm9yd2FyZFJlZihTZWFyY2hPdXRsaW5lZCk7XG52YXIgVW5yZWFjaGFibGVFeGNlcHRpb24gPSAvKiBAX19QVVJFX18gKi8gX2NyZWF0ZUNsYXNzKGZ1bmN0aW9uIFVucmVhY2hhYmxlRXhjZXB0aW9uMih2YWx1ZSkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVW5yZWFjaGFibGVFeGNlcHRpb24yKTtcbiAgdGhpcy5lcnJvciA9IG5ldyBFcnJvcihcInVucmVhY2hhYmxlIGNhc2U6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh2YWx1ZSkpKTtcbn0pO1xudmFyIF9fcmVzdCQ0ID0gZ2xvYmFsVGhpcyAmJiBnbG9iYWxUaGlzLl9fcmVzdCB8fCBmdW5jdGlvbihzLCBlMikge1xuICB2YXIgdDIgPSB7fTtcbiAgZm9yICh2YXIgcDIgaW4gcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcDIpICYmIGUyLmluZGV4T2YocDIpIDwgMClcbiAgICAgIHQyW3AyXSA9IHNbcDJdO1xuICB9XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICBmb3IgKHZhciBpID0gMCwgcDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChlMi5pbmRleE9mKHAyW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHAyW2ldKSlcbiAgICAgICAgdDJbcDJbaV1dID0gc1twMltpXV07XG4gICAgfVxuICByZXR1cm4gdDI7XG59O1xudmFyIEJ1dHRvbkdyb3VwID0gZnVuY3Rpb24gQnV0dG9uR3JvdXAyKHByb3BzKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb25maWdDb25zdW1lciwgbnVsbCwgZnVuY3Rpb24oX3JlZikge1xuICAgIHZhciBfY2xhc3NOYW1lcztcbiAgICB2YXIgZ2V0UHJlZml4Q2xzID0gX3JlZi5nZXRQcmVmaXhDbHMsIGRpcmVjdGlvbiA9IF9yZWYuZGlyZWN0aW9uO1xuICAgIHZhciBjdXN0b21pemVQcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHMsIHNpemUgPSBwcm9wcy5zaXplLCBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsIG90aGVycyA9IF9fcmVzdCQ0KHByb3BzLCBbXCJwcmVmaXhDbHNcIiwgXCJzaXplXCIsIFwiY2xhc3NOYW1lXCJdKTtcbiAgICB2YXIgcHJlZml4Q2xzID0gZ2V0UHJlZml4Q2xzKFwiYnRuLWdyb3VwXCIsIGN1c3RvbWl6ZVByZWZpeENscyk7XG4gICAgdmFyIHNpemVDbHMgPSBcIlwiO1xuICAgIHN3aXRjaCAoc2l6ZSkge1xuICAgICAgY2FzZSBcImxhcmdlXCI6XG4gICAgICAgIHNpemVDbHMgPSBcImxnXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNtYWxsXCI6XG4gICAgICAgIHNpemVDbHMgPSBcInNtXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKG5ldyBVbnJlYWNoYWJsZUV4Y2VwdGlvbihzaXplKS5lcnJvcik7XG4gICAgfVxuICAgIHZhciBjbGFzc2VzID0gY2xhc3NOYW1lcyhwcmVmaXhDbHMsIChfY2xhc3NOYW1lcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lcywgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1cIikuY29uY2F0KHNpemVDbHMpLCBzaXplQ2xzKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItcnRsXCIpLCBkaXJlY3Rpb24gPT09IFwicnRsXCIpLCBfY2xhc3NOYW1lcyksIGNsYXNzTmFtZSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzJDEoe30sIG90aGVycywge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gICAgfSkpO1xuICB9KTtcbn07XG52YXIgR3JvdXAyID0gQnV0dG9uR3JvdXA7XG52YXIgZ2V0Q29sbGFwc2VkV2lkdGggPSBmdW5jdGlvbiBnZXRDb2xsYXBzZWRXaWR0aDIoKSB7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IDAsXG4gICAgb3BhY2l0eTogMCxcbiAgICB0cmFuc2Zvcm06IFwic2NhbGUoMClcIlxuICB9O1xufTtcbnZhciBnZXRSZWFsV2lkdGggPSBmdW5jdGlvbiBnZXRSZWFsV2lkdGgyKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogbm9kZS5zY3JvbGxXaWR0aCxcbiAgICBvcGFjaXR5OiAxLFxuICAgIHRyYW5zZm9ybTogXCJzY2FsZSgxKVwiXG4gIH07XG59O1xudmFyIExvYWRpbmdJY29uID0gZnVuY3Rpb24gTG9hZGluZ0ljb24yKF9yZWYpIHtcbiAgdmFyIHByZWZpeENscyA9IF9yZWYucHJlZml4Q2xzLCBsb2FkaW5nID0gX3JlZi5sb2FkaW5nLCBleGlzdEljb24gPSBfcmVmLmV4aXN0SWNvbjtcbiAgdmFyIHZpc2libGUgPSAhIWxvYWRpbmc7XG4gIGlmIChleGlzdEljb24pIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1sb2FkaW5nLWljb25cIilcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChMb2FkaW5nT3V0bGluZWQkMSwgbnVsbCkpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDU1NNb3Rpb24sIHtcbiAgICB2aXNpYmxlLFxuICAgIG1vdGlvbk5hbWU6IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItbG9hZGluZy1pY29uLW1vdGlvblwiKSxcbiAgICByZW1vdmVPbkxlYXZlOiB0cnVlLFxuICAgIG9uQXBwZWFyU3RhcnQ6IGdldENvbGxhcHNlZFdpZHRoLFxuICAgIG9uQXBwZWFyQWN0aXZlOiBnZXRSZWFsV2lkdGgsXG4gICAgb25FbnRlclN0YXJ0OiBnZXRDb2xsYXBzZWRXaWR0aCxcbiAgICBvbkVudGVyQWN0aXZlOiBnZXRSZWFsV2lkdGgsXG4gICAgb25MZWF2ZVN0YXJ0OiBnZXRSZWFsV2lkdGgsXG4gICAgb25MZWF2ZUFjdGl2ZTogZ2V0Q29sbGFwc2VkV2lkdGhcbiAgfSwgZnVuY3Rpb24oX3JlZjIsIHJlZikge1xuICAgIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsIHN0eWxlMiA9IF9yZWYyLnN0eWxlO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWxvYWRpbmctaWNvblwiKSxcbiAgICAgIHN0eWxlOiBzdHlsZTIsXG4gICAgICByZWZcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChMb2FkaW5nT3V0bGluZWQkMSwge1xuICAgICAgY2xhc3NOYW1lXG4gICAgfSkpO1xuICB9KTtcbn07XG52YXIgTG9hZGluZ0ljb24kMSA9IExvYWRpbmdJY29uO1xudmFyIF9fcmVzdCQzID0gZ2xvYmFsVGhpcyAmJiBnbG9iYWxUaGlzLl9fcmVzdCB8fCBmdW5jdGlvbihzLCBlMikge1xuICB2YXIgdDIgPSB7fTtcbiAgZm9yICh2YXIgcDIgaW4gcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcDIpICYmIGUyLmluZGV4T2YocDIpIDwgMClcbiAgICAgIHQyW3AyXSA9IHNbcDJdO1xuICB9XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICBmb3IgKHZhciBpID0gMCwgcDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChlMi5pbmRleE9mKHAyW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHAyW2ldKSlcbiAgICAgICAgdDJbcDJbaV1dID0gc1twMltpXV07XG4gICAgfVxuICByZXR1cm4gdDI7XG59O1xudmFyIHJ4VHdvQ05DaGFyID0gL15bXFx1NGUwMC1cXHU5ZmE1XXsyfSQvO1xudmFyIGlzVHdvQ05DaGFyID0gcnhUd29DTkNoYXIudGVzdC5iaW5kKHJ4VHdvQ05DaGFyKTtcbmZ1bmN0aW9uIGlzU3RyaW5nKHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzVW5ib3JkZXJlZEJ1dHRvblR5cGUodHlwZTQpIHtcbiAgcmV0dXJuIHR5cGU0ID09PSBcInRleHRcIiB8fCB0eXBlNCA9PT0gXCJsaW5rXCI7XG59XG5mdW5jdGlvbiBpc1JlYWN0RnJhZ21lbnQobm9kZSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmlzVmFsaWRFbGVtZW50KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gUmVhY3QuRnJhZ21lbnQ7XG59XG5mdW5jdGlvbiBpbnNlcnRTcGFjZShjaGlsZCwgbmVlZEluc2VydGVkKSB7XG4gIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBTUEFDRSA9IG5lZWRJbnNlcnRlZCA/IFwiIFwiIDogXCJcIjtcbiAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgY2hpbGQgIT09IFwibnVtYmVyXCIgJiYgaXNTdHJpbmcoY2hpbGQudHlwZSkgJiYgaXNUd29DTkNoYXIoY2hpbGQucHJvcHMuY2hpbGRyZW4pKSB7XG4gICAgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgY2hpbGRyZW46IGNoaWxkLnByb3BzLmNoaWxkcmVuLnNwbGl0KFwiXCIpLmpvaW4oU1BBQ0UpXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBpc1R3b0NOQ2hhcihjaGlsZCkgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgY2hpbGQuc3BsaXQoXCJcIikuam9pbihTUEFDRSkpIDogLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIGNoaWxkKTtcbiAgfVxuICBpZiAoaXNSZWFjdEZyYWdtZW50KGNoaWxkKSkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgY2hpbGQpO1xuICB9XG4gIHJldHVybiBjaGlsZDtcbn1cbmZ1bmN0aW9uIHNwYWNlQ2hpbGRyZW4oY2hpbGRyZW4sIG5lZWRJbnNlcnRlZCkge1xuICB2YXIgaXNQcmV2Q2hpbGRQdXJlID0gZmFsc2U7XG4gIHZhciBjaGlsZExpc3QgPSBbXTtcbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICB2YXIgdHlwZTQgPSBfdHlwZW9mJDEoY2hpbGQpO1xuICAgIHZhciBpc0N1cnJlbnRDaGlsZFB1cmUgPSB0eXBlNCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlNCA9PT0gXCJudW1iZXJcIjtcbiAgICBpZiAoaXNQcmV2Q2hpbGRQdXJlICYmIGlzQ3VycmVudENoaWxkUHVyZSkge1xuICAgICAgdmFyIGxhc3RJbmRleCA9IGNoaWxkTGlzdC5sZW5ndGggLSAxO1xuICAgICAgdmFyIGxhc3RDaGlsZCA9IGNoaWxkTGlzdFtsYXN0SW5kZXhdO1xuICAgICAgY2hpbGRMaXN0W2xhc3RJbmRleF0gPSBcIlwiLmNvbmNhdChsYXN0Q2hpbGQpLmNvbmNhdChjaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkTGlzdC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gICAgaXNQcmV2Q2hpbGRQdXJlID0gaXNDdXJyZW50Q2hpbGRQdXJlO1xuICB9KTtcbiAgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZExpc3QsIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgcmV0dXJuIGluc2VydFNwYWNlKGNoaWxkLCBuZWVkSW5zZXJ0ZWQpO1xuICB9KTtcbn1cbnR1cGxlKFwiZGVmYXVsdFwiLCBcInByaW1hcnlcIiwgXCJnaG9zdFwiLCBcImRhc2hlZFwiLCBcImxpbmtcIiwgXCJ0ZXh0XCIpO1xudHVwbGUoXCJkZWZhdWx0XCIsIFwiY2lyY2xlXCIsIFwicm91bmRcIik7XG50dXBsZShcInN1Ym1pdFwiLCBcImJ1dHRvblwiLCBcInJlc2V0XCIpO1xudmFyIEludGVybmFsQnV0dG9uID0gZnVuY3Rpb24gSW50ZXJuYWxCdXR0b24yKHByb3BzLCByZWYpIHtcbiAgdmFyIF9jbGFzc05hbWVzO1xuICB2YXIgX3Byb3BzJGxvYWRpbmcgPSBwcm9wcy5sb2FkaW5nLCBsb2FkaW5nID0gX3Byb3BzJGxvYWRpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGxvYWRpbmcsIGN1c3RvbWl6ZVByZWZpeENscyA9IHByb3BzLnByZWZpeENscywgX3Byb3BzJHR5cGUgPSBwcm9wcy50eXBlLCB0eXBlNCA9IF9wcm9wcyR0eXBlID09PSB2b2lkIDAgPyBcImRlZmF1bHRcIiA6IF9wcm9wcyR0eXBlLCBkYW5nZXIgPSBwcm9wcy5kYW5nZXIsIF9wcm9wcyRzaGFwZSA9IHByb3BzLnNoYXBlLCBzaGFwZSA9IF9wcm9wcyRzaGFwZSA9PT0gdm9pZCAwID8gXCJkZWZhdWx0XCIgOiBfcHJvcHMkc2hhcGUsIGN1c3RvbWl6ZVNpemUgPSBwcm9wcy5zaXplLCBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sIGljb24gPSBwcm9wcy5pY29uLCBfcHJvcHMkZ2hvc3QgPSBwcm9wcy5naG9zdCwgZ2hvc3QgPSBfcHJvcHMkZ2hvc3QgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGdob3N0LCBfcHJvcHMkYmxvY2sgPSBwcm9wcy5ibG9jaywgYmxvY2sgPSBfcHJvcHMkYmxvY2sgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGJsb2NrLCBfcHJvcHMkaHRtbFR5cGUgPSBwcm9wcy5odG1sVHlwZSwgaHRtbFR5cGUgPSBfcHJvcHMkaHRtbFR5cGUgPT09IHZvaWQgMCA/IFwiYnV0dG9uXCIgOiBfcHJvcHMkaHRtbFR5cGUsIHJlc3QgPSBfX3Jlc3QkMyhwcm9wcywgW1wibG9hZGluZ1wiLCBcInByZWZpeENsc1wiLCBcInR5cGVcIiwgXCJkYW5nZXJcIiwgXCJzaGFwZVwiLCBcInNpemVcIiwgXCJjbGFzc05hbWVcIiwgXCJjaGlsZHJlblwiLCBcImljb25cIiwgXCJnaG9zdFwiLCBcImJsb2NrXCIsIFwiaHRtbFR5cGVcIl0pO1xuICB2YXIgc2l6ZSA9IFJlYWN0LnVzZUNvbnRleHQoU2l6ZUNvbnRleHQkMSk7XG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZSghIWxvYWRpbmcpLCBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSwgaW5uZXJMb2FkaW5nID0gX1JlYWN0JHVzZVN0YXRlMlswXSwgc2V0TG9hZGluZyA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLCBfUmVhY3QkdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlMywgMiksIGhhc1R3b0NOQ2hhciA9IF9SZWFjdCR1c2VTdGF0ZTRbMF0sIHNldEhhc1R3b0NOQ2hhciA9IF9SZWFjdCR1c2VTdGF0ZTRbMV07XG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQ29uZmlnQ29udGV4dCksIGdldFByZWZpeENscyA9IF9SZWFjdCR1c2VDb250ZXh0LmdldFByZWZpeENscywgYXV0b0luc2VydFNwYWNlSW5CdXR0b24gPSBfUmVhY3QkdXNlQ29udGV4dC5hdXRvSW5zZXJ0U3BhY2VJbkJ1dHRvbiwgZGlyZWN0aW9uID0gX1JlYWN0JHVzZUNvbnRleHQuZGlyZWN0aW9uO1xuICB2YXIgYnV0dG9uUmVmID0gcmVmIHx8IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgdmFyIGlzTmVlZEluc2VydGVkID0gZnVuY3Rpb24gaXNOZWVkSW5zZXJ0ZWQyKCkge1xuICAgIHJldHVybiBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDEgJiYgIWljb24gJiYgIWlzVW5ib3JkZXJlZEJ1dHRvblR5cGUodHlwZTQpO1xuICB9O1xuICB2YXIgZml4VHdvQ05DaGFyID0gZnVuY3Rpb24gZml4VHdvQ05DaGFyMigpIHtcbiAgICBpZiAoIWJ1dHRvblJlZiB8fCAhYnV0dG9uUmVmLmN1cnJlbnQgfHwgYXV0b0luc2VydFNwYWNlSW5CdXR0b24gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBidXR0b25UZXh0ID0gYnV0dG9uUmVmLmN1cnJlbnQudGV4dENvbnRlbnQ7XG4gICAgaWYgKGlzTmVlZEluc2VydGVkKCkgJiYgaXNUd29DTkNoYXIoYnV0dG9uVGV4dCkpIHtcbiAgICAgIGlmICghaGFzVHdvQ05DaGFyKSB7XG4gICAgICAgIHNldEhhc1R3b0NOQ2hhcih0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhc1R3b0NOQ2hhcikge1xuICAgICAgc2V0SGFzVHdvQ05DaGFyKGZhbHNlKTtcbiAgICB9XG4gIH07XG4gIHZhciBsb2FkaW5nT3JEZWxheSA9IF90eXBlb2YkMShsb2FkaW5nKSA9PT0gXCJvYmplY3RcIiAmJiBsb2FkaW5nLmRlbGF5ID8gbG9hZGluZy5kZWxheSB8fCB0cnVlIDogISFsb2FkaW5nO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlbGF5VGltZXIgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgbG9hZGluZ09yRGVsYXkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGRlbGF5VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgZGVsYXlUaW1lciA9IG51bGw7XG4gICAgICAgIHNldExvYWRpbmcobG9hZGluZ09yRGVsYXkpO1xuICAgICAgfSwgbG9hZGluZ09yRGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRMb2FkaW5nKGxvYWRpbmdPckRlbGF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGRlbGF5VGltZXIpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChkZWxheVRpbWVyKTtcbiAgICAgICAgZGVsYXlUaW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2xvYWRpbmdPckRlbGF5XSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmaXhUd29DTkNoYXIsIFtidXR0b25SZWZdKTtcbiAgdmFyIGhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2syKGUyKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBvbkNsaWNrID0gcHJvcHMub25DbGljaywgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZDtcbiAgICBpZiAoaW5uZXJMb2FkaW5nIHx8IGRpc2FibGVkKSB7XG4gICAgICBlMi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoX2EgPSBvbkNsaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoZTIpO1xuICB9O1xuICBkZXZXYXJuaW5nKCEodHlwZW9mIGljb24gPT09IFwic3RyaW5nXCIgJiYgaWNvbi5sZW5ndGggPiAyKSwgXCJCdXR0b25cIiwgXCJgaWNvbmAgaXMgdXNpbmcgUmVhY3ROb2RlIGluc3RlYWQgb2Ygc3RyaW5nIG5hbWluZyBpbiB2NC4gUGxlYXNlIGNoZWNrIGBcIi5jb25jYXQoaWNvbiwgXCJgIGF0IGh0dHBzOi8vYW50LmRlc2lnbi9jb21wb25lbnRzL2ljb25cIikpO1xuICBkZXZXYXJuaW5nKCEoZ2hvc3QgJiYgaXNVbmJvcmRlcmVkQnV0dG9uVHlwZSh0eXBlNCkpLCBcIkJ1dHRvblwiLCBcImBsaW5rYCBvciBgdGV4dGAgYnV0dG9uIGNhbid0IGJlIGEgYGdob3N0YCBidXR0b24uXCIpO1xuICB2YXIgcHJlZml4Q2xzID0gZ2V0UHJlZml4Q2xzKFwiYnRuXCIsIGN1c3RvbWl6ZVByZWZpeENscyk7XG4gIHZhciBhdXRvSW5zZXJ0U3BhY2UgPSBhdXRvSW5zZXJ0U3BhY2VJbkJ1dHRvbiAhPT0gZmFsc2U7XG4gIHZhciBzaXplQ2xhc3NOYW1lTWFwID0ge1xuICAgIGxhcmdlOiBcImxnXCIsXG4gICAgc21hbGw6IFwic21cIixcbiAgICBtaWRkbGU6IHZvaWQgMFxuICB9O1xuICB2YXIgc2l6ZUZ1bGxuYW1lID0gY3VzdG9taXplU2l6ZSB8fCBzaXplO1xuICB2YXIgc2l6ZUNscyA9IHNpemVGdWxsbmFtZSA/IHNpemVDbGFzc05hbWVNYXBbc2l6ZUZ1bGxuYW1lXSB8fCBcIlwiIDogXCJcIjtcbiAgdmFyIGljb25UeXBlID0gaW5uZXJMb2FkaW5nID8gXCJsb2FkaW5nXCIgOiBpY29uO1xuICB2YXIgY2xhc3NlcyA9IGNsYXNzTmFtZXMocHJlZml4Q2xzLCAoX2NsYXNzTmFtZXMgPSB7fSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItXCIpLmNvbmNhdChzaGFwZSksIHNoYXBlICE9PSBcImRlZmF1bHRcIiAmJiBzaGFwZSksIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLVwiKS5jb25jYXQodHlwZTQpLCB0eXBlNCksIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLVwiKS5jb25jYXQoc2l6ZUNscyksIHNpemVDbHMpLCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lcywgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1pY29uLW9ubHlcIiksICFjaGlsZHJlbiAmJiBjaGlsZHJlbiAhPT0gMCAmJiAhIWljb25UeXBlKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItYmFja2dyb3VuZC1naG9zdFwiKSwgZ2hvc3QgJiYgIWlzVW5ib3JkZXJlZEJ1dHRvblR5cGUodHlwZTQpKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItbG9hZGluZ1wiKSwgaW5uZXJMb2FkaW5nKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItdHdvLWNoaW5lc2UtY2hhcnNcIiksIGhhc1R3b0NOQ2hhciAmJiBhdXRvSW5zZXJ0U3BhY2UpLCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lcywgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1ibG9ja1wiKSwgYmxvY2spLCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lcywgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1kYW5nZXJvdXNcIiksICEhZGFuZ2VyKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItcnRsXCIpLCBkaXJlY3Rpb24gPT09IFwicnRsXCIpLCBfY2xhc3NOYW1lcyksIGNsYXNzTmFtZSk7XG4gIHZhciBpY29uTm9kZSA9IGljb24gJiYgIWlubmVyTG9hZGluZyA/IGljb24gOiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChMb2FkaW5nSWNvbiQxLCB7XG4gICAgZXhpc3RJY29uOiAhIWljb24sXG4gICAgcHJlZml4Q2xzLFxuICAgIGxvYWRpbmc6ICEhaW5uZXJMb2FkaW5nXG4gIH0pO1xuICB2YXIga2lkcyA9IGNoaWxkcmVuIHx8IGNoaWxkcmVuID09PSAwID8gc3BhY2VDaGlsZHJlbihjaGlsZHJlbiwgaXNOZWVkSW5zZXJ0ZWQoKSAmJiBhdXRvSW5zZXJ0U3BhY2UpIDogbnVsbDtcbiAgdmFyIGxpbmtCdXR0b25SZXN0UHJvcHMgPSBvbWl0KHJlc3QsIFtcIm5hdmlnYXRlXCJdKTtcbiAgaWYgKGxpbmtCdXR0b25SZXN0UHJvcHMuaHJlZiAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBfZXh0ZW5kcyQxKHt9LCBsaW5rQnV0dG9uUmVzdFByb3BzLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzZXMsXG4gICAgICBvbkNsaWNrOiBoYW5kbGVDbGljayxcbiAgICAgIHJlZjogYnV0dG9uUmVmXG4gICAgfSksIGljb25Ob2RlLCBraWRzKTtcbiAgfVxuICB2YXIgYnV0dG9uTm9kZSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIF9leHRlbmRzJDEoe30sIHJlc3QsIHtcbiAgICB0eXBlOiBodG1sVHlwZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMsXG4gICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgcmVmOiBidXR0b25SZWZcbiAgfSksIGljb25Ob2RlLCBraWRzKTtcbiAgaWYgKGlzVW5ib3JkZXJlZEJ1dHRvblR5cGUodHlwZTQpKSB7XG4gICAgcmV0dXJuIGJ1dHRvbk5vZGU7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFdhdmUsIHtcbiAgICBkaXNhYmxlZDogISFpbm5lckxvYWRpbmdcbiAgfSwgYnV0dG9uTm9kZSk7XG59O1xudmFyIEJ1dHRvbiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5mb3J3YXJkUmVmKEludGVybmFsQnV0dG9uKTtcbkJ1dHRvbi5kaXNwbGF5TmFtZSA9IFwiQnV0dG9uXCI7XG5CdXR0b24uR3JvdXAgPSBHcm91cDI7XG5CdXR0b24uX19BTlRfQlVUVE9OID0gdHJ1ZTtcbnZhciBCdXR0b24kMSA9IEJ1dHRvbjtcbnZhciBfX3Jlc3QkMiA9IGdsb2JhbFRoaXMgJiYgZ2xvYmFsVGhpcy5fX3Jlc3QgfHwgZnVuY3Rpb24ocywgZTIpIHtcbiAgdmFyIHQyID0ge307XG4gIGZvciAodmFyIHAyIGluIHMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHAyKSAmJiBlMi5pbmRleE9mKHAyKSA8IDApXG4gICAgICB0MltwMl0gPSBzW3AyXTtcbiAgfVxuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgZm9yICh2YXIgaSA9IDAsIHAyID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZTIuaW5kZXhPZihwMltpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwMltpXSkpXG4gICAgICAgIHQyW3AyW2ldXSA9IHNbcDJbaV1dO1xuICAgIH1cbiAgcmV0dXJuIHQyO1xufTtcbnZhciBTZWFyY2ggPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbihwcm9wcywgcmVmKSB7XG4gIHZhciBfY2xhc3NOYW1lcztcbiAgdmFyIGN1c3RvbWl6ZVByZWZpeENscyA9IHByb3BzLnByZWZpeENscywgY3VzdG9taXplSW5wdXRQcmVmaXhDbHMgPSBwcm9wcy5pbnB1dFByZWZpeENscywgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLCBjdXN0b21pemVTaXplID0gcHJvcHMuc2l6ZSwgc3VmZml4ID0gcHJvcHMuc3VmZml4LCBfcHJvcHMkZW50ZXJCdXR0b24gPSBwcm9wcy5lbnRlckJ1dHRvbiwgZW50ZXJCdXR0b24gPSBfcHJvcHMkZW50ZXJCdXR0b24gPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGVudGVyQnV0dG9uLCBhZGRvbkFmdGVyID0gcHJvcHMuYWRkb25BZnRlciwgbG9hZGluZyA9IHByb3BzLmxvYWRpbmcsIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQsIGN1c3RvbU9uU2VhcmNoID0gcHJvcHMub25TZWFyY2gsIGN1c3RvbU9uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2UsIHJlc3RQcm9wcyA9IF9fcmVzdCQyKHByb3BzLCBbXCJwcmVmaXhDbHNcIiwgXCJpbnB1dFByZWZpeENsc1wiLCBcImNsYXNzTmFtZVwiLCBcInNpemVcIiwgXCJzdWZmaXhcIiwgXCJlbnRlckJ1dHRvblwiLCBcImFkZG9uQWZ0ZXJcIiwgXCJsb2FkaW5nXCIsIFwiZGlzYWJsZWRcIiwgXCJvblNlYXJjaFwiLCBcIm9uQ2hhbmdlXCJdKTtcbiAgdmFyIF9SZWFjdCR1c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChDb25maWdDb250ZXh0KSwgZ2V0UHJlZml4Q2xzID0gX1JlYWN0JHVzZUNvbnRleHQuZ2V0UHJlZml4Q2xzLCBkaXJlY3Rpb24gPSBfUmVhY3QkdXNlQ29udGV4dC5kaXJlY3Rpb247XG4gIHZhciBjb250ZXh0U2l6ZSA9IFJlYWN0LnVzZUNvbnRleHQoU2l6ZUNvbnRleHQkMSk7XG4gIHZhciBzaXplID0gY3VzdG9taXplU2l6ZSB8fCBjb250ZXh0U2l6ZTtcbiAgdmFyIGlucHV0UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgb25DaGFuZ2UgPSBmdW5jdGlvbiBvbkNoYW5nZTIoZTIpIHtcbiAgICBpZiAoZTIgJiYgZTIudGFyZ2V0ICYmIGUyLnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXN0b21PblNlYXJjaCkge1xuICAgICAgY3VzdG9tT25TZWFyY2goZTIudGFyZ2V0LnZhbHVlLCBlMik7XG4gICAgfVxuICAgIGlmIChjdXN0b21PbkNoYW5nZSkge1xuICAgICAgY3VzdG9tT25DaGFuZ2UoZTIpO1xuICAgIH1cbiAgfTtcbiAgdmFyIG9uTW91c2VEb3duID0gZnVuY3Rpb24gb25Nb3VzZURvd24yKGUyKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSAoKF9hID0gaW5wdXRSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlucHV0KSkge1xuICAgICAgZTIucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG4gIHZhciBvblNlYXJjaCA9IGZ1bmN0aW9uIG9uU2VhcmNoMihlMikge1xuICAgIHZhciBfYTtcbiAgICBpZiAoY3VzdG9tT25TZWFyY2gpIHtcbiAgICAgIGN1c3RvbU9uU2VhcmNoKChfYSA9IGlucHV0UmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnB1dC52YWx1ZSwgZTIpO1xuICAgIH1cbiAgfTtcbiAgdmFyIHByZWZpeENscyA9IGdldFByZWZpeENscyhcImlucHV0LXNlYXJjaFwiLCBjdXN0b21pemVQcmVmaXhDbHMpO1xuICB2YXIgaW5wdXRQcmVmaXhDbHMgPSBnZXRQcmVmaXhDbHMoXCJpbnB1dFwiLCBjdXN0b21pemVJbnB1dFByZWZpeENscyk7XG4gIHZhciBzZWFyY2hJY29uID0gdHlwZW9mIGVudGVyQnV0dG9uID09PSBcImJvb2xlYW5cIiA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFNlYXJjaE91dGxpbmVkJDEsIG51bGwpIDogbnVsbDtcbiAgdmFyIGJ0bkNsYXNzTmFtZSA9IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItYnV0dG9uXCIpO1xuICB2YXIgYnV0dG9uO1xuICB2YXIgZW50ZXJCdXR0b25Bc0VsZW1lbnQgPSBlbnRlckJ1dHRvbiB8fCB7fTtcbiAgdmFyIGlzQW50ZEJ1dHRvbiA9IGVudGVyQnV0dG9uQXNFbGVtZW50LnR5cGUgJiYgZW50ZXJCdXR0b25Bc0VsZW1lbnQudHlwZS5fX0FOVF9CVVRUT04gPT09IHRydWU7XG4gIGlmIChpc0FudGRCdXR0b24gfHwgZW50ZXJCdXR0b25Bc0VsZW1lbnQudHlwZSA9PT0gXCJidXR0b25cIikge1xuICAgIGJ1dHRvbiA9IGNsb25lRWxlbWVudChlbnRlckJ1dHRvbkFzRWxlbWVudCwgX2V4dGVuZHMkMSh7XG4gICAgICBvbk1vdXNlRG93bixcbiAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZTIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgKF9iID0gKF9hID0gZW50ZXJCdXR0b25Bc0VsZW1lbnQgPT09IG51bGwgfHwgZW50ZXJCdXR0b25Bc0VsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVudGVyQnV0dG9uQXNFbGVtZW50LnByb3BzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25DbGljaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGUyKTtcbiAgICAgICAgb25TZWFyY2goZTIpO1xuICAgICAgfSxcbiAgICAgIGtleTogXCJlbnRlckJ1dHRvblwiXG4gICAgfSwgaXNBbnRkQnV0dG9uID8ge1xuICAgICAgY2xhc3NOYW1lOiBidG5DbGFzc05hbWUsXG4gICAgICBzaXplXG4gICAgfSA6IHt9KSk7XG4gIH0gZWxzZSB7XG4gICAgYnV0dG9uID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uJDEsIHtcbiAgICAgIGNsYXNzTmFtZTogYnRuQ2xhc3NOYW1lLFxuICAgICAgdHlwZTogZW50ZXJCdXR0b24gPyBcInByaW1hcnlcIiA6IHZvaWQgMCxcbiAgICAgIHNpemUsXG4gICAgICBkaXNhYmxlZCxcbiAgICAgIGtleTogXCJlbnRlckJ1dHRvblwiLFxuICAgICAgb25Nb3VzZURvd24sXG4gICAgICBvbkNsaWNrOiBvblNlYXJjaCxcbiAgICAgIGxvYWRpbmcsXG4gICAgICBpY29uOiBzZWFyY2hJY29uXG4gICAgfSwgZW50ZXJCdXR0b24pO1xuICB9XG4gIGlmIChhZGRvbkFmdGVyKSB7XG4gICAgYnV0dG9uID0gW2J1dHRvbiwgY2xvbmVFbGVtZW50KGFkZG9uQWZ0ZXIsIHtcbiAgICAgIGtleTogXCJhZGRvbkFmdGVyXCJcbiAgICB9KV07XG4gIH1cbiAgdmFyIGNscyA9IGNsYXNzTmFtZXMocHJlZml4Q2xzLCAoX2NsYXNzTmFtZXMgPSB7fSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItcnRsXCIpLCBkaXJlY3Rpb24gPT09IFwicnRsXCIpLCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lcywgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1cIikuY29uY2F0KHNpemUpLCAhIXNpemUpLCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lcywgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi13aXRoLWJ1dHRvblwiKSwgISFlbnRlckJ1dHRvbiksIF9jbGFzc05hbWVzKSwgY2xhc3NOYW1lKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KElucHV0JDEsIF9leHRlbmRzJDEoe1xuICAgIHJlZjogY29tcG9zZVJlZihpbnB1dFJlZiwgcmVmKSxcbiAgICBvblByZXNzRW50ZXI6IG9uU2VhcmNoXG4gIH0sIHJlc3RQcm9wcywge1xuICAgIHNpemUsXG4gICAgcHJlZml4Q2xzOiBpbnB1dFByZWZpeENscyxcbiAgICBhZGRvbkFmdGVyOiBidXR0b24sXG4gICAgc3VmZml4LFxuICAgIG9uQ2hhbmdlLFxuICAgIGNsYXNzTmFtZTogY2xzLFxuICAgIGRpc2FibGVkXG4gIH0pKTtcbn0pO1xuU2VhcmNoLmRpc3BsYXlOYW1lID0gXCJTZWFyY2hcIjtcbnZhciBTZWFyY2gkMSA9IFNlYXJjaDtcbnZhciBlbGVtZW50TGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIG9uUmVzaXplKGVudGl0aWVzKSB7XG4gIGVudGl0aWVzLmZvckVhY2goZnVuY3Rpb24oZW50aXR5KSB7XG4gICAgdmFyIF9lbGVtZW50TGlzdGVuZXJzJGdldDtcbiAgICB2YXIgdGFyZ2V0ID0gZW50aXR5LnRhcmdldDtcbiAgICAoX2VsZW1lbnRMaXN0ZW5lcnMkZ2V0ID0gZWxlbWVudExpc3RlbmVycy5nZXQodGFyZ2V0KSkgPT09IG51bGwgfHwgX2VsZW1lbnRMaXN0ZW5lcnMkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZWxlbWVudExpc3RlbmVycyRnZXQuZm9yRWFjaChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyKHRhcmdldCk7XG4gICAgfSk7XG4gIH0pO1xufVxudmFyIHJlc2l6ZU9ic2VydmVyID0gbmV3IGluZGV4KG9uUmVzaXplKTtcbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgaWYgKCFlbGVtZW50TGlzdGVuZXJzLmhhcyhlbGVtZW50KSkge1xuICAgIGVsZW1lbnRMaXN0ZW5lcnMuc2V0KGVsZW1lbnQsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gIH1cbiAgZWxlbWVudExpc3RlbmVycy5nZXQoZWxlbWVudCkuYWRkKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHVub2JzZXJ2ZShlbGVtZW50LCBjYWxsYmFjaykge1xuICBpZiAoZWxlbWVudExpc3RlbmVycy5oYXMoZWxlbWVudCkpIHtcbiAgICBlbGVtZW50TGlzdGVuZXJzLmdldChlbGVtZW50KS5kZWxldGUoY2FsbGJhY2spO1xuICAgIGlmICghZWxlbWVudExpc3RlbmVycy5nZXQoZWxlbWVudCkuc2l6ZSkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgZWxlbWVudExpc3RlbmVycy5kZWxldGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG59XG52YXIgRG9tV3JhcHBlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhEb21XcmFwcGVyMiwgX1JlYWN0JENvbXBvbmVudCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRG9tV3JhcHBlcjIpO1xuICBmdW5jdGlvbiBEb21XcmFwcGVyMigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9tV3JhcHBlcjIpO1xuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoRG9tV3JhcHBlcjIsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERvbVdyYXBwZXIyO1xufShSZWFjdC5Db21wb25lbnQpO1xudmFyIENvbGxlY3Rpb25Db250ZXh0ID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiBDb2xsZWN0aW9uKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbiwgb25CYXRjaFJlc2l6ZSA9IF9yZWYub25CYXRjaFJlc2l6ZTtcbiAgdmFyIHJlc2l6ZUlkUmVmID0gUmVhY3QudXNlUmVmKDApO1xuICB2YXIgcmVzaXplSW5mb3NSZWYgPSBSZWFjdC51c2VSZWYoW10pO1xuICB2YXIgb25Db2xsZWN0aW9uUmVzaXplID0gUmVhY3QudXNlQ29udGV4dChDb2xsZWN0aW9uQ29udGV4dCk7XG4gIHZhciBvblJlc2l6ZTIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbihzaXplLCBlbGVtZW50LCBkYXRhKSB7XG4gICAgcmVzaXplSWRSZWYuY3VycmVudCArPSAxO1xuICAgIHZhciBjdXJyZW50SWQgPSByZXNpemVJZFJlZi5jdXJyZW50O1xuICAgIHJlc2l6ZUluZm9zUmVmLmN1cnJlbnQucHVzaCh7XG4gICAgICBzaXplLFxuICAgICAgZWxlbWVudCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGN1cnJlbnRJZCA9PT0gcmVzaXplSWRSZWYuY3VycmVudCkge1xuICAgICAgICBvbkJhdGNoUmVzaXplID09PSBudWxsIHx8IG9uQmF0Y2hSZXNpemUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQmF0Y2hSZXNpemUocmVzaXplSW5mb3NSZWYuY3VycmVudCk7XG4gICAgICAgIHJlc2l6ZUluZm9zUmVmLmN1cnJlbnQgPSBbXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvbkNvbGxlY3Rpb25SZXNpemUgPT09IG51bGwgfHwgb25Db2xsZWN0aW9uUmVzaXplID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNvbGxlY3Rpb25SZXNpemUoc2l6ZSwgZWxlbWVudCwgZGF0YSk7XG4gIH0sIFtvbkJhdGNoUmVzaXplLCBvbkNvbGxlY3Rpb25SZXNpemVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbGxlY3Rpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG9uUmVzaXplMlxuICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBTaW5nbGVPYnNlcnZlcihwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbiwgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZDtcbiAgdmFyIGVsZW1lbnRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciB3cmFwcGVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgb25Db2xsZWN0aW9uUmVzaXplID0gUmVhY3QudXNlQ29udGV4dChDb2xsZWN0aW9uQ29udGV4dCk7XG4gIHZhciBpc1JlbmRlclByb3BzID0gdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCI7XG4gIHZhciBtZXJnZWRDaGlsZHJlbiA9IGlzUmVuZGVyUHJvcHMgPyBjaGlsZHJlbihlbGVtZW50UmVmKSA6IGNoaWxkcmVuO1xuICB2YXIgc2l6ZVJlZiA9IFJlYWN0LnVzZVJlZih7XG4gICAgd2lkdGg6IC0xLFxuICAgIGhlaWdodDogLTEsXG4gICAgb2Zmc2V0V2lkdGg6IC0xLFxuICAgIG9mZnNldEhlaWdodDogLTFcbiAgfSk7XG4gIHZhciBjYW5SZWYgPSAhaXNSZW5kZXJQcm9wcyAmJiAvKiBAX19QVVJFX18gKi8gUmVhY3QuaXNWYWxpZEVsZW1lbnQobWVyZ2VkQ2hpbGRyZW4pICYmIHN1cHBvcnRSZWYobWVyZ2VkQ2hpbGRyZW4pO1xuICB2YXIgb3JpZ2luUmVmID0gY2FuUmVmID8gbWVyZ2VkQ2hpbGRyZW4ucmVmIDogbnVsbDtcbiAgdmFyIG1lcmdlZFJlZiA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbXBvc2VSZWYob3JpZ2luUmVmLCBlbGVtZW50UmVmKTtcbiAgfSwgW29yaWdpblJlZiwgZWxlbWVudFJlZl0pO1xuICB2YXIgcHJvcHNSZWYgPSBSZWFjdC51c2VSZWYocHJvcHMpO1xuICBwcm9wc1JlZi5jdXJyZW50ID0gcHJvcHM7XG4gIHZhciBvbkludGVybmFsUmVzaXplID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgdmFyIF9wcm9wc1JlZiRjdXJyZW50ID0gcHJvcHNSZWYuY3VycmVudCwgb25SZXNpemUyID0gX3Byb3BzUmVmJGN1cnJlbnQub25SZXNpemUsIGRhdGEgPSBfcHJvcHNSZWYkY3VycmVudC5kYXRhO1xuICAgIHZhciBfdGFyZ2V0JGdldEJvdW5kaW5nQ2wgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpZHRoID0gX3RhcmdldCRnZXRCb3VuZGluZ0NsLndpZHRoLCBoZWlnaHQgPSBfdGFyZ2V0JGdldEJvdW5kaW5nQ2wuaGVpZ2h0O1xuICAgIHZhciBvZmZzZXRXaWR0aCA9IHRhcmdldC5vZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0ID0gdGFyZ2V0Lm9mZnNldEhlaWdodDtcbiAgICB2YXIgZml4ZWRXaWR0aCA9IE1hdGguZmxvb3Iod2lkdGgpO1xuICAgIHZhciBmaXhlZEhlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0KTtcbiAgICBpZiAoc2l6ZVJlZi5jdXJyZW50LndpZHRoICE9PSBmaXhlZFdpZHRoIHx8IHNpemVSZWYuY3VycmVudC5oZWlnaHQgIT09IGZpeGVkSGVpZ2h0IHx8IHNpemVSZWYuY3VycmVudC5vZmZzZXRXaWR0aCAhPT0gb2Zmc2V0V2lkdGggfHwgc2l6ZVJlZi5jdXJyZW50Lm9mZnNldEhlaWdodCAhPT0gb2Zmc2V0SGVpZ2h0KSB7XG4gICAgICB2YXIgc2l6ZSA9IHtcbiAgICAgICAgd2lkdGg6IGZpeGVkV2lkdGgsXG4gICAgICAgIGhlaWdodDogZml4ZWRIZWlnaHQsXG4gICAgICAgIG9mZnNldFdpZHRoLFxuICAgICAgICBvZmZzZXRIZWlnaHRcbiAgICAgIH07XG4gICAgICBzaXplUmVmLmN1cnJlbnQgPSBzaXplO1xuICAgICAgdmFyIG1lcmdlZE9mZnNldFdpZHRoID0gb2Zmc2V0V2lkdGggPT09IE1hdGgucm91bmQod2lkdGgpID8gd2lkdGggOiBvZmZzZXRXaWR0aDtcbiAgICAgIHZhciBtZXJnZWRPZmZzZXRIZWlnaHQgPSBvZmZzZXRIZWlnaHQgPT09IE1hdGgucm91bmQoaGVpZ2h0KSA/IGhlaWdodCA6IG9mZnNldEhlaWdodDtcbiAgICAgIHZhciBzaXplSW5mbyA9IF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwgc2l6ZSksIHt9LCB7XG4gICAgICAgIG9mZnNldFdpZHRoOiBtZXJnZWRPZmZzZXRXaWR0aCxcbiAgICAgICAgb2Zmc2V0SGVpZ2h0OiBtZXJnZWRPZmZzZXRIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgb25Db2xsZWN0aW9uUmVzaXplID09PSBudWxsIHx8IG9uQ29sbGVjdGlvblJlc2l6ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Db2xsZWN0aW9uUmVzaXplKHNpemVJbmZvLCB0YXJnZXQsIGRhdGEpO1xuICAgICAgaWYgKG9uUmVzaXplMikge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG9uUmVzaXplMihzaXplSW5mbywgdGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBmaW5kRE9NTm9kZShlbGVtZW50UmVmLmN1cnJlbnQpIHx8IGZpbmRET01Ob2RlKHdyYXBwZXJSZWYuY3VycmVudCk7XG4gICAgaWYgKGN1cnJlbnRFbGVtZW50ICYmICFkaXNhYmxlZCkge1xuICAgICAgb2JzZXJ2ZShjdXJyZW50RWxlbWVudCwgb25JbnRlcm5hbFJlc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB1bm9ic2VydmUoY3VycmVudEVsZW1lbnQsIG9uSW50ZXJuYWxSZXNpemUpO1xuICAgIH07XG4gIH0sIFtlbGVtZW50UmVmLmN1cnJlbnQsIGRpc2FibGVkXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChEb21XcmFwcGVyLCB7XG4gICAgcmVmOiB3cmFwcGVyUmVmXG4gIH0sIGNhblJlZiA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jbG9uZUVsZW1lbnQobWVyZ2VkQ2hpbGRyZW4sIHtcbiAgICByZWY6IG1lcmdlZFJlZlxuICB9KSA6IG1lcmdlZENoaWxkcmVuKTtcbn1cbnZhciBJTlRFUk5BTF9QUkVGSVhfS0VZID0gXCJyYy1vYnNlcnZlci1rZXlcIjtcbmZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICB2YXIgY2hpbGROb2RlcyA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gW2NoaWxkcmVuXSA6IHRvQXJyYXkkMShjaGlsZHJlbik7XG4gIHJldHVybiBjaGlsZE5vZGVzLm1hcChmdW5jdGlvbihjaGlsZCwgaW5kZXgyKSB7XG4gICAgdmFyIGtleTIgPSAoY2hpbGQgPT09IG51bGwgfHwgY2hpbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkLmtleSkgfHwgXCJcIi5jb25jYXQoSU5URVJOQUxfUFJFRklYX0tFWSwgXCItXCIpLmNvbmNhdChpbmRleDIpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChTaW5nbGVPYnNlcnZlciwgX2V4dGVuZHMkMSh7fSwgcHJvcHMsIHtcbiAgICAgIGtleToga2V5MlxuICAgIH0pLCBjaGlsZCk7XG4gIH0pO1xufVxuUmVzaXplT2JzZXJ2ZXIuQ29sbGVjdGlvbiA9IENvbGxlY3Rpb247XG52YXIgSElEREVOX1RFWFRBUkVBX1NUWUxFID0gXCJcXG4gIG1pbi1oZWlnaHQ6MCAhaW1wb3J0YW50O1xcbiAgbWF4LWhlaWdodDpub25lICFpbXBvcnRhbnQ7XFxuICBoZWlnaHQ6MCAhaW1wb3J0YW50O1xcbiAgdmlzaWJpbGl0eTpoaWRkZW4gIWltcG9ydGFudDtcXG4gIG92ZXJmbG93OmhpZGRlbiAhaW1wb3J0YW50O1xcbiAgcG9zaXRpb246YWJzb2x1dGUgIWltcG9ydGFudDtcXG4gIHotaW5kZXg6LTEwMDAgIWltcG9ydGFudDtcXG4gIHRvcDowICFpbXBvcnRhbnQ7XFxuICByaWdodDowICFpbXBvcnRhbnRcXG5cIjtcbnZhciBTSVpJTkdfU1RZTEUgPSBbXCJsZXR0ZXItc3BhY2luZ1wiLCBcImxpbmUtaGVpZ2h0XCIsIFwicGFkZGluZy10b3BcIiwgXCJwYWRkaW5nLWJvdHRvbVwiLCBcImZvbnQtZmFtaWx5XCIsIFwiZm9udC13ZWlnaHRcIiwgXCJmb250LXNpemVcIiwgXCJmb250LXZhcmlhbnRcIiwgXCJ0ZXh0LXJlbmRlcmluZ1wiLCBcInRleHQtdHJhbnNmb3JtXCIsIFwid2lkdGhcIiwgXCJ0ZXh0LWluZGVudFwiLCBcInBhZGRpbmctbGVmdFwiLCBcInBhZGRpbmctcmlnaHRcIiwgXCJib3JkZXItd2lkdGhcIiwgXCJib3gtc2l6aW5nXCIsIFwid29yZC1icmVha1wiXTtcbnZhciBjb21wdXRlZFN0eWxlQ2FjaGUgPSB7fTtcbnZhciBoaWRkZW5UZXh0YXJlYTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZU5vZGVTdHlsaW5nKG5vZGUpIHtcbiAgdmFyIHVzZUNhY2hlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIG5vZGVSZWYgPSBub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpIHx8IG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWFjdGlkXCIpIHx8IG5vZGUuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcbiAgaWYgKHVzZUNhY2hlICYmIGNvbXB1dGVkU3R5bGVDYWNoZVtub2RlUmVmXSkge1xuICAgIHJldHVybiBjb21wdXRlZFN0eWxlQ2FjaGVbbm9kZVJlZl07XG4gIH1cbiAgdmFyIHN0eWxlMiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICB2YXIgYm94U2l6aW5nID0gc3R5bGUyLmdldFByb3BlcnR5VmFsdWUoXCJib3gtc2l6aW5nXCIpIHx8IHN0eWxlMi5nZXRQcm9wZXJ0eVZhbHVlKFwiLW1vei1ib3gtc2l6aW5nXCIpIHx8IHN0eWxlMi5nZXRQcm9wZXJ0eVZhbHVlKFwiLXdlYmtpdC1ib3gtc2l6aW5nXCIpO1xuICB2YXIgcGFkZGluZ1NpemUgPSBwYXJzZUZsb2F0KHN0eWxlMi5nZXRQcm9wZXJ0eVZhbHVlKFwicGFkZGluZy1ib3R0b21cIikpICsgcGFyc2VGbG9hdChzdHlsZTIuZ2V0UHJvcGVydHlWYWx1ZShcInBhZGRpbmctdG9wXCIpKTtcbiAgdmFyIGJvcmRlclNpemUgPSBwYXJzZUZsb2F0KHN0eWxlMi5nZXRQcm9wZXJ0eVZhbHVlKFwiYm9yZGVyLWJvdHRvbS13aWR0aFwiKSkgKyBwYXJzZUZsb2F0KHN0eWxlMi5nZXRQcm9wZXJ0eVZhbHVlKFwiYm9yZGVyLXRvcC13aWR0aFwiKSk7XG4gIHZhciBzaXppbmdTdHlsZSA9IFNJWklOR19TVFlMRS5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChuYW1lLCBcIjpcIikuY29uY2F0KHN0eWxlMi5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpKTtcbiAgfSkuam9pbihcIjtcIik7XG4gIHZhciBub2RlSW5mbyA9IHtcbiAgICBzaXppbmdTdHlsZSxcbiAgICBwYWRkaW5nU2l6ZSxcbiAgICBib3JkZXJTaXplLFxuICAgIGJveFNpemluZ1xuICB9O1xuICBpZiAodXNlQ2FjaGUgJiYgbm9kZVJlZikge1xuICAgIGNvbXB1dGVkU3R5bGVDYWNoZVtub2RlUmVmXSA9IG5vZGVJbmZvO1xuICB9XG4gIHJldHVybiBub2RlSW5mbztcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5vZGVIZWlnaHQodWlUZXh0Tm9kZSkge1xuICB2YXIgdXNlQ2FjaGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgbWluUm93cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgdmFyIG1heFJvd3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gIGlmICghaGlkZGVuVGV4dGFyZWEpIHtcbiAgICBoaWRkZW5UZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICBoaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoXCJ0YWItaW5kZXhcIiwgXCItMVwiKTtcbiAgICBoaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChoaWRkZW5UZXh0YXJlYSk7XG4gIH1cbiAgaWYgKHVpVGV4dE5vZGUuZ2V0QXR0cmlidXRlKFwid3JhcFwiKSkge1xuICAgIGhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZShcIndyYXBcIiwgdWlUZXh0Tm9kZS5nZXRBdHRyaWJ1dGUoXCJ3cmFwXCIpKTtcbiAgfSBlbHNlIHtcbiAgICBoaWRkZW5UZXh0YXJlYS5yZW1vdmVBdHRyaWJ1dGUoXCJ3cmFwXCIpO1xuICB9XG4gIHZhciBfY2FsY3VsYXRlTm9kZVN0eWxpbmcgPSBjYWxjdWxhdGVOb2RlU3R5bGluZyh1aVRleHROb2RlLCB1c2VDYWNoZSksIHBhZGRpbmdTaXplID0gX2NhbGN1bGF0ZU5vZGVTdHlsaW5nLnBhZGRpbmdTaXplLCBib3JkZXJTaXplID0gX2NhbGN1bGF0ZU5vZGVTdHlsaW5nLmJvcmRlclNpemUsIGJveFNpemluZyA9IF9jYWxjdWxhdGVOb2RlU3R5bGluZy5ib3hTaXppbmcsIHNpemluZ1N0eWxlID0gX2NhbGN1bGF0ZU5vZGVTdHlsaW5nLnNpemluZ1N0eWxlO1xuICBoaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiLmNvbmNhdChzaXppbmdTdHlsZSwgXCI7XCIpLmNvbmNhdChISURERU5fVEVYVEFSRUFfU1RZTEUpKTtcbiAgaGlkZGVuVGV4dGFyZWEudmFsdWUgPSB1aVRleHROb2RlLnZhbHVlIHx8IHVpVGV4dE5vZGUucGxhY2Vob2xkZXIgfHwgXCJcIjtcbiAgdmFyIG1pbkhlaWdodCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICB2YXIgbWF4SGVpZ2h0ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gIHZhciBoZWlnaHQgPSBoaWRkZW5UZXh0YXJlYS5zY3JvbGxIZWlnaHQ7XG4gIHZhciBvdmVyZmxvd1k7XG4gIGlmIChib3hTaXppbmcgPT09IFwiYm9yZGVyLWJveFwiKSB7XG4gICAgaGVpZ2h0ICs9IGJvcmRlclNpemU7XG4gIH0gZWxzZSBpZiAoYm94U2l6aW5nID09PSBcImNvbnRlbnQtYm94XCIpIHtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ1NpemU7XG4gIH1cbiAgaWYgKG1pblJvd3MgIT09IG51bGwgfHwgbWF4Um93cyAhPT0gbnVsbCkge1xuICAgIGhpZGRlblRleHRhcmVhLnZhbHVlID0gXCIgXCI7XG4gICAgdmFyIHNpbmdsZVJvd0hlaWdodCA9IGhpZGRlblRleHRhcmVhLnNjcm9sbEhlaWdodCAtIHBhZGRpbmdTaXplO1xuICAgIGlmIChtaW5Sb3dzICE9PSBudWxsKSB7XG4gICAgICBtaW5IZWlnaHQgPSBzaW5nbGVSb3dIZWlnaHQgKiBtaW5Sb3dzO1xuICAgICAgaWYgKGJveFNpemluZyA9PT0gXCJib3JkZXItYm94XCIpIHtcbiAgICAgICAgbWluSGVpZ2h0ID0gbWluSGVpZ2h0ICsgcGFkZGluZ1NpemUgKyBib3JkZXJTaXplO1xuICAgICAgfVxuICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgobWluSGVpZ2h0LCBoZWlnaHQpO1xuICAgIH1cbiAgICBpZiAobWF4Um93cyAhPT0gbnVsbCkge1xuICAgICAgbWF4SGVpZ2h0ID0gc2luZ2xlUm93SGVpZ2h0ICogbWF4Um93cztcbiAgICAgIGlmIChib3hTaXppbmcgPT09IFwiYm9yZGVyLWJveFwiKSB7XG4gICAgICAgIG1heEhlaWdodCA9IG1heEhlaWdodCArIHBhZGRpbmdTaXplICsgYm9yZGVyU2l6ZTtcbiAgICAgIH1cbiAgICAgIG92ZXJmbG93WSA9IGhlaWdodCA+IG1heEhlaWdodCA/IFwiXCIgOiBcImhpZGRlblwiO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5taW4obWF4SGVpZ2h0LCBoZWlnaHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGhlaWdodCxcbiAgICBtaW5IZWlnaHQsXG4gICAgbWF4SGVpZ2h0LFxuICAgIG92ZXJmbG93WSxcbiAgICByZXNpemU6IFwibm9uZVwiXG4gIH07XG59XG52YXIgc2hhbGxvd2VxdWFsID0gZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIsIGNvbXBhcmUsIGNvbXBhcmVDb250ZXh0KSB7XG4gIHZhciByZXQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCBvYmpBLCBvYmpCKSA6IHZvaWQgMDtcbiAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuICEhcmV0O1xuICB9XG4gIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSBcIm9iamVjdFwiIHx8ICFvYmpBIHx8IHR5cGVvZiBvYmpCICE9PSBcIm9iamVjdFwiIHx8ICFvYmpCKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBiSGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmJpbmQob2JqQik7XG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGtleXNBLmxlbmd0aDsgaWR4KyspIHtcbiAgICB2YXIga2V5MiA9IGtleXNBW2lkeF07XG4gICAgaWYgKCFiSGFzT3duUHJvcGVydHkoa2V5MikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHZhbHVlQSA9IG9iakFba2V5Ml07XG4gICAgdmFyIHZhbHVlQiA9IG9iakJba2V5Ml07XG4gICAgcmV0ID0gY29tcGFyZSA/IGNvbXBhcmUuY2FsbChjb21wYXJlQ29udGV4dCwgdmFsdWVBLCB2YWx1ZUIsIGtleTIpIDogdm9pZCAwO1xuICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IHJldCA9PT0gdm9pZCAwICYmIHZhbHVlQSAhPT0gdmFsdWVCKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBSRVNJWkVfU1RBVFVTO1xuKGZ1bmN0aW9uKFJFU0laRV9TVEFUVVMyKSB7XG4gIFJFU0laRV9TVEFUVVMyW1JFU0laRV9TVEFUVVMyW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gIFJFU0laRV9TVEFUVVMyW1JFU0laRV9TVEFUVVMyW1wiUkVTSVpJTkdcIl0gPSAxXSA9IFwiUkVTSVpJTkdcIjtcbiAgUkVTSVpFX1NUQVRVUzJbUkVTSVpFX1NUQVRVUzJbXCJSRVNJWkVEXCJdID0gMl0gPSBcIlJFU0laRURcIjtcbn0pKFJFU0laRV9TVEFUVVMgfHwgKFJFU0laRV9TVEFUVVMgPSB7fSkpO1xudmFyIFJlc2l6YWJsZVRleHRBcmVhID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJlc2l6YWJsZVRleHRBcmVhMiwgX1JlYWN0JENvbXBvbmVudCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUmVzaXphYmxlVGV4dEFyZWEyKTtcbiAgZnVuY3Rpb24gUmVzaXphYmxlVGV4dEFyZWEyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNpemFibGVUZXh0QXJlYTIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpO1xuICAgIF90aGlzLm5leHRGcmFtZUFjdGlvbklkID0gdm9pZCAwO1xuICAgIF90aGlzLnJlc2l6ZUZyYW1lSWQgPSB2b2lkIDA7XG4gICAgX3RoaXMudGV4dEFyZWEgPSB2b2lkIDA7XG4gICAgX3RoaXMuc2F2ZVRleHRBcmVhID0gZnVuY3Rpb24odGV4dEFyZWEpIHtcbiAgICAgIF90aGlzLnRleHRBcmVhID0gdGV4dEFyZWE7XG4gICAgfTtcbiAgICBfdGhpcy5oYW5kbGVSZXNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgcmVzaXplU3RhdHVzID0gX3RoaXMuc3RhdGUucmVzaXplU3RhdHVzO1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsIGF1dG9TaXplID0gX3RoaXMkcHJvcHMuYXV0b1NpemUsIG9uUmVzaXplMiA9IF90aGlzJHByb3BzLm9uUmVzaXplO1xuICAgICAgaWYgKHJlc2l6ZVN0YXR1cyAhPT0gUkVTSVpFX1NUQVRVUy5OT05FKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb25SZXNpemUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb25SZXNpemUyKHNpemUpO1xuICAgICAgfVxuICAgICAgaWYgKGF1dG9TaXplKSB7XG4gICAgICAgIF90aGlzLnJlc2l6ZU9uTmV4dEZyYW1lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfdGhpcy5yZXNpemVPbk5leHRGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoX3RoaXMubmV4dEZyYW1lQWN0aW9uSWQpO1xuICAgICAgX3RoaXMubmV4dEZyYW1lQWN0aW9uSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMucmVzaXplVGV4dGFyZWEpO1xuICAgIH07XG4gICAgX3RoaXMucmVzaXplVGV4dGFyZWEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhdXRvU2l6ZSA9IF90aGlzLnByb3BzLmF1dG9TaXplO1xuICAgICAgaWYgKCFhdXRvU2l6ZSB8fCAhX3RoaXMudGV4dEFyZWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG1pblJvd3MgPSBhdXRvU2l6ZS5taW5Sb3dzLCBtYXhSb3dzID0gYXV0b1NpemUubWF4Um93cztcbiAgICAgIHZhciB0ZXh0YXJlYVN0eWxlcyA9IGNhbGN1bGF0ZU5vZGVIZWlnaHQoX3RoaXMudGV4dEFyZWEsIGZhbHNlLCBtaW5Sb3dzLCBtYXhSb3dzKTtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdGV4dGFyZWFTdHlsZXMsXG4gICAgICAgIHJlc2l6ZVN0YXR1czogUkVTSVpFX1NUQVRVUy5SRVNJWklOR1xuICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKF90aGlzLnJlc2l6ZUZyYW1lSWQpO1xuICAgICAgICBfdGhpcy5yZXNpemVGcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHJlc2l6ZVN0YXR1czogUkVTSVpFX1NUQVRVUy5SRVNJWkVEXG4gICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfdGhpcy5yZXNpemVGcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcmVzaXplU3RhdHVzOiBSRVNJWkVfU1RBVFVTLk5PTkVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIF90aGlzLmZpeEZpcmVmb3hBdXRvU2Nyb2xsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF90aGlzLnJlbmRlclRleHRBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gX3RoaXMucHJvcHMsIF90aGlzJHByb3BzMiRwcmVmaXhDbCA9IF90aGlzJHByb3BzMi5wcmVmaXhDbHMsIHByZWZpeENscyA9IF90aGlzJHByb3BzMiRwcmVmaXhDbCA9PT0gdm9pZCAwID8gXCJyYy10ZXh0YXJlYVwiIDogX3RoaXMkcHJvcHMyJHByZWZpeENsLCBhdXRvU2l6ZSA9IF90aGlzJHByb3BzMi5hdXRvU2l6ZSwgb25SZXNpemUyID0gX3RoaXMkcHJvcHMyLm9uUmVzaXplLCBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczIuY2xhc3NOYW1lLCBkaXNhYmxlZCA9IF90aGlzJHByb3BzMi5kaXNhYmxlZDtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSA9IF90aGlzLnN0YXRlLCB0ZXh0YXJlYVN0eWxlcyA9IF90aGlzJHN0YXRlLnRleHRhcmVhU3R5bGVzLCByZXNpemVTdGF0dXMgPSBfdGhpcyRzdGF0ZS5yZXNpemVTdGF0dXM7XG4gICAgICB2YXIgb3RoZXJQcm9wcyA9IG9taXQoX3RoaXMucHJvcHMsIFtcInByZWZpeENsc1wiLCBcIm9uUHJlc3NFbnRlclwiLCBcImF1dG9TaXplXCIsIFwiZGVmYXVsdFZhbHVlXCIsIFwib25SZXNpemVcIl0pO1xuICAgICAgdmFyIGNscyA9IGNsYXNzTmFtZXMocHJlZml4Q2xzLCBjbGFzc05hbWUsIF9kZWZpbmVQcm9wZXJ0eSQxKHt9LCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWRpc2FibGVkXCIpLCBkaXNhYmxlZCkpO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBvdGhlclByb3BzKSB7XG4gICAgICAgIG90aGVyUHJvcHMudmFsdWUgPSBvdGhlclByb3BzLnZhbHVlIHx8IFwiXCI7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGUyID0gX29iamVjdFNwcmVhZDIkMShfb2JqZWN0U3ByZWFkMiQxKF9vYmplY3RTcHJlYWQyJDEoe30sIF90aGlzLnByb3BzLnN0eWxlKSwgdGV4dGFyZWFTdHlsZXMpLCByZXNpemVTdGF0dXMgPT09IFJFU0laRV9TVEFUVVMuUkVTSVpJTkcgPyB7XG4gICAgICAgIG92ZXJmbG93WDogXCJoaWRkZW5cIixcbiAgICAgICAgb3ZlcmZsb3dZOiBcImhpZGRlblwiXG4gICAgICB9IDogbnVsbCk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzaXplT2JzZXJ2ZXIsIHtcbiAgICAgICAgb25SZXNpemU6IF90aGlzLmhhbmRsZVJlc2l6ZSxcbiAgICAgICAgZGlzYWJsZWQ6ICEoYXV0b1NpemUgfHwgb25SZXNpemUyKVxuICAgICAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiLCBfZXh0ZW5kcyQxKHt9LCBvdGhlclByb3BzLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xzLFxuICAgICAgICBzdHlsZTogc3R5bGUyLFxuICAgICAgICByZWY6IF90aGlzLnNhdmVUZXh0QXJlYVxuICAgICAgfSkpKTtcbiAgICB9O1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgdGV4dGFyZWFTdHlsZXM6IHt9LFxuICAgICAgcmVzaXplU3RhdHVzOiBSRVNJWkVfU1RBVFVTLk5PTkVcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoUmVzaXphYmxlVGV4dEFyZWEyLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgaWYgKHByZXZQcm9wcy52YWx1ZSAhPT0gdGhpcy5wcm9wcy52YWx1ZSB8fCAhc2hhbGxvd2VxdWFsKHByZXZQcm9wcy5hdXRvU2l6ZSwgdGhpcy5wcm9wcy5hdXRvU2l6ZSkpIHtcbiAgICAgICAgdGhpcy5yZXNpemVUZXh0YXJlYSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubmV4dEZyYW1lQWN0aW9uSWQpO1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXNpemVGcmFtZUlkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZml4RmlyZWZveEF1dG9TY3JvbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml4RmlyZWZveEF1dG9TY3JvbGwoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy50ZXh0QXJlYSkge1xuICAgICAgICAgIHZhciBjdXJyZW50U3RhcnQgPSB0aGlzLnRleHRBcmVhLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgIHZhciBjdXJyZW50RW5kID0gdGhpcy50ZXh0QXJlYS5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgdGhpcy50ZXh0QXJlYS5zZXRTZWxlY3Rpb25SYW5nZShjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVGV4dEFyZWEoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlc2l6YWJsZVRleHRBcmVhMjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcbnZhciBUZXh0QXJlYSQyID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFRleHRBcmVhMiwgX1JlYWN0JENvbXBvbmVudCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVGV4dEFyZWEyKTtcbiAgZnVuY3Rpb24gVGV4dEFyZWEyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0QXJlYTIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpO1xuICAgIF90aGlzLnJlc2l6YWJsZVRleHRBcmVhID0gdm9pZCAwO1xuICAgIF90aGlzLmZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgICBfdGhpcy5yZXNpemFibGVUZXh0QXJlYS50ZXh0QXJlYS5mb2N1cygpO1xuICAgIH07XG4gICAgX3RoaXMuc2F2ZVRleHRBcmVhID0gZnVuY3Rpb24ocmVzaXphYmxlVGV4dEFyZWEpIHtcbiAgICAgIF90aGlzLnJlc2l6YWJsZVRleHRBcmVhID0gcmVzaXphYmxlVGV4dEFyZWE7XG4gICAgfTtcbiAgICBfdGhpcy5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbihlMikge1xuICAgICAgdmFyIG9uQ2hhbmdlID0gX3RoaXMucHJvcHMub25DaGFuZ2U7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShlMi50YXJnZXQudmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5yZXNpemFibGVUZXh0QXJlYS5yZXNpemVUZXh0YXJlYSgpO1xuICAgICAgfSk7XG4gICAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgICAgb25DaGFuZ2UoZTIpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3RoaXMuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcywgb25QcmVzc0VudGVyID0gX3RoaXMkcHJvcHMub25QcmVzc0VudGVyLCBvbktleURvd24gPSBfdGhpcyRwcm9wcy5vbktleURvd247XG4gICAgICBpZiAoZTIua2V5Q29kZSA9PT0gMTMgJiYgb25QcmVzc0VudGVyKSB7XG4gICAgICAgIG9uUHJlc3NFbnRlcihlMik7XG4gICAgICB9XG4gICAgICBpZiAob25LZXlEb3duKSB7XG4gICAgICAgIG9uS2V5RG93bihlMik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgcHJvcHMudmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvcHMudmFsdWUgPT09IG51bGwgPyBwcm9wcy5kZWZhdWx0VmFsdWUgOiBwcm9wcy52YWx1ZTtcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFRleHRBcmVhMiwgW3tcbiAgICBrZXk6IFwic2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUyKHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCEoXCJ2YWx1ZVwiIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmx1clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBibHVyKCkge1xuICAgICAgdGhpcy5yZXNpemFibGVUZXh0QXJlYS50ZXh0QXJlYS5ibHVyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzaXphYmxlVGV4dEFyZWEsIF9leHRlbmRzJDEoe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuc3RhdGUudmFsdWUsXG4gICAgICAgIG9uS2V5RG93bjogdGhpcy5oYW5kbGVLZXlEb3duLFxuICAgICAgICBvbkNoYW5nZTogdGhpcy5oYW5kbGVDaGFuZ2UsXG4gICAgICAgIHJlZjogdGhpcy5zYXZlVGV4dEFyZWFcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcykge1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogbmV4dFByb3BzLnZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRleHRBcmVhMjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcbnZhciBfX3Jlc3QkMSA9IGdsb2JhbFRoaXMgJiYgZ2xvYmFsVGhpcy5fX3Jlc3QgfHwgZnVuY3Rpb24ocywgZTIpIHtcbiAgdmFyIHQyID0ge307XG4gIGZvciAodmFyIHAyIGluIHMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHAyKSAmJiBlMi5pbmRleE9mKHAyKSA8IDApXG4gICAgICB0MltwMl0gPSBzW3AyXTtcbiAgfVxuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgZm9yICh2YXIgaSA9IDAsIHAyID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZTIuaW5kZXhPZihwMltpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwMltpXSkpXG4gICAgICAgIHQyW3AyW2ldXSA9IHNbcDJbaV1dO1xuICAgIH1cbiAgcmV0dXJuIHQyO1xufTtcbmZ1bmN0aW9uIGZpeEVtb2ppTGVuZ3RoKHZhbHVlLCBtYXhMZW5ndGgpIHtcbiAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheSh2YWx1ZSB8fCBcIlwiKS5zbGljZSgwLCBtYXhMZW5ndGgpLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBzZXRUcmlnZ2VyVmFsdWUoaXNDdXJzb3JJbkVuZCwgcHJlVmFsdWUsIHRyaWdnZXJWYWx1ZSwgbWF4TGVuZ3RoKSB7XG4gIHZhciBuZXdUcmlnZ2VyVmFsdWUgPSB0cmlnZ2VyVmFsdWU7XG4gIGlmIChpc0N1cnNvckluRW5kKSB7XG4gICAgbmV3VHJpZ2dlclZhbHVlID0gZml4RW1vamlMZW5ndGgodHJpZ2dlclZhbHVlLCBtYXhMZW5ndGgpO1xuICB9IGVsc2UgaWYgKF90b0NvbnN1bWFibGVBcnJheShwcmVWYWx1ZSB8fCBcIlwiKS5sZW5ndGggPCB0cmlnZ2VyVmFsdWUubGVuZ3RoICYmIF90b0NvbnN1bWFibGVBcnJheSh0cmlnZ2VyVmFsdWUgfHwgXCJcIikubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgbmV3VHJpZ2dlclZhbHVlID0gcHJlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIG5ld1RyaWdnZXJWYWx1ZTtcbn1cbnZhciBUZXh0QXJlYSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uKF9hLCByZWYpIHtcbiAgdmFyIF9jbGFzc05hbWVzO1xuICB2YXIgY3VzdG9taXplUHJlZml4Q2xzID0gX2EucHJlZml4Q2xzLCBfYSRib3JkZXJlZCA9IF9hLmJvcmRlcmVkLCBib3JkZXJlZCA9IF9hJGJvcmRlcmVkID09PSB2b2lkIDAgPyB0cnVlIDogX2EkYm9yZGVyZWQsIF9hJHNob3dDb3VudCA9IF9hLnNob3dDb3VudCwgc2hvd0NvdW50ID0gX2Ekc2hvd0NvdW50ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hJHNob3dDb3VudCwgbWF4TGVuZ3RoID0gX2EubWF4TGVuZ3RoLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIHN0eWxlMiA9IF9hLnN0eWxlLCBjdXN0b21pemVTaXplID0gX2Euc2l6ZSwgb25Db21wb3NpdGlvblN0YXJ0ID0gX2Eub25Db21wb3NpdGlvblN0YXJ0LCBvbkNvbXBvc2l0aW9uRW5kID0gX2Eub25Db21wb3NpdGlvbkVuZCwgb25DaGFuZ2UgPSBfYS5vbkNoYW5nZSwgcHJvcHMgPSBfX3Jlc3QkMShfYSwgW1wicHJlZml4Q2xzXCIsIFwiYm9yZGVyZWRcIiwgXCJzaG93Q291bnRcIiwgXCJtYXhMZW5ndGhcIiwgXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcInNpemVcIiwgXCJvbkNvbXBvc2l0aW9uU3RhcnRcIiwgXCJvbkNvbXBvc2l0aW9uRW5kXCIsIFwib25DaGFuZ2VcIl0pO1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KENvbmZpZ0NvbnRleHQpLCBnZXRQcmVmaXhDbHMgPSBfUmVhY3QkdXNlQ29udGV4dC5nZXRQcmVmaXhDbHMsIGRpcmVjdGlvbiA9IF9SZWFjdCR1c2VDb250ZXh0LmRpcmVjdGlvbjtcbiAgdmFyIHNpemUgPSBSZWFjdC51c2VDb250ZXh0KFNpemVDb250ZXh0JDEpO1xuICB2YXIgaW5uZXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBjbGVhcmFibGVJbnB1dFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSwgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksIGNvbXBvc2l0aW5nID0gX1JlYWN0JHVzZVN0YXRlMlswXSwgc2V0Q29tcG9zaXRpbmcgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuICB2YXIgb2xkQ29tcG9zaXRpb25WYWx1ZVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICB2YXIgb2xkU2VsZWN0aW9uU3RhcnRSZWYgPSBSZWFjdC51c2VSZWYoMCk7XG4gIHZhciBfdXNlTWVyZ2VkU3RhdGUgPSB1c2VDb250cm9sbGVkU3RhdGUocHJvcHMuZGVmYXVsdFZhbHVlLCB7XG4gICAgdmFsdWU6IHByb3BzLnZhbHVlXG4gIH0pLCBfdXNlTWVyZ2VkU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZU1lcmdlZFN0YXRlLCAyKSwgdmFsdWUgPSBfdXNlTWVyZ2VkU3RhdGUyWzBdLCBzZXRWYWx1ZTIgPSBfdXNlTWVyZ2VkU3RhdGUyWzFdO1xuICB2YXIgaGlkZGVuID0gcHJvcHMuaGlkZGVuO1xuICB2YXIgaGFuZGxlU2V0VmFsdWUgPSBmdW5jdGlvbiBoYW5kbGVTZXRWYWx1ZTIodmFsMiwgY2FsbGJhY2spIHtcbiAgICBpZiAocHJvcHMudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgc2V0VmFsdWUyKHZhbDIpO1xuICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xuICB2YXIgaGFzTWF4TGVuZ3RoID0gTnVtYmVyKG1heExlbmd0aCkgPiAwO1xuICB2YXIgb25JbnRlcm5hbENvbXBvc2l0aW9uU3RhcnQgPSBmdW5jdGlvbiBvbkludGVybmFsQ29tcG9zaXRpb25TdGFydDIoZTIpIHtcbiAgICBzZXRDb21wb3NpdGluZyh0cnVlKTtcbiAgICBvbGRDb21wb3NpdGlvblZhbHVlUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICBvbGRTZWxlY3Rpb25TdGFydFJlZi5jdXJyZW50ID0gZTIuY3VycmVudFRhcmdldC5zZWxlY3Rpb25TdGFydDtcbiAgICBvbkNvbXBvc2l0aW9uU3RhcnQgPT09IG51bGwgfHwgb25Db21wb3NpdGlvblN0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNvbXBvc2l0aW9uU3RhcnQoZTIpO1xuICB9O1xuICB2YXIgb25JbnRlcm5hbENvbXBvc2l0aW9uRW5kID0gZnVuY3Rpb24gb25JbnRlcm5hbENvbXBvc2l0aW9uRW5kMihlMikge1xuICAgIHZhciBfYTI7XG4gICAgc2V0Q29tcG9zaXRpbmcoZmFsc2UpO1xuICAgIHZhciB0cmlnZ2VyVmFsdWUgPSBlMi5jdXJyZW50VGFyZ2V0LnZhbHVlO1xuICAgIGlmIChoYXNNYXhMZW5ndGgpIHtcbiAgICAgIHZhciBpc0N1cnNvckluRW5kID0gb2xkU2VsZWN0aW9uU3RhcnRSZWYuY3VycmVudCA+PSBtYXhMZW5ndGggKyAxIHx8IG9sZFNlbGVjdGlvblN0YXJ0UmVmLmN1cnJlbnQgPT09ICgoX2EyID0gb2xkQ29tcG9zaXRpb25WYWx1ZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMi5sZW5ndGgpO1xuICAgICAgdHJpZ2dlclZhbHVlID0gc2V0VHJpZ2dlclZhbHVlKGlzQ3Vyc29ySW5FbmQsIG9sZENvbXBvc2l0aW9uVmFsdWVSZWYuY3VycmVudCwgdHJpZ2dlclZhbHVlLCBtYXhMZW5ndGgpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlclZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgaGFuZGxlU2V0VmFsdWUodHJpZ2dlclZhbHVlKTtcbiAgICAgIHJlc29sdmVPbkNoYW5nZShlMi5jdXJyZW50VGFyZ2V0LCBlMiwgb25DaGFuZ2UsIHRyaWdnZXJWYWx1ZSk7XG4gICAgfVxuICAgIG9uQ29tcG9zaXRpb25FbmQgPT09IG51bGwgfHwgb25Db21wb3NpdGlvbkVuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Db21wb3NpdGlvbkVuZChlMik7XG4gIH07XG4gIHZhciBoYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UyKGUyKSB7XG4gICAgdmFyIHRyaWdnZXJWYWx1ZSA9IGUyLnRhcmdldC52YWx1ZTtcbiAgICBpZiAoIWNvbXBvc2l0aW5nICYmIGhhc01heExlbmd0aCkge1xuICAgICAgdmFyIGlzQ3Vyc29ySW5FbmQgPSBlMi50YXJnZXQuc2VsZWN0aW9uU3RhcnQgPj0gbWF4TGVuZ3RoICsgMSB8fCBlMi50YXJnZXQuc2VsZWN0aW9uU3RhcnQgPT09IHRyaWdnZXJWYWx1ZS5sZW5ndGggfHwgIWUyLnRhcmdldC5zZWxlY3Rpb25TdGFydDtcbiAgICAgIHRyaWdnZXJWYWx1ZSA9IHNldFRyaWdnZXJWYWx1ZShpc0N1cnNvckluRW5kLCB2YWx1ZSwgdHJpZ2dlclZhbHVlLCBtYXhMZW5ndGgpO1xuICAgIH1cbiAgICBoYW5kbGVTZXRWYWx1ZSh0cmlnZ2VyVmFsdWUpO1xuICAgIHJlc29sdmVPbkNoYW5nZShlMi5jdXJyZW50VGFyZ2V0LCBlMiwgb25DaGFuZ2UsIHRyaWdnZXJWYWx1ZSk7XG4gIH07XG4gIHZhciBoYW5kbGVSZXNldCA9IGZ1bmN0aW9uIGhhbmRsZVJlc2V0MihlMikge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGhhbmRsZVNldFZhbHVlKFwiXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9hMztcbiAgICAgIChfYTMgPSBpbm5lclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMy5mb2N1cygpO1xuICAgIH0pO1xuICAgIHJlc29sdmVPbkNoYW5nZSgoX2IgPSAoX2EyID0gaW5uZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIucmVzaXphYmxlVGV4dEFyZWEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50ZXh0QXJlYSwgZTIsIG9uQ2hhbmdlKTtcbiAgfTtcbiAgdmFyIHByZWZpeENscyA9IGdldFByZWZpeENscyhcImlucHV0XCIsIGN1c3RvbWl6ZVByZWZpeENscyk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiB7XG4gICAgICByZXNpemFibGVUZXh0QXJlYTogKF9hMiA9IGlubmVyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLnJlc2l6YWJsZVRleHRBcmVhLFxuICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKG9wdGlvbikge1xuICAgICAgICB2YXIgX2EzLCBfYjtcbiAgICAgICAgdHJpZ2dlckZvY3VzKChfYiA9IChfYTMgPSBpbm5lclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMy5yZXNpemFibGVUZXh0QXJlYSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRleHRBcmVhLCBvcHRpb24pO1xuICAgICAgfSxcbiAgICAgIGJsdXI6IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgICAgIHZhciBfYTM7XG4gICAgICAgIHJldHVybiAoX2EzID0gaW5uZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTMuYmx1cigpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICB2YXIgdGV4dEFyZWEgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0QXJlYSQyLCBfZXh0ZW5kcyQxKHt9LCBvbWl0KHByb3BzLCBbXCJhbGxvd0NsZWFyXCJdKSwge1xuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcygoX2NsYXNzTmFtZXMgPSB7fSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItYm9yZGVybGVzc1wiKSwgIWJvcmRlcmVkKSwgX2RlZmluZVByb3BlcnR5JDEoX2NsYXNzTmFtZXMsIGNsYXNzTmFtZSwgY2xhc3NOYW1lICYmICFzaG93Q291bnQpLCBfZGVmaW5lUHJvcGVydHkkMShfY2xhc3NOYW1lcywgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1zbVwiKSwgc2l6ZSA9PT0gXCJzbWFsbFwiIHx8IGN1c3RvbWl6ZVNpemUgPT09IFwic21hbGxcIiksIF9kZWZpbmVQcm9wZXJ0eSQxKF9jbGFzc05hbWVzLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWxnXCIpLCBzaXplID09PSBcImxhcmdlXCIgfHwgY3VzdG9taXplU2l6ZSA9PT0gXCJsYXJnZVwiKSwgX2NsYXNzTmFtZXMpKSxcbiAgICBzdHlsZTogc2hvd0NvdW50ID8gdm9pZCAwIDogc3R5bGUyLFxuICAgIHByZWZpeENscyxcbiAgICBvbkNvbXBvc2l0aW9uU3RhcnQ6IG9uSW50ZXJuYWxDb21wb3NpdGlvblN0YXJ0LFxuICAgIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2UsXG4gICAgb25Db21wb3NpdGlvbkVuZDogb25JbnRlcm5hbENvbXBvc2l0aW9uRW5kLFxuICAgIHJlZjogaW5uZXJSZWZcbiAgfSkpO1xuICB2YXIgdmFsID0gZml4Q29udHJvbGxlZFZhbHVlKHZhbHVlKTtcbiAgaWYgKCFjb21wb3NpdGluZyAmJiBoYXNNYXhMZW5ndGggJiYgKHByb3BzLnZhbHVlID09PSBudWxsIHx8IHByb3BzLnZhbHVlID09PSB2b2lkIDApKSB7XG4gICAgdmFsID0gZml4RW1vamlMZW5ndGgodmFsLCBtYXhMZW5ndGgpO1xuICB9XG4gIHZhciB0ZXh0YXJlYU5vZGUgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDbGVhcmFibGVMYWJlbGVkSW5wdXQkMSwgX2V4dGVuZHMkMSh7fSwgcHJvcHMsIHtcbiAgICBwcmVmaXhDbHMsXG4gICAgZGlyZWN0aW9uLFxuICAgIGlucHV0VHlwZTogXCJ0ZXh0XCIsXG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbGVtZW50OiB0ZXh0QXJlYSxcbiAgICBoYW5kbGVSZXNldCxcbiAgICByZWY6IGNsZWFyYWJsZUlucHV0UmVmLFxuICAgIGJvcmRlcmVkLFxuICAgIHN0eWxlOiBzaG93Q291bnQgPyB2b2lkIDAgOiBzdHlsZTJcbiAgfSkpO1xuICBpZiAoc2hvd0NvdW50KSB7XG4gICAgdmFyIHZhbHVlTGVuZ3RoID0gX3RvQ29uc3VtYWJsZUFycmF5KHZhbCkubGVuZ3RoO1xuICAgIHZhciBkYXRhQ291bnQgPSBcIlwiO1xuICAgIGlmIChfdHlwZW9mJDEoc2hvd0NvdW50KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZGF0YUNvdW50ID0gc2hvd0NvdW50LmZvcm1hdHRlcih7XG4gICAgICAgIGNvdW50OiB2YWx1ZUxlbmd0aCxcbiAgICAgICAgbWF4TGVuZ3RoXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YUNvdW50ID0gXCJcIi5jb25jYXQodmFsdWVMZW5ndGgpLmNvbmNhdChoYXNNYXhMZW5ndGggPyBcIiAvIFwiLmNvbmNhdChtYXhMZW5ndGgpIDogXCJcIik7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBoaWRkZW4sXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi10ZXh0YXJlYVwiKSwgX2RlZmluZVByb3BlcnR5JDEoe30sIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItdGV4dGFyZWEtcnRsXCIpLCBkaXJlY3Rpb24gPT09IFwicnRsXCIpLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXRleHRhcmVhLXNob3ctY291bnRcIiksIGNsYXNzTmFtZSksXG4gICAgICBzdHlsZTogc3R5bGUyLFxuICAgICAgXCJkYXRhLWNvdW50XCI6IGRhdGFDb3VudFxuICAgIH0sIHRleHRhcmVhTm9kZSk7XG4gIH1cbiAgcmV0dXJuIHRleHRhcmVhTm9kZTtcbn0pO1xudmFyIFRleHRBcmVhJDEgPSBUZXh0QXJlYTtcbnZhciBFeWVPdXRsaW5lZCQyID0geyBcImljb25cIjogeyBcInRhZ1wiOiBcInN2Z1wiLCBcImF0dHJzXCI6IHsgXCJ2aWV3Qm94XCI6IFwiNjQgNjQgODk2IDg5NlwiLCBcImZvY3VzYWJsZVwiOiBcImZhbHNlXCIgfSwgXCJjaGlsZHJlblwiOiBbeyBcInRhZ1wiOiBcInBhdGhcIiwgXCJhdHRyc1wiOiB7IFwiZFwiOiBcIk05NDIuMiA0ODYuMkM4NDcuNCAyODYuNSA3MDQuMSAxODYgNTEyIDE4NmMtMTkyLjIgMC0zMzUuNCAxMDAuNS00MzAuMiAzMDAuM2E2MC4zIDYwLjMgMCAwMDAgNTEuNUMxNzYuNiA3MzcuNSAzMTkuOSA4MzggNTEyIDgzOGMxOTIuMiAwIDMzNS40LTEwMC41IDQzMC4yLTMwMC4zIDcuNy0xNi4yIDcuNy0zNSAwLTUxLjV6TTUxMiA3NjZjLTE2MS4zIDAtMjc5LjQtODEuOC0zNjIuNy0yNTRDMjMyLjYgMzM5LjggMzUwLjcgMjU4IDUxMiAyNThjMTYxLjMgMCAyNzkuNCA4MS44IDM2Mi43IDI1NEM3OTEuNSA2ODQuMiA2NzMuNCA3NjYgNTEyIDc2NnptLTQtNDMwYy05Ny4yIDAtMTc2IDc4LjgtMTc2IDE3NnM3OC44IDE3NiAxNzYgMTc2IDE3Ni03OC44IDE3Ni0xNzYtNzguOC0xNzYtMTc2LTE3NnptMCAyODhjLTYxLjkgMC0xMTItNTAuMS0xMTItMTEyczUwLjEtMTEyIDExMi0xMTIgMTEyIDUwLjEgMTEyIDExMi01MC4xIDExMi0xMTIgMTEyelwiIH0gfV0gfSwgXCJuYW1lXCI6IFwiZXllXCIsIFwidGhlbWVcIjogXCJvdXRsaW5lZFwiIH07XG52YXIgRXllT3V0bGluZWRTdmcgPSBFeWVPdXRsaW5lZCQyO1xudmFyIEV5ZU91dGxpbmVkID0gZnVuY3Rpb24gRXllT3V0bGluZWQyKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEFudGRJY29uLCBfb2JqZWN0U3ByZWFkMiQxKF9vYmplY3RTcHJlYWQyJDEoe30sIHByb3BzKSwge30sIHtcbiAgICByZWYsXG4gICAgaWNvbjogRXllT3V0bGluZWRTdmdcbiAgfSkpO1xufTtcbkV5ZU91dGxpbmVkLmRpc3BsYXlOYW1lID0gXCJFeWVPdXRsaW5lZFwiO1xudmFyIEV5ZU91dGxpbmVkJDEgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuZm9yd2FyZFJlZihFeWVPdXRsaW5lZCk7XG52YXIgRXllSW52aXNpYmxlT3V0bGluZWQkMiA9IHsgXCJpY29uXCI6IHsgXCJ0YWdcIjogXCJzdmdcIiwgXCJhdHRyc1wiOiB7IFwidmlld0JveFwiOiBcIjY0IDY0IDg5NiA4OTZcIiwgXCJmb2N1c2FibGVcIjogXCJmYWxzZVwiIH0sIFwiY2hpbGRyZW5cIjogW3sgXCJ0YWdcIjogXCJwYXRoXCIsIFwiYXR0cnNcIjogeyBcImRcIjogXCJNOTQyLjIgNDg2LjJRODg5LjQ3IDM3NS4xMSA4MTYuNyAzMDVsLTUwLjg4IDUwLjg4QzgwNy4zMSAzOTUuNTMgODQzLjQ1IDQ0Ny40IDg3NC43IDUxMiA3OTEuNSA2ODQuMiA2NzMuNCA3NjYgNTEyIDc2NnEtNzIuNjcgMC0xMzMuODctMjIuMzhMMzIzIDc5OC43NVE0MDggODM4IDUxMiA4MzhxMjg4LjMgMCA0MzAuMi0zMDAuM2E2MC4yOSA2MC4yOSAwIDAwMC01MS41em0tNjMuNTctMzIwLjY0TDgzNiAxMjIuODhhOCA4IDAgMDAtMTEuMzIgMEw3MTUuMzEgMjMyLjJRNjI0Ljg2IDE4NiA1MTIgMTg2cS0yODguMyAwLTQzMC4yIDMwMC4zYTYwLjMgNjAuMyAwIDAwMCA1MS41cTU2LjY5IDExOS40IDEzNi41IDE5MS40MUwxMTIuNDggODM1YTggOCAwIDAwMCAxMS4zMUwxNTUuMTcgODg5YTggOCAwIDAwMTEuMzEgMGw3MTIuMTUtNzEyLjEyYTggOCAwIDAwMC0xMS4zMnpNMTQ5LjMgNTEyQzIzMi42IDMzOS44IDM1MC43IDI1OCA1MTIgMjU4YzU0LjU0IDAgMTA0LjEzIDkuMzYgMTQ5LjEyIDI4LjM5bC03MC4zIDcwLjNhMTc2IDE3NiAwIDAwLTIzOC4xMyAyMzguMTNsLTgzLjQyIDgzLjQyQzIyMy4xIDYzNy40OSAxODMuMyA1ODIuMjggMTQ5LjMgNTEyem0yNDYuNyAwYTExMi4xMSAxMTIuMTEgMCAwMTE0Ni4yLTEwNi42OUw0MDEuMzEgNTQ2LjJBMTEyIDExMiAwIDAxMzk2IDUxMnpcIiB9IH0sIHsgXCJ0YWdcIjogXCJwYXRoXCIsIFwiYXR0cnNcIjogeyBcImRcIjogXCJNNTA4IDYyNGMtMy40NiAwLTYuODctLjE2LTEwLjI1LS40N2wtNTIuODIgNTIuODJhMTc2LjA5IDE3Ni4wOSAwIDAwMjI3LjQyLTIyNy40MmwtNTIuODIgNTIuODJjLjMxIDMuMzguNDcgNi43OS40NyAxMC4yNWExMTEuOTQgMTExLjk0IDAgMDEtMTEyIDExMnpcIiB9IH1dIH0sIFwibmFtZVwiOiBcImV5ZS1pbnZpc2libGVcIiwgXCJ0aGVtZVwiOiBcIm91dGxpbmVkXCIgfTtcbnZhciBFeWVJbnZpc2libGVPdXRsaW5lZFN2ZyA9IEV5ZUludmlzaWJsZU91dGxpbmVkJDI7XG52YXIgRXllSW52aXNpYmxlT3V0bGluZWQgPSBmdW5jdGlvbiBFeWVJbnZpc2libGVPdXRsaW5lZDIocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW50ZEljb24sIF9vYmplY3RTcHJlYWQyJDEoX29iamVjdFNwcmVhZDIkMSh7fSwgcHJvcHMpLCB7fSwge1xuICAgIHJlZixcbiAgICBpY29uOiBFeWVJbnZpc2libGVPdXRsaW5lZFN2Z1xuICB9KSk7XG59O1xuRXllSW52aXNpYmxlT3V0bGluZWQuZGlzcGxheU5hbWUgPSBcIkV5ZUludmlzaWJsZU91dGxpbmVkXCI7XG52YXIgRXllSW52aXNpYmxlT3V0bGluZWQkMSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5mb3J3YXJkUmVmKEV5ZUludmlzaWJsZU91dGxpbmVkKTtcbnZhciBfX3Jlc3QgPSBnbG9iYWxUaGlzICYmIGdsb2JhbFRoaXMuX19yZXN0IHx8IGZ1bmN0aW9uKHMsIGUyKSB7XG4gIHZhciB0MiA9IHt9O1xuICBmb3IgKHZhciBwMiBpbiBzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwMikgJiYgZTIuaW5kZXhPZihwMikgPCAwKVxuICAgICAgdDJbcDJdID0gc1twMl07XG4gIH1cbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgIGZvciAodmFyIGkgPSAwLCBwMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwMi5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGUyLmluZGV4T2YocDJbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcDJbaV0pKVxuICAgICAgICB0MltwMltpXV0gPSBzW3AyW2ldXTtcbiAgICB9XG4gIHJldHVybiB0Mjtcbn07XG52YXIgQWN0aW9uTWFwID0ge1xuICBjbGljazogXCJvbkNsaWNrXCIsXG4gIGhvdmVyOiBcIm9uTW91c2VPdmVyXCJcbn07XG52YXIgUGFzc3dvcmQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbihwcm9wcywgcmVmKSB7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShmYWxzZSksIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLCB2aXNpYmxlID0gX3VzZVN0YXRlMlswXSwgc2V0VmlzaWJsZSA9IF91c2VTdGF0ZTJbMV07XG4gIHZhciBvblZpc2libGVDaGFuZ2UgPSBmdW5jdGlvbiBvblZpc2libGVDaGFuZ2UyKCkge1xuICAgIHZhciBkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkO1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRWaXNpYmxlKCF2aXNpYmxlKTtcbiAgfTtcbiAgdmFyIGdldEljb24gPSBmdW5jdGlvbiBnZXRJY29uMihwcmVmaXhDbHMpIHtcbiAgICB2YXIgX2ljb25Qcm9wcztcbiAgICB2YXIgYWN0aW9uID0gcHJvcHMuYWN0aW9uLCBfcHJvcHMkaWNvblJlbmRlciA9IHByb3BzLmljb25SZW5kZXIsIGljb25SZW5kZXIyID0gX3Byb3BzJGljb25SZW5kZXIgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSA6IF9wcm9wcyRpY29uUmVuZGVyO1xuICAgIHZhciBpY29uVHJpZ2dlciA9IEFjdGlvbk1hcFthY3Rpb25dIHx8IFwiXCI7XG4gICAgdmFyIGljb24gPSBpY29uUmVuZGVyMih2aXNpYmxlKTtcbiAgICB2YXIgaWNvblByb3BzID0gKF9pY29uUHJvcHMgPSB7fSwgX2RlZmluZVByb3BlcnR5JDEoX2ljb25Qcm9wcywgaWNvblRyaWdnZXIsIG9uVmlzaWJsZUNoYW5nZSksIF9kZWZpbmVQcm9wZXJ0eSQxKF9pY29uUHJvcHMsIFwiY2xhc3NOYW1lXCIsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItaWNvblwiKSksIF9kZWZpbmVQcm9wZXJ0eSQxKF9pY29uUHJvcHMsIFwia2V5XCIsIFwicGFzc3dvcmRJY29uXCIpLCBfZGVmaW5lUHJvcGVydHkkMShfaWNvblByb3BzLCBcIm9uTW91c2VEb3duXCIsIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUyKSB7XG4gICAgICBlMi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pLCBfZGVmaW5lUHJvcGVydHkkMShfaWNvblByb3BzLCBcIm9uTW91c2VVcFwiLCBmdW5jdGlvbiBvbk1vdXNlVXAoZTIpIHtcbiAgICAgIGUyLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSksIF9pY29uUHJvcHMpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY2xvbmVFbGVtZW50KC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5pc1ZhbGlkRWxlbWVudChpY29uKSA/IGljb24gOiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgaWNvbiksIGljb25Qcm9wcyk7XG4gIH07XG4gIHZhciByZW5kZXJQYXNzd29yZCA9IGZ1bmN0aW9uIHJlbmRlclBhc3N3b3JkMihfcmVmKSB7XG4gICAgdmFyIGdldFByZWZpeENscyA9IF9yZWYuZ2V0UHJlZml4Q2xzO1xuICAgIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsIGN1c3RvbWl6ZVByZWZpeENscyA9IHByb3BzLnByZWZpeENscywgY3VzdG9taXplSW5wdXRQcmVmaXhDbHMgPSBwcm9wcy5pbnB1dFByZWZpeENscywgc2l6ZSA9IHByb3BzLnNpemUsIHZpc2liaWxpdHlUb2dnbGUgPSBwcm9wcy52aXNpYmlsaXR5VG9nZ2xlLCByZXN0UHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcImNsYXNzTmFtZVwiLCBcInByZWZpeENsc1wiLCBcImlucHV0UHJlZml4Q2xzXCIsIFwic2l6ZVwiLCBcInZpc2liaWxpdHlUb2dnbGVcIl0pO1xuICAgIHZhciBpbnB1dFByZWZpeENscyA9IGdldFByZWZpeENscyhcImlucHV0XCIsIGN1c3RvbWl6ZUlucHV0UHJlZml4Q2xzKTtcbiAgICB2YXIgcHJlZml4Q2xzID0gZ2V0UHJlZml4Q2xzKFwiaW5wdXQtcGFzc3dvcmRcIiwgY3VzdG9taXplUHJlZml4Q2xzKTtcbiAgICB2YXIgc3VmZml4SWNvbiA9IHZpc2liaWxpdHlUb2dnbGUgJiYgZ2V0SWNvbihwcmVmaXhDbHMpO1xuICAgIHZhciBpbnB1dENsYXNzTmFtZSA9IGNsYXNzTmFtZXMocHJlZml4Q2xzLCBjbGFzc05hbWUsIF9kZWZpbmVQcm9wZXJ0eSQxKHt9LCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLVwiKS5jb25jYXQoc2l6ZSksICEhc2l6ZSkpO1xuICAgIHZhciBvbWl0dGVkUHJvcHMgPSBfZXh0ZW5kcyQxKF9leHRlbmRzJDEoe30sIG9taXQocmVzdFByb3BzLCBbXCJzdWZmaXhcIiwgXCJpY29uUmVuZGVyXCJdKSksIHtcbiAgICAgIHR5cGU6IHZpc2libGUgPyBcInRleHRcIiA6IFwicGFzc3dvcmRcIixcbiAgICAgIGNsYXNzTmFtZTogaW5wdXRDbGFzc05hbWUsXG4gICAgICBwcmVmaXhDbHM6IGlucHV0UHJlZml4Q2xzLFxuICAgICAgc3VmZml4OiBzdWZmaXhJY29uXG4gICAgfSk7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgIG9taXR0ZWRQcm9wcy5zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KElucHV0JDEsIF9leHRlbmRzJDEoe1xuICAgICAgcmVmXG4gICAgfSwgb21pdHRlZFByb3BzKSk7XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb25maWdDb25zdW1lciwgbnVsbCwgcmVuZGVyUGFzc3dvcmQpO1xufSk7XG5QYXNzd29yZC5kZWZhdWx0UHJvcHMgPSB7XG4gIGFjdGlvbjogXCJjbGlja1wiLFxuICB2aXNpYmlsaXR5VG9nZ2xlOiB0cnVlLFxuICBpY29uUmVuZGVyOiBmdW5jdGlvbiBpY29uUmVuZGVyKHZpc2libGUpIHtcbiAgICByZXR1cm4gdmlzaWJsZSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEV5ZU91dGxpbmVkJDEsIG51bGwpIDogLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRXllSW52aXNpYmxlT3V0bGluZWQkMSwgbnVsbCk7XG4gIH1cbn07XG5QYXNzd29yZC5kaXNwbGF5TmFtZSA9IFwiUGFzc3dvcmRcIjtcbnZhciBQYXNzd29yZCQxID0gUGFzc3dvcmQ7XG5JbnB1dCQxLkdyb3VwID0gR3JvdXAkMjtcbklucHV0JDEuU2VhcmNoID0gU2VhcmNoJDE7XG5JbnB1dCQxLlRleHRBcmVhID0gVGV4dEFyZWEkMTtcbklucHV0JDEuUGFzc3dvcmQgPSBQYXNzd29yZCQxO1xuY29uc3QgdGFnSW5wdXQgPSBcIl90YWdJbnB1dF8xNnZlb18xXCI7XG5jb25zdCBpbnB1dCA9IFwiX2lucHV0XzE2dmVvXzFcIjtcbmNvbnN0IGNsZWFyID0gXCJfY2xlYXJfMTZ2ZW9fNVwiO1xudmFyIHN0eWxlcyA9IHtcbiAgdGFnSW5wdXQsXG4gIGlucHV0LFxuICBjbGVhclxufTtcbnZhciBqc3hSdW50aW1lID0geyBleHBvcnRzOiB7fSB9O1xudmFyIHJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbiA9IHt9O1xuLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG4gIHRyeSB7XG4gICAgaWYgKCFPYmplY3QuYXNzaWduKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoXCJhYmNcIik7XG4gICAgdGVzdDFbNV0gPSBcImRlXCI7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gXCI1XCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRlc3QyID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICB0ZXN0MltcIl9cIiArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcbiAgICB9XG4gICAgdmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24objIpIHtcbiAgICAgIHJldHVybiB0ZXN0MltuMl07XG4gICAgfSk7XG4gICAgaWYgKG9yZGVyMi5qb2luKFwiXCIpICE9PSBcIjAxMjM0NTY3ODlcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdGVzdDMgPSB7fTtcbiAgICBcImFiY2RlZmdoaWprbG1ub3BxcnN0XCIuc3BsaXQoXCJcIikuZm9yRWFjaChmdW5jdGlvbihsZXR0ZXIpIHtcbiAgICAgIHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbihcIlwiKSAhPT0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbnNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBmcm9tO1xuICB2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgc3ltYm9scztcbiAgZm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcbiAgICBmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG4gICAgZm9yICh2YXIga2V5MiBpbiBmcm9tKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkyKSkge1xuICAgICAgICB0b1trZXkyXSA9IGZyb21ba2V5Ml07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuICAgICAgICAgIHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59O1xuLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBmID0gUmVhY3RfX2RlZmF1bHQsIGcgPSA2MDEwMztcbnJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbi5GcmFnbWVudCA9IDYwMTA3O1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBoID0gU3ltYm9sLmZvcjtcbiAgZyA9IGgoXCJyZWFjdC5lbGVtZW50XCIpO1xuICByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW4uRnJhZ21lbnQgPSBoKFwicmVhY3QuZnJhZ21lbnRcIik7XG59XG52YXIgbSA9IGYuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIsIG4gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBwID0geyBrZXk6IHRydWUsIHJlZjogdHJ1ZSwgX19zZWxmOiB0cnVlLCBfX3NvdXJjZTogdHJ1ZSB9O1xuZnVuY3Rpb24gcShjMiwgYSwgazIpIHtcbiAgdmFyIGIyLCBkMiA9IHt9LCBlMiA9IG51bGwsIGwyID0gbnVsbDtcbiAgazIgIT09IHZvaWQgMCAmJiAoZTIgPSBcIlwiICsgazIpO1xuICBhLmtleSAhPT0gdm9pZCAwICYmIChlMiA9IFwiXCIgKyBhLmtleSk7XG4gIGEucmVmICE9PSB2b2lkIDAgJiYgKGwyID0gYS5yZWYpO1xuICBmb3IgKGIyIGluIGEpXG4gICAgbi5jYWxsKGEsIGIyKSAmJiAhcC5oYXNPd25Qcm9wZXJ0eShiMikgJiYgKGQyW2IyXSA9IGFbYjJdKTtcbiAgaWYgKGMyICYmIGMyLmRlZmF1bHRQcm9wcylcbiAgICBmb3IgKGIyIGluIGEgPSBjMi5kZWZhdWx0UHJvcHMsIGEpXG4gICAgICBkMltiMl0gPT09IHZvaWQgMCAmJiAoZDJbYjJdID0gYVtiMl0pO1xuICByZXR1cm4geyAkJHR5cGVvZjogZywgdHlwZTogYzIsIGtleTogZTIsIHJlZjogbDIsIHByb3BzOiBkMiwgX293bmVyOiBtLmN1cnJlbnQgfTtcbn1cbnJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbi5qc3ggPSBxO1xucmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb25fbWluLmpzeHMgPSBxO1xue1xuICBqc3hSdW50aW1lLmV4cG9ydHMgPSByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW47XG59XG5jb25zdCBqc3ggPSBqc3hSdW50aW1lLmV4cG9ydHMuanN4O1xuY29uc3QganN4cyA9IGpzeFJ1bnRpbWUuZXhwb3J0cy5qc3hzO1xuY29uc3QgVGFnSW5wdXQgPSAoX2EpID0+IHtcbiAgdmFyIF9iID0gX2EsIHtcbiAgICB2YWx1ZSA9IFtdLFxuICAgIG9uQ2hhbmdlLFxuICAgIHBsYWNlaG9sZGVyXG4gIH0gPSBfYiwgcHJvcHMgPSBfX29ialJlc3QoX2IsIFtcbiAgICBcInZhbHVlXCIsXG4gICAgXCJvbkNoYW5nZVwiLFxuICAgIFwicGxhY2Vob2xkZXJcIlxuICBdKTtcbiAgY29uc3QgW2NvbnRlbnQsIHNldENvbnRlbnRdID0gdXNlU3RhdGUoKTtcbiAgY29uc3QgaW5wdXRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGhhbmRsZURlbGV0ZSA9ICh0YWcpID0+IHtcbiAgICBjb25zdCBuZXdBcnIgPSB2YWx1ZS5maWx0ZXIoKGkpID0+IGkgIT09IHRhZyk7XG4gICAgb25DaGFuZ2UobmV3QXJyKTtcbiAgICBtZXNzYWdlLmRlc3Ryb3koKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlQ2hhbmdlID0gKGUyKSA9PiB7XG4gICAgc2V0Q29udGVudChlMi50YXJnZXQudmFsdWUpO1xuICB9O1xuICBjb25zdCBoYW5kbGVCbHVyID0gKCkgPT4ge1xuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBpZiAodmFsdWUuaW5jbHVkZXMoY29udGVudCkpIHtcbiAgICAgICAgbWVzc2FnZS53YXJuKGBbdGFnOiAke2NvbnRlbnR9XSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvbkNoYW5nZShbLi4udmFsdWUsIGNvbnRlbnRdKTtcbiAgICAgIHNldENvbnRlbnQoXCJcIik7XG4gICAgfVxuICB9O1xuICBjb25zdCBoYW5kbGVLZXlQcmVzcyA9IChlMikgPT4gZTIua2V5ID09PSBcIkVudGVyXCIgJiYgZTIucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgaGFuZGxlS2V5VXAgPSAoZTIpID0+IHtcbiAgICBpZiAoZTIua2V5ID09PSBcIkVudGVyXCIgJiYgY29udGVudCkge1xuICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKGNvbnRlbnQpKSB7XG4gICAgICAgIG1lc3NhZ2Uud2FybihgW3RhZzogJHtjb250ZW50fV0gYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb25DaGFuZ2UoWy4uLnZhbHVlLCBjb250ZW50XSk7XG4gICAgICBzZXRDb250ZW50KFwiXCIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaGFuZGxlQ2xlYXIgPSAoKSA9PiB7XG4gICAgb25DaGFuZ2UoW10pO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoXCJkaXZcIiwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgY2xhc3NOYW1lOiBgJHtzdHlsZXMudGFnSW5wdXR9IGFudC1pbnB1dGAsXG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHJldHVybiAoX2EyID0gaW5wdXRSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5mb2N1cygpO1xuICAgIH1cbiAgfSwgcHJvcHMpLCB7XG4gICAgY2hpbGRyZW46IFt2YWx1ZS5tYXAoKGl0ZW0pID0+IGl0ZW0ubGVuZ3RoID4gMjAgPyAvKiBAX19QVVJFX18gKi8ganN4KFRvb2x0aXAkMSwge1xuICAgICAgdGl0bGU6IGl0ZW0sXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChUYWckMSwge1xuICAgICAgICBjbG9zYWJsZTogdHJ1ZSxcbiAgICAgICAgb25DbG9zZTogKCkgPT4gaGFuZGxlRGVsZXRlKGl0ZW0pLFxuICAgICAgICBjaGlsZHJlbjogYCR7aXRlbS5zbGljZSgwLCAyMCl9Li4uYFxuICAgICAgfSlcbiAgICB9LCBpdGVtKSA6IC8qIEBfX1BVUkVfXyAqLyBqc3goVGFnJDEsIHtcbiAgICAgIGNsb3NhYmxlOiB0cnVlLFxuICAgICAgb25DbG9zZTogKCkgPT4gaGFuZGxlRGVsZXRlKGl0ZW0pLFxuICAgICAgY2hpbGRyZW46IGl0ZW1cbiAgICB9LCBpdGVtKSksIC8qIEBfX1BVUkVfXyAqLyBqc3goSW5wdXQkMSwge1xuICAgICAgcmVmOiBpbnB1dFJlZixcbiAgICAgIGJvcmRlcmVkOiBmYWxzZSxcbiAgICAgIHBsYWNlaG9sZGVyOiAhdmFsdWUubGVuZ3RoID8gcGxhY2Vob2xkZXIgOiBcIlwiLFxuICAgICAgY2xhc3NOYW1lOiBzdHlsZXMuaW5wdXQsXG4gICAgICB2YWx1ZTogY29udGVudCxcbiAgICAgIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2UsXG4gICAgICBvbkJsdXI6IGhhbmRsZUJsdXIsXG4gICAgICBvbktleVByZXNzOiBoYW5kbGVLZXlQcmVzcyxcbiAgICAgIG9uS2V5VXA6IGhhbmRsZUtleVVwXG4gICAgfSksIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogYCR7c3R5bGVzLmNsZWFyfSBhbnQtaW5wdXQtc3VmZml4YCxcbiAgICAgIG9uQ2xpY2s6IGhhbmRsZUNsZWFyLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHtcbiAgICAgICAgcm9sZTogXCJidXR0b25cIixcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IFwiY2xvc2UtY2lyY2xlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJhbnRpY29uIGFudGljb24tY2xvc2UtY2lyY2xlIGFudC1pbnB1dC1jbGVhci1pY29uXCIsXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwic3ZnXCIsIHtcbiAgICAgICAgICB2aWV3Qm94OiBcIjY0IDY0IDg5NiA4OTZcIixcbiAgICAgICAgICBmb2N1c2FibGU6IFwiZmFsc2VcIixcbiAgICAgICAgICBjbGFzc05hbWU6IFwiXCIsXG4gICAgICAgICAgXCJkYXRhLWljb25cIjogXCJjbG9zZS1jaXJjbGVcIixcbiAgICAgICAgICB3aWR0aDogXCIxZW1cIixcbiAgICAgICAgICBoZWlnaHQ6IFwiMWVtXCIsXG4gICAgICAgICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcbiAgICAgICAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwicGF0aFwiLCB7XG4gICAgICAgICAgICBkOiBcIk01MTIgNjRDMjY0LjYgNjQgNjQgMjY0LjYgNjQgNTEyczIwMC42IDQ0OCA0NDggNDQ4IDQ0OC0yMDAuNiA0NDgtNDQ4Uzc1OS40IDY0IDUxMiA2NHptMTY1LjQgNjE4LjJsLTY2LS4zTDUxMiA1NjMuNGwtOTkuMyAxMTguNC02Ni4xLjNjLTQuNCAwLTgtMy41LTgtOCAwLTEuOS43LTMuNyAxLjktNS4ybDEzMC4xLTE1NUwzNDAuNSAzNTlhOC4zMiA4LjMyIDAgMDEtMS45LTUuMmMwLTQuNCAzLjYtOCA4LThsNjYuMS4zTDUxMiA0NjQuNmw5OS4zLTExOC40IDY2LS4zYzQuNCAwIDggMy41IDggOCAwIDEuOS0uNyAzLjctMS45IDUuMkw1NTMuNSA1MTRsMTMwIDE1NWMxLjIgMS41IDEuOSAzLjMgMS45IDUuMiAwIDQuNC0zLjYgOC04IDh6XCJcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KV1cbiAgfSkpO1xufTtcbmV4cG9ydCB7IFRhZ0lucHV0IGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/antd-tag-input/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/antd-tag-input/dist/style.css":
/*!****************************************************!*\
  !*** ./node_modules/antd-tag-input/dist/style.css ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"9a7c352604e4\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYW50ZC10YWctaW5wdXQvZGlzdC9zdHlsZS5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWNod2F2ZS1uZXh0anMvLi9ub2RlX21vZHVsZXMvYW50ZC10YWctaW5wdXQvZGlzdC9zdHlsZS5jc3M/Y2U4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjlhN2MzNTI2MDRlNFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/antd-tag-input/dist/style.css\n");

/***/ })

};
;