"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-tag-autocomplete";
exports.ids = ["vendor-chunks/react-tag-autocomplete"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-tag-autocomplete/dist/ReactTags.cjs.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-tag-autocomplete/dist/ReactTags.cjs.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\nconst React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nconst KeyNames = {\n  Enter: \"Enter\",\n  Escape: \"Escape\",\n  Tab: \"Tab\",\n  Backspace: \"Backspace\",\n  UpArrow: \"ArrowUp\",\n  UpArrowCompat: \"Up\",\n  DownArrow: \"ArrowDown\",\n  DownArrowCompat: \"Down\",\n  PageDown: \"PageDown\",\n  PageUp: \"PageUp\"\n};\nconst NewOptionValue = Symbol(\"Create new tag\");\nconst NoOptionsValue = Symbol(\"No options\");\nconst VoidFn = () => void 0;\nconst GlobalContext = React.createContext(void 0);\nfunction arrayDiff(a, b) {\n  if (a === b) {\n    return [];\n  } else {\n    return a.filter((item) => !b.includes(item));\n  }\n}\nfunction isCaretAtStart(target) {\n  return target.selectionStart === 0 && target.selectionEnd === 0;\n}\nfunction isCaretAtEnd(target) {\n  const length = target.value.length;\n  return target.selectionStart === length && target.selectionEnd === length;\n}\nfunction rootId(id) {\n  return id;\n}\nfunction labelId(id) {\n  return `${id}-label`;\n}\nfunction comboBoxId(id) {\n  return `${id}-combobox`;\n}\nfunction inputId(id) {\n  return `${id}-input`;\n}\nfunction listBoxId(id) {\n  return `${id}-listbox`;\n}\nfunction optionId(id, tag) {\n  return `${id}-option-${tagToId(tag)}`;\n}\nfunction getNewTag(option, value) {\n  if ((option == null ? void 0 : option.value) === NewOptionValue && option.disabled === false) {\n    return { value, label: value };\n  }\n}\nfunction findSelectedOption(state) {\n  const tag = getNewTag(state.activeOption, state.value) || state.activeOption || matchTagExact(state.value, state.options);\n  return tag && !tag.disabled ? tag : void 0;\n}\nfunction loopOptionsIndex(next, size, min) {\n  const max = size - 1;\n  if (next > max) {\n    return min;\n  }\n  if (next < min) {\n    return max;\n  }\n  return next;\n}\nconst ReplaceRegExp = /%value%/;\nfunction replacePlaceholder(string, value) {\n  return string.replace(ReplaceRegExp, value);\n}\nfunction highlightText(text, query) {\n  const regexp = partialRegExp(query);\n  const matches = text.match(regexp);\n  if (matches) {\n    const match = matches[0];\n    const lastIndex = matches.index + match.length;\n    return [\n      text.slice(0, matches.index),\n      text.slice(matches.index, lastIndex),\n      text.slice(lastIndex)\n    ];\n  }\n}\nconst Whitespace = /\\s+/g;\nfunction tagToKey(tag) {\n  return `${String(tag.value)}-${tag.label}`;\n}\nfunction tagToId(tag) {\n  return tagToKey(tag).replace(Whitespace, \"_\");\n}\nfunction findTagIndex(tag, tags) {\n  return tags.findIndex(({ value }) => value === tag.value);\n}\nconst EscapeRegExp = /[-\\\\^$*+?.()|[\\]{}]/g;\nfunction escapeForRegExp(string) {\n  return string.replace(EscapeRegExp, \"\\\\$&\");\n}\nfunction partialRegExp(query) {\n  return new RegExp(escapeForRegExp(query), \"i\");\n}\nfunction exactRegExp(query) {\n  return new RegExp(`^${escapeForRegExp(query)}$`, \"i\");\n}\nfunction matchTagsPartial(query, suggestions) {\n  if (query) {\n    const regexp = partialRegExp(query);\n    return suggestions.filter((item) => regexp.test(item.label));\n  } else {\n    return [].concat(suggestions);\n  }\n}\nfunction matchTagExact(query, suggestions) {\n  const regexp = exactRegExp(query);\n  return suggestions.find((item) => regexp.test(item.label)) || null;\n}\nconst DisableAutoCompleteAttrs = {\n  autoComplete: \"off\",\n  autoCorrect: \"off\",\n  \"data-form-type\": \"other\",\n  spellCheck: false\n};\nfunction useInput({\n  allowBackspace,\n  ariaDescribedBy,\n  ariaErrorMessage,\n  delimiterKeys\n}) {\n  const { id, comboBoxRef, inputRef, isDisabled, isInvalid, managerRef } = React.useContext(GlobalContext);\n  const events = React.useMemo(() => {\n    const onChange = (e) => {\n      const value2 = e.currentTarget.value;\n      managerRef.current.updateInputValue(value2);\n      if (document.activeElement === inputRef.current) {\n        managerRef.current.listBoxExpand(value2);\n      }\n    };\n    const onFocus = () => {\n      managerRef.current.listBoxExpand();\n    };\n    const onBlur = (e) => {\n      var _a;\n      if (((_a = comboBoxRef.current) == null ? void 0 : _a.contains(e.relatedTarget)) === false) {\n        managerRef.current.listBoxCollapse();\n      }\n    };\n    const onClick = () => {\n      managerRef.current.listBoxExpand();\n    };\n    const onDownArrowKey = (e) => {\n      const { activeIndex, isExpanded: isExpanded2 } = managerRef.current.state;\n      if (isExpanded2) {\n        e.preventDefault();\n        managerRef.current.updateActiveIndex(activeIndex + 1);\n      } else if (isCaretAtEnd(e.currentTarget) || e.altKey) {\n        e.preventDefault();\n        managerRef.current.listBoxExpand();\n      }\n    };\n    const onUpArrowKey = (e) => {\n      const { activeIndex, isExpanded: isExpanded2 } = managerRef.current.state;\n      if (isExpanded2) {\n        e.preventDefault();\n        managerRef.current.updateActiveIndex(activeIndex - 1);\n      } else if (isCaretAtStart(e.currentTarget)) {\n        e.preventDefault();\n        managerRef.current.listBoxExpand();\n      }\n    };\n    const onPageDownKey = (e) => {\n      const { isExpanded: isExpanded2, options } = managerRef.current.state;\n      if (isExpanded2) {\n        e.preventDefault();\n        managerRef.current.updateActiveIndex(options.length - 1);\n      }\n    };\n    const onPageUpKey = (e) => {\n      if (managerRef.current.state.isExpanded) {\n        e.preventDefault();\n        managerRef.current.updateActiveIndex(0);\n      }\n    };\n    const onEscapeKey = () => {\n      if (managerRef.current.state.isExpanded) {\n        managerRef.current.listBoxCollapse();\n      } else {\n        managerRef.current.updateInputValue(\"\");\n      }\n    };\n    const onBackspaceKey = () => {\n      if (allowBackspace) {\n        const { value: value2, selected } = managerRef.current.state;\n        const lastTag = selected[selected.length - 1];\n        if (value2 === \"\" && lastTag) {\n          managerRef.current.selectTag(lastTag);\n        }\n      }\n    };\n    const onDelimiterKey = (e) => {\n      if (managerRef.current.state.isExpanded) {\n        e.preventDefault();\n        managerRef.current.selectTag();\n      }\n    };\n    const onKeyDown = (e) => {\n      if (e.key === KeyNames.UpArrow) return onUpArrowKey(e);\n      if (e.key === KeyNames.DownArrow) return onDownArrowKey(e);\n      if (e.key === KeyNames.PageUp) return onPageUpKey(e);\n      if (e.key === KeyNames.PageDown) return onPageDownKey(e);\n      if (e.key === KeyNames.Escape) return onEscapeKey();\n      if (e.key === KeyNames.Backspace) return onBackspaceKey();\n      if (delimiterKeys.includes(e.key)) return onDelimiterKey(e);\n    };\n    return { onBlur, onChange, onClick, onFocus, onKeyDown };\n  }, [allowBackspace, comboBoxRef, delimiterKeys, inputRef, managerRef]);\n  const { activeOption, isExpanded, value } = managerRef.current.state;\n  return {\n    ...DisableAutoCompleteAttrs,\n    \"aria-autocomplete\": \"list\",\n    \"aria-activedescendant\": activeOption ? optionId(id, activeOption) : void 0,\n    \"aria-controls\": listBoxId(id),\n    \"aria-describedby\": ariaDescribedBy || void 0,\n    \"aria-disabled\": isDisabled,\n    \"aria-errormessage\": isInvalid && ariaErrorMessage || void 0,\n    \"aria-invalid\": isInvalid,\n    \"aria-labelledby\": labelId(id),\n    \"aria-expanded\": isExpanded,\n    id: inputId(id),\n    onBlur: isDisabled ? VoidFn : events.onBlur,\n    onChange: isDisabled ? VoidFn : events.onChange,\n    onClick: isDisabled ? VoidFn : events.onClick,\n    onFocus: isDisabled ? VoidFn : events.onFocus,\n    onKeyDown: isDisabled ? VoidFn : events.onKeyDown,\n    ref: inputRef,\n    role: \"combobox\",\n    type: \"text\",\n    value\n  };\n}\nconst SizerStyles = {\n  position: \"absolute\",\n  width: 0,\n  height: 0,\n  visibility: \"hidden\",\n  overflow: \"scroll\",\n  whiteSpace: \"pre\"\n};\nconst StyleProps = [\n  \"font-family\",\n  \"font-size\",\n  \"font-style\",\n  \"font-weight\",\n  \"letter-spacing\",\n  \"text-transform\"\n];\nfunction useInputSizer({ allowResize = true, text }) {\n  const sizerRef = React.useRef(null);\n  const { inputRef } = React.useContext(GlobalContext);\n  const [width, setWidth] = React.useState(null);\n  React.useLayoutEffect(() => {\n    if (allowResize && inputRef.current && sizerRef.current && window.getComputedStyle) {\n      const inputStyle = window.getComputedStyle(inputRef.current);\n      StyleProps.forEach((prop) => {\n        const value = inputStyle.getPropertyValue(prop);\n        sizerRef.current.style.setProperty(prop, value);\n      });\n    }\n  }, [allowResize, inputRef, sizerRef]);\n  React.useLayoutEffect(() => {\n    var _a;\n    if (allowResize) {\n      const newWidth = Math.ceil(((_a = sizerRef.current) == null ? void 0 : _a.scrollWidth) ?? 0) + 2;\n      if (width !== newWidth) setWidth(newWidth);\n    }\n  }, [allowResize, text, width]);\n  return {\n    width,\n    sizerProps: {\n      ref: sizerRef,\n      style: SizerStyles\n    }\n  };\n}\nfunction useListBox() {\n  const { id, inputRef, listBoxRef, managerRef } = React.useContext(GlobalContext);\n  const scrollToTop = managerRef.current.state.activeIndex === -1;\n  const onFocus = React.useCallback(\n    (e) => {\n      var _a;\n      if (e.target !== inputRef.current) {\n        (_a = inputRef.current) == null ? void 0 : _a.focus({ preventScroll: true });\n      }\n    },\n    [inputRef]\n  );\n  React.useEffect(() => {\n    var _a;\n    if (scrollToTop) {\n      (_a = listBoxRef.current) == null ? void 0 : _a.scrollTo({ top: 0 });\n    }\n  }, [listBoxRef, scrollToTop]);\n  return {\n    \"aria-labelledby\": labelId(id),\n    id: listBoxId(id),\n    onFocus,\n    ref: listBoxRef,\n    role: \"listbox\",\n    tabIndex: -1\n  };\n}\nfunction useManager({\n  activateFirstOption,\n  allowNew,\n  collapseOnSelect,\n  newOptionText,\n  noOptionsText,\n  onAdd,\n  onDelete,\n  onCollapse,\n  onExpand,\n  onInput,\n  onShouldCollapse,\n  onShouldExpand,\n  onValidate,\n  selected,\n  suggestions,\n  suggestionsTransform\n}) {\n  const ref = React.useRef();\n  const [lastActiveOption, setLastActiveOption] = React.useState(null);\n  const [isExpanded, setIsExpanded] = React.useState(false);\n  const [value, setValue] = React.useState(\"\");\n  const options = React.useMemo(() => {\n    const opts = suggestionsTransform(value, suggestions);\n    if (value) {\n      if (allowNew) {\n        opts.push({\n          disabled: onValidate ? !onValidate(value) : false,\n          label: newOptionText,\n          value: NewOptionValue\n        });\n      }\n      if (opts.length === 0) {\n        opts.push({\n          disabled: true,\n          label: noOptionsText,\n          value: NoOptionsValue\n        });\n      }\n    }\n    return opts;\n  }, [allowNew, newOptionText, noOptionsText, onValidate, suggestions, suggestionsTransform, value]);\n  const optionIndex = lastActiveOption ? findTagIndex(lastActiveOption, options) : -1;\n  const activeIndex = activateFirstOption ? Math.max(optionIndex, 0) : optionIndex;\n  const activeOption = options[activeIndex];\n  const state = {\n    activeIndex,\n    activeOption,\n    isExpanded,\n    options,\n    selected,\n    value\n  };\n  const flags = {\n    tagsAdded: ref.current ? arrayDiff(selected, ref.current.state.selected) : [],\n    tagsDeleted: ref.current ? arrayDiff(ref.current.state.selected, selected) : []\n  };\n  const api = {\n    listBoxCollapse(value2) {\n      if (!isExpanded) return;\n      if (onShouldCollapse ? onShouldCollapse(value2 ?? state.value) : true) {\n        setIsExpanded(false);\n        setLastActiveOption(null);\n        onCollapse == null ? void 0 : onCollapse();\n      }\n    },\n    listBoxExpand(value2) {\n      if (isExpanded) return;\n      if (onShouldExpand ? onShouldExpand(value2 ?? state.value) : true) {\n        setIsExpanded(true);\n        setLastActiveOption(options[activeIndex]);\n        onExpand == null ? void 0 : onExpand();\n      }\n    },\n    updateActiveIndex(index) {\n      const activeIndex2 = loopOptionsIndex(index, options.length, activateFirstOption ? 0 : -1);\n      setLastActiveOption(options[activeIndex2]);\n    },\n    updateInputValue(newValue) {\n      if (value !== newValue) {\n        setValue(newValue);\n        onInput == null ? void 0 : onInput(newValue);\n      }\n    },\n    selectTag(tag) {\n      tag ?? (tag = findSelectedOption(state));\n      if (tag) {\n        const tagIndex = findTagIndex(tag, state.selected);\n        if (tagIndex > -1) {\n          onDelete(tagIndex);\n        } else {\n          onAdd(tag);\n        }\n        if (collapseOnSelect) {\n          this.listBoxCollapse();\n        }\n        this.updateInputValue(\"\");\n      }\n    }\n  };\n  ref.current = { ...api, flags, state };\n  return ref;\n}\nfunction useOption(index) {\n  const { id, inputRef, listBoxRef, managerRef } = React.useContext(GlobalContext);\n  const optionRef = React.useRef(null);\n  const option = managerRef.current.state.options[index];\n  const active = index === managerRef.current.state.activeIndex;\n  const disabled = option.disabled ?? false;\n  const selected = findTagIndex(option, managerRef.current.state.selected) > -1;\n  const onClick = React.useCallback(() => {\n    var _a;\n    managerRef.current.selectTag();\n    (_a = inputRef.current) == null ? void 0 : _a.focus();\n  }, [inputRef, managerRef]);\n  const onMouseDown = React.useCallback(() => {\n    if (index !== managerRef.current.state.activeIndex) {\n      managerRef.current.updateActiveIndex(index);\n    }\n  }, [index, managerRef]);\n  useScrollIntoView(optionRef, listBoxRef, active);\n  return {\n    option: {\n      ...option,\n      active,\n      disabled,\n      index,\n      selected\n    },\n    optionProps: {\n      \"aria-disabled\": disabled,\n      \"aria-posinset\": index + 1,\n      \"aria-selected\": disabled ? void 0 : selected,\n      \"aria-setsize\": managerRef.current.state.options.length,\n      id: optionId(id, option),\n      onClick,\n      onMouseDown,\n      ref: optionRef,\n      role: \"option\",\n      tabIndex: -1\n    }\n  };\n}\nfunction usePublicAPI({ inputRef, managerRef }) {\n  const api = React.useRef({\n    input: {\n      blur() {\n        var _a;\n        (_a = inputRef.current) == null ? void 0 : _a.blur();\n      },\n      focus() {\n        var _a;\n        (_a = inputRef.current) == null ? void 0 : _a.focus();\n      },\n      get value() {\n        return managerRef.current.state.value;\n      },\n      set value(value) {\n        if (typeof value !== \"string\") {\n          value = String(value);\n        }\n        managerRef.current.updateInputValue(value);\n      }\n    },\n    listBox: {\n      collapse() {\n        managerRef.current.listBoxCollapse();\n      },\n      expand() {\n        managerRef.current.listBoxExpand();\n      },\n      get activeOption() {\n        return managerRef.current.state.activeOption;\n      },\n      get isExpanded() {\n        return managerRef.current.state.isExpanded;\n      }\n    },\n    select(tag) {\n      managerRef.current.selectTag(tag);\n    }\n  });\n  return api.current;\n}\nfunction useRoot({ onBlur, onFocus }) {\n  const [isActive, setIsActive] = React.useState(false);\n  const { id, inputRef, rootRef } = React.useContext(GlobalContext);\n  const rootProps = React.useMemo(() => {\n    return {\n      \"aria-describedby\": labelId(id),\n      id: rootId(id),\n      onFocus() {\n        setIsActive(true);\n        onFocus == null ? void 0 : onFocus();\n      },\n      onBlur() {\n        var _a;\n        if (!((_a = rootRef.current) == null ? void 0 : _a.contains(document.activeElement))) {\n          setIsActive(false);\n          onBlur == null ? void 0 : onBlur();\n        }\n      },\n      onClick() {\n        var _a;\n        if (document.activeElement === rootRef.current) {\n          (_a = inputRef.current) == null ? void 0 : _a.focus();\n        }\n      },\n      ref: rootRef,\n      tabIndex: -1\n    };\n  }, [inputRef, id, onBlur, onFocus, rootRef]);\n  return {\n    isActive,\n    rootProps\n  };\n}\nfunction useScrollIntoView(targetRef, containerRef, shouldScroll) {\n  React.useEffect(() => {\n    var _a, _b, _c, _d;\n    if (shouldScroll) {\n      const targetHeight = (_a = targetRef.current) == null ? void 0 : _a.offsetHeight;\n      const targetOffset = (_b = targetRef.current) == null ? void 0 : _b.offsetTop;\n      const containerHeight = (_c = containerRef.current) == null ? void 0 : _c.offsetHeight;\n      const containerScroll = (_d = containerRef.current) == null ? void 0 : _d.scrollTop;\n      if (targetOffset < containerScroll) {\n        containerRef.current.scrollTo(0, targetOffset);\n      }\n      if (targetOffset + targetHeight > containerScroll + containerHeight) {\n        containerRef.current.scrollTo(0, targetOffset + targetHeight - containerHeight);\n      }\n    }\n  }, [shouldScroll, containerRef, targetRef]);\n}\nfunction useSelectedTag(index, title) {\n  const { isDisabled, managerRef } = React.useContext(GlobalContext);\n  const tag = managerRef.current.state.selected[index];\n  const onClick = React.useCallback(() => managerRef.current.selectTag(tag), [managerRef, tag]);\n  return {\n    tag,\n    tagProps: {\n      \"aria-disabled\": isDisabled,\n      title: replacePlaceholder(title, tag.label),\n      onClick: isDisabled ? VoidFn : onClick\n    }\n  };\n}\nfunction useTagList({ label }) {\n  var _a;\n  const { rootRef, managerRef } = React.useContext(GlobalContext);\n  const listRef = React.useRef();\n  const tagDeleted = managerRef.current.flags.tagsDeleted[0];\n  const isFocusInList = (_a = listRef.current) == null ? void 0 : _a.contains(document.activeElement);\n  React.useLayoutEffect(() => {\n    var _a2, _b;\n    if (tagDeleted) {\n      const isFocusInListNow = (_a2 = listRef.current) == null ? void 0 : _a2.contains(document.activeElement);\n      if (isFocusInList && !isFocusInListNow) {\n        (_b = rootRef.current) == null ? void 0 : _b.focus({ preventScroll: true });\n      }\n    }\n  }, [isFocusInList, listRef, rootRef, tagDeleted]);\n  return { ref: listRef, \"aria-label\": label };\n}\nconst VisuallyHiddenStyles = {\n  position: \"absolute\",\n  width: 1,\n  height: 1,\n  left: -9999,\n  overflow: \"hidden\",\n  clip: \"rect(0 0 0 0)\"\n};\nfunction Announcements({ ariaAddedText, ariaDeletedText }) {\n  const { managerRef } = React.useContext(GlobalContext);\n  const logsRef = React.useRef([]);\n  managerRef.current.flags.tagsAdded.forEach((tag) => {\n    logsRef.current.push(replacePlaceholder(ariaAddedText, tag.label));\n  });\n  managerRef.current.flags.tagsDeleted.forEach((tag) => {\n    logsRef.current.push(replacePlaceholder(ariaDeletedText, tag.label));\n  });\n  return /* @__PURE__ */ React.createElement(\"div\", { \"aria-live\": \"polite\", \"aria-relevant\": \"additions\", role: \"status\", style: VisuallyHiddenStyles }, logsRef.current.join(\"\\n\"));\n}\nfunction ComboBox({ children }) {\n  const { classNames, comboBoxRef, id } = React.useContext(GlobalContext);\n  return /* @__PURE__ */ React.createElement(\"div\", { className: classNames.comboBox, id: comboBoxId(id), ref: comboBoxRef }, children);\n}\nconst DefaultHighlight = ({ classNames, text }) => {\n  return /* @__PURE__ */ React.createElement(\"mark\", { className: classNames.highlight }, text);\n};\nfunction Highlight({ option, query, render = DefaultHighlight }) {\n  const { classNames } = React.useContext(GlobalContext);\n  if (option.value === NewOptionValue || option.value === NoOptionsValue) {\n    return /* @__PURE__ */ React.createElement(React.Fragment, null, replacePlaceholder(option.label, query));\n  }\n  if (query) {\n    const result = highlightText(option.label, query);\n    if (result) {\n      const highlighted = render({ text: result[1], classNames });\n      return /* @__PURE__ */ React.createElement(React.Fragment, null, result[0], highlighted, result[2]);\n    }\n  }\n  return /* @__PURE__ */ React.createElement(React.Fragment, null, option.label);\n}\nconst MemoizedHighlight = React.memo(Highlight);\nconst DefaultInput = ({ classNames, inputWidth, ...inputProps }) => {\n  return /* @__PURE__ */ React.createElement(\"input\", { className: classNames.input, style: { width: inputWidth }, ...inputProps });\n};\nfunction Input({\n  allowBackspace = true,\n  allowResize = true,\n  ariaDescribedBy,\n  ariaErrorMessage,\n  delimiterKeys,\n  placeholderText,\n  render = DefaultInput\n}) {\n  const { classNames } = React.useContext(GlobalContext);\n  const { value, ...inputProps } = useInput({\n    allowBackspace,\n    ariaDescribedBy,\n    ariaErrorMessage,\n    delimiterKeys\n  });\n  const text = value.length < placeholderText.length ? placeholderText : value;\n  const { width, sizerProps } = useInputSizer({ allowResize, text });\n  return /* @__PURE__ */ React.createElement(React.Fragment, null, render({\n    classNames,\n    inputWidth: width,\n    placeholder: placeholderText,\n    value,\n    ...inputProps\n  }), allowResize ? /* @__PURE__ */ React.createElement(\"div\", { ...sizerProps }, text) : null);\n}\nconst DefaultLabel = ({ children, classNames, id }) => {\n  return /* @__PURE__ */ React.createElement(\"div\", { className: classNames.label, id }, children);\n};\nfunction Label({ children, render = DefaultLabel }) {\n  const { classNames, id } = React.useContext(GlobalContext);\n  return render({ children, classNames, id: labelId(id) });\n}\nconst DefaultListBox = ({ children, classNames, ...listBoxProps }) => {\n  return /* @__PURE__ */ React.createElement(\"div\", { className: classNames.listBox, ...listBoxProps }, children);\n};\nfunction ListBox({ children, render = DefaultListBox }) {\n  const { classNames, managerRef } = React.useContext(GlobalContext);\n  const listBoxProps = useListBox();\n  if (!managerRef.current.state.isExpanded || React.Children.count(children) === 0) return null;\n  return render({ children, classNames, ...listBoxProps });\n}\nconst DefaultOption = ({ children, classNames, option, ...optionProps }) => {\n  const classes = [classNames.option];\n  if (option.active) classes.push(classNames.optionIsActive);\n  return /* @__PURE__ */ React.createElement(\"div\", { className: classes.join(\" \"), ...optionProps }, children);\n};\nfunction Option({ children, index, render = DefaultOption }) {\n  const { classNames } = React.useContext(GlobalContext);\n  const { option, optionProps } = useOption(index);\n  return render({ classNames, children, option, ...optionProps });\n}\nconst DefaultRoot = ({\n  children,\n  classNames,\n  isActive,\n  isDisabled,\n  isInvalid,\n  ...rootProps\n}) => {\n  const classes = [classNames.root];\n  if (isActive) classes.push(classNames.rootIsActive);\n  if (isDisabled) classes.push(classNames.rootIsDisabled);\n  if (isInvalid) classes.push(classNames.rootIsInvalid);\n  return /* @__PURE__ */ React.createElement(\"div\", { className: classes.join(\" \"), ...rootProps }, children);\n};\nfunction Root({ children, onBlur, onFocus, render = DefaultRoot }) {\n  const { classNames, isDisabled, isInvalid } = React.useContext(GlobalContext);\n  const { isActive, rootProps } = useRoot({ onBlur, onFocus });\n  return render({ children, classNames, isActive, isDisabled, isInvalid, ...rootProps });\n}\nconst DefaultTag = ({ classNames, tag, ...tagProps }) => {\n  return /* @__PURE__ */ React.createElement(\"button\", { type: \"button\", className: classNames.tag, ...tagProps }, /* @__PURE__ */ React.createElement(\"span\", { className: classNames.tagName }, tag.label));\n};\nfunction Tag({ render = DefaultTag, index, title }) {\n  const { classNames } = React.useContext(GlobalContext);\n  const { tag, tagProps } = useSelectedTag(index, title);\n  return render({ classNames, tag, ...tagProps });\n}\nconst DefaultTagList = ({\n  children,\n  classNames,\n  ...tagListProps\n}) => {\n  return /* @__PURE__ */ React.createElement(\"ul\", { className: classNames.tagList, ...tagListProps, role: \"list\" }, React.Children.map(children, (child) => {\n    if (React.isValidElement(child)) {\n      return /* @__PURE__ */ React.createElement(\"li\", { className: classNames.tagListItem, key: child.key, role: \"listitem\" }, child);\n    }\n  }));\n};\nfunction TagList({ children, label, render = DefaultTagList }) {\n  const { classNames } = React.useContext(GlobalContext);\n  const tagListProps = useTagList({ label });\n  return render({ classNames, children, ...tagListProps });\n}\nconst DefaultClassNames = {\n  root: \"react-tags\",\n  rootIsActive: \"is-active\",\n  rootIsDisabled: \"is-disabled\",\n  rootIsInvalid: \"is-invalid\",\n  label: \"react-tags__label\",\n  tagList: \"react-tags__list\",\n  tagListItem: \"react-tags__list-item\",\n  tag: \"react-tags__tag\",\n  tagName: \"react-tags__tag-name\",\n  comboBox: \"react-tags__combobox\",\n  input: \"react-tags__combobox-input\",\n  listBox: \"react-tags__listbox\",\n  option: \"react-tags__listbox-option\",\n  optionIsActive: \"is-active\",\n  highlight: \"react-tags__listbox-option-highlight\"\n};\nconst DefaultDelimiterKeys = [KeyNames.Enter];\nfunction ReactTags({\n  activateFirstOption = false,\n  allowBackspace = true,\n  allowNew = false,\n  allowResize = true,\n  ariaAddedText = \"Added tag %value%\",\n  ariaDescribedBy,\n  ariaErrorMessage,\n  ariaDeletedText = \"Removed tag %value%\",\n  classNames = DefaultClassNames,\n  collapseOnSelect = false,\n  deleteButtonText = \"Remove %value% from the list\",\n  delimiterKeys = DefaultDelimiterKeys,\n  id = \"react-tags\",\n  isDisabled = false,\n  isInvalid = false,\n  labelText = \"Select tags\",\n  newOptionText = \"Add %value%\",\n  noOptionsText = \"No options found for %value%\",\n  onAdd,\n  onBlur,\n  onCollapse,\n  onDelete,\n  onExpand,\n  onFocus,\n  onInput,\n  onShouldCollapse,\n  onShouldExpand,\n  onValidate,\n  placeholderText = \"Add a tag\",\n  renderHighlight,\n  renderInput,\n  renderLabel,\n  renderListBox,\n  renderOption,\n  renderRoot,\n  renderTag,\n  renderTagList,\n  selected = [],\n  suggestions = [],\n  suggestionsTransform = matchTagsPartial,\n  tagListLabelText = \"Selected tags\"\n}, ref) {\n  const comboBoxRef = React.useRef(null);\n  const inputRef = React.useRef(null);\n  const listBoxRef = React.useRef(null);\n  const rootRef = React.useRef(null);\n  const managerRef = useManager({\n    activateFirstOption,\n    allowNew,\n    collapseOnSelect,\n    newOptionText,\n    noOptionsText,\n    onAdd,\n    onDelete,\n    onCollapse,\n    onExpand,\n    onInput,\n    onShouldCollapse,\n    onShouldExpand,\n    onValidate,\n    selected,\n    suggestions,\n    suggestionsTransform\n  });\n  const publicAPI = usePublicAPI({ inputRef, managerRef });\n  if (ref) {\n    if (typeof ref === \"function\") {\n      ref(publicAPI);\n    } else {\n      ref.current = publicAPI;\n    }\n  }\n  return /* @__PURE__ */ React.createElement(\n    GlobalContext.Provider,\n    {\n      value: {\n        classNames,\n        comboBoxRef,\n        id,\n        inputRef,\n        isDisabled,\n        isInvalid,\n        listBoxRef,\n        managerRef,\n        rootRef\n      }\n    },\n    /* @__PURE__ */ React.createElement(Root, { onBlur, onFocus, render: renderRoot }, /* @__PURE__ */ React.createElement(Label, { render: renderLabel }, labelText), /* @__PURE__ */ React.createElement(TagList, { render: renderTagList, label: tagListLabelText }, managerRef.current.state.selected.map((tag, index) => /* @__PURE__ */ React.createElement(Tag, { key: tagToKey(tag), index, render: renderTag, title: deleteButtonText }))), /* @__PURE__ */ React.createElement(ComboBox, null, /* @__PURE__ */ React.createElement(\n      Input,\n      {\n        allowBackspace,\n        allowResize,\n        ariaDescribedBy,\n        ariaErrorMessage,\n        delimiterKeys,\n        placeholderText,\n        render: renderInput\n      }\n    ), /* @__PURE__ */ React.createElement(ListBox, { render: renderListBox }, managerRef.current.state.options.map((option, index) => /* @__PURE__ */ React.createElement(Option, { key: tagToKey(option), index, render: renderOption }, /* @__PURE__ */ React.createElement(\n      MemoizedHighlight,\n      {\n        option,\n        query: managerRef.current.state.value,\n        render: renderHighlight\n      }\n    ))))), /* @__PURE__ */ React.createElement(Announcements, { ariaAddedText, ariaDeletedText }))\n  );\n}\nconst ReactTagsWithRef = React.forwardRef(ReactTags);\nexports.ReactTags = ReactTagsWithRef;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFnLWF1dG9jb21wbGV0ZS9kaXN0L1JlYWN0VGFncy5janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixxREFBcUQsaUJBQWlCO0FBQ3RFLGNBQWMsbUJBQU8sQ0FBQyx3R0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBLFlBQVksR0FBRyxVQUFVLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQixHQUFHLFVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQ0FBbUMsc0JBQXNCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdEQUFnRCxxQ0FBcUMsK0NBQStDLHFCQUFxQiw2REFBNkQsZ0RBQWdELG1HQUFtRyx1RUFBdUU7QUFDaGI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsdUJBQXVCLHdHQUF3RyxvREFBb0Q7QUFDek87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGdDQUFnQztBQUNoRztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWNod2F2ZS1uZXh0anMvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFnLWF1dG9jb21wbGV0ZS9kaXN0L1JlYWN0VGFncy5janMuanM/NzgwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSk7XG5jb25zdCBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmNvbnN0IEtleU5hbWVzID0ge1xuICBFbnRlcjogXCJFbnRlclwiLFxuICBFc2NhcGU6IFwiRXNjYXBlXCIsXG4gIFRhYjogXCJUYWJcIixcbiAgQmFja3NwYWNlOiBcIkJhY2tzcGFjZVwiLFxuICBVcEFycm93OiBcIkFycm93VXBcIixcbiAgVXBBcnJvd0NvbXBhdDogXCJVcFwiLFxuICBEb3duQXJyb3c6IFwiQXJyb3dEb3duXCIsXG4gIERvd25BcnJvd0NvbXBhdDogXCJEb3duXCIsXG4gIFBhZ2VEb3duOiBcIlBhZ2VEb3duXCIsXG4gIFBhZ2VVcDogXCJQYWdlVXBcIlxufTtcbmNvbnN0IE5ld09wdGlvblZhbHVlID0gU3ltYm9sKFwiQ3JlYXRlIG5ldyB0YWdcIik7XG5jb25zdCBOb09wdGlvbnNWYWx1ZSA9IFN5bWJvbChcIk5vIG9wdGlvbnNcIik7XG5jb25zdCBWb2lkRm4gPSAoKSA9PiB2b2lkIDA7XG5jb25zdCBHbG9iYWxDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuZnVuY3Rpb24gYXJyYXlEaWZmKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gW107XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGEuZmlsdGVyKChpdGVtKSA9PiAhYi5pbmNsdWRlcyhpdGVtKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQ2FyZXRBdFN0YXJ0KHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0LnNlbGVjdGlvblN0YXJ0ID09PSAwICYmIHRhcmdldC5zZWxlY3Rpb25FbmQgPT09IDA7XG59XG5mdW5jdGlvbiBpc0NhcmV0QXRFbmQodGFyZ2V0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRhcmdldC52YWx1ZS5sZW5ndGg7XG4gIHJldHVybiB0YXJnZXQuc2VsZWN0aW9uU3RhcnQgPT09IGxlbmd0aCAmJiB0YXJnZXQuc2VsZWN0aW9uRW5kID09PSBsZW5ndGg7XG59XG5mdW5jdGlvbiByb290SWQoaWQpIHtcbiAgcmV0dXJuIGlkO1xufVxuZnVuY3Rpb24gbGFiZWxJZChpZCkge1xuICByZXR1cm4gYCR7aWR9LWxhYmVsYDtcbn1cbmZ1bmN0aW9uIGNvbWJvQm94SWQoaWQpIHtcbiAgcmV0dXJuIGAke2lkfS1jb21ib2JveGA7XG59XG5mdW5jdGlvbiBpbnB1dElkKGlkKSB7XG4gIHJldHVybiBgJHtpZH0taW5wdXRgO1xufVxuZnVuY3Rpb24gbGlzdEJveElkKGlkKSB7XG4gIHJldHVybiBgJHtpZH0tbGlzdGJveGA7XG59XG5mdW5jdGlvbiBvcHRpb25JZChpZCwgdGFnKSB7XG4gIHJldHVybiBgJHtpZH0tb3B0aW9uLSR7dGFnVG9JZCh0YWcpfWA7XG59XG5mdW5jdGlvbiBnZXROZXdUYWcob3B0aW9uLCB2YWx1ZSkge1xuICBpZiAoKG9wdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9uLnZhbHVlKSA9PT0gTmV3T3B0aW9uVmFsdWUgJiYgb3B0aW9uLmRpc2FibGVkID09PSBmYWxzZSkge1xuICAgIHJldHVybiB7IHZhbHVlLCBsYWJlbDogdmFsdWUgfTtcbiAgfVxufVxuZnVuY3Rpb24gZmluZFNlbGVjdGVkT3B0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IHRhZyA9IGdldE5ld1RhZyhzdGF0ZS5hY3RpdmVPcHRpb24sIHN0YXRlLnZhbHVlKSB8fCBzdGF0ZS5hY3RpdmVPcHRpb24gfHwgbWF0Y2hUYWdFeGFjdChzdGF0ZS52YWx1ZSwgc3RhdGUub3B0aW9ucyk7XG4gIHJldHVybiB0YWcgJiYgIXRhZy5kaXNhYmxlZCA/IHRhZyA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGxvb3BPcHRpb25zSW5kZXgobmV4dCwgc2l6ZSwgbWluKSB7XG4gIGNvbnN0IG1heCA9IHNpemUgLSAxO1xuICBpZiAobmV4dCA+IG1heCkge1xuICAgIHJldHVybiBtaW47XG4gIH1cbiAgaWYgKG5leHQgPCBtaW4pIHtcbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIHJldHVybiBuZXh0O1xufVxuY29uc3QgUmVwbGFjZVJlZ0V4cCA9IC8ldmFsdWUlLztcbmZ1bmN0aW9uIHJlcGxhY2VQbGFjZWhvbGRlcihzdHJpbmcsIHZhbHVlKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShSZXBsYWNlUmVnRXhwLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBoaWdobGlnaHRUZXh0KHRleHQsIHF1ZXJ5KSB7XG4gIGNvbnN0IHJlZ2V4cCA9IHBhcnRpYWxSZWdFeHAocXVlcnkpO1xuICBjb25zdCBtYXRjaGVzID0gdGV4dC5tYXRjaChyZWdleHApO1xuICBpZiAobWF0Y2hlcykge1xuICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlc1swXTtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBtYXRjaGVzLmluZGV4ICsgbWF0Y2gubGVuZ3RoO1xuICAgIHJldHVybiBbXG4gICAgICB0ZXh0LnNsaWNlKDAsIG1hdGNoZXMuaW5kZXgpLFxuICAgICAgdGV4dC5zbGljZShtYXRjaGVzLmluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgdGV4dC5zbGljZShsYXN0SW5kZXgpXG4gICAgXTtcbiAgfVxufVxuY29uc3QgV2hpdGVzcGFjZSA9IC9cXHMrL2c7XG5mdW5jdGlvbiB0YWdUb0tleSh0YWcpIHtcbiAgcmV0dXJuIGAke1N0cmluZyh0YWcudmFsdWUpfS0ke3RhZy5sYWJlbH1gO1xufVxuZnVuY3Rpb24gdGFnVG9JZCh0YWcpIHtcbiAgcmV0dXJuIHRhZ1RvS2V5KHRhZykucmVwbGFjZShXaGl0ZXNwYWNlLCBcIl9cIik7XG59XG5mdW5jdGlvbiBmaW5kVGFnSW5kZXgodGFnLCB0YWdzKSB7XG4gIHJldHVybiB0YWdzLmZpbmRJbmRleCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSA9PT0gdGFnLnZhbHVlKTtcbn1cbmNvbnN0IEVzY2FwZVJlZ0V4cCA9IC9bLVxcXFxeJCorPy4oKXxbXFxde31dL2c7XG5mdW5jdGlvbiBlc2NhcGVGb3JSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShFc2NhcGVSZWdFeHAsIFwiXFxcXCQmXCIpO1xufVxuZnVuY3Rpb24gcGFydGlhbFJlZ0V4cChxdWVyeSkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChlc2NhcGVGb3JSZWdFeHAocXVlcnkpLCBcImlcIik7XG59XG5mdW5jdGlvbiBleGFjdFJlZ0V4cChxdWVyeSkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7ZXNjYXBlRm9yUmVnRXhwKHF1ZXJ5KX0kYCwgXCJpXCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hUYWdzUGFydGlhbChxdWVyeSwgc3VnZ2VzdGlvbnMpIHtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgY29uc3QgcmVnZXhwID0gcGFydGlhbFJlZ0V4cChxdWVyeSk7XG4gICAgcmV0dXJuIHN1Z2dlc3Rpb25zLmZpbHRlcigoaXRlbSkgPT4gcmVnZXhwLnRlc3QoaXRlbS5sYWJlbCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXS5jb25jYXQoc3VnZ2VzdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiBtYXRjaFRhZ0V4YWN0KHF1ZXJ5LCBzdWdnZXN0aW9ucykge1xuICBjb25zdCByZWdleHAgPSBleGFjdFJlZ0V4cChxdWVyeSk7XG4gIHJldHVybiBzdWdnZXN0aW9ucy5maW5kKChpdGVtKSA9PiByZWdleHAudGVzdChpdGVtLmxhYmVsKSkgfHwgbnVsbDtcbn1cbmNvbnN0IERpc2FibGVBdXRvQ29tcGxldGVBdHRycyA9IHtcbiAgYXV0b0NvbXBsZXRlOiBcIm9mZlwiLFxuICBhdXRvQ29ycmVjdDogXCJvZmZcIixcbiAgXCJkYXRhLWZvcm0tdHlwZVwiOiBcIm90aGVyXCIsXG4gIHNwZWxsQ2hlY2s6IGZhbHNlXG59O1xuZnVuY3Rpb24gdXNlSW5wdXQoe1xuICBhbGxvd0JhY2tzcGFjZSxcbiAgYXJpYURlc2NyaWJlZEJ5LFxuICBhcmlhRXJyb3JNZXNzYWdlLFxuICBkZWxpbWl0ZXJLZXlzXG59KSB7XG4gIGNvbnN0IHsgaWQsIGNvbWJvQm94UmVmLCBpbnB1dFJlZiwgaXNEaXNhYmxlZCwgaXNJbnZhbGlkLCBtYW5hZ2VyUmVmIH0gPSBSZWFjdC51c2VDb250ZXh0KEdsb2JhbENvbnRleHQpO1xuICBjb25zdCBldmVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBvbkNoYW5nZSA9IChlKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZTIgPSBlLmN1cnJlbnRUYXJnZXQudmFsdWU7XG4gICAgICBtYW5hZ2VyUmVmLmN1cnJlbnQudXBkYXRlSW5wdXRWYWx1ZSh2YWx1ZTIpO1xuICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGlucHV0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgbWFuYWdlclJlZi5jdXJyZW50Lmxpc3RCb3hFeHBhbmQodmFsdWUyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uRm9jdXMgPSAoKSA9PiB7XG4gICAgICBtYW5hZ2VyUmVmLmN1cnJlbnQubGlzdEJveEV4cGFuZCgpO1xuICAgIH07XG4gICAgY29uc3Qgb25CbHVyID0gKGUpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICgoKF9hID0gY29tYm9Cb3hSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpID09PSBmYWxzZSkge1xuICAgICAgICBtYW5hZ2VyUmVmLmN1cnJlbnQubGlzdEJveENvbGxhcHNlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkNsaWNrID0gKCkgPT4ge1xuICAgICAgbWFuYWdlclJlZi5jdXJyZW50Lmxpc3RCb3hFeHBhbmQoKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRG93bkFycm93S2V5ID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgYWN0aXZlSW5kZXgsIGlzRXhwYW5kZWQ6IGlzRXhwYW5kZWQyIH0gPSBtYW5hZ2VyUmVmLmN1cnJlbnQuc3RhdGU7XG4gICAgICBpZiAoaXNFeHBhbmRlZDIpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBtYW5hZ2VyUmVmLmN1cnJlbnQudXBkYXRlQWN0aXZlSW5kZXgoYWN0aXZlSW5kZXggKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNDYXJldEF0RW5kKGUuY3VycmVudFRhcmdldCkgfHwgZS5hbHRLZXkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBtYW5hZ2VyUmVmLmN1cnJlbnQubGlzdEJveEV4cGFuZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25VcEFycm93S2V5ID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgYWN0aXZlSW5kZXgsIGlzRXhwYW5kZWQ6IGlzRXhwYW5kZWQyIH0gPSBtYW5hZ2VyUmVmLmN1cnJlbnQuc3RhdGU7XG4gICAgICBpZiAoaXNFeHBhbmRlZDIpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBtYW5hZ2VyUmVmLmN1cnJlbnQudXBkYXRlQWN0aXZlSW5kZXgoYWN0aXZlSW5kZXggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNDYXJldEF0U3RhcnQoZS5jdXJyZW50VGFyZ2V0KSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG1hbmFnZXJSZWYuY3VycmVudC5saXN0Qm94RXhwYW5kKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvblBhZ2VEb3duS2V5ID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgaXNFeHBhbmRlZDogaXNFeHBhbmRlZDIsIG9wdGlvbnMgfSA9IG1hbmFnZXJSZWYuY3VycmVudC5zdGF0ZTtcbiAgICAgIGlmIChpc0V4cGFuZGVkMikge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG1hbmFnZXJSZWYuY3VycmVudC51cGRhdGVBY3RpdmVJbmRleChvcHRpb25zLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25QYWdlVXBLZXkgPSAoZSkgPT4ge1xuICAgICAgaWYgKG1hbmFnZXJSZWYuY3VycmVudC5zdGF0ZS5pc0V4cGFuZGVkKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbWFuYWdlclJlZi5jdXJyZW50LnVwZGF0ZUFjdGl2ZUluZGV4KDApO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25Fc2NhcGVLZXkgPSAoKSA9PiB7XG4gICAgICBpZiAobWFuYWdlclJlZi5jdXJyZW50LnN0YXRlLmlzRXhwYW5kZWQpIHtcbiAgICAgICAgbWFuYWdlclJlZi5jdXJyZW50Lmxpc3RCb3hDb2xsYXBzZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFuYWdlclJlZi5jdXJyZW50LnVwZGF0ZUlucHV0VmFsdWUoXCJcIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkJhY2tzcGFjZUtleSA9ICgpID0+IHtcbiAgICAgIGlmIChhbGxvd0JhY2tzcGFjZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlOiB2YWx1ZTIsIHNlbGVjdGVkIH0gPSBtYW5hZ2VyUmVmLmN1cnJlbnQuc3RhdGU7XG4gICAgICAgIGNvbnN0IGxhc3RUYWcgPSBzZWxlY3RlZFtzZWxlY3RlZC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHZhbHVlMiA9PT0gXCJcIiAmJiBsYXN0VGFnKSB7XG4gICAgICAgICAgbWFuYWdlclJlZi5jdXJyZW50LnNlbGVjdFRhZyhsYXN0VGFnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25EZWxpbWl0ZXJLZXkgPSAoZSkgPT4ge1xuICAgICAgaWYgKG1hbmFnZXJSZWYuY3VycmVudC5zdGF0ZS5pc0V4cGFuZGVkKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbWFuYWdlclJlZi5jdXJyZW50LnNlbGVjdFRhZygpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGUpID0+IHtcbiAgICAgIGlmIChlLmtleSA9PT0gS2V5TmFtZXMuVXBBcnJvdykgcmV0dXJuIG9uVXBBcnJvd0tleShlKTtcbiAgICAgIGlmIChlLmtleSA9PT0gS2V5TmFtZXMuRG93bkFycm93KSByZXR1cm4gb25Eb3duQXJyb3dLZXkoZSk7XG4gICAgICBpZiAoZS5rZXkgPT09IEtleU5hbWVzLlBhZ2VVcCkgcmV0dXJuIG9uUGFnZVVwS2V5KGUpO1xuICAgICAgaWYgKGUua2V5ID09PSBLZXlOYW1lcy5QYWdlRG93bikgcmV0dXJuIG9uUGFnZURvd25LZXkoZSk7XG4gICAgICBpZiAoZS5rZXkgPT09IEtleU5hbWVzLkVzY2FwZSkgcmV0dXJuIG9uRXNjYXBlS2V5KCk7XG4gICAgICBpZiAoZS5rZXkgPT09IEtleU5hbWVzLkJhY2tzcGFjZSkgcmV0dXJuIG9uQmFja3NwYWNlS2V5KCk7XG4gICAgICBpZiAoZGVsaW1pdGVyS2V5cy5pbmNsdWRlcyhlLmtleSkpIHJldHVybiBvbkRlbGltaXRlcktleShlKTtcbiAgICB9O1xuICAgIHJldHVybiB7IG9uQmx1ciwgb25DaGFuZ2UsIG9uQ2xpY2ssIG9uRm9jdXMsIG9uS2V5RG93biB9O1xuICB9LCBbYWxsb3dCYWNrc3BhY2UsIGNvbWJvQm94UmVmLCBkZWxpbWl0ZXJLZXlzLCBpbnB1dFJlZiwgbWFuYWdlclJlZl0pO1xuICBjb25zdCB7IGFjdGl2ZU9wdGlvbiwgaXNFeHBhbmRlZCwgdmFsdWUgfSA9IG1hbmFnZXJSZWYuY3VycmVudC5zdGF0ZTtcbiAgcmV0dXJuIHtcbiAgICAuLi5EaXNhYmxlQXV0b0NvbXBsZXRlQXR0cnMsXG4gICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBcImxpc3RcIixcbiAgICBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiBhY3RpdmVPcHRpb24gPyBvcHRpb25JZChpZCwgYWN0aXZlT3B0aW9uKSA6IHZvaWQgMCxcbiAgICBcImFyaWEtY29udHJvbHNcIjogbGlzdEJveElkKGlkKSxcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZEJ5IHx8IHZvaWQgMCxcbiAgICBcImFyaWEtZGlzYWJsZWRcIjogaXNEaXNhYmxlZCxcbiAgICBcImFyaWEtZXJyb3JtZXNzYWdlXCI6IGlzSW52YWxpZCAmJiBhcmlhRXJyb3JNZXNzYWdlIHx8IHZvaWQgMCxcbiAgICBcImFyaWEtaW52YWxpZFwiOiBpc0ludmFsaWQsXG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxJZChpZCksXG4gICAgXCJhcmlhLWV4cGFuZGVkXCI6IGlzRXhwYW5kZWQsXG4gICAgaWQ6IGlucHV0SWQoaWQpLFxuICAgIG9uQmx1cjogaXNEaXNhYmxlZCA/IFZvaWRGbiA6IGV2ZW50cy5vbkJsdXIsXG4gICAgb25DaGFuZ2U6IGlzRGlzYWJsZWQgPyBWb2lkRm4gOiBldmVudHMub25DaGFuZ2UsXG4gICAgb25DbGljazogaXNEaXNhYmxlZCA/IFZvaWRGbiA6IGV2ZW50cy5vbkNsaWNrLFxuICAgIG9uRm9jdXM6IGlzRGlzYWJsZWQgPyBWb2lkRm4gOiBldmVudHMub25Gb2N1cyxcbiAgICBvbktleURvd246IGlzRGlzYWJsZWQgPyBWb2lkRm4gOiBldmVudHMub25LZXlEb3duLFxuICAgIHJlZjogaW5wdXRSZWYsXG4gICAgcm9sZTogXCJjb21ib2JveFwiLFxuICAgIHR5cGU6IFwidGV4dFwiLFxuICAgIHZhbHVlXG4gIH07XG59XG5jb25zdCBTaXplclN0eWxlcyA9IHtcbiAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIixcbiAgb3ZlcmZsb3c6IFwic2Nyb2xsXCIsXG4gIHdoaXRlU3BhY2U6IFwicHJlXCJcbn07XG5jb25zdCBTdHlsZVByb3BzID0gW1xuICBcImZvbnQtZmFtaWx5XCIsXG4gIFwiZm9udC1zaXplXCIsXG4gIFwiZm9udC1zdHlsZVwiLFxuICBcImZvbnQtd2VpZ2h0XCIsXG4gIFwibGV0dGVyLXNwYWNpbmdcIixcbiAgXCJ0ZXh0LXRyYW5zZm9ybVwiXG5dO1xuZnVuY3Rpb24gdXNlSW5wdXRTaXplcih7IGFsbG93UmVzaXplID0gdHJ1ZSwgdGV4dCB9KSB7XG4gIGNvbnN0IHNpemVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCB7IGlucHV0UmVmIH0gPSBSZWFjdC51c2VDb250ZXh0KEdsb2JhbENvbnRleHQpO1xuICBjb25zdCBbd2lkdGgsIHNldFdpZHRoXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChhbGxvd1Jlc2l6ZSAmJiBpbnB1dFJlZi5jdXJyZW50ICYmIHNpemVyUmVmLmN1cnJlbnQgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgIGNvbnN0IGlucHV0U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpbnB1dFJlZi5jdXJyZW50KTtcbiAgICAgIFN0eWxlUHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGlucHV0U3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKTtcbiAgICAgICAgc2l6ZXJSZWYuY3VycmVudC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFthbGxvd1Jlc2l6ZSwgaW5wdXRSZWYsIHNpemVyUmVmXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChhbGxvd1Jlc2l6ZSkge1xuICAgICAgY29uc3QgbmV3V2lkdGggPSBNYXRoLmNlaWwoKChfYSA9IHNpemVyUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zY3JvbGxXaWR0aCkgPz8gMCkgKyAyO1xuICAgICAgaWYgKHdpZHRoICE9PSBuZXdXaWR0aCkgc2V0V2lkdGgobmV3V2lkdGgpO1xuICAgIH1cbiAgfSwgW2FsbG93UmVzaXplLCB0ZXh0LCB3aWR0aF0pO1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIHNpemVyUHJvcHM6IHtcbiAgICAgIHJlZjogc2l6ZXJSZWYsXG4gICAgICBzdHlsZTogU2l6ZXJTdHlsZXNcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB1c2VMaXN0Qm94KCkge1xuICBjb25zdCB7IGlkLCBpbnB1dFJlZiwgbGlzdEJveFJlZiwgbWFuYWdlclJlZiB9ID0gUmVhY3QudXNlQ29udGV4dChHbG9iYWxDb250ZXh0KTtcbiAgY29uc3Qgc2Nyb2xsVG9Ub3AgPSBtYW5hZ2VyUmVmLmN1cnJlbnQuc3RhdGUuYWN0aXZlSW5kZXggPT09IC0xO1xuICBjb25zdCBvbkZvY3VzID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGUpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChlLnRhcmdldCAhPT0gaW5wdXRSZWYuY3VycmVudCkge1xuICAgICAgICAoX2EgPSBpbnB1dFJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2lucHV0UmVmXVxuICApO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoc2Nyb2xsVG9Ub3ApIHtcbiAgICAgIChfYSA9IGxpc3RCb3hSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNjcm9sbFRvKHsgdG9wOiAwIH0pO1xuICAgIH1cbiAgfSwgW2xpc3RCb3hSZWYsIHNjcm9sbFRvVG9wXSk7XG4gIHJldHVybiB7XG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxJZChpZCksXG4gICAgaWQ6IGxpc3RCb3hJZChpZCksXG4gICAgb25Gb2N1cyxcbiAgICByZWY6IGxpc3RCb3hSZWYsXG4gICAgcm9sZTogXCJsaXN0Ym94XCIsXG4gICAgdGFiSW5kZXg6IC0xXG4gIH07XG59XG5mdW5jdGlvbiB1c2VNYW5hZ2VyKHtcbiAgYWN0aXZhdGVGaXJzdE9wdGlvbixcbiAgYWxsb3dOZXcsXG4gIGNvbGxhcHNlT25TZWxlY3QsXG4gIG5ld09wdGlvblRleHQsXG4gIG5vT3B0aW9uc1RleHQsXG4gIG9uQWRkLFxuICBvbkRlbGV0ZSxcbiAgb25Db2xsYXBzZSxcbiAgb25FeHBhbmQsXG4gIG9uSW5wdXQsXG4gIG9uU2hvdWxkQ29sbGFwc2UsXG4gIG9uU2hvdWxkRXhwYW5kLFxuICBvblZhbGlkYXRlLFxuICBzZWxlY3RlZCxcbiAgc3VnZ2VzdGlvbnMsXG4gIHN1Z2dlc3Rpb25zVHJhbnNmb3JtXG59KSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBbbGFzdEFjdGl2ZU9wdGlvbiwgc2V0TGFzdEFjdGl2ZU9wdGlvbl0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2lzRXhwYW5kZWQsIHNldElzRXhwYW5kZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBvcHRpb25zID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qgb3B0cyA9IHN1Z2dlc3Rpb25zVHJhbnNmb3JtKHZhbHVlLCBzdWdnZXN0aW9ucyk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoYWxsb3dOZXcpIHtcbiAgICAgICAgb3B0cy5wdXNoKHtcbiAgICAgICAgICBkaXNhYmxlZDogb25WYWxpZGF0ZSA/ICFvblZhbGlkYXRlKHZhbHVlKSA6IGZhbHNlLFxuICAgICAgICAgIGxhYmVsOiBuZXdPcHRpb25UZXh0LFxuICAgICAgICAgIHZhbHVlOiBOZXdPcHRpb25WYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvcHRzLnB1c2goe1xuICAgICAgICAgIGRpc2FibGVkOiB0cnVlLFxuICAgICAgICAgIGxhYmVsOiBub09wdGlvbnNUZXh0LFxuICAgICAgICAgIHZhbHVlOiBOb09wdGlvbnNWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdHM7XG4gIH0sIFthbGxvd05ldywgbmV3T3B0aW9uVGV4dCwgbm9PcHRpb25zVGV4dCwgb25WYWxpZGF0ZSwgc3VnZ2VzdGlvbnMsIHN1Z2dlc3Rpb25zVHJhbnNmb3JtLCB2YWx1ZV0pO1xuICBjb25zdCBvcHRpb25JbmRleCA9IGxhc3RBY3RpdmVPcHRpb24gPyBmaW5kVGFnSW5kZXgobGFzdEFjdGl2ZU9wdGlvbiwgb3B0aW9ucykgOiAtMTtcbiAgY29uc3QgYWN0aXZlSW5kZXggPSBhY3RpdmF0ZUZpcnN0T3B0aW9uID8gTWF0aC5tYXgob3B0aW9uSW5kZXgsIDApIDogb3B0aW9uSW5kZXg7XG4gIGNvbnN0IGFjdGl2ZU9wdGlvbiA9IG9wdGlvbnNbYWN0aXZlSW5kZXhdO1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICBhY3RpdmVPcHRpb24sXG4gICAgaXNFeHBhbmRlZCxcbiAgICBvcHRpb25zLFxuICAgIHNlbGVjdGVkLFxuICAgIHZhbHVlXG4gIH07XG4gIGNvbnN0IGZsYWdzID0ge1xuICAgIHRhZ3NBZGRlZDogcmVmLmN1cnJlbnQgPyBhcnJheURpZmYoc2VsZWN0ZWQsIHJlZi5jdXJyZW50LnN0YXRlLnNlbGVjdGVkKSA6IFtdLFxuICAgIHRhZ3NEZWxldGVkOiByZWYuY3VycmVudCA/IGFycmF5RGlmZihyZWYuY3VycmVudC5zdGF0ZS5zZWxlY3RlZCwgc2VsZWN0ZWQpIDogW11cbiAgfTtcbiAgY29uc3QgYXBpID0ge1xuICAgIGxpc3RCb3hDb2xsYXBzZSh2YWx1ZTIpIHtcbiAgICAgIGlmICghaXNFeHBhbmRlZCkgcmV0dXJuO1xuICAgICAgaWYgKG9uU2hvdWxkQ29sbGFwc2UgPyBvblNob3VsZENvbGxhcHNlKHZhbHVlMiA/PyBzdGF0ZS52YWx1ZSkgOiB0cnVlKSB7XG4gICAgICAgIHNldElzRXhwYW5kZWQoZmFsc2UpO1xuICAgICAgICBzZXRMYXN0QWN0aXZlT3B0aW9uKG51bGwpO1xuICAgICAgICBvbkNvbGxhcHNlID09IG51bGwgPyB2b2lkIDAgOiBvbkNvbGxhcHNlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsaXN0Qm94RXhwYW5kKHZhbHVlMikge1xuICAgICAgaWYgKGlzRXhwYW5kZWQpIHJldHVybjtcbiAgICAgIGlmIChvblNob3VsZEV4cGFuZCA/IG9uU2hvdWxkRXhwYW5kKHZhbHVlMiA/PyBzdGF0ZS52YWx1ZSkgOiB0cnVlKSB7XG4gICAgICAgIHNldElzRXhwYW5kZWQodHJ1ZSk7XG4gICAgICAgIHNldExhc3RBY3RpdmVPcHRpb24ob3B0aW9uc1thY3RpdmVJbmRleF0pO1xuICAgICAgICBvbkV4cGFuZCA9PSBudWxsID8gdm9pZCAwIDogb25FeHBhbmQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZUFjdGl2ZUluZGV4KGluZGV4KSB7XG4gICAgICBjb25zdCBhY3RpdmVJbmRleDIgPSBsb29wT3B0aW9uc0luZGV4KGluZGV4LCBvcHRpb25zLmxlbmd0aCwgYWN0aXZhdGVGaXJzdE9wdGlvbiA/IDAgOiAtMSk7XG4gICAgICBzZXRMYXN0QWN0aXZlT3B0aW9uKG9wdGlvbnNbYWN0aXZlSW5kZXgyXSk7XG4gICAgfSxcbiAgICB1cGRhdGVJbnB1dFZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgb25JbnB1dCA9PSBudWxsID8gdm9pZCAwIDogb25JbnB1dChuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3RUYWcodGFnKSB7XG4gICAgICB0YWcgPz8gKHRhZyA9IGZpbmRTZWxlY3RlZE9wdGlvbihzdGF0ZSkpO1xuICAgICAgaWYgKHRhZykge1xuICAgICAgICBjb25zdCB0YWdJbmRleCA9IGZpbmRUYWdJbmRleCh0YWcsIHN0YXRlLnNlbGVjdGVkKTtcbiAgICAgICAgaWYgKHRhZ0luZGV4ID4gLTEpIHtcbiAgICAgICAgICBvbkRlbGV0ZSh0YWdJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25BZGQodGFnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sbGFwc2VPblNlbGVjdCkge1xuICAgICAgICAgIHRoaXMubGlzdEJveENvbGxhcHNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVJbnB1dFZhbHVlKFwiXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmVmLmN1cnJlbnQgPSB7IC4uLmFwaSwgZmxhZ3MsIHN0YXRlIH07XG4gIHJldHVybiByZWY7XG59XG5mdW5jdGlvbiB1c2VPcHRpb24oaW5kZXgpIHtcbiAgY29uc3QgeyBpZCwgaW5wdXRSZWYsIGxpc3RCb3hSZWYsIG1hbmFnZXJSZWYgfSA9IFJlYWN0LnVzZUNvbnRleHQoR2xvYmFsQ29udGV4dCk7XG4gIGNvbnN0IG9wdGlvblJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgb3B0aW9uID0gbWFuYWdlclJlZi5jdXJyZW50LnN0YXRlLm9wdGlvbnNbaW5kZXhdO1xuICBjb25zdCBhY3RpdmUgPSBpbmRleCA9PT0gbWFuYWdlclJlZi5jdXJyZW50LnN0YXRlLmFjdGl2ZUluZGV4O1xuICBjb25zdCBkaXNhYmxlZCA9IG9wdGlvbi5kaXNhYmxlZCA/PyBmYWxzZTtcbiAgY29uc3Qgc2VsZWN0ZWQgPSBmaW5kVGFnSW5kZXgob3B0aW9uLCBtYW5hZ2VyUmVmLmN1cnJlbnQuc3RhdGUuc2VsZWN0ZWQpID4gLTE7XG4gIGNvbnN0IG9uQ2xpY2sgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIG1hbmFnZXJSZWYuY3VycmVudC5zZWxlY3RUYWcoKTtcbiAgICAoX2EgPSBpbnB1dFJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9jdXMoKTtcbiAgfSwgW2lucHV0UmVmLCBtYW5hZ2VyUmVmXSk7XG4gIGNvbnN0IG9uTW91c2VEb3duID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChpbmRleCAhPT0gbWFuYWdlclJlZi5jdXJyZW50LnN0YXRlLmFjdGl2ZUluZGV4KSB7XG4gICAgICBtYW5hZ2VyUmVmLmN1cnJlbnQudXBkYXRlQWN0aXZlSW5kZXgoaW5kZXgpO1xuICAgIH1cbiAgfSwgW2luZGV4LCBtYW5hZ2VyUmVmXSk7XG4gIHVzZVNjcm9sbEludG9WaWV3KG9wdGlvblJlZiwgbGlzdEJveFJlZiwgYWN0aXZlKTtcbiAgcmV0dXJuIHtcbiAgICBvcHRpb246IHtcbiAgICAgIC4uLm9wdGlvbixcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgaW5kZXgsXG4gICAgICBzZWxlY3RlZFxuICAgIH0sXG4gICAgb3B0aW9uUHJvcHM6IHtcbiAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiBkaXNhYmxlZCxcbiAgICAgIFwiYXJpYS1wb3NpbnNldFwiOiBpbmRleCArIDEsXG4gICAgICBcImFyaWEtc2VsZWN0ZWRcIjogZGlzYWJsZWQgPyB2b2lkIDAgOiBzZWxlY3RlZCxcbiAgICAgIFwiYXJpYS1zZXRzaXplXCI6IG1hbmFnZXJSZWYuY3VycmVudC5zdGF0ZS5vcHRpb25zLmxlbmd0aCxcbiAgICAgIGlkOiBvcHRpb25JZChpZCwgb3B0aW9uKSxcbiAgICAgIG9uQ2xpY2ssXG4gICAgICBvbk1vdXNlRG93bixcbiAgICAgIHJlZjogb3B0aW9uUmVmLFxuICAgICAgcm9sZTogXCJvcHRpb25cIixcbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZVB1YmxpY0FQSSh7IGlucHV0UmVmLCBtYW5hZ2VyUmVmIH0pIHtcbiAgY29uc3QgYXBpID0gUmVhY3QudXNlUmVmKHtcbiAgICBpbnB1dDoge1xuICAgICAgYmx1cigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBpbnB1dFJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuYmx1cigpO1xuICAgICAgfSxcbiAgICAgIGZvY3VzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IGlucHV0UmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5mb2N1cygpO1xuICAgICAgfSxcbiAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZXJSZWYuY3VycmVudC5zdGF0ZS52YWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBtYW5hZ2VyUmVmLmN1cnJlbnQudXBkYXRlSW5wdXRWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsaXN0Qm94OiB7XG4gICAgICBjb2xsYXBzZSgpIHtcbiAgICAgICAgbWFuYWdlclJlZi5jdXJyZW50Lmxpc3RCb3hDb2xsYXBzZSgpO1xuICAgICAgfSxcbiAgICAgIGV4cGFuZCgpIHtcbiAgICAgICAgbWFuYWdlclJlZi5jdXJyZW50Lmxpc3RCb3hFeHBhbmQoKTtcbiAgICAgIH0sXG4gICAgICBnZXQgYWN0aXZlT3B0aW9uKCkge1xuICAgICAgICByZXR1cm4gbWFuYWdlclJlZi5jdXJyZW50LnN0YXRlLmFjdGl2ZU9wdGlvbjtcbiAgICAgIH0sXG4gICAgICBnZXQgaXNFeHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZXJSZWYuY3VycmVudC5zdGF0ZS5pc0V4cGFuZGVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0KHRhZykge1xuICAgICAgbWFuYWdlclJlZi5jdXJyZW50LnNlbGVjdFRhZyh0YWcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhcGkuY3VycmVudDtcbn1cbmZ1bmN0aW9uIHVzZVJvb3QoeyBvbkJsdXIsIG9uRm9jdXMgfSkge1xuICBjb25zdCBbaXNBY3RpdmUsIHNldElzQWN0aXZlXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgeyBpZCwgaW5wdXRSZWYsIHJvb3RSZWYgfSA9IFJlYWN0LnVzZUNvbnRleHQoR2xvYmFsQ29udGV4dCk7XG4gIGNvbnN0IHJvb3RQcm9wcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogbGFiZWxJZChpZCksXG4gICAgICBpZDogcm9vdElkKGlkKSxcbiAgICAgIG9uRm9jdXMoKSB7XG4gICAgICAgIHNldElzQWN0aXZlKHRydWUpO1xuICAgICAgICBvbkZvY3VzID09IG51bGwgPyB2b2lkIDAgOiBvbkZvY3VzKCk7XG4gICAgICB9LFxuICAgICAgb25CbHVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghKChfYSA9IHJvb3RSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSkge1xuICAgICAgICAgIHNldElzQWN0aXZlKGZhbHNlKTtcbiAgICAgICAgICBvbkJsdXIgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQmx1cigpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbGljaygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gcm9vdFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgKF9hID0gaW5wdXRSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZWY6IHJvb3RSZWYsXG4gICAgICB0YWJJbmRleDogLTFcbiAgICB9O1xuICB9LCBbaW5wdXRSZWYsIGlkLCBvbkJsdXIsIG9uRm9jdXMsIHJvb3RSZWZdKTtcbiAgcmV0dXJuIHtcbiAgICBpc0FjdGl2ZSxcbiAgICByb290UHJvcHNcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZVNjcm9sbEludG9WaWV3KHRhcmdldFJlZiwgY29udGFpbmVyUmVmLCBzaG91bGRTY3JvbGwpIHtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKHNob3VsZFNjcm9sbCkge1xuICAgICAgY29uc3QgdGFyZ2V0SGVpZ2h0ID0gKF9hID0gdGFyZ2V0UmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5vZmZzZXRIZWlnaHQ7XG4gICAgICBjb25zdCB0YXJnZXRPZmZzZXQgPSAoX2IgPSB0YXJnZXRSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm9mZnNldFRvcDtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckhlaWdodCA9IChfYyA9IGNvbnRhaW5lclJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Mub2Zmc2V0SGVpZ2h0O1xuICAgICAgY29uc3QgY29udGFpbmVyU2Nyb2xsID0gKF9kID0gY29udGFpbmVyUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZC5zY3JvbGxUb3A7XG4gICAgICBpZiAodGFyZ2V0T2Zmc2V0IDwgY29udGFpbmVyU2Nyb2xsKSB7XG4gICAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50LnNjcm9sbFRvKDAsIHRhcmdldE9mZnNldCk7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0T2Zmc2V0ICsgdGFyZ2V0SGVpZ2h0ID4gY29udGFpbmVyU2Nyb2xsICsgY29udGFpbmVySGVpZ2h0KSB7XG4gICAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50LnNjcm9sbFRvKDAsIHRhcmdldE9mZnNldCArIHRhcmdldEhlaWdodCAtIGNvbnRhaW5lckhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbc2hvdWxkU2Nyb2xsLCBjb250YWluZXJSZWYsIHRhcmdldFJlZl0pO1xufVxuZnVuY3Rpb24gdXNlU2VsZWN0ZWRUYWcoaW5kZXgsIHRpdGxlKSB7XG4gIGNvbnN0IHsgaXNEaXNhYmxlZCwgbWFuYWdlclJlZiB9ID0gUmVhY3QudXNlQ29udGV4dChHbG9iYWxDb250ZXh0KTtcbiAgY29uc3QgdGFnID0gbWFuYWdlclJlZi5jdXJyZW50LnN0YXRlLnNlbGVjdGVkW2luZGV4XTtcbiAgY29uc3Qgb25DbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IG1hbmFnZXJSZWYuY3VycmVudC5zZWxlY3RUYWcodGFnKSwgW21hbmFnZXJSZWYsIHRhZ10pO1xuICByZXR1cm4ge1xuICAgIHRhZyxcbiAgICB0YWdQcm9wczoge1xuICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IGlzRGlzYWJsZWQsXG4gICAgICB0aXRsZTogcmVwbGFjZVBsYWNlaG9sZGVyKHRpdGxlLCB0YWcubGFiZWwpLFxuICAgICAgb25DbGljazogaXNEaXNhYmxlZCA/IFZvaWRGbiA6IG9uQ2xpY2tcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB1c2VUYWdMaXN0KHsgbGFiZWwgfSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHsgcm9vdFJlZiwgbWFuYWdlclJlZiB9ID0gUmVhY3QudXNlQ29udGV4dChHbG9iYWxDb250ZXh0KTtcbiAgY29uc3QgbGlzdFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCB0YWdEZWxldGVkID0gbWFuYWdlclJlZi5jdXJyZW50LmZsYWdzLnRhZ3NEZWxldGVkWzBdO1xuICBjb25zdCBpc0ZvY3VzSW5MaXN0ID0gKF9hID0gbGlzdFJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgaWYgKHRhZ0RlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGlzRm9jdXNJbkxpc3ROb3cgPSAoX2EyID0gbGlzdFJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgaWYgKGlzRm9jdXNJbkxpc3QgJiYgIWlzRm9jdXNJbkxpc3ROb3cpIHtcbiAgICAgICAgKF9iID0gcm9vdFJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2lzRm9jdXNJbkxpc3QsIGxpc3RSZWYsIHJvb3RSZWYsIHRhZ0RlbGV0ZWRdKTtcbiAgcmV0dXJuIHsgcmVmOiBsaXN0UmVmLCBcImFyaWEtbGFiZWxcIjogbGFiZWwgfTtcbn1cbmNvbnN0IFZpc3VhbGx5SGlkZGVuU3R5bGVzID0ge1xuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICB3aWR0aDogMSxcbiAgaGVpZ2h0OiAxLFxuICBsZWZ0OiAtOTk5OSxcbiAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gIGNsaXA6IFwicmVjdCgwIDAgMCAwKVwiXG59O1xuZnVuY3Rpb24gQW5ub3VuY2VtZW50cyh7IGFyaWFBZGRlZFRleHQsIGFyaWFEZWxldGVkVGV4dCB9KSB7XG4gIGNvbnN0IHsgbWFuYWdlclJlZiB9ID0gUmVhY3QudXNlQ29udGV4dChHbG9iYWxDb250ZXh0KTtcbiAgY29uc3QgbG9nc1JlZiA9IFJlYWN0LnVzZVJlZihbXSk7XG4gIG1hbmFnZXJSZWYuY3VycmVudC5mbGFncy50YWdzQWRkZWQuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgbG9nc1JlZi5jdXJyZW50LnB1c2gocmVwbGFjZVBsYWNlaG9sZGVyKGFyaWFBZGRlZFRleHQsIHRhZy5sYWJlbCkpO1xuICB9KTtcbiAgbWFuYWdlclJlZi5jdXJyZW50LmZsYWdzLnRhZ3NEZWxldGVkLmZvckVhY2goKHRhZykgPT4ge1xuICAgIGxvZ3NSZWYuY3VycmVudC5wdXNoKHJlcGxhY2VQbGFjZWhvbGRlcihhcmlhRGVsZXRlZFRleHQsIHRhZy5sYWJlbCkpO1xuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJhcmlhLWxpdmVcIjogXCJwb2xpdGVcIiwgXCJhcmlhLXJlbGV2YW50XCI6IFwiYWRkaXRpb25zXCIsIHJvbGU6IFwic3RhdHVzXCIsIHN0eWxlOiBWaXN1YWxseUhpZGRlblN0eWxlcyB9LCBsb2dzUmVmLmN1cnJlbnQuam9pbihcIlxcblwiKSk7XG59XG5mdW5jdGlvbiBDb21ib0JveCh7IGNoaWxkcmVuIH0pIHtcbiAgY29uc3QgeyBjbGFzc05hbWVzLCBjb21ib0JveFJlZiwgaWQgfSA9IFJlYWN0LnVzZUNvbnRleHQoR2xvYmFsQ29udGV4dCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5jb21ib0JveCwgaWQ6IGNvbWJvQm94SWQoaWQpLCByZWY6IGNvbWJvQm94UmVmIH0sIGNoaWxkcmVuKTtcbn1cbmNvbnN0IERlZmF1bHRIaWdobGlnaHQgPSAoeyBjbGFzc05hbWVzLCB0ZXh0IH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwibWFya1wiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5oaWdobGlnaHQgfSwgdGV4dCk7XG59O1xuZnVuY3Rpb24gSGlnaGxpZ2h0KHsgb3B0aW9uLCBxdWVyeSwgcmVuZGVyID0gRGVmYXVsdEhpZ2hsaWdodCB9KSB7XG4gIGNvbnN0IHsgY2xhc3NOYW1lcyB9ID0gUmVhY3QudXNlQ29udGV4dChHbG9iYWxDb250ZXh0KTtcbiAgaWYgKG9wdGlvbi52YWx1ZSA9PT0gTmV3T3B0aW9uVmFsdWUgfHwgb3B0aW9uLnZhbHVlID09PSBOb09wdGlvbnNWYWx1ZSkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgcmVwbGFjZVBsYWNlaG9sZGVyKG9wdGlvbi5sYWJlbCwgcXVlcnkpKTtcbiAgfVxuICBpZiAocXVlcnkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBoaWdobGlnaHRUZXh0KG9wdGlvbi5sYWJlbCwgcXVlcnkpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGNvbnN0IGhpZ2hsaWdodGVkID0gcmVuZGVyKHsgdGV4dDogcmVzdWx0WzFdLCBjbGFzc05hbWVzIH0pO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByZXN1bHRbMF0sIGhpZ2hsaWdodGVkLCByZXN1bHRbMl0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIG9wdGlvbi5sYWJlbCk7XG59XG5jb25zdCBNZW1vaXplZEhpZ2hsaWdodCA9IFJlYWN0Lm1lbW8oSGlnaGxpZ2h0KTtcbmNvbnN0IERlZmF1bHRJbnB1dCA9ICh7IGNsYXNzTmFtZXMsIGlucHV0V2lkdGgsIC4uLmlucHV0UHJvcHMgfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5pbnB1dCwgc3R5bGU6IHsgd2lkdGg6IGlucHV0V2lkdGggfSwgLi4uaW5wdXRQcm9wcyB9KTtcbn07XG5mdW5jdGlvbiBJbnB1dCh7XG4gIGFsbG93QmFja3NwYWNlID0gdHJ1ZSxcbiAgYWxsb3dSZXNpemUgPSB0cnVlLFxuICBhcmlhRGVzY3JpYmVkQnksXG4gIGFyaWFFcnJvck1lc3NhZ2UsXG4gIGRlbGltaXRlcktleXMsXG4gIHBsYWNlaG9sZGVyVGV4dCxcbiAgcmVuZGVyID0gRGVmYXVsdElucHV0XG59KSB7XG4gIGNvbnN0IHsgY2xhc3NOYW1lcyB9ID0gUmVhY3QudXNlQ29udGV4dChHbG9iYWxDb250ZXh0KTtcbiAgY29uc3QgeyB2YWx1ZSwgLi4uaW5wdXRQcm9wcyB9ID0gdXNlSW5wdXQoe1xuICAgIGFsbG93QmFja3NwYWNlLFxuICAgIGFyaWFEZXNjcmliZWRCeSxcbiAgICBhcmlhRXJyb3JNZXNzYWdlLFxuICAgIGRlbGltaXRlcktleXNcbiAgfSk7XG4gIGNvbnN0IHRleHQgPSB2YWx1ZS5sZW5ndGggPCBwbGFjZWhvbGRlclRleHQubGVuZ3RoID8gcGxhY2Vob2xkZXJUZXh0IDogdmFsdWU7XG4gIGNvbnN0IHsgd2lkdGgsIHNpemVyUHJvcHMgfSA9IHVzZUlucHV0U2l6ZXIoeyBhbGxvd1Jlc2l6ZSwgdGV4dCB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByZW5kZXIoe1xuICAgIGNsYXNzTmFtZXMsXG4gICAgaW5wdXRXaWR0aDogd2lkdGgsXG4gICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyVGV4dCxcbiAgICB2YWx1ZSxcbiAgICAuLi5pbnB1dFByb3BzXG4gIH0pLCBhbGxvd1Jlc2l6ZSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgLi4uc2l6ZXJQcm9wcyB9LCB0ZXh0KSA6IG51bGwpO1xufVxuY29uc3QgRGVmYXVsdExhYmVsID0gKHsgY2hpbGRyZW4sIGNsYXNzTmFtZXMsIGlkIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmxhYmVsLCBpZCB9LCBjaGlsZHJlbik7XG59O1xuZnVuY3Rpb24gTGFiZWwoeyBjaGlsZHJlbiwgcmVuZGVyID0gRGVmYXVsdExhYmVsIH0pIHtcbiAgY29uc3QgeyBjbGFzc05hbWVzLCBpZCB9ID0gUmVhY3QudXNlQ29udGV4dChHbG9iYWxDb250ZXh0KTtcbiAgcmV0dXJuIHJlbmRlcih7IGNoaWxkcmVuLCBjbGFzc05hbWVzLCBpZDogbGFiZWxJZChpZCkgfSk7XG59XG5jb25zdCBEZWZhdWx0TGlzdEJveCA9ICh7IGNoaWxkcmVuLCBjbGFzc05hbWVzLCAuLi5saXN0Qm94UHJvcHMgfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMubGlzdEJveCwgLi4ubGlzdEJveFByb3BzIH0sIGNoaWxkcmVuKTtcbn07XG5mdW5jdGlvbiBMaXN0Qm94KHsgY2hpbGRyZW4sIHJlbmRlciA9IERlZmF1bHRMaXN0Qm94IH0pIHtcbiAgY29uc3QgeyBjbGFzc05hbWVzLCBtYW5hZ2VyUmVmIH0gPSBSZWFjdC51c2VDb250ZXh0KEdsb2JhbENvbnRleHQpO1xuICBjb25zdCBsaXN0Qm94UHJvcHMgPSB1c2VMaXN0Qm94KCk7XG4gIGlmICghbWFuYWdlclJlZi5jdXJyZW50LnN0YXRlLmlzRXhwYW5kZWQgfHwgUmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pID09PSAwKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHJlbmRlcih7IGNoaWxkcmVuLCBjbGFzc05hbWVzLCAuLi5saXN0Qm94UHJvcHMgfSk7XG59XG5jb25zdCBEZWZhdWx0T3B0aW9uID0gKHsgY2hpbGRyZW4sIGNsYXNzTmFtZXMsIG9wdGlvbiwgLi4ub3B0aW9uUHJvcHMgfSkgPT4ge1xuICBjb25zdCBjbGFzc2VzID0gW2NsYXNzTmFtZXMub3B0aW9uXTtcbiAgaWYgKG9wdGlvbi5hY3RpdmUpIGNsYXNzZXMucHVzaChjbGFzc05hbWVzLm9wdGlvbklzQWN0aXZlKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc2VzLmpvaW4oXCIgXCIpLCAuLi5vcHRpb25Qcm9wcyB9LCBjaGlsZHJlbik7XG59O1xuZnVuY3Rpb24gT3B0aW9uKHsgY2hpbGRyZW4sIGluZGV4LCByZW5kZXIgPSBEZWZhdWx0T3B0aW9uIH0pIHtcbiAgY29uc3QgeyBjbGFzc05hbWVzIH0gPSBSZWFjdC51c2VDb250ZXh0KEdsb2JhbENvbnRleHQpO1xuICBjb25zdCB7IG9wdGlvbiwgb3B0aW9uUHJvcHMgfSA9IHVzZU9wdGlvbihpbmRleCk7XG4gIHJldHVybiByZW5kZXIoeyBjbGFzc05hbWVzLCBjaGlsZHJlbiwgb3B0aW9uLCAuLi5vcHRpb25Qcm9wcyB9KTtcbn1cbmNvbnN0IERlZmF1bHRSb290ID0gKHtcbiAgY2hpbGRyZW4sXG4gIGNsYXNzTmFtZXMsXG4gIGlzQWN0aXZlLFxuICBpc0Rpc2FibGVkLFxuICBpc0ludmFsaWQsXG4gIC4uLnJvb3RQcm9wc1xufSkgPT4ge1xuICBjb25zdCBjbGFzc2VzID0gW2NsYXNzTmFtZXMucm9vdF07XG4gIGlmIChpc0FjdGl2ZSkgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZXMucm9vdElzQWN0aXZlKTtcbiAgaWYgKGlzRGlzYWJsZWQpIGNsYXNzZXMucHVzaChjbGFzc05hbWVzLnJvb3RJc0Rpc2FibGVkKTtcbiAgaWYgKGlzSW52YWxpZCkgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZXMucm9vdElzSW52YWxpZCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3Nlcy5qb2luKFwiIFwiKSwgLi4ucm9vdFByb3BzIH0sIGNoaWxkcmVuKTtcbn07XG5mdW5jdGlvbiBSb290KHsgY2hpbGRyZW4sIG9uQmx1ciwgb25Gb2N1cywgcmVuZGVyID0gRGVmYXVsdFJvb3QgfSkge1xuICBjb25zdCB7IGNsYXNzTmFtZXMsIGlzRGlzYWJsZWQsIGlzSW52YWxpZCB9ID0gUmVhY3QudXNlQ29udGV4dChHbG9iYWxDb250ZXh0KTtcbiAgY29uc3QgeyBpc0FjdGl2ZSwgcm9vdFByb3BzIH0gPSB1c2VSb290KHsgb25CbHVyLCBvbkZvY3VzIH0pO1xuICByZXR1cm4gcmVuZGVyKHsgY2hpbGRyZW4sIGNsYXNzTmFtZXMsIGlzQWN0aXZlLCBpc0Rpc2FibGVkLCBpc0ludmFsaWQsIC4uLnJvb3RQcm9wcyB9KTtcbn1cbmNvbnN0IERlZmF1bHRUYWcgPSAoeyBjbGFzc05hbWVzLCB0YWcsIC4uLnRhZ1Byb3BzIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnRhZywgLi4udGFnUHJvcHMgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnRhZ05hbWUgfSwgdGFnLmxhYmVsKSk7XG59O1xuZnVuY3Rpb24gVGFnKHsgcmVuZGVyID0gRGVmYXVsdFRhZywgaW5kZXgsIHRpdGxlIH0pIHtcbiAgY29uc3QgeyBjbGFzc05hbWVzIH0gPSBSZWFjdC51c2VDb250ZXh0KEdsb2JhbENvbnRleHQpO1xuICBjb25zdCB7IHRhZywgdGFnUHJvcHMgfSA9IHVzZVNlbGVjdGVkVGFnKGluZGV4LCB0aXRsZSk7XG4gIHJldHVybiByZW5kZXIoeyBjbGFzc05hbWVzLCB0YWcsIC4uLnRhZ1Byb3BzIH0pO1xufVxuY29uc3QgRGVmYXVsdFRhZ0xpc3QgPSAoe1xuICBjaGlsZHJlbixcbiAgY2xhc3NOYW1lcyxcbiAgLi4udGFnTGlzdFByb3BzXG59KSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnRhZ0xpc3QsIC4uLnRhZ0xpc3RQcm9wcywgcm9sZTogXCJsaXN0XCIgfSwgUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy50YWdMaXN0SXRlbSwga2V5OiBjaGlsZC5rZXksIHJvbGU6IFwibGlzdGl0ZW1cIiB9LCBjaGlsZCk7XG4gICAgfVxuICB9KSk7XG59O1xuZnVuY3Rpb24gVGFnTGlzdCh7IGNoaWxkcmVuLCBsYWJlbCwgcmVuZGVyID0gRGVmYXVsdFRhZ0xpc3QgfSkge1xuICBjb25zdCB7IGNsYXNzTmFtZXMgfSA9IFJlYWN0LnVzZUNvbnRleHQoR2xvYmFsQ29udGV4dCk7XG4gIGNvbnN0IHRhZ0xpc3RQcm9wcyA9IHVzZVRhZ0xpc3QoeyBsYWJlbCB9KTtcbiAgcmV0dXJuIHJlbmRlcih7IGNsYXNzTmFtZXMsIGNoaWxkcmVuLCAuLi50YWdMaXN0UHJvcHMgfSk7XG59XG5jb25zdCBEZWZhdWx0Q2xhc3NOYW1lcyA9IHtcbiAgcm9vdDogXCJyZWFjdC10YWdzXCIsXG4gIHJvb3RJc0FjdGl2ZTogXCJpcy1hY3RpdmVcIixcbiAgcm9vdElzRGlzYWJsZWQ6IFwiaXMtZGlzYWJsZWRcIixcbiAgcm9vdElzSW52YWxpZDogXCJpcy1pbnZhbGlkXCIsXG4gIGxhYmVsOiBcInJlYWN0LXRhZ3NfX2xhYmVsXCIsXG4gIHRhZ0xpc3Q6IFwicmVhY3QtdGFnc19fbGlzdFwiLFxuICB0YWdMaXN0SXRlbTogXCJyZWFjdC10YWdzX19saXN0LWl0ZW1cIixcbiAgdGFnOiBcInJlYWN0LXRhZ3NfX3RhZ1wiLFxuICB0YWdOYW1lOiBcInJlYWN0LXRhZ3NfX3RhZy1uYW1lXCIsXG4gIGNvbWJvQm94OiBcInJlYWN0LXRhZ3NfX2NvbWJvYm94XCIsXG4gIGlucHV0OiBcInJlYWN0LXRhZ3NfX2NvbWJvYm94LWlucHV0XCIsXG4gIGxpc3RCb3g6IFwicmVhY3QtdGFnc19fbGlzdGJveFwiLFxuICBvcHRpb246IFwicmVhY3QtdGFnc19fbGlzdGJveC1vcHRpb25cIixcbiAgb3B0aW9uSXNBY3RpdmU6IFwiaXMtYWN0aXZlXCIsXG4gIGhpZ2hsaWdodDogXCJyZWFjdC10YWdzX19saXN0Ym94LW9wdGlvbi1oaWdobGlnaHRcIlxufTtcbmNvbnN0IERlZmF1bHREZWxpbWl0ZXJLZXlzID0gW0tleU5hbWVzLkVudGVyXTtcbmZ1bmN0aW9uIFJlYWN0VGFncyh7XG4gIGFjdGl2YXRlRmlyc3RPcHRpb24gPSBmYWxzZSxcbiAgYWxsb3dCYWNrc3BhY2UgPSB0cnVlLFxuICBhbGxvd05ldyA9IGZhbHNlLFxuICBhbGxvd1Jlc2l6ZSA9IHRydWUsXG4gIGFyaWFBZGRlZFRleHQgPSBcIkFkZGVkIHRhZyAldmFsdWUlXCIsXG4gIGFyaWFEZXNjcmliZWRCeSxcbiAgYXJpYUVycm9yTWVzc2FnZSxcbiAgYXJpYURlbGV0ZWRUZXh0ID0gXCJSZW1vdmVkIHRhZyAldmFsdWUlXCIsXG4gIGNsYXNzTmFtZXMgPSBEZWZhdWx0Q2xhc3NOYW1lcyxcbiAgY29sbGFwc2VPblNlbGVjdCA9IGZhbHNlLFxuICBkZWxldGVCdXR0b25UZXh0ID0gXCJSZW1vdmUgJXZhbHVlJSBmcm9tIHRoZSBsaXN0XCIsXG4gIGRlbGltaXRlcktleXMgPSBEZWZhdWx0RGVsaW1pdGVyS2V5cyxcbiAgaWQgPSBcInJlYWN0LXRhZ3NcIixcbiAgaXNEaXNhYmxlZCA9IGZhbHNlLFxuICBpc0ludmFsaWQgPSBmYWxzZSxcbiAgbGFiZWxUZXh0ID0gXCJTZWxlY3QgdGFnc1wiLFxuICBuZXdPcHRpb25UZXh0ID0gXCJBZGQgJXZhbHVlJVwiLFxuICBub09wdGlvbnNUZXh0ID0gXCJObyBvcHRpb25zIGZvdW5kIGZvciAldmFsdWUlXCIsXG4gIG9uQWRkLFxuICBvbkJsdXIsXG4gIG9uQ29sbGFwc2UsXG4gIG9uRGVsZXRlLFxuICBvbkV4cGFuZCxcbiAgb25Gb2N1cyxcbiAgb25JbnB1dCxcbiAgb25TaG91bGRDb2xsYXBzZSxcbiAgb25TaG91bGRFeHBhbmQsXG4gIG9uVmFsaWRhdGUsXG4gIHBsYWNlaG9sZGVyVGV4dCA9IFwiQWRkIGEgdGFnXCIsXG4gIHJlbmRlckhpZ2hsaWdodCxcbiAgcmVuZGVySW5wdXQsXG4gIHJlbmRlckxhYmVsLFxuICByZW5kZXJMaXN0Qm94LFxuICByZW5kZXJPcHRpb24sXG4gIHJlbmRlclJvb3QsXG4gIHJlbmRlclRhZyxcbiAgcmVuZGVyVGFnTGlzdCxcbiAgc2VsZWN0ZWQgPSBbXSxcbiAgc3VnZ2VzdGlvbnMgPSBbXSxcbiAgc3VnZ2VzdGlvbnNUcmFuc2Zvcm0gPSBtYXRjaFRhZ3NQYXJ0aWFsLFxuICB0YWdMaXN0TGFiZWxUZXh0ID0gXCJTZWxlY3RlZCB0YWdzXCJcbn0sIHJlZikge1xuICBjb25zdCBjb21ib0JveFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaW5wdXRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGxpc3RCb3hSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHJvb3RSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IG1hbmFnZXJSZWYgPSB1c2VNYW5hZ2VyKHtcbiAgICBhY3RpdmF0ZUZpcnN0T3B0aW9uLFxuICAgIGFsbG93TmV3LFxuICAgIGNvbGxhcHNlT25TZWxlY3QsXG4gICAgbmV3T3B0aW9uVGV4dCxcbiAgICBub09wdGlvbnNUZXh0LFxuICAgIG9uQWRkLFxuICAgIG9uRGVsZXRlLFxuICAgIG9uQ29sbGFwc2UsXG4gICAgb25FeHBhbmQsXG4gICAgb25JbnB1dCxcbiAgICBvblNob3VsZENvbGxhcHNlLFxuICAgIG9uU2hvdWxkRXhwYW5kLFxuICAgIG9uVmFsaWRhdGUsXG4gICAgc2VsZWN0ZWQsXG4gICAgc3VnZ2VzdGlvbnMsXG4gICAgc3VnZ2VzdGlvbnNUcmFuc2Zvcm1cbiAgfSk7XG4gIGNvbnN0IHB1YmxpY0FQSSA9IHVzZVB1YmxpY0FQSSh7IGlucHV0UmVmLCBtYW5hZ2VyUmVmIH0pO1xuICBpZiAocmVmKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmVmKHB1YmxpY0FQSSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZi5jdXJyZW50ID0gcHVibGljQVBJO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR2xvYmFsQ29udGV4dC5Qcm92aWRlcixcbiAgICB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBjbGFzc05hbWVzLFxuICAgICAgICBjb21ib0JveFJlZixcbiAgICAgICAgaWQsXG4gICAgICAgIGlucHV0UmVmLFxuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICBpc0ludmFsaWQsXG4gICAgICAgIGxpc3RCb3hSZWYsXG4gICAgICAgIG1hbmFnZXJSZWYsXG4gICAgICAgIHJvb3RSZWZcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJvb3QsIHsgb25CbHVyLCBvbkZvY3VzLCByZW5kZXI6IHJlbmRlclJvb3QgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGFiZWwsIHsgcmVuZGVyOiByZW5kZXJMYWJlbCB9LCBsYWJlbFRleHQpLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChUYWdMaXN0LCB7IHJlbmRlcjogcmVuZGVyVGFnTGlzdCwgbGFiZWw6IHRhZ0xpc3RMYWJlbFRleHQgfSwgbWFuYWdlclJlZi5jdXJyZW50LnN0YXRlLnNlbGVjdGVkLm1hcCgodGFnLCBpbmRleCkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGFnLCB7IGtleTogdGFnVG9LZXkodGFnKSwgaW5kZXgsIHJlbmRlcjogcmVuZGVyVGFnLCB0aXRsZTogZGVsZXRlQnV0dG9uVGV4dCB9KSkpLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb21ib0JveCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBJbnB1dCxcbiAgICAgIHtcbiAgICAgICAgYWxsb3dCYWNrc3BhY2UsXG4gICAgICAgIGFsbG93UmVzaXplLFxuICAgICAgICBhcmlhRGVzY3JpYmVkQnksXG4gICAgICAgIGFyaWFFcnJvck1lc3NhZ2UsXG4gICAgICAgIGRlbGltaXRlcktleXMsXG4gICAgICAgIHBsYWNlaG9sZGVyVGV4dCxcbiAgICAgICAgcmVuZGVyOiByZW5kZXJJbnB1dFxuICAgICAgfVxuICAgICksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KExpc3RCb3gsIHsgcmVuZGVyOiByZW5kZXJMaXN0Qm94IH0sIG1hbmFnZXJSZWYuY3VycmVudC5zdGF0ZS5vcHRpb25zLm1hcCgob3B0aW9uLCBpbmRleCkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoT3B0aW9uLCB7IGtleTogdGFnVG9LZXkob3B0aW9uKSwgaW5kZXgsIHJlbmRlcjogcmVuZGVyT3B0aW9uIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgTWVtb2l6ZWRIaWdobGlnaHQsXG4gICAgICB7XG4gICAgICAgIG9wdGlvbixcbiAgICAgICAgcXVlcnk6IG1hbmFnZXJSZWYuY3VycmVudC5zdGF0ZS52YWx1ZSxcbiAgICAgICAgcmVuZGVyOiByZW5kZXJIaWdobGlnaHRcbiAgICAgIH1cbiAgICApKSkpKSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW5ub3VuY2VtZW50cywgeyBhcmlhQWRkZWRUZXh0LCBhcmlhRGVsZXRlZFRleHQgfSkpXG4gICk7XG59XG5jb25zdCBSZWFjdFRhZ3NXaXRoUmVmID0gUmVhY3QuZm9yd2FyZFJlZihSZWFjdFRhZ3MpO1xuZXhwb3J0cy5SZWFjdFRhZ3MgPSBSZWFjdFRhZ3NXaXRoUmVmO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-tag-autocomplete/dist/ReactTags.cjs.js\n");

/***/ })

};
;